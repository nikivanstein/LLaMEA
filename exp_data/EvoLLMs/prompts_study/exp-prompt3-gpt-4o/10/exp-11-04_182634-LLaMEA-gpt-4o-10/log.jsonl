{"id": "efece450-f1ba-457b-ae00-3702f71f25c7", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 0, "fitness": 0.38961586939502635, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "e7b6b240-2cd2-455e-8b5c-199bfa07ee6b", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            # Adaptive population resizing\n            if np.std(self.fitness) < 0.01:\n                self.population_size = max(4, int(self.population_size * 0.9))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM with Adaptive Population Resizing - adjusts population size dynamically based on convergence to improve exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.3266024155924762, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.5974837040451026, 0.5772744834403504, 0.5406555426549999, 0.5209707601469582, 0.5225404751389515, 0.5310292875230679, 0.512151740158748, 0.5131407241903785, 0.521585312378297, 0.4605061316588914, 0.4389189041616113, 0.4490025420781383, 0.48055890619517916, 0.4659945705789661, 0.4472776756324055, 0.45281520366453776, 0.5119090557159451, 0.49621492248175125, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.4788069895245487, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8394283438438426, 0.8548409222289488, 0.9598061880317073, 0.3185501417265941, 0.35532168085921656, 0.3758381734552879, 0.32247558747243543, 0.2872966392388936, 0.34374783112240515, 0.33443938682956864, 0.36760199851808184, 0.36996048374372525, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7550214892231478, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.37711723257060525, 0.2517705854167439, 0.18628316867064965, 0.2086289995472722, 0.2599954330578049, 0.2225513083935804, 0.24856813131103128, 0.30530880051437825, 0.2360228375692517, 0.1923838955047289, 0.2890041604607725, 0.2770220922596832, 0.29287792398677726, 0.17362227654488438, 0.2569629266787856, 0.2558652499052019, 0.30021086092789206, 0.203638162965724, 0.3643664815909743, 0.33194124144471227, 0.32231310686189385, 0.34716446446760296, 0.3486621524200757, 0.32079146991109575, 0.32748968608534856, 0.32415484838783937, 0.3484147087599748, 0.4353937430732011, 0.4263606331390388, 0.3691727305257707, 0.3879919735725037, 0.3840302092253708, 0.44091732817820206, 0.42572238779203886, 0.48271362372846593, 0.47146190826809287, 0.17914754504671693, 0.10042102185966051, 0.1094458063176349, 0.1874153538442891, 0.25720089682628067, 0.26164047680189384, 0.14777372473640882, 0.16552650399091184, 0.15544865901067662, 0.29153863988270967, 0.2908277401158209, 0.2744343717642619, 0.3287184683108889, 0.31640981876321284, 0.318044401949355, 0.2922775240655153, 0.3191873305506576, 0.29551353375257006, 0.5100231022544379, 0.4819496526785719, 0.5949557458726258, 0.47080892402889507, 0.49145119332925213, 0.4670577101371335, 0.4969210782434169, 0.4558586760377712, 0.5521842413309688, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.2127268741284275, 0.1577126553447179, 0.17778289692217875, 0.36471763741258834, 0.37832286547254323, 0.3723594054863494, 0.33880304730770805, 0.3612362630513435, 0.39462727257077257, 0.39077184948392263, 0.41905486958454496, 0.3747895022308839, 0.35003457263316373, 0.3195522282432147, 0.33995369701819533, 0.34437289951383987, 0.3092528030421826, 0.3174664989232542, 0.3138362102051361, 0.3208743125025161, 0.33442700077017584, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.2541980197501572, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.2424037706376162, 0.6132922093403252, 0.19796788760578943, 0.19251591939909152, 0.5049320490871196, 0.740757366526744, 0.17860598656957793, 0.49964562531985435, 0.17117223703619344, 0.18106628265367863, 0.4174143340914359, 0.24943572774936418, 0.6280469866149007, 0.19791566006814554, 0.2012511907010256, 0.5182960565488821, 0.5324646933673871, 0.15061214103362452, 0.21042824266917903, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "44f0927d-50d7-4617-ad01-12de6524b636", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "9f28d30c-efc1-42e3-b9f1-356b9cd7efab", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "f32d8e95-3192-46b0-b8b5-ae0bc892e383", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "8ea2255a-811d-4b95-88cb-a6ec54a1dd88", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, iter_ratio):\n        adaptive_CR = self.CR * (1 - iter_ratio) + 0.1 * iter_ratio  # Adaptively adjust CR\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        \n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                iter_ratio = self.eval_count / self.budget\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant, iter_ratio)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "ADERM+: Introduces adaptive crossover probability and dynamic population size to enhance performance by better balancing exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.2982279627308873, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8233159452607614, 0.8136637706789176, 0.8167755414988757, 0.8221084149317688, 0.820610629948239, 0.811101544526962, 0.8286813267434724, 0.7956961289870771, 0.8153342944618334, 0.6813422205072683, 0.6755100187390579, 0.667852410687565, 0.6575096387025602, 0.6526960769264374, 0.6746512531212677, 0.6806005666767343, 0.669526783876905, 0.6673979423690217, 0.30446060627313576, 0.22442296276624008, 0.2305043902999263, 0.29268074450695314, 0.25140524179196644, 0.270022327398454, 0.2487191223937747, 0.3037110935890528, 0.3365484206112671, 0.21396152033022697, 0.2323011870101357, 0.21577022854845496, 0.20682525549011999, 0.24936224557469044, 0.18581696333369557, 0.20141217947522339, 0.22525045474481775, 0.19892939195185388, 0.9034712843893947, 0.9345284412668908, 0.8983074377034129, 0.9062188547056711, 0.8827051082872736, 0.9129733214832527, 0.9292700016912374, 0.8926759270977515, 0.9482477864184299, 0.39582185741958176, 0.3596800035364699, 0.3537872251789569, 0.3664511096292832, 0.38000252359506825, 0.3706360682036369, 0.3570390808116546, 0.4077640192951467, 0.34595738480276095, 0.527610387263149, 0.5742789454319205, 0.5202642792880942, 0.6876862276696551, 0.34607857718040813, 0.6104103836923882, 0.661992577268054, 0.611611230934769, 0.632916560363626, 0.15242319973604113, 0.16278275818536658, 0.18512909938015354, 0.1992669016264671, 0.1921037494018929, 0.16698302705833867, 0.17616247341267643, 0.16311059771037528, 0.1640064155980735, 0.18397446997178613, 0.13470879845507877, 0.1861990005292321, 0.14086306635497603, 0.15417858379195715, 0.15704587618200871, 0.15969882879847774, 0.17299339183305806, 0.1755275637541578, 0.03200909456586065, 0.0371407083131029, 0.047119555722855644, 0.06268000332096968, 0.011563919356635033, 0.047348752877608424, 0.049383960585383635, 0.03109385484610594, 0.020370382181674862, 0.18681312687951424, 0.13559467121187285, 0.17348103805818704, 0.14830784233569227, 0.08541320019881715, 0.18487375853035648, 0.19646616668685302, 0.20035524386087178, 0.19567067119012316, 0.000709563436428251, 0.012123795115819624, 0.003551864627534096, 0.03632474698977661, 0.016632800819317728, 9.999999999998899e-05, 0.02592317501417618, 0.01832168118934263, 0.04414122031713741, 0.14634372546631091, 0.14073527044896217, 0.14740192234659732, 0.16533048155687335, 0.17012545456866024, 0.1573749507239347, 0.152513569324066, 0.15351666544362308, 0.1502519522415814, 0.5107399439491227, 0.5093909037367252, 0.5285459422615303, 0.5141253083473429, 0.505273322863393, 0.5104133113871752, 0.5434268683977541, 0.5175229475065055, 0.5326375655007087, 0.10785815772000384, 0.10695976038067379, 0.12279721665979249, 0.10197199767327514, 0.10597596524572506, 0.09244170540873442, 0.1035008457065626, 0.11222617846141514, 0.10254350807941315, 0.16388103695951106, 0.15958680719785157, 0.1329733921336772, 0.14191259226281694, 0.15426978035936267, 0.1530683427032402, 0.15403002451542525, 0.14952296478536897, 0.13780292380061587, 0.33327833263722173, 0.36458123787953856, 0.3389886310646444, 0.33550269044817993, 0.3260451185672879, 0.3869692110598366, 0.37767107029235814, 0.388816150151734, 0.3835370508426037, 0.227855549747087, 0.2385382106349282, 0.22158686941854044, 0.22841975168123307, 0.23385784225687611, 0.24495202659232562, 0.22699335102221496, 0.29034787793962347, 0.27882588253454677, 0.1940071937382465, 0.22958964514149316, 0.20116982305857634, 0.20205266045987824, 0.19311811910493737, 0.19024874685539617, 0.2152528958843729, 0.20501340106256072, 0.18394169375160196, 0.3067850101569024, 0.22620092142853987, 0.32336573710686, 0.21496383069111602, 0.23113143224541022, 0.23719949694123732, 0.2655618638652173, 0.20392691791783768, 0.26912813696597326, 0.20891785976624533, 0.1782201196167702, 0.16107599987186638, 0.7211183684218495, 0.285641080367809, 0.22895664732553744, 0.23674861068398512, 0.37657536038653283, 0.20777228381745505, 0.16681281293710293, 0.20173601836999755, 0.36877562397862784, 0.20003845582610535, 0.2893108756063244, 0.22449551536804158, 0.1475840495247317, 0.20181906153095053, 0.20775395954407483, 0.2005044494411885, 0.18139758441268772, 0.18579395717566238, 0.17952943220755713, 0.17548584444598347, 0.1858398220987203, 0.18433966888218234, 0.19745085282667096, 0.18415972346014864, 0.0771180939158197, 0.0777358531648068, 0.0939513059369439, 0.07387723527230028, 0.08693198676444369, 0.08652545139176493, 0.07526730896031475, 0.08829672655679155, 0.07572621338759855]}, "mutation_prompt": null}
{"id": "0c237745-4725-47c2-a935-8a09183ed45f", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "883047a5-b489-473b-beb0-d9fe3dcfa593", "solution": "import numpy as np\n\nclass EADE_AMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F_dynamic = 0.4 + 0.1 * np.cos(self.eval_count / self.budget * np.pi)  # Adaptive mutation factor\n        mutant = self.population[a] + F_dynamic * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EADE_AMC", "description": "Enhanced Adaptive Differential Evolution with Adaptive Mutation Control (EADE-AMC) - introduces adaptive control of the mutation factor to dynamically adjust exploration and exploitation balance for improved optimization performance.", "configspace": "", "generation": 7, "fitness": 0.3890915691228396, "feedback": "The algorithm EADE_AMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.814057142598322, 0.8168153903403075, 0.8134707636780005, 0.8309917759039117, 0.8195009536742297, 0.822183990602404, 0.8313091434507406, 0.8109190198080913, 0.8228370775614271, 0.6766594585192764, 0.6995002073337685, 0.6885368567398922, 0.6921542150628991, 0.6740260283667883, 0.6866241399644577, 0.7020763048672356, 0.6802036371660083, 0.6886894538145593, 0.11147719366404274, 0.12293091025366065, 0.11875292393417547, 0.12369922327586047, 0.11793567891108725, 0.11689397699070558, 0.09976143727540876, 0.12685300495088925, 0.1176250463251507, 0.12239225781717955, 0.11545130574531137, 0.11093280782317239, 0.09733744823661672, 0.12606511591905034, 0.10380201896838337, 0.10613989049544614, 0.10818332797118924, 0.1101907820007697, 0.8835288583940291, 0.839324650874162, 0.8729241261371693, 0.9422486707005805, 0.9003168215453258, 0.8821767208917225, 0.7808004141625067, 0.8146224815162701, 0.9597849298115306, 0.4990994752483142, 0.49488889388465473, 0.39763985631483445, 0.5492974246173554, 0.48293345770573115, 0.3802083738357924, 0.3289350901355458, 0.5042127739511604, 0.49675598828757495, 0.7993335136165595, 0.7780122892861338, 0.7834883487555063, 0.8077423519294418, 0.8171340901178111, 0.8199166243737182, 0.7917436209446014, 0.8004376628938792, 0.8085965519421787, 0.5663930677900191, 0.23253329716931526, 0.15847689719310676, 0.19982270954225867, 0.19556678847395859, 0.2112007845483519, 0.4051205051815927, 0.16759886394550938, 0.2220999821757138, 0.19614318768975425, 0.18888041613612605, 0.21110552325241416, 0.25816050593046824, 0.2121790477335248, 0.25430660061783805, 0.24106891843124956, 0.15853733984639007, 0.16973626590864155, 0.4835056146960208, 0.4967218937986144, 0.5108956631657933, 0.544198655872435, 0.4172326751394372, 0.4981057805859468, 0.46165821572855037, 0.48281977094539685, 0.4877519078695628, 0.5832113245337047, 0.5973291603882496, 0.5740496547724289, 0.6282290189540747, 0.5991391940193175, 0.5704459247273548, 0.6223943068809821, 0.6556141300056633, 0.6361618142424947, 0.16280495485365587, 0.09441362467726666, 0.14926182291124934, 0.20778758394230223, 0.18992373046240307, 0.11085688506906921, 0.17180336299423138, 0.2844995086816998, 0.21158018135612044, 0.3349260048866022, 0.3397315782654201, 0.3949422372625879, 0.3538966159906446, 0.3985311908210819, 0.3689868032477758, 0.35436209162542764, 0.40665171487247176, 0.40052419316322896, 0.7213541563376291, 0.7482722010251285, 0.7470123628196039, 0.7230596734019381, 0.7339892616966914, 0.7533036922962447, 0.6892538043939371, 0.7346203013178851, 0.7181264089249026, 0.10924460482879694, 0.09862726376562114, 0.11390146774484744, 0.10103817752083433, 0.11190670780467826, 0.09494512887534201, 0.10629215383525936, 0.10105199713030721, 0.10767042505031499, 0.14197220648827968, 0.1789325587721463, 0.16677541194419632, 0.1433762362083798, 0.13596527231767086, 0.15622613563746857, 0.19542840104588266, 0.14576085864849486, 0.13300118418074725, 0.4727382874219729, 0.49469373506326164, 0.49457442025266407, 0.4444502444187104, 0.4385415504903831, 0.4603775697694279, 0.5321248636559015, 0.5118811634589705, 0.49979667438679376, 0.38213273618407406, 0.4070794341641403, 0.4215195793331957, 0.3695615078137411, 0.3697413254678348, 0.3854173694718692, 0.392770740950371, 0.39250084922761597, 0.418492906423651, 0.1939298421772936, 0.2120415436397337, 0.19978852006599723, 0.19220050129152455, 0.22073348602520138, 0.19218632255950618, 0.19364473385210357, 0.19196270110417812, 0.2019381782487405, 0.44181872586124493, 0.3042946926353184, 0.39314656344697907, 0.20021884775480303, 0.2574503459402867, 0.3588398040488714, 0.24972678079220212, 0.1913431001268826, 0.26930981488919237, 0.6739941076943621, 0.2009984677892257, 0.19239945537107128, 0.7487526982485935, 0.6145788495129919, 0.1786457689286186, 0.5451395811813802, 0.17112219610554402, 0.18113535055648766, 0.475896104706682, 0.20411501137815535, 0.32162999146311655, 0.4797958436660339, 0.20168274377973516, 0.7488626622289294, 0.19528110704162838, 0.1506373768686905, 0.2104883284590886, 0.17681823822906395, 0.1830311696885648, 0.183964984068265, 0.1832422800060094, 0.20423795763427788, 0.17526508579827837, 0.19047653391586605, 0.1790264031879384, 0.17944310298322397, 0.08173039039562502, 0.08037655409498945, 0.07908261551662343, 0.07540028726099501, 0.08618344109359821, 0.08163982800453107, 0.09512311408593521, 0.08413074380656815, 0.08840957449478681]}, "mutation_prompt": null}
{"id": "49ec78f7-f0cb-4aa5-9554-acfd1504802b", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "11b61236-b3d4-4bc1-a031-976fdc668ad1", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "c1da1f4c-e981-47f4-a07f-828c4419748f", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "acfed2dc-196f-4d2f-a8a5-4a6d02daf4bb", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "d96351cd-d841-4d22-a076-5eb1475d4f11", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "56f95ad5-47fa-41e3-b4b4-71cd03fd0deb", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "4894640b-e6c3-4048-8816-331182c31f73", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive Differential Evolution with Random Mutation (ADERM) - combines adaptive control of differential evolution parameters with random mutation to balance exploration and exploitation for effective black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8082951982740995, 0.8014414204667654, 0.8054453577133506, 0.8046704133521985, 0.8058463131857888, 0.8188884175907455, 0.8319621845238742, 0.8024921727708646, 0.8156784341351663, 0.6374593667227992, 0.6889401945204383, 0.6840853480293522, 0.6967349454168776, 0.6836546441420059, 0.7013571449635906, 0.6666788686750416, 0.6770639713943923, 0.6863840800439489, 0.12406593503725594, 0.12297465129273255, 0.14058632370994584, 0.1052595427488272, 0.11167461882941265, 0.13007467230320757, 0.12365019145486145, 0.11918356450990464, 0.11488744604263235, 0.10535781951712397, 0.11481994548974239, 0.09822569063089581, 0.11315686760328558, 0.095718207154741, 0.1284589936656112, 0.11755130828269289, 0.12022350325463882, 0.11584820962019216, 0.8597756612502457, 0.9157991407067686, 0.8919211963318844, 0.9422525779112587, 0.8841830878570923, 0.8793771590025652, 0.8459523177512822, 0.848382114063899, 0.9598061880317073, 0.5245512181825833, 0.48590193773332546, 0.4726385713433626, 0.49755790842027525, 0.44050793004714717, 0.4860225812214042, 0.48923614479716393, 0.5626004529120301, 0.5661570195281409, 0.7502562973574359, 0.7880396995674364, 0.774806000419606, 0.7926459197490786, 0.8196606075332389, 0.7521743278710327, 0.804043637659155, 0.826297721791377, 0.7746707969526332, 0.49293502300884817, 0.271219826626266, 0.19525206862626898, 0.21208489548313536, 0.28795742039245853, 0.23712476040114228, 0.26456600091702454, 0.42421509633777477, 0.24608110188436494, 0.20232704007066327, 0.3997401225652686, 0.3946916881107272, 0.3321086903701219, 0.17433639000156165, 0.34057707605230425, 0.3185375665222645, 0.44875467299607996, 0.22345913743219759, 0.47817446858601365, 0.4614805127441417, 0.4102169989000195, 0.44686108002553415, 0.43915453207298905, 0.4440057175463302, 0.44242477992667906, 0.45027983433914365, 0.45654985092748845, 0.5447193995815659, 0.587850359461022, 0.5479286276366925, 0.5932712354594567, 0.5281597245465506, 0.576369408068012, 0.5895215243182369, 0.6533175907468016, 0.5580757098786728, 0.1820234248487943, 0.10042102185966051, 0.1094458063176349, 0.18975380863799762, 0.2616899769940645, 0.2704787827836086, 0.14806365752002526, 0.16644564002240947, 0.15630378745456364, 0.3522612834402613, 0.34558762409589794, 0.30832940654158036, 0.3548320422232081, 0.36776095379850093, 0.36386973613151785, 0.32759195569500954, 0.36128975575133904, 0.3295039643056106, 0.7251247130914591, 0.7421906635710509, 0.7496270213295275, 0.7230575132501221, 0.7251778593971584, 0.755831239590211, 0.7223247260970481, 0.7243412267015438, 0.7346211765929873, 0.09425026936346892, 0.10579369271440497, 0.09773862024513658, 0.09069026109797595, 0.09873614125013352, 0.11727414971731487, 0.11161073672894872, 0.1053016798615024, 0.10926195124569171, 0.1668445090052374, 0.13100362643348562, 0.14861021678460906, 0.1597184884703442, 0.1703972777954268, 0.1536571464041484, 0.21274717756607497, 0.1577126553447179, 0.17778289692217875, 0.41067801371860546, 0.43734698273738726, 0.46862066207838815, 0.39221448766203615, 0.41783463202763027, 0.4328395179856588, 0.4438323548298344, 0.4822833501481897, 0.4826278681932962, 0.3433992730587172, 0.3441615990342961, 0.33987749587443383, 0.3503815404539863, 0.32444776412018095, 0.3406782878289202, 0.35588497881207926, 0.35848157334592856, 0.32881957612434887, 0.20687612780704456, 0.21476317805421452, 0.19118188338739683, 0.20720838202013414, 0.22689532950204405, 0.19706522310943897, 0.2048548004556734, 0.2102999473590339, 0.2048058029438542, 0.19922743430889167, 0.2137604528357705, 0.1964308170507908, 0.18742924286984874, 0.25777128882776845, 0.18928562755462075, 0.2023242721488182, 0.21173853655341168, 0.24001795766827494, 0.6726255830604337, 0.19796955755725243, 0.19251605048532705, 0.6089964619245598, 0.7234653051791861, 0.1786098411700403, 0.565304270779537, 0.17117816801315844, 0.18106701919554602, 0.6868763099660992, 0.31772736525156975, 0.710391785663764, 0.1979188806567178, 0.2012540407726643, 0.70839429766416, 0.6418310694978038, 0.15061184268873962, 0.2104471192807641, 0.1938161867954813, 0.1886171753911593, 0.21371843256686773, 0.18694601503491992, 0.2054013654456397, 0.18033810841782072, 0.1958685708189951, 0.20650369436260085, 0.1886939359094303, 0.07497160228750599, 0.08931752520059522, 0.08148000773387032, 0.07270439939139905, 0.08257615351081926, 0.08619801121010329, 0.08427141040888397, 0.07555033649169784, 0.08109924643008071]}, "mutation_prompt": null}
{"id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM with adaptive mutation scaling to better balance exploration and exploitation across function landscapes.", "configspace": "", "generation": 15, "fitness": 0.3940491142578293, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "efece450-f1ba-457b-ae00-3702f71f25c7", "metadata": {"aucs": [0.8189917612543086, 0.7940046396522192, 0.8197413166857499, 0.8215958738741156, 0.8256352848480368, 0.843128942279562, 0.8033517635096421, 0.8361355294041023, 0.8239888611248899, 0.6547592550917212, 0.6948856005191064, 0.6893210169781734, 0.6895717687233951, 0.6896204841684097, 0.6630822676198038, 0.673397075579908, 0.6819914834763802, 0.6716857004961911, 0.11113788328637242, 0.11787942222121894, 0.1088448125555811, 0.11766936891755808, 0.11893893531036426, 0.11317287450925984, 0.12873450891196603, 0.12336226129818517, 0.10929380997129357, 0.10995132377653705, 0.11219570133074608, 0.09888777357366474, 0.10150790563777012, 0.11990637997817899, 0.10578638186690537, 0.10686319319436666, 0.10835640873835617, 0.11494248461581624, 0.9173895297038399, 0.9024749284934813, 0.9188535311169952, 0.9481978000951217, 0.9301144525995659, 0.9618110813115364, 0.8779015189372863, 0.8999430573694092, 0.8882952287771846, 0.48534553766430444, 0.5016032379476014, 0.48932084229191963, 0.4711370345498276, 0.4810649549464854, 0.46823924364364133, 0.5717313766371033, 0.5079557193491571, 0.491492831163008, 0.8108116611103264, 0.7706735234914861, 0.7786629944646344, 0.7874247265279258, 0.8324805955323907, 0.8148483881841687, 0.7691755136868256, 0.7701159436354101, 0.7681305597374761, 0.30249870614960717, 0.26415854163578845, 0.18617657607246496, 0.25318787561262346, 0.30015940337318336, 0.21203613856537507, 0.19217625267683924, 0.22933646120090367, 0.3696823483564311, 0.36200881517680694, 0.13735624710358663, 0.27889635000776125, 0.1958146562128581, 0.3308709014055341, 0.2631310706560205, 0.36049311482298296, 0.2205462414125049, 0.36977219723690047, 0.4712037808332876, 0.42407206273922826, 0.4306531867266241, 0.42364296463373474, 0.47466802469897507, 0.4839025886738174, 0.42439338510310176, 0.48002388915692296, 0.42753702617256517, 0.5785731094100006, 0.6015657369919465, 0.5879238725799287, 0.5655089562473176, 0.5892417950721796, 0.4421000496877808, 0.5661560280065823, 0.5739957387818424, 0.5935580811582143, 0.12099069296090803, 0.23460109150684305, 0.1383050650264166, 0.32287721490176624, 0.2528606774255332, 0.2252132283366628, 0.2161411318880263, 0.2291272901266097, 0.14155141732266507, 0.32174144478105116, 0.33958172155855815, 0.3478014137359927, 0.3534623597496266, 0.35061137426417144, 0.3884324172333451, 0.33194562384932647, 0.3284399102655876, 0.3481403929299903, 0.7335157572902015, 0.731355106226979, 0.7255246737751284, 0.7055605877429727, 0.7406476156159796, 0.7318809341888919, 0.7309908938261409, 0.7384863412851679, 0.7393924325044655, 0.10475481276352783, 0.09579139923086155, 0.09457622801372834, 0.0973323055192643, 0.0965001843380896, 0.1014201120085172, 0.11453708781703331, 0.09393870507141822, 0.09349892746655097, 0.16211110078390534, 0.18155062716749015, 0.15250386262159377, 0.13276231953277806, 0.15380994891160538, 0.14091540604172403, 0.13738190403678197, 0.13508168644935137, 0.15695851086366253, 0.42085026979858464, 0.4400893242845124, 0.42467201974765534, 0.40623871078734797, 0.41864192495984476, 0.4284965314507654, 0.4499723837522227, 0.45165832955507235, 0.49875162353970437, 0.29826364202702804, 0.3399361089246692, 0.3542199833275079, 0.3156901909024665, 0.31425745203138444, 0.338321891988716, 0.3401473074932496, 0.36585917033586124, 0.3585754616631309, 0.23585843465070233, 0.1854337622317761, 0.19543746229176318, 0.21084327285189475, 0.20519515758420914, 0.193911862203355, 0.19405187273610414, 0.1817163260966851, 0.19177502016550896, 0.28146999828435937, 0.21403171538916266, 0.22165994061299443, 0.18187198989276976, 0.23942398350247684, 0.25932151846903695, 0.1976548802355761, 0.193841738138548, 0.2938752867356288, 0.6926549473852487, 0.16091325349405383, 0.18818900252223303, 0.7844291555418526, 0.7571636532444267, 0.6858018864000714, 0.18073701121783503, 0.1814574443932946, 0.7213461897943582, 0.7197179545693719, 0.7552443145276226, 0.5528450858917529, 0.161185825876626, 0.4269785767345804, 0.2031267788880482, 0.6190181087772927, 0.7421875025533857, 0.211073955063792, 0.18274732114792647, 0.19261705458314504, 0.18838144628452103, 0.20294136096814974, 0.17865493616273997, 0.19105965856306595, 0.18960666363472667, 0.18390641926285767, 0.1877632201107009, 0.06899015036304923, 0.0883698986245075, 0.08088038434350076, 0.07724345113178155, 0.07937524422819864, 0.07977743363874124, 0.07788884937200014, 0.08195734110433461, 0.07721866939197297]}, "mutation_prompt": null}
{"id": "60b13672-8a2b-4d55-8515-26d5ff80a5fe", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM with adaptive mutation scaling to better balance exploration and exploitation across function landscapes.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "metadata": {"aucs": [0.8189917612543086, 0.7940046396522192, 0.8197413166857499, 0.8215958738741156, 0.8256352848480368, 0.843128942279562, 0.8033517635096421, 0.8361355294041023, 0.8239888611248899, 0.6547592550917212, 0.6948856005191064, 0.6893210169781734, 0.6895717687233951, 0.6896204841684097, 0.6630822676198038, 0.673397075579908, 0.6819914834763802, 0.6716857004961911, 0.11113788328637242, 0.11787942222121894, 0.1088448125555811, 0.11766936891755808, 0.11893893531036426, 0.11317287450925984, 0.12873450891196603, 0.12336226129818517, 0.10929380997129357, 0.10995132377653705, 0.11219570133074608, 0.09888777357366474, 0.10150790563777012, 0.11990637997817899, 0.10578638186690537, 0.10686319319436666, 0.10835640873835617, 0.11494248461581624, 0.9173895297038399, 0.9024749284934813, 0.9188535311169952, 0.9481978000951217, 0.9301144525995659, 0.9618110813115364, 0.8779015189372863, 0.8999430573694092, 0.8882952287771846, 0.48534553766430444, 0.5016032379476014, 0.48932084229191963, 0.4711370345498276, 0.4810649549464854, 0.46823924364364133, 0.5717313766371033, 0.5079557193491571, 0.491492831163008, 0.8108116611103264, 0.7706735234914861, 0.7786629944646344, 0.7874247265279258, 0.8324805955323907, 0.8148483881841687, 0.7691755136868256, 0.7701159436354101, 0.7681305597374761, 0.30249870614960717, 0.26415854163578845, 0.18617657607246496, 0.25318787561262346, 0.30015940337318336, 0.21203613856537507, 0.19217625267683924, 0.22933646120090367, 0.3696823483564311, 0.36200881517680694, 0.13735624710358663, 0.27889635000776125, 0.1958146562128581, 0.3308709014055341, 0.2631310706560205, 0.36049311482298296, 0.2205462414125049, 0.36977219723690047, 0.4712037808332876, 0.42407206273922826, 0.4306531867266241, 0.42364296463373474, 0.47466802469897507, 0.4839025886738174, 0.42439338510310176, 0.48002388915692296, 0.42753702617256517, 0.5785731094100006, 0.6015657369919465, 0.5879238725799287, 0.5655089562473176, 0.5892417950721796, 0.4421000496877808, 0.5661560280065823, 0.5739957387818424, 0.5935580811582143, 0.12099069296090803, 0.23460109150684305, 0.1383050650264166, 0.32287721490176624, 0.2528606774255332, 0.2252132283366628, 0.2161411318880263, 0.2291272901266097, 0.14155141732266507, 0.32174144478105116, 0.33958172155855815, 0.3478014137359927, 0.3534623597496266, 0.35061137426417144, 0.3884324172333451, 0.33194562384932647, 0.3284399102655876, 0.3481403929299903, 0.7335157572902015, 0.731355106226979, 0.7255246737751284, 0.7055605877429727, 0.7406476156159796, 0.7318809341888919, 0.7309908938261409, 0.7384863412851679, 0.7393924325044655, 0.10475481276352783, 0.09579139923086155, 0.09457622801372834, 0.0973323055192643, 0.0965001843380896, 0.1014201120085172, 0.11453708781703331, 0.09393870507141822, 0.09349892746655097, 0.16211110078390534, 0.18155062716749015, 0.15250386262159377, 0.13276231953277806, 0.15380994891160538, 0.14091540604172403, 0.13738190403678197, 0.13508168644935137, 0.15695851086366253, 0.42085026979858464, 0.4400893242845124, 0.42467201974765534, 0.40623871078734797, 0.41864192495984476, 0.4284965314507654, 0.4499723837522227, 0.45165832955507235, 0.49875162353970437, 0.29826364202702804, 0.3399361089246692, 0.3542199833275079, 0.3156901909024665, 0.31425745203138444, 0.338321891988716, 0.3401473074932496, 0.36585917033586124, 0.3585754616631309, 0.23585843465070233, 0.1854337622317761, 0.19543746229176318, 0.21084327285189475, 0.20519515758420914, 0.193911862203355, 0.19405187273610414, 0.1817163260966851, 0.19177502016550896, 0.28146999828435937, 0.21403171538916266, 0.22165994061299443, 0.18187198989276976, 0.23942398350247684, 0.25932151846903695, 0.1976548802355761, 0.193841738138548, 0.2938752867356288, 0.6926549473852487, 0.16091325349405383, 0.18818900252223303, 0.7844291555418526, 0.7571636532444267, 0.6858018864000714, 0.18073701121783503, 0.1814574443932946, 0.7213461897943582, 0.7197179545693719, 0.7552443145276226, 0.5528450858917529, 0.161185825876626, 0.4269785767345804, 0.2031267788880482, 0.6190181087772927, 0.7421875025533857, 0.211073955063792, 0.18274732114792647, 0.19261705458314504, 0.18838144628452103, 0.20294136096814974, 0.17865493616273997, 0.19105965856306595, 0.18960666363472667, 0.18390641926285767, 0.1877632201107009, 0.06899015036304923, 0.0883698986245075, 0.08088038434350076, 0.07724345113178155, 0.07937524422819864, 0.07977743363874124, 0.07788884937200014, 0.08195734110433461, 0.07721866939197297]}, "mutation_prompt": null}
{"id": "58f66204-4a80-4e63-ad8a-4dd942452376", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM with adaptive mutation scaling to better balance exploration and exploitation across function landscapes.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "metadata": {"aucs": [0.8189917612543086, 0.7940046396522192, 0.8197413166857499, 0.8215958738741156, 0.8256352848480368, 0.843128942279562, 0.8033517635096421, 0.8361355294041023, 0.8239888611248899, 0.6547592550917212, 0.6948856005191064, 0.6893210169781734, 0.6895717687233951, 0.6896204841684097, 0.6630822676198038, 0.673397075579908, 0.6819914834763802, 0.6716857004961911, 0.11113788328637242, 0.11787942222121894, 0.1088448125555811, 0.11766936891755808, 0.11893893531036426, 0.11317287450925984, 0.12873450891196603, 0.12336226129818517, 0.10929380997129357, 0.10995132377653705, 0.11219570133074608, 0.09888777357366474, 0.10150790563777012, 0.11990637997817899, 0.10578638186690537, 0.10686319319436666, 0.10835640873835617, 0.11494248461581624, 0.9173895297038399, 0.9024749284934813, 0.9188535311169952, 0.9481978000951217, 0.9301144525995659, 0.9618110813115364, 0.8779015189372863, 0.8999430573694092, 0.8882952287771846, 0.48534553766430444, 0.5016032379476014, 0.48932084229191963, 0.4711370345498276, 0.4810649549464854, 0.46823924364364133, 0.5717313766371033, 0.5079557193491571, 0.491492831163008, 0.8108116611103264, 0.7706735234914861, 0.7786629944646344, 0.7874247265279258, 0.8324805955323907, 0.8148483881841687, 0.7691755136868256, 0.7701159436354101, 0.7681305597374761, 0.30249870614960717, 0.26415854163578845, 0.18617657607246496, 0.25318787561262346, 0.30015940337318336, 0.21203613856537507, 0.19217625267683924, 0.22933646120090367, 0.3696823483564311, 0.36200881517680694, 0.13735624710358663, 0.27889635000776125, 0.1958146562128581, 0.3308709014055341, 0.2631310706560205, 0.36049311482298296, 0.2205462414125049, 0.36977219723690047, 0.4712037808332876, 0.42407206273922826, 0.4306531867266241, 0.42364296463373474, 0.47466802469897507, 0.4839025886738174, 0.42439338510310176, 0.48002388915692296, 0.42753702617256517, 0.5785731094100006, 0.6015657369919465, 0.5879238725799287, 0.5655089562473176, 0.5892417950721796, 0.4421000496877808, 0.5661560280065823, 0.5739957387818424, 0.5935580811582143, 0.12099069296090803, 0.23460109150684305, 0.1383050650264166, 0.32287721490176624, 0.2528606774255332, 0.2252132283366628, 0.2161411318880263, 0.2291272901266097, 0.14155141732266507, 0.32174144478105116, 0.33958172155855815, 0.3478014137359927, 0.3534623597496266, 0.35061137426417144, 0.3884324172333451, 0.33194562384932647, 0.3284399102655876, 0.3481403929299903, 0.7335157572902015, 0.731355106226979, 0.7255246737751284, 0.7055605877429727, 0.7406476156159796, 0.7318809341888919, 0.7309908938261409, 0.7384863412851679, 0.7393924325044655, 0.10475481276352783, 0.09579139923086155, 0.09457622801372834, 0.0973323055192643, 0.0965001843380896, 0.1014201120085172, 0.11453708781703331, 0.09393870507141822, 0.09349892746655097, 0.16211110078390534, 0.18155062716749015, 0.15250386262159377, 0.13276231953277806, 0.15380994891160538, 0.14091540604172403, 0.13738190403678197, 0.13508168644935137, 0.15695851086366253, 0.42085026979858464, 0.4400893242845124, 0.42467201974765534, 0.40623871078734797, 0.41864192495984476, 0.4284965314507654, 0.4499723837522227, 0.45165832955507235, 0.49875162353970437, 0.29826364202702804, 0.3399361089246692, 0.3542199833275079, 0.3156901909024665, 0.31425745203138444, 0.338321891988716, 0.3401473074932496, 0.36585917033586124, 0.3585754616631309, 0.23585843465070233, 0.1854337622317761, 0.19543746229176318, 0.21084327285189475, 0.20519515758420914, 0.193911862203355, 0.19405187273610414, 0.1817163260966851, 0.19177502016550896, 0.28146999828435937, 0.21403171538916266, 0.22165994061299443, 0.18187198989276976, 0.23942398350247684, 0.25932151846903695, 0.1976548802355761, 0.193841738138548, 0.2938752867356288, 0.6926549473852487, 0.16091325349405383, 0.18818900252223303, 0.7844291555418526, 0.7571636532444267, 0.6858018864000714, 0.18073701121783503, 0.1814574443932946, 0.7213461897943582, 0.7197179545693719, 0.7552443145276226, 0.5528450858917529, 0.161185825876626, 0.4269785767345804, 0.2031267788880482, 0.6190181087772927, 0.7421875025533857, 0.211073955063792, 0.18274732114792647, 0.19261705458314504, 0.18838144628452103, 0.20294136096814974, 0.17865493616273997, 0.19105965856306595, 0.18960666363472667, 0.18390641926285767, 0.1877632201107009, 0.06899015036304923, 0.0883698986245075, 0.08088038434350076, 0.07724345113178155, 0.07937524422819864, 0.07977743363874124, 0.07788884937200014, 0.08195734110433461, 0.07721866939197297]}, "mutation_prompt": null}
{"id": "e696d967-96d0-4af5-b307-eeaa329b4c89", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM with adaptive mutation scaling to better balance exploration and exploitation across function landscapes.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "metadata": {"aucs": [0.8189917612543086, 0.7940046396522192, 0.8197413166857499, 0.8215958738741156, 0.8256352848480368, 0.843128942279562, 0.8033517635096421, 0.8361355294041023, 0.8239888611248899, 0.6547592550917212, 0.6948856005191064, 0.6893210169781734, 0.6895717687233951, 0.6896204841684097, 0.6630822676198038, 0.673397075579908, 0.6819914834763802, 0.6716857004961911, 0.11113788328637242, 0.11787942222121894, 0.1088448125555811, 0.11766936891755808, 0.11893893531036426, 0.11317287450925984, 0.12873450891196603, 0.12336226129818517, 0.10929380997129357, 0.10995132377653705, 0.11219570133074608, 0.09888777357366474, 0.10150790563777012, 0.11990637997817899, 0.10578638186690537, 0.10686319319436666, 0.10835640873835617, 0.11494248461581624, 0.9173895297038399, 0.9024749284934813, 0.9188535311169952, 0.9481978000951217, 0.9301144525995659, 0.9618110813115364, 0.8779015189372863, 0.8999430573694092, 0.8882952287771846, 0.48534553766430444, 0.5016032379476014, 0.48932084229191963, 0.4711370345498276, 0.4810649549464854, 0.46823924364364133, 0.5717313766371033, 0.5079557193491571, 0.491492831163008, 0.8108116611103264, 0.7706735234914861, 0.7786629944646344, 0.7874247265279258, 0.8324805955323907, 0.8148483881841687, 0.7691755136868256, 0.7701159436354101, 0.7681305597374761, 0.30249870614960717, 0.26415854163578845, 0.18617657607246496, 0.25318787561262346, 0.30015940337318336, 0.21203613856537507, 0.19217625267683924, 0.22933646120090367, 0.3696823483564311, 0.36200881517680694, 0.13735624710358663, 0.27889635000776125, 0.1958146562128581, 0.3308709014055341, 0.2631310706560205, 0.36049311482298296, 0.2205462414125049, 0.36977219723690047, 0.4712037808332876, 0.42407206273922826, 0.4306531867266241, 0.42364296463373474, 0.47466802469897507, 0.4839025886738174, 0.42439338510310176, 0.48002388915692296, 0.42753702617256517, 0.5785731094100006, 0.6015657369919465, 0.5879238725799287, 0.5655089562473176, 0.5892417950721796, 0.4421000496877808, 0.5661560280065823, 0.5739957387818424, 0.5935580811582143, 0.12099069296090803, 0.23460109150684305, 0.1383050650264166, 0.32287721490176624, 0.2528606774255332, 0.2252132283366628, 0.2161411318880263, 0.2291272901266097, 0.14155141732266507, 0.32174144478105116, 0.33958172155855815, 0.3478014137359927, 0.3534623597496266, 0.35061137426417144, 0.3884324172333451, 0.33194562384932647, 0.3284399102655876, 0.3481403929299903, 0.7335157572902015, 0.731355106226979, 0.7255246737751284, 0.7055605877429727, 0.7406476156159796, 0.7318809341888919, 0.7309908938261409, 0.7384863412851679, 0.7393924325044655, 0.10475481276352783, 0.09579139923086155, 0.09457622801372834, 0.0973323055192643, 0.0965001843380896, 0.1014201120085172, 0.11453708781703331, 0.09393870507141822, 0.09349892746655097, 0.16211110078390534, 0.18155062716749015, 0.15250386262159377, 0.13276231953277806, 0.15380994891160538, 0.14091540604172403, 0.13738190403678197, 0.13508168644935137, 0.15695851086366253, 0.42085026979858464, 0.4400893242845124, 0.42467201974765534, 0.40623871078734797, 0.41864192495984476, 0.4284965314507654, 0.4499723837522227, 0.45165832955507235, 0.49875162353970437, 0.29826364202702804, 0.3399361089246692, 0.3542199833275079, 0.3156901909024665, 0.31425745203138444, 0.338321891988716, 0.3401473074932496, 0.36585917033586124, 0.3585754616631309, 0.23585843465070233, 0.1854337622317761, 0.19543746229176318, 0.21084327285189475, 0.20519515758420914, 0.193911862203355, 0.19405187273610414, 0.1817163260966851, 0.19177502016550896, 0.28146999828435937, 0.21403171538916266, 0.22165994061299443, 0.18187198989276976, 0.23942398350247684, 0.25932151846903695, 0.1976548802355761, 0.193841738138548, 0.2938752867356288, 0.6926549473852487, 0.16091325349405383, 0.18818900252223303, 0.7844291555418526, 0.7571636532444267, 0.6858018864000714, 0.18073701121783503, 0.1814574443932946, 0.7213461897943582, 0.7197179545693719, 0.7552443145276226, 0.5528450858917529, 0.161185825876626, 0.4269785767345804, 0.2031267788880482, 0.6190181087772927, 0.7421875025533857, 0.211073955063792, 0.18274732114792647, 0.19261705458314504, 0.18838144628452103, 0.20294136096814974, 0.17865493616273997, 0.19105965856306595, 0.18960666363472667, 0.18390641926285767, 0.1877632201107009, 0.06899015036304923, 0.0883698986245075, 0.08088038434350076, 0.07724345113178155, 0.07937524422819864, 0.07977743363874124, 0.07788884937200014, 0.08195734110433461, 0.07721866939197297]}, "mutation_prompt": null}
{"id": "b9d947df-71c7-4f32-af19-b1cb5e5190de", "solution": "# Description: Adaptive ADERM with dynamic population size to enhance exploration in early stages and fine-tune solutions later.\n# Code: \nimport numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population.shape[0]) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population.shape[0]\n\n        while self.eval_count < self.budget:\n            current_size = self.population.shape[0]\n            if self.eval_count > self.budget / 2:\n                self.population = self.population[:current_size // 2]\n                self.fitness = self.fitness[:current_size // 2]\n\n            for i in range(self.population.shape[0]):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Adaptive ADERM with dynamic population size to enhance exploration in early stages and fine-tune solutions later.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "metadata": {}, "mutation_prompt": null}
{"id": "f5fe80ad-ab7e-4303-a076-15e58346879f", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM with adaptive mutation scaling to better balance exploration and exploitation across function landscapes.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "metadata": {"aucs": [0.8189917612543086, 0.7940046396522192, 0.8197413166857499, 0.8215958738741156, 0.8256352848480368, 0.843128942279562, 0.8033517635096421, 0.8361355294041023, 0.8239888611248899, 0.6547592550917212, 0.6948856005191064, 0.6893210169781734, 0.6895717687233951, 0.6896204841684097, 0.6630822676198038, 0.673397075579908, 0.6819914834763802, 0.6716857004961911, 0.11113788328637242, 0.11787942222121894, 0.1088448125555811, 0.11766936891755808, 0.11893893531036426, 0.11317287450925984, 0.12873450891196603, 0.12336226129818517, 0.10929380997129357, 0.10995132377653705, 0.11219570133074608, 0.09888777357366474, 0.10150790563777012, 0.11990637997817899, 0.10578638186690537, 0.10686319319436666, 0.10835640873835617, 0.11494248461581624, 0.9173895297038399, 0.9024749284934813, 0.9188535311169952, 0.9481978000951217, 0.9301144525995659, 0.9618110813115364, 0.8779015189372863, 0.8999430573694092, 0.8882952287771846, 0.48534553766430444, 0.5016032379476014, 0.48932084229191963, 0.4711370345498276, 0.4810649549464854, 0.46823924364364133, 0.5717313766371033, 0.5079557193491571, 0.491492831163008, 0.8108116611103264, 0.7706735234914861, 0.7786629944646344, 0.7874247265279258, 0.8324805955323907, 0.8148483881841687, 0.7691755136868256, 0.7701159436354101, 0.7681305597374761, 0.30249870614960717, 0.26415854163578845, 0.18617657607246496, 0.25318787561262346, 0.30015940337318336, 0.21203613856537507, 0.19217625267683924, 0.22933646120090367, 0.3696823483564311, 0.36200881517680694, 0.13735624710358663, 0.27889635000776125, 0.1958146562128581, 0.3308709014055341, 0.2631310706560205, 0.36049311482298296, 0.2205462414125049, 0.36977219723690047, 0.4712037808332876, 0.42407206273922826, 0.4306531867266241, 0.42364296463373474, 0.47466802469897507, 0.4839025886738174, 0.42439338510310176, 0.48002388915692296, 0.42753702617256517, 0.5785731094100006, 0.6015657369919465, 0.5879238725799287, 0.5655089562473176, 0.5892417950721796, 0.4421000496877808, 0.5661560280065823, 0.5739957387818424, 0.5935580811582143, 0.12099069296090803, 0.23460109150684305, 0.1383050650264166, 0.32287721490176624, 0.2528606774255332, 0.2252132283366628, 0.2161411318880263, 0.2291272901266097, 0.14155141732266507, 0.32174144478105116, 0.33958172155855815, 0.3478014137359927, 0.3534623597496266, 0.35061137426417144, 0.3884324172333451, 0.33194562384932647, 0.3284399102655876, 0.3481403929299903, 0.7335157572902015, 0.731355106226979, 0.7255246737751284, 0.7055605877429727, 0.7406476156159796, 0.7318809341888919, 0.7309908938261409, 0.7384863412851679, 0.7393924325044655, 0.10475481276352783, 0.09579139923086155, 0.09457622801372834, 0.0973323055192643, 0.0965001843380896, 0.1014201120085172, 0.11453708781703331, 0.09393870507141822, 0.09349892746655097, 0.16211110078390534, 0.18155062716749015, 0.15250386262159377, 0.13276231953277806, 0.15380994891160538, 0.14091540604172403, 0.13738190403678197, 0.13508168644935137, 0.15695851086366253, 0.42085026979858464, 0.4400893242845124, 0.42467201974765534, 0.40623871078734797, 0.41864192495984476, 0.4284965314507654, 0.4499723837522227, 0.45165832955507235, 0.49875162353970437, 0.29826364202702804, 0.3399361089246692, 0.3542199833275079, 0.3156901909024665, 0.31425745203138444, 0.338321891988716, 0.3401473074932496, 0.36585917033586124, 0.3585754616631309, 0.23585843465070233, 0.1854337622317761, 0.19543746229176318, 0.21084327285189475, 0.20519515758420914, 0.193911862203355, 0.19405187273610414, 0.1817163260966851, 0.19177502016550896, 0.28146999828435937, 0.21403171538916266, 0.22165994061299443, 0.18187198989276976, 0.23942398350247684, 0.25932151846903695, 0.1976548802355761, 0.193841738138548, 0.2938752867356288, 0.6926549473852487, 0.16091325349405383, 0.18818900252223303, 0.7844291555418526, 0.7571636532444267, 0.6858018864000714, 0.18073701121783503, 0.1814574443932946, 0.7213461897943582, 0.7197179545693719, 0.7552443145276226, 0.5528450858917529, 0.161185825876626, 0.4269785767345804, 0.2031267788880482, 0.6190181087772927, 0.7421875025533857, 0.211073955063792, 0.18274732114792647, 0.19261705458314504, 0.18838144628452103, 0.20294136096814974, 0.17865493616273997, 0.19105965856306595, 0.18960666363472667, 0.18390641926285767, 0.1877632201107009, 0.06899015036304923, 0.0883698986245075, 0.08088038434350076, 0.07724345113178155, 0.07937524422819864, 0.07977743363874124, 0.07788884937200014, 0.08195734110433461, 0.07721866939197297]}, "mutation_prompt": null}
{"id": "433bfc13-f6fc-48b6-8214-a1f752e943d5", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM with adaptive mutation scaling to better balance exploration and exploitation across function landscapes.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "metadata": {"aucs": [0.8189917612543086, 0.7940046396522192, 0.8197413166857499, 0.8215958738741156, 0.8256352848480368, 0.843128942279562, 0.8033517635096421, 0.8361355294041023, 0.8239888611248899, 0.6547592550917212, 0.6948856005191064, 0.6893210169781734, 0.6895717687233951, 0.6896204841684097, 0.6630822676198038, 0.673397075579908, 0.6819914834763802, 0.6716857004961911, 0.11113788328637242, 0.11787942222121894, 0.1088448125555811, 0.11766936891755808, 0.11893893531036426, 0.11317287450925984, 0.12873450891196603, 0.12336226129818517, 0.10929380997129357, 0.10995132377653705, 0.11219570133074608, 0.09888777357366474, 0.10150790563777012, 0.11990637997817899, 0.10578638186690537, 0.10686319319436666, 0.10835640873835617, 0.11494248461581624, 0.9173895297038399, 0.9024749284934813, 0.9188535311169952, 0.9481978000951217, 0.9301144525995659, 0.9618110813115364, 0.8779015189372863, 0.8999430573694092, 0.8882952287771846, 0.48534553766430444, 0.5016032379476014, 0.48932084229191963, 0.4711370345498276, 0.4810649549464854, 0.46823924364364133, 0.5717313766371033, 0.5079557193491571, 0.491492831163008, 0.8108116611103264, 0.7706735234914861, 0.7786629944646344, 0.7874247265279258, 0.8324805955323907, 0.8148483881841687, 0.7691755136868256, 0.7701159436354101, 0.7681305597374761, 0.30249870614960717, 0.26415854163578845, 0.18617657607246496, 0.25318787561262346, 0.30015940337318336, 0.21203613856537507, 0.19217625267683924, 0.22933646120090367, 0.3696823483564311, 0.36200881517680694, 0.13735624710358663, 0.27889635000776125, 0.1958146562128581, 0.3308709014055341, 0.2631310706560205, 0.36049311482298296, 0.2205462414125049, 0.36977219723690047, 0.4712037808332876, 0.42407206273922826, 0.4306531867266241, 0.42364296463373474, 0.47466802469897507, 0.4839025886738174, 0.42439338510310176, 0.48002388915692296, 0.42753702617256517, 0.5785731094100006, 0.6015657369919465, 0.5879238725799287, 0.5655089562473176, 0.5892417950721796, 0.4421000496877808, 0.5661560280065823, 0.5739957387818424, 0.5935580811582143, 0.12099069296090803, 0.23460109150684305, 0.1383050650264166, 0.32287721490176624, 0.2528606774255332, 0.2252132283366628, 0.2161411318880263, 0.2291272901266097, 0.14155141732266507, 0.32174144478105116, 0.33958172155855815, 0.3478014137359927, 0.3534623597496266, 0.35061137426417144, 0.3884324172333451, 0.33194562384932647, 0.3284399102655876, 0.3481403929299903, 0.7335157572902015, 0.731355106226979, 0.7255246737751284, 0.7055605877429727, 0.7406476156159796, 0.7318809341888919, 0.7309908938261409, 0.7384863412851679, 0.7393924325044655, 0.10475481276352783, 0.09579139923086155, 0.09457622801372834, 0.0973323055192643, 0.0965001843380896, 0.1014201120085172, 0.11453708781703331, 0.09393870507141822, 0.09349892746655097, 0.16211110078390534, 0.18155062716749015, 0.15250386262159377, 0.13276231953277806, 0.15380994891160538, 0.14091540604172403, 0.13738190403678197, 0.13508168644935137, 0.15695851086366253, 0.42085026979858464, 0.4400893242845124, 0.42467201974765534, 0.40623871078734797, 0.41864192495984476, 0.4284965314507654, 0.4499723837522227, 0.45165832955507235, 0.49875162353970437, 0.29826364202702804, 0.3399361089246692, 0.3542199833275079, 0.3156901909024665, 0.31425745203138444, 0.338321891988716, 0.3401473074932496, 0.36585917033586124, 0.3585754616631309, 0.23585843465070233, 0.1854337622317761, 0.19543746229176318, 0.21084327285189475, 0.20519515758420914, 0.193911862203355, 0.19405187273610414, 0.1817163260966851, 0.19177502016550896, 0.28146999828435937, 0.21403171538916266, 0.22165994061299443, 0.18187198989276976, 0.23942398350247684, 0.25932151846903695, 0.1976548802355761, 0.193841738138548, 0.2938752867356288, 0.6926549473852487, 0.16091325349405383, 0.18818900252223303, 0.7844291555418526, 0.7571636532444267, 0.6858018864000714, 0.18073701121783503, 0.1814574443932946, 0.7213461897943582, 0.7197179545693719, 0.7552443145276226, 0.5528450858917529, 0.161185825876626, 0.4269785767345804, 0.2031267788880482, 0.6190181087772927, 0.7421875025533857, 0.211073955063792, 0.18274732114792647, 0.19261705458314504, 0.18838144628452103, 0.20294136096814974, 0.17865493616273997, 0.19105965856306595, 0.18960666363472667, 0.18390641926285767, 0.1877632201107009, 0.06899015036304923, 0.0883698986245075, 0.08088038434350076, 0.07724345113178155, 0.07937524422819864, 0.07977743363874124, 0.07788884937200014, 0.08195734110433461, 0.07721866939197297]}, "mutation_prompt": null}
{"id": "b3acd21d-f23b-477c-b7fa-0511045367ed", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM with adaptive mutation scaling to better balance exploration and exploitation across function landscapes.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "metadata": {"aucs": [0.8189917612543086, 0.7940046396522192, 0.8197413166857499, 0.8215958738741156, 0.8256352848480368, 0.843128942279562, 0.8033517635096421, 0.8361355294041023, 0.8239888611248899, 0.6547592550917212, 0.6948856005191064, 0.6893210169781734, 0.6895717687233951, 0.6896204841684097, 0.6630822676198038, 0.673397075579908, 0.6819914834763802, 0.6716857004961911, 0.11113788328637242, 0.11787942222121894, 0.1088448125555811, 0.11766936891755808, 0.11893893531036426, 0.11317287450925984, 0.12873450891196603, 0.12336226129818517, 0.10929380997129357, 0.10995132377653705, 0.11219570133074608, 0.09888777357366474, 0.10150790563777012, 0.11990637997817899, 0.10578638186690537, 0.10686319319436666, 0.10835640873835617, 0.11494248461581624, 0.9173895297038399, 0.9024749284934813, 0.9188535311169952, 0.9481978000951217, 0.9301144525995659, 0.9618110813115364, 0.8779015189372863, 0.8999430573694092, 0.8882952287771846, 0.48534553766430444, 0.5016032379476014, 0.48932084229191963, 0.4711370345498276, 0.4810649549464854, 0.46823924364364133, 0.5717313766371033, 0.5079557193491571, 0.491492831163008, 0.8108116611103264, 0.7706735234914861, 0.7786629944646344, 0.7874247265279258, 0.8324805955323907, 0.8148483881841687, 0.7691755136868256, 0.7701159436354101, 0.7681305597374761, 0.30249870614960717, 0.26415854163578845, 0.18617657607246496, 0.25318787561262346, 0.30015940337318336, 0.21203613856537507, 0.19217625267683924, 0.22933646120090367, 0.3696823483564311, 0.36200881517680694, 0.13735624710358663, 0.27889635000776125, 0.1958146562128581, 0.3308709014055341, 0.2631310706560205, 0.36049311482298296, 0.2205462414125049, 0.36977219723690047, 0.4712037808332876, 0.42407206273922826, 0.4306531867266241, 0.42364296463373474, 0.47466802469897507, 0.4839025886738174, 0.42439338510310176, 0.48002388915692296, 0.42753702617256517, 0.5785731094100006, 0.6015657369919465, 0.5879238725799287, 0.5655089562473176, 0.5892417950721796, 0.4421000496877808, 0.5661560280065823, 0.5739957387818424, 0.5935580811582143, 0.12099069296090803, 0.23460109150684305, 0.1383050650264166, 0.32287721490176624, 0.2528606774255332, 0.2252132283366628, 0.2161411318880263, 0.2291272901266097, 0.14155141732266507, 0.32174144478105116, 0.33958172155855815, 0.3478014137359927, 0.3534623597496266, 0.35061137426417144, 0.3884324172333451, 0.33194562384932647, 0.3284399102655876, 0.3481403929299903, 0.7335157572902015, 0.731355106226979, 0.7255246737751284, 0.7055605877429727, 0.7406476156159796, 0.7318809341888919, 0.7309908938261409, 0.7384863412851679, 0.7393924325044655, 0.10475481276352783, 0.09579139923086155, 0.09457622801372834, 0.0973323055192643, 0.0965001843380896, 0.1014201120085172, 0.11453708781703331, 0.09393870507141822, 0.09349892746655097, 0.16211110078390534, 0.18155062716749015, 0.15250386262159377, 0.13276231953277806, 0.15380994891160538, 0.14091540604172403, 0.13738190403678197, 0.13508168644935137, 0.15695851086366253, 0.42085026979858464, 0.4400893242845124, 0.42467201974765534, 0.40623871078734797, 0.41864192495984476, 0.4284965314507654, 0.4499723837522227, 0.45165832955507235, 0.49875162353970437, 0.29826364202702804, 0.3399361089246692, 0.3542199833275079, 0.3156901909024665, 0.31425745203138444, 0.338321891988716, 0.3401473074932496, 0.36585917033586124, 0.3585754616631309, 0.23585843465070233, 0.1854337622317761, 0.19543746229176318, 0.21084327285189475, 0.20519515758420914, 0.193911862203355, 0.19405187273610414, 0.1817163260966851, 0.19177502016550896, 0.28146999828435937, 0.21403171538916266, 0.22165994061299443, 0.18187198989276976, 0.23942398350247684, 0.25932151846903695, 0.1976548802355761, 0.193841738138548, 0.2938752867356288, 0.6926549473852487, 0.16091325349405383, 0.18818900252223303, 0.7844291555418526, 0.7571636532444267, 0.6858018864000714, 0.18073701121783503, 0.1814574443932946, 0.7213461897943582, 0.7197179545693719, 0.7552443145276226, 0.5528450858917529, 0.161185825876626, 0.4269785767345804, 0.2031267788880482, 0.6190181087772927, 0.7421875025533857, 0.211073955063792, 0.18274732114792647, 0.19261705458314504, 0.18838144628452103, 0.20294136096814974, 0.17865493616273997, 0.19105965856306595, 0.18960666363472667, 0.18390641926285767, 0.1877632201107009, 0.06899015036304923, 0.0883698986245075, 0.08088038434350076, 0.07724345113178155, 0.07937524422819864, 0.07977743363874124, 0.07788884937200014, 0.08195734110433461, 0.07721866939197297]}, "mutation_prompt": null}
{"id": "ed75273a-69dd-4658-9c50-ae17b4c55f07", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM with adaptive mutation scaling to better balance exploration and exploitation across function landscapes.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "metadata": {"aucs": [0.8189917612543086, 0.7940046396522192, 0.8197413166857499, 0.8215958738741156, 0.8256352848480368, 0.843128942279562, 0.8033517635096421, 0.8361355294041023, 0.8239888611248899, 0.6547592550917212, 0.6948856005191064, 0.6893210169781734, 0.6895717687233951, 0.6896204841684097, 0.6630822676198038, 0.673397075579908, 0.6819914834763802, 0.6716857004961911, 0.11113788328637242, 0.11787942222121894, 0.1088448125555811, 0.11766936891755808, 0.11893893531036426, 0.11317287450925984, 0.12873450891196603, 0.12336226129818517, 0.10929380997129357, 0.10995132377653705, 0.11219570133074608, 0.09888777357366474, 0.10150790563777012, 0.11990637997817899, 0.10578638186690537, 0.10686319319436666, 0.10835640873835617, 0.11494248461581624, 0.9173895297038399, 0.9024749284934813, 0.9188535311169952, 0.9481978000951217, 0.9301144525995659, 0.9618110813115364, 0.8779015189372863, 0.8999430573694092, 0.8882952287771846, 0.48534553766430444, 0.5016032379476014, 0.48932084229191963, 0.4711370345498276, 0.4810649549464854, 0.46823924364364133, 0.5717313766371033, 0.5079557193491571, 0.491492831163008, 0.8108116611103264, 0.7706735234914861, 0.7786629944646344, 0.7874247265279258, 0.8324805955323907, 0.8148483881841687, 0.7691755136868256, 0.7701159436354101, 0.7681305597374761, 0.30249870614960717, 0.26415854163578845, 0.18617657607246496, 0.25318787561262346, 0.30015940337318336, 0.21203613856537507, 0.19217625267683924, 0.22933646120090367, 0.3696823483564311, 0.36200881517680694, 0.13735624710358663, 0.27889635000776125, 0.1958146562128581, 0.3308709014055341, 0.2631310706560205, 0.36049311482298296, 0.2205462414125049, 0.36977219723690047, 0.4712037808332876, 0.42407206273922826, 0.4306531867266241, 0.42364296463373474, 0.47466802469897507, 0.4839025886738174, 0.42439338510310176, 0.48002388915692296, 0.42753702617256517, 0.5785731094100006, 0.6015657369919465, 0.5879238725799287, 0.5655089562473176, 0.5892417950721796, 0.4421000496877808, 0.5661560280065823, 0.5739957387818424, 0.5935580811582143, 0.12099069296090803, 0.23460109150684305, 0.1383050650264166, 0.32287721490176624, 0.2528606774255332, 0.2252132283366628, 0.2161411318880263, 0.2291272901266097, 0.14155141732266507, 0.32174144478105116, 0.33958172155855815, 0.3478014137359927, 0.3534623597496266, 0.35061137426417144, 0.3884324172333451, 0.33194562384932647, 0.3284399102655876, 0.3481403929299903, 0.7335157572902015, 0.731355106226979, 0.7255246737751284, 0.7055605877429727, 0.7406476156159796, 0.7318809341888919, 0.7309908938261409, 0.7384863412851679, 0.7393924325044655, 0.10475481276352783, 0.09579139923086155, 0.09457622801372834, 0.0973323055192643, 0.0965001843380896, 0.1014201120085172, 0.11453708781703331, 0.09393870507141822, 0.09349892746655097, 0.16211110078390534, 0.18155062716749015, 0.15250386262159377, 0.13276231953277806, 0.15380994891160538, 0.14091540604172403, 0.13738190403678197, 0.13508168644935137, 0.15695851086366253, 0.42085026979858464, 0.4400893242845124, 0.42467201974765534, 0.40623871078734797, 0.41864192495984476, 0.4284965314507654, 0.4499723837522227, 0.45165832955507235, 0.49875162353970437, 0.29826364202702804, 0.3399361089246692, 0.3542199833275079, 0.3156901909024665, 0.31425745203138444, 0.338321891988716, 0.3401473074932496, 0.36585917033586124, 0.3585754616631309, 0.23585843465070233, 0.1854337622317761, 0.19543746229176318, 0.21084327285189475, 0.20519515758420914, 0.193911862203355, 0.19405187273610414, 0.1817163260966851, 0.19177502016550896, 0.28146999828435937, 0.21403171538916266, 0.22165994061299443, 0.18187198989276976, 0.23942398350247684, 0.25932151846903695, 0.1976548802355761, 0.193841738138548, 0.2938752867356288, 0.6926549473852487, 0.16091325349405383, 0.18818900252223303, 0.7844291555418526, 0.7571636532444267, 0.6858018864000714, 0.18073701121783503, 0.1814574443932946, 0.7213461897943582, 0.7197179545693719, 0.7552443145276226, 0.5528450858917529, 0.161185825876626, 0.4269785767345804, 0.2031267788880482, 0.6190181087772927, 0.7421875025533857, 0.211073955063792, 0.18274732114792647, 0.19261705458314504, 0.18838144628452103, 0.20294136096814974, 0.17865493616273997, 0.19105965856306595, 0.18960666363472667, 0.18390641926285767, 0.1877632201107009, 0.06899015036304923, 0.0883698986245075, 0.08088038434350076, 0.07724345113178155, 0.07937524422819864, 0.07977743363874124, 0.07788884937200014, 0.08195734110433461, 0.07721866939197297]}, "mutation_prompt": null}
{"id": "1074df8e-cf6b-41e9-9e65-07470beb2d10", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "ADERM with adaptive crossover rate to enhance diversity and convergence speed.", "configspace": "", "generation": 24, "fitness": 0.3957021446019458, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "c4725eb5-05d5-47c4-9f82-0a7ee4fefc27", "metadata": {"aucs": [0.8121933010417008, 0.7969578579077381, 0.7959838938190844, 0.8227368198742276, 0.8228828374501048, 0.8189671089866604, 0.8059801593852574, 0.8120124182516303, 0.8226324701566095, 0.6774118046298189, 0.6730770189354132, 0.6813466249661048, 0.6756682998449044, 0.6792445425473155, 0.6829772664024436, 0.655448328655961, 0.6658036182364147, 0.6706526708337471, 0.1520884003295816, 0.09845889892796389, 0.1232019763250568, 0.11221244520631313, 0.11228416859267432, 0.13357280729914933, 0.1159961256960298, 0.12528761916329967, 0.09801791901757662, 0.0987175352788392, 0.11009938747378478, 0.12297495861845731, 0.11148598021174572, 0.10952746081625031, 0.10416145899043716, 0.10626651348412763, 0.10041883366232829, 0.10576151032663295, 0.9324681063480904, 0.9508008195228748, 0.8866526599290863, 0.895503340481922, 0.9051655411038649, 0.8956093466155234, 0.8473520347239772, 0.8590321061856251, 0.9116253299955821, 0.5337671369042521, 0.5108286831166855, 0.49253105674965547, 0.5300405992716655, 0.5253403501352967, 0.5223842646278771, 0.45444867835730474, 0.4855578208719278, 0.48936348712469646, 0.7623282567734136, 0.8131139342101897, 0.7437136475323327, 0.792002487093675, 0.8077486270145816, 0.7961604874349566, 0.7910884838572869, 0.7460895078674502, 0.7738623101881661, 0.28727385482509826, 0.17294402565351918, 0.24203554837906982, 0.28160302350727673, 0.21180830643721604, 0.28186558615741, 0.21640778137522343, 0.24322187127187234, 0.21355739588122913, 0.4242217055130322, 0.1997605769726699, 0.19255832344866408, 0.24889586633903038, 0.28592081045149986, 0.31360388236398307, 0.20300251755452026, 0.5069326065670706, 0.2458345426179308, 0.4494647007804118, 0.44311700231245477, 0.4377676314437513, 0.4064142816282199, 0.4174794188479475, 0.43841698201642676, 0.46121687896202945, 0.45399964684893845, 0.43339006748136166, 0.6056890834797664, 0.579341475122907, 0.5409818697886248, 0.5783816090192665, 0.570518132318413, 0.5408260033259501, 0.5473137777351091, 0.5653188517025316, 0.5903692506058007, 0.14652834660003633, 0.08085946054945692, 0.21592605821701416, 0.30706046283358024, 0.3139581097056032, 0.3067618358203349, 0.20836445733580344, 0.15547252946016743, 0.15222626154358554, 0.3642824358805373, 0.3551754772071083, 0.3473146210863919, 0.35360095351601173, 0.37677534609625796, 0.38839749877846264, 0.3498853639045677, 0.3367617848577307, 0.33129661349451967, 0.7393695698146366, 0.7306809739631781, 0.7339951528777695, 0.7372779723195364, 0.7246181413533992, 0.7271356553757395, 0.7432997719987486, 0.7096736329512785, 0.764500444440489, 0.10817398349192064, 0.1126645921760544, 0.10926903315934344, 0.11047540206659856, 0.1008516828624082, 0.10957451257062911, 0.10606804802179848, 0.10010351889748659, 0.105148051578271, 0.1585633057796887, 0.14868548173559448, 0.14175008731702632, 0.1416890855738222, 0.17255996500959858, 0.13234712402832682, 0.23917276423186185, 0.1583166488742085, 0.20285129111536027, 0.4296729433719805, 0.4548205432307062, 0.43955639062012597, 0.4425956676837902, 0.4440318351695325, 0.4012707844223793, 0.48139321019438763, 0.4802323299399537, 0.48199279880431445, 0.3197503718132876, 0.3385576220233384, 0.34635727165452823, 0.31028817727218416, 0.3117937755647707, 0.31781621273803673, 0.3660603653562339, 0.32785617033414816, 0.38514938144372923, 0.1984162584614303, 0.18743967478021717, 0.19501390598919366, 0.23289993739246484, 0.20430714090833457, 0.18703307995933016, 0.2097922351720607, 0.18663313453122532, 0.2133407096794202, 0.3156164302561618, 0.22124721426091798, 0.1985105214952252, 0.20047462375491454, 0.1947019042330621, 0.19829188888664961, 0.18547284955318732, 0.22690023979006546, 0.19723481149644273, 0.7563851693030174, 0.18227580577399272, 0.7449882087203531, 0.8205738911266509, 0.7040728278300544, 0.675696702270352, 0.18672453090216046, 0.32442238307816074, 0.6968020508881985, 0.591234202376534, 0.16443804030250908, 0.20194625817437095, 0.20165236682955634, 0.6660693894913337, 0.7180267965254151, 0.7132097753519236, 0.6535911267434085, 0.20748319093708034, 0.18194319791552493, 0.1870231991184914, 0.18732486288627248, 0.1825192530698858, 0.1796476434331158, 0.18153749291730292, 0.17141630011953057, 0.18434341990193504, 0.18535300958100875, 0.0811725546006995, 0.08208032585179148, 0.07706191989191191, 0.08240312728861865, 0.08524417133923912, 0.08135094737654924, 0.07309771828209854, 0.08668052487297773, 0.08133989211903558]}, "mutation_prompt": null}
{"id": "52c66551-2787-4d34-96a2-8ae2e5e91a98", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "ADERM with adaptive crossover rate to enhance diversity and convergence speed.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1074df8e-cf6b-41e9-9e65-07470beb2d10", "metadata": {"aucs": [0.8121933010417008, 0.7969578579077381, 0.7959838938190844, 0.8227368198742276, 0.8228828374501048, 0.8189671089866604, 0.8059801593852574, 0.8120124182516303, 0.8226324701566095, 0.6774118046298189, 0.6730770189354132, 0.6813466249661048, 0.6756682998449044, 0.6792445425473155, 0.6829772664024436, 0.655448328655961, 0.6658036182364147, 0.6706526708337471, 0.1520884003295816, 0.09845889892796389, 0.1232019763250568, 0.11221244520631313, 0.11228416859267432, 0.13357280729914933, 0.1159961256960298, 0.12528761916329967, 0.09801791901757662, 0.0987175352788392, 0.11009938747378478, 0.12297495861845731, 0.11148598021174572, 0.10952746081625031, 0.10416145899043716, 0.10626651348412763, 0.10041883366232829, 0.10576151032663295, 0.9324681063480904, 0.9508008195228748, 0.8866526599290863, 0.895503340481922, 0.9051655411038649, 0.8956093466155234, 0.8473520347239772, 0.8590321061856251, 0.9116253299955821, 0.5337671369042521, 0.5108286831166855, 0.49253105674965547, 0.5300405992716655, 0.5253403501352967, 0.5223842646278771, 0.45444867835730474, 0.4855578208719278, 0.48936348712469646, 0.7623282567734136, 0.8131139342101897, 0.7437136475323327, 0.792002487093675, 0.8077486270145816, 0.7961604874349566, 0.7910884838572869, 0.7460895078674502, 0.7738623101881661, 0.28727385482509826, 0.17294402565351918, 0.24203554837906982, 0.28160302350727673, 0.21180830643721604, 0.28186558615741, 0.21640778137522343, 0.24322187127187234, 0.21355739588122913, 0.4242217055130322, 0.1997605769726699, 0.19255832344866408, 0.24889586633903038, 0.28592081045149986, 0.31360388236398307, 0.20300251755452026, 0.5069326065670706, 0.2458345426179308, 0.4494647007804118, 0.44311700231245477, 0.4377676314437513, 0.4064142816282199, 0.4174794188479475, 0.43841698201642676, 0.46121687896202945, 0.45399964684893845, 0.43339006748136166, 0.6056890834797664, 0.579341475122907, 0.5409818697886248, 0.5783816090192665, 0.570518132318413, 0.5408260033259501, 0.5473137777351091, 0.5653188517025316, 0.5903692506058007, 0.14652834660003633, 0.08085946054945692, 0.21592605821701416, 0.30706046283358024, 0.3139581097056032, 0.3067618358203349, 0.20836445733580344, 0.15547252946016743, 0.15222626154358554, 0.3642824358805373, 0.3551754772071083, 0.3473146210863919, 0.35360095351601173, 0.37677534609625796, 0.38839749877846264, 0.3498853639045677, 0.3367617848577307, 0.33129661349451967, 0.7393695698146366, 0.7306809739631781, 0.7339951528777695, 0.7372779723195364, 0.7246181413533992, 0.7271356553757395, 0.7432997719987486, 0.7096736329512785, 0.764500444440489, 0.10817398349192064, 0.1126645921760544, 0.10926903315934344, 0.11047540206659856, 0.1008516828624082, 0.10957451257062911, 0.10606804802179848, 0.10010351889748659, 0.105148051578271, 0.1585633057796887, 0.14868548173559448, 0.14175008731702632, 0.1416890855738222, 0.17255996500959858, 0.13234712402832682, 0.23917276423186185, 0.1583166488742085, 0.20285129111536027, 0.4296729433719805, 0.4548205432307062, 0.43955639062012597, 0.4425956676837902, 0.4440318351695325, 0.4012707844223793, 0.48139321019438763, 0.4802323299399537, 0.48199279880431445, 0.3197503718132876, 0.3385576220233384, 0.34635727165452823, 0.31028817727218416, 0.3117937755647707, 0.31781621273803673, 0.3660603653562339, 0.32785617033414816, 0.38514938144372923, 0.1984162584614303, 0.18743967478021717, 0.19501390598919366, 0.23289993739246484, 0.20430714090833457, 0.18703307995933016, 0.2097922351720607, 0.18663313453122532, 0.2133407096794202, 0.3156164302561618, 0.22124721426091798, 0.1985105214952252, 0.20047462375491454, 0.1947019042330621, 0.19829188888664961, 0.18547284955318732, 0.22690023979006546, 0.19723481149644273, 0.7563851693030174, 0.18227580577399272, 0.7449882087203531, 0.8205738911266509, 0.7040728278300544, 0.675696702270352, 0.18672453090216046, 0.32442238307816074, 0.6968020508881985, 0.591234202376534, 0.16443804030250908, 0.20194625817437095, 0.20165236682955634, 0.6660693894913337, 0.7180267965254151, 0.7132097753519236, 0.6535911267434085, 0.20748319093708034, 0.18194319791552493, 0.1870231991184914, 0.18732486288627248, 0.1825192530698858, 0.1796476434331158, 0.18153749291730292, 0.17141630011953057, 0.18434341990193504, 0.18535300958100875, 0.0811725546006995, 0.08208032585179148, 0.07706191989191191, 0.08240312728861865, 0.08524417133923912, 0.08135094737654924, 0.07309771828209854, 0.08668052487297773, 0.08133989211903558]}, "mutation_prompt": null}
{"id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Introducing self-adaptive differential weights and elitism to enhance convergence and stability.", "configspace": "", "generation": 26, "fitness": 0.39718532744937946, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "1074df8e-cf6b-41e9-9e65-07470beb2d10", "metadata": {"aucs": [0.8297458042463494, 0.8156480002827302, 0.8143894473036027, 0.8213638973173589, 0.8278855043832772, 0.8051116066873488, 0.8196321296912182, 0.8255257236660725, 0.8188025389461273, 0.6819857244062847, 0.6736333566609699, 0.6878050655810275, 0.6791726825534778, 0.6804604691226493, 0.6803607278099388, 0.6920943248535969, 0.6836562785220861, 0.6815167766054107, 0.11931659690405738, 0.1172289943082222, 0.10339605801729779, 0.11045092254378142, 0.11614302152963951, 0.1123404038585315, 0.1273058064156095, 0.1144501291547011, 0.12740282350091436, 0.09893377714571705, 0.1123499378778231, 0.11088285992643576, 0.10656668585397944, 0.12478911762375211, 0.1133647201609157, 0.11043390792648866, 0.10284918460972736, 0.10731258665704424, 0.9443228317890835, 0.9380074864713106, 0.8581222616975699, 0.9038856916925254, 0.9160926925131349, 0.9594155442462438, 0.9403802415858479, 0.9522564639051768, 0.9437097330891902, 0.525009313016245, 0.5118457269556749, 0.4815845019436472, 0.5373397030557419, 0.471789976449591, 0.5185353308116601, 0.5608025250019346, 0.514247370728256, 0.5102076667975377, 0.7974837346192244, 0.7800697867147564, 0.7904599897137514, 0.8136565960396315, 0.7938698572854825, 0.8139048436847278, 0.7882819723124609, 0.7991638782700725, 0.7867459464538453, 0.19417985999883824, 0.2010846719245024, 0.208977961127924, 0.16667251993646548, 0.19906186939947967, 0.23319733215677052, 0.4641489692042742, 0.3935568699790509, 0.4331213021736606, 0.2197222181768751, 0.17051083560722213, 0.20775592807226706, 0.22953980603295, 0.21662876244346263, 0.18259238241267928, 0.1703873764535907, 0.2931786409245878, 0.2041746300063484, 0.4128975676761405, 0.4483671539584203, 0.47835305626004954, 0.43609675570009865, 0.4978201326809182, 0.43271526669775884, 0.4950437675261451, 0.47720020837329735, 0.42036823175462523, 0.5813655513199145, 0.6130753935272687, 0.5761154904640875, 0.5510220852189298, 0.5997574532082599, 0.579512240584326, 0.6398484173382619, 0.5560441590387513, 0.557729464269517, 0.09482148592965134, 0.1336271869596145, 0.2067762831832226, 0.2987721382553641, 0.3102352918424556, 0.3155471589598925, 0.15375567883799668, 0.18953195265721046, 0.13810211960786944, 0.359627020613831, 0.3531014295428201, 0.3722879789943907, 0.3649108346909722, 0.3570663077335843, 0.3491015800202639, 0.33066108112120196, 0.3635576267881403, 0.3803243576039914, 0.7337719379708636, 0.742001778433809, 0.7411444780606073, 0.7428250793750546, 0.73757391644181, 0.7418910568868908, 0.7172159995207952, 0.7048249665606516, 0.7381905794724631, 0.12716356408834872, 0.09291236006257553, 0.102506927278745, 0.1016083805459781, 0.1317765813060804, 0.09688548907068617, 0.09848808532635789, 0.11270260055980574, 0.11186319067676798, 0.16212413840628392, 0.14243389658368655, 0.22221469381853987, 0.12696921258317428, 0.16589868328370283, 0.13708420264789034, 0.17297767338798842, 0.12515885736816723, 0.1315516589912329, 0.406108108863548, 0.4174614354622481, 0.4444905754435988, 0.4520940992602076, 0.42254940338213176, 0.44075385598475714, 0.4768406304744778, 0.48466222481663546, 0.4847729119286832, 0.3787570004609824, 0.3546516690248013, 0.35600845662264313, 0.3367484683681664, 0.3402231198816511, 0.34335524285089525, 0.36292831658963776, 0.37247009535374487, 0.3838455237809446, 0.2038978576651429, 0.22463217393761747, 0.19616214368892604, 0.2183139834062382, 0.18556569767277387, 0.2082935374289745, 0.1846077324151364, 0.18243046541189867, 0.22010577725596603, 0.18442998491849827, 0.3025622028966575, 0.1800939059669372, 0.2408461801860583, 0.1896568287092706, 0.18338929123877856, 0.20088219774647342, 0.2029516571354918, 0.23213088346535538, 0.6999143731044579, 0.7132501272512096, 0.1688265360950476, 0.7360871426745444, 0.716751675635316, 0.7564821985788197, 0.6821453881303693, 0.17921803120211788, 0.7373262207955855, 0.4839285763209237, 0.20443760723073456, 0.8034578739867151, 0.19516544195565244, 0.20374232734466213, 0.19369912840445314, 0.7034414364662376, 0.199312752030111, 0.5497223052146374, 0.19771320767755463, 0.17600142488006476, 0.1905150252820561, 0.1857067704001406, 0.17495083231295994, 0.17711089215565412, 0.1786421858131929, 0.18676389367520452, 0.1840608518637148, 0.0773742464968098, 0.0773335950561228, 0.08684644390454432, 0.08989326258074293, 0.08173719051758399, 0.08135339948508336, 0.0789434526531595, 0.07907687859406975, 0.08053330042211859]}, "mutation_prompt": null}
{"id": "81fca851-1401-492b-a4f1-b82563bbe26b", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Introducing self-adaptive differential weights and elitism to enhance convergence and stability.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "metadata": {"aucs": [0.8297458042463494, 0.8156480002827302, 0.8143894473036027, 0.8213638973173589, 0.8278855043832772, 0.8051116066873488, 0.8196321296912182, 0.8255257236660725, 0.8188025389461273, 0.6819857244062847, 0.6736333566609699, 0.6878050655810275, 0.6791726825534778, 0.6804604691226493, 0.6803607278099388, 0.6920943248535969, 0.6836562785220861, 0.6815167766054107, 0.11931659690405738, 0.1172289943082222, 0.10339605801729779, 0.11045092254378142, 0.11614302152963951, 0.1123404038585315, 0.1273058064156095, 0.1144501291547011, 0.12740282350091436, 0.09893377714571705, 0.1123499378778231, 0.11088285992643576, 0.10656668585397944, 0.12478911762375211, 0.1133647201609157, 0.11043390792648866, 0.10284918460972736, 0.10731258665704424, 0.9443228317890835, 0.9380074864713106, 0.8581222616975699, 0.9038856916925254, 0.9160926925131349, 0.9594155442462438, 0.9403802415858479, 0.9522564639051768, 0.9437097330891902, 0.525009313016245, 0.5118457269556749, 0.4815845019436472, 0.5373397030557419, 0.471789976449591, 0.5185353308116601, 0.5608025250019346, 0.514247370728256, 0.5102076667975377, 0.7974837346192244, 0.7800697867147564, 0.7904599897137514, 0.8136565960396315, 0.7938698572854825, 0.8139048436847278, 0.7882819723124609, 0.7991638782700725, 0.7867459464538453, 0.19417985999883824, 0.2010846719245024, 0.208977961127924, 0.16667251993646548, 0.19906186939947967, 0.23319733215677052, 0.4641489692042742, 0.3935568699790509, 0.4331213021736606, 0.2197222181768751, 0.17051083560722213, 0.20775592807226706, 0.22953980603295, 0.21662876244346263, 0.18259238241267928, 0.1703873764535907, 0.2931786409245878, 0.2041746300063484, 0.4128975676761405, 0.4483671539584203, 0.47835305626004954, 0.43609675570009865, 0.4978201326809182, 0.43271526669775884, 0.4950437675261451, 0.47720020837329735, 0.42036823175462523, 0.5813655513199145, 0.6130753935272687, 0.5761154904640875, 0.5510220852189298, 0.5997574532082599, 0.579512240584326, 0.6398484173382619, 0.5560441590387513, 0.557729464269517, 0.09482148592965134, 0.1336271869596145, 0.2067762831832226, 0.2987721382553641, 0.3102352918424556, 0.3155471589598925, 0.15375567883799668, 0.18953195265721046, 0.13810211960786944, 0.359627020613831, 0.3531014295428201, 0.3722879789943907, 0.3649108346909722, 0.3570663077335843, 0.3491015800202639, 0.33066108112120196, 0.3635576267881403, 0.3803243576039914, 0.7337719379708636, 0.742001778433809, 0.7411444780606073, 0.7428250793750546, 0.73757391644181, 0.7418910568868908, 0.7172159995207952, 0.7048249665606516, 0.7381905794724631, 0.12716356408834872, 0.09291236006257553, 0.102506927278745, 0.1016083805459781, 0.1317765813060804, 0.09688548907068617, 0.09848808532635789, 0.11270260055980574, 0.11186319067676798, 0.16212413840628392, 0.14243389658368655, 0.22221469381853987, 0.12696921258317428, 0.16589868328370283, 0.13708420264789034, 0.17297767338798842, 0.12515885736816723, 0.1315516589912329, 0.406108108863548, 0.4174614354622481, 0.4444905754435988, 0.4520940992602076, 0.42254940338213176, 0.44075385598475714, 0.4768406304744778, 0.48466222481663546, 0.4847729119286832, 0.3787570004609824, 0.3546516690248013, 0.35600845662264313, 0.3367484683681664, 0.3402231198816511, 0.34335524285089525, 0.36292831658963776, 0.37247009535374487, 0.3838455237809446, 0.2038978576651429, 0.22463217393761747, 0.19616214368892604, 0.2183139834062382, 0.18556569767277387, 0.2082935374289745, 0.1846077324151364, 0.18243046541189867, 0.22010577725596603, 0.18442998491849827, 0.3025622028966575, 0.1800939059669372, 0.2408461801860583, 0.1896568287092706, 0.18338929123877856, 0.20088219774647342, 0.2029516571354918, 0.23213088346535538, 0.6999143731044579, 0.7132501272512096, 0.1688265360950476, 0.7360871426745444, 0.716751675635316, 0.7564821985788197, 0.6821453881303693, 0.17921803120211788, 0.7373262207955855, 0.4839285763209237, 0.20443760723073456, 0.8034578739867151, 0.19516544195565244, 0.20374232734466213, 0.19369912840445314, 0.7034414364662376, 0.199312752030111, 0.5497223052146374, 0.19771320767755463, 0.17600142488006476, 0.1905150252820561, 0.1857067704001406, 0.17495083231295994, 0.17711089215565412, 0.1786421858131929, 0.18676389367520452, 0.1840608518637148, 0.0773742464968098, 0.0773335950561228, 0.08684644390454432, 0.08989326258074293, 0.08173719051758399, 0.08135339948508336, 0.0789434526531595, 0.07907687859406975, 0.08053330042211859]}, "mutation_prompt": null}
{"id": "92777f7a-ecd7-44a9-9fb1-6ecb3289dcbe", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best two individuals\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n            # Adaptive population resizing every 10% of budget used\n            if self.eval_count % (self.budget // 10) == 0:  \n                self.population_size = max(5 * self.dim, int(0.95 * self.population_size))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Introducing adaptive population resizing and enhanced elitism to improve exploration and exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.39718532744937946, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "metadata": {"aucs": [0.8297458042463494, 0.8156480002827302, 0.8143894473036027, 0.8213638973173589, 0.8278855043832772, 0.8051116066873488, 0.8196321296912182, 0.8255257236660725, 0.8188025389461273, 0.6819857244062847, 0.6736333566609699, 0.6878050655810275, 0.6791726825534778, 0.6804604691226493, 0.6803607278099388, 0.6920943248535969, 0.6836562785220861, 0.6815167766054107, 0.11931659690405738, 0.1172289943082222, 0.10339605801729779, 0.11045092254378142, 0.11614302152963951, 0.1123404038585315, 0.1273058064156095, 0.1144501291547011, 0.12740282350091436, 0.09893377714571705, 0.1123499378778231, 0.11088285992643576, 0.10656668585397944, 0.12478911762375211, 0.1133647201609157, 0.11043390792648866, 0.10284918460972736, 0.10731258665704424, 0.9443228317890835, 0.9380074864713106, 0.8581222616975699, 0.9038856916925254, 0.9160926925131349, 0.9594155442462438, 0.9403802415858479, 0.9522564639051768, 0.9437097330891902, 0.525009313016245, 0.5118457269556749, 0.4815845019436472, 0.5373397030557419, 0.471789976449591, 0.5185353308116601, 0.5608025250019346, 0.514247370728256, 0.5102076667975377, 0.7974837346192244, 0.7800697867147564, 0.7904599897137514, 0.8136565960396315, 0.7938698572854825, 0.8139048436847278, 0.7882819723124609, 0.7991638782700725, 0.7867459464538453, 0.19417985999883824, 0.2010846719245024, 0.208977961127924, 0.16667251993646548, 0.19906186939947967, 0.23319733215677052, 0.4641489692042742, 0.3935568699790509, 0.4331213021736606, 0.2197222181768751, 0.17051083560722213, 0.20775592807226706, 0.22953980603295, 0.21662876244346263, 0.18259238241267928, 0.1703873764535907, 0.2931786409245878, 0.2041746300063484, 0.4128975676761405, 0.4483671539584203, 0.47835305626004954, 0.43609675570009865, 0.4978201326809182, 0.43271526669775884, 0.4950437675261451, 0.47720020837329735, 0.42036823175462523, 0.5813655513199145, 0.6130753935272687, 0.5761154904640875, 0.5510220852189298, 0.5997574532082599, 0.579512240584326, 0.6398484173382619, 0.5560441590387513, 0.557729464269517, 0.09482148592965134, 0.1336271869596145, 0.2067762831832226, 0.2987721382553641, 0.3102352918424556, 0.3155471589598925, 0.15375567883799668, 0.18953195265721046, 0.13810211960786944, 0.359627020613831, 0.3531014295428201, 0.3722879789943907, 0.3649108346909722, 0.3570663077335843, 0.3491015800202639, 0.33066108112120196, 0.3635576267881403, 0.3803243576039914, 0.7337719379708636, 0.742001778433809, 0.7411444780606073, 0.7428250793750546, 0.73757391644181, 0.7418910568868908, 0.7172159995207952, 0.7048249665606516, 0.7381905794724631, 0.12716356408834872, 0.09291236006257553, 0.102506927278745, 0.1016083805459781, 0.1317765813060804, 0.09688548907068617, 0.09848808532635789, 0.11270260055980574, 0.11186319067676798, 0.16212413840628392, 0.14243389658368655, 0.22221469381853987, 0.12696921258317428, 0.16589868328370283, 0.13708420264789034, 0.17297767338798842, 0.12515885736816723, 0.1315516589912329, 0.406108108863548, 0.4174614354622481, 0.4444905754435988, 0.4520940992602076, 0.42254940338213176, 0.44075385598475714, 0.4768406304744778, 0.48466222481663546, 0.4847729119286832, 0.3787570004609824, 0.3546516690248013, 0.35600845662264313, 0.3367484683681664, 0.3402231198816511, 0.34335524285089525, 0.36292831658963776, 0.37247009535374487, 0.3838455237809446, 0.2038978576651429, 0.22463217393761747, 0.19616214368892604, 0.2183139834062382, 0.18556569767277387, 0.2082935374289745, 0.1846077324151364, 0.18243046541189867, 0.22010577725596603, 0.18442998491849827, 0.3025622028966575, 0.1800939059669372, 0.2408461801860583, 0.1896568287092706, 0.18338929123877856, 0.20088219774647342, 0.2029516571354918, 0.23213088346535538, 0.6999143731044579, 0.7132501272512096, 0.1688265360950476, 0.7360871426745444, 0.716751675635316, 0.7564821985788197, 0.6821453881303693, 0.17921803120211788, 0.7373262207955855, 0.4839285763209237, 0.20443760723073456, 0.8034578739867151, 0.19516544195565244, 0.20374232734466213, 0.19369912840445314, 0.7034414364662376, 0.199312752030111, 0.5497223052146374, 0.19771320767755463, 0.17600142488006476, 0.1905150252820561, 0.1857067704001406, 0.17495083231295994, 0.17711089215565412, 0.1786421858131929, 0.18676389367520452, 0.1840608518637148, 0.0773742464968098, 0.0773335950561228, 0.08684644390454432, 0.08989326258074293, 0.08173719051758399, 0.08135339948508336, 0.0789434526531595, 0.07907687859406975, 0.08053330042211859]}, "mutation_prompt": null}
{"id": "2d294d93-0b62-44e9-bc11-6d693c648b5b", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Introducing self-adaptive differential weights and elitism to enhance convergence and stability.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "metadata": {"aucs": [0.8297458042463494, 0.8156480002827302, 0.8143894473036027, 0.8213638973173589, 0.8278855043832772, 0.8051116066873488, 0.8196321296912182, 0.8255257236660725, 0.8188025389461273, 0.6819857244062847, 0.6736333566609699, 0.6878050655810275, 0.6791726825534778, 0.6804604691226493, 0.6803607278099388, 0.6920943248535969, 0.6836562785220861, 0.6815167766054107, 0.11931659690405738, 0.1172289943082222, 0.10339605801729779, 0.11045092254378142, 0.11614302152963951, 0.1123404038585315, 0.1273058064156095, 0.1144501291547011, 0.12740282350091436, 0.09893377714571705, 0.1123499378778231, 0.11088285992643576, 0.10656668585397944, 0.12478911762375211, 0.1133647201609157, 0.11043390792648866, 0.10284918460972736, 0.10731258665704424, 0.9443228317890835, 0.9380074864713106, 0.8581222616975699, 0.9038856916925254, 0.9160926925131349, 0.9594155442462438, 0.9403802415858479, 0.9522564639051768, 0.9437097330891902, 0.525009313016245, 0.5118457269556749, 0.4815845019436472, 0.5373397030557419, 0.471789976449591, 0.5185353308116601, 0.5608025250019346, 0.514247370728256, 0.5102076667975377, 0.7974837346192244, 0.7800697867147564, 0.7904599897137514, 0.8136565960396315, 0.7938698572854825, 0.8139048436847278, 0.7882819723124609, 0.7991638782700725, 0.7867459464538453, 0.19417985999883824, 0.2010846719245024, 0.208977961127924, 0.16667251993646548, 0.19906186939947967, 0.23319733215677052, 0.4641489692042742, 0.3935568699790509, 0.4331213021736606, 0.2197222181768751, 0.17051083560722213, 0.20775592807226706, 0.22953980603295, 0.21662876244346263, 0.18259238241267928, 0.1703873764535907, 0.2931786409245878, 0.2041746300063484, 0.4128975676761405, 0.4483671539584203, 0.47835305626004954, 0.43609675570009865, 0.4978201326809182, 0.43271526669775884, 0.4950437675261451, 0.47720020837329735, 0.42036823175462523, 0.5813655513199145, 0.6130753935272687, 0.5761154904640875, 0.5510220852189298, 0.5997574532082599, 0.579512240584326, 0.6398484173382619, 0.5560441590387513, 0.557729464269517, 0.09482148592965134, 0.1336271869596145, 0.2067762831832226, 0.2987721382553641, 0.3102352918424556, 0.3155471589598925, 0.15375567883799668, 0.18953195265721046, 0.13810211960786944, 0.359627020613831, 0.3531014295428201, 0.3722879789943907, 0.3649108346909722, 0.3570663077335843, 0.3491015800202639, 0.33066108112120196, 0.3635576267881403, 0.3803243576039914, 0.7337719379708636, 0.742001778433809, 0.7411444780606073, 0.7428250793750546, 0.73757391644181, 0.7418910568868908, 0.7172159995207952, 0.7048249665606516, 0.7381905794724631, 0.12716356408834872, 0.09291236006257553, 0.102506927278745, 0.1016083805459781, 0.1317765813060804, 0.09688548907068617, 0.09848808532635789, 0.11270260055980574, 0.11186319067676798, 0.16212413840628392, 0.14243389658368655, 0.22221469381853987, 0.12696921258317428, 0.16589868328370283, 0.13708420264789034, 0.17297767338798842, 0.12515885736816723, 0.1315516589912329, 0.406108108863548, 0.4174614354622481, 0.4444905754435988, 0.4520940992602076, 0.42254940338213176, 0.44075385598475714, 0.4768406304744778, 0.48466222481663546, 0.4847729119286832, 0.3787570004609824, 0.3546516690248013, 0.35600845662264313, 0.3367484683681664, 0.3402231198816511, 0.34335524285089525, 0.36292831658963776, 0.37247009535374487, 0.3838455237809446, 0.2038978576651429, 0.22463217393761747, 0.19616214368892604, 0.2183139834062382, 0.18556569767277387, 0.2082935374289745, 0.1846077324151364, 0.18243046541189867, 0.22010577725596603, 0.18442998491849827, 0.3025622028966575, 0.1800939059669372, 0.2408461801860583, 0.1896568287092706, 0.18338929123877856, 0.20088219774647342, 0.2029516571354918, 0.23213088346535538, 0.6999143731044579, 0.7132501272512096, 0.1688265360950476, 0.7360871426745444, 0.716751675635316, 0.7564821985788197, 0.6821453881303693, 0.17921803120211788, 0.7373262207955855, 0.4839285763209237, 0.20443760723073456, 0.8034578739867151, 0.19516544195565244, 0.20374232734466213, 0.19369912840445314, 0.7034414364662376, 0.199312752030111, 0.5497223052146374, 0.19771320767755463, 0.17600142488006476, 0.1905150252820561, 0.1857067704001406, 0.17495083231295994, 0.17711089215565412, 0.1786421858131929, 0.18676389367520452, 0.1840608518637148, 0.0773742464968098, 0.0773335950561228, 0.08684644390454432, 0.08989326258074293, 0.08173719051758399, 0.08135339948508336, 0.0789434526531595, 0.07907687859406975, 0.08053330042211859]}, "mutation_prompt": null}
{"id": "17c87dbd-7c73-4927-a7bf-49b2f6f37c92", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1)) \n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05)) \n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(self.fitness)\n        best_fitness = self.fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            dynamic_pop_size = max(4, int(self.population_size * (1 - self.eval_count / self.budget)))\n            for i in range(dynamic_pop_size):\n                if i != best_idx:\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_idx = i\n                            best_fitness = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        return self.population[best_idx]", "name": "ADERM", "description": "Implementing dynamic population resizing and adaptive fitness-based convergence for enhanced exploration and exploitation.", "configspace": "", "generation": 30, "fitness": 0.29677042263944786, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "metadata": {"aucs": [0.7289981204089468, 0.7438267304518932, 0.652614529903048, 0.6625354124687609, 0.6589965490462317, 0.7049450322391511, 0.7506226351494347, 0.7012734202107018, 0.7282441278115757, 0.37892964027242226, 0.3341323193347796, 0.3612596256843501, 0.41980207775636924, 0.3562250787870621, 0.3825676286927925, 0.3996443256089386, 0.39056266209042023, 0.4311137121591466, 0.10952981931999528, 0.10299953109937665, 0.11333665212607757, 0.11745929227856045, 0.11425891677860878, 0.12025096717458816, 0.12266647855382395, 0.11921621807792604, 0.11611768165849079, 0.11342198619407373, 0.09872923769669073, 0.09999529299673993, 0.08926015559629907, 0.08840089972497678, 0.08989451264403159, 0.10217646837706618, 0.10128957610816847, 0.11276901323949073, 0.9571392480695582, 0.9438325959080046, 0.9187697031129418, 0.9563441019783973, 0.9315941057324678, 0.9510536372377121, 0.9430338229376777, 0.9486299376630908, 0.9349847473053221, 0.31890321962053214, 0.2751042119893198, 0.3055872769777711, 0.33737153617477256, 0.2953261082492916, 0.32053117694112343, 0.27486898937787396, 0.3524106291920419, 0.3380233330686109, 0.7303381228965284, 0.7346004136915311, 0.7552104578735145, 0.6673204524587717, 0.7573636494339863, 0.6502533168258913, 0.707076991738303, 0.6893506991662625, 0.7038373895315716, 0.2330089259033583, 0.14299616596851816, 0.165963997622406, 0.20333599702147764, 0.20633899622240248, 0.18585077050637533, 0.2967097111915341, 0.2032249217049923, 0.23333338132351233, 0.1501808888734869, 0.2054577439817088, 0.17034757906937925, 0.20168514302123552, 0.21526671968946698, 0.18292147730664654, 0.18873936990903195, 0.16290703009342955, 0.20268820947863542, 0.15464497054233617, 0.19194649986459267, 0.20821771157330782, 0.22434855182560565, 0.2389802570316888, 0.12313500861410864, 0.19980134157922003, 0.19938547407179208, 0.16532115339429088, 0.27078709280587976, 0.33629204872910345, 0.3561342498409924, 0.3501651619566861, 0.29927114601139193, 0.3219674371053717, 0.31645969840637667, 0.33225833441062835, 0.3510628774935649, 0.04370472236013445, 0.08815423091300001, 0.08676386959681404, 0.050024389397934965, 0.08137549674618094, 0.07260559894832719, 0.08705031570290045, 0.07721955781941892, 0.07349929581525061, 0.18263443371107857, 0.20253869001860836, 0.2094137714965042, 0.17243361259392298, 0.18326807328896755, 0.22382855147393255, 0.19943661058117645, 0.17314130169586694, 0.20527094846956973, 0.5077454043573507, 0.5629417979273355, 0.5596953140090082, 0.5429149426701599, 0.5245280000262327, 0.5690079292166998, 0.525485754128862, 0.5266711133587633, 0.5694924236905026, 0.08143604408868654, 0.08976523647499102, 0.1097324551176011, 0.09100090896633062, 0.09036534303070676, 0.10807952579406921, 0.1119662082552999, 0.08946286292693895, 0.0915860495414692, 0.14927237303383534, 0.1391904029628307, 0.1565588335505319, 0.17568406834527472, 0.15542632485269747, 0.15773455517369317, 0.16487858891867946, 0.15928476331680652, 0.1419693017962862, 0.3094185609928727, 0.33651442223624894, 0.3098758810960972, 0.3065267257508897, 0.3232338074351324, 0.34270707485549323, 0.3419019340459495, 0.3374621291875477, 0.35805851717691406, 0.2278324678990743, 0.25806147977209914, 0.23575868940210853, 0.24054737457341357, 0.2699416926305944, 0.2434907224592886, 0.27326635239137653, 0.27122695092100924, 0.26435185602255873, 0.20680918174103513, 0.18652646081243884, 0.18799958880116485, 0.20962063989171686, 0.19106995452952547, 0.19864078708069488, 0.18431439335959032, 0.19679985141457856, 0.18568083052653372, 0.18382247459453616, 0.22979907466990213, 0.18341968887568527, 0.18759964773341486, 0.18870814742312858, 0.18685820946836884, 0.18715484487774037, 0.18524402413845598, 0.18985643058092416, 0.16442030983761247, 0.479287149276572, 0.1512429968085235, 0.5822649481424252, 0.18547412733104407, 0.7183613612010624, 0.18028423892615153, 0.1982830916432381, 0.6169116625084823, 0.5377439012340643, 0.20427729614436374, 0.6220316790696221, 0.1956966220308317, 0.19034331367362134, 0.20018419368753726, 0.15262503152037898, 0.20099604593199494, 0.2054935202065662, 0.17946557960900955, 0.1846642286123642, 0.18064245507895516, 0.1828486866127792, 0.1837727726163113, 0.21353106719755355, 0.19717228422660504, 0.18148804616983583, 0.17796590305993287, 0.08206430015358968, 0.07092508510157836, 0.07326873880417173, 0.07311434731666655, 0.09634002165094879, 0.08185718269430431, 0.10679227056467211, 0.0837545041269463, 0.07441921480267899]}, "mutation_prompt": null}
{"id": "ba8f860a-5319-4ed1-a710-237242686038", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in np.random.permutation(self.population_size):  # Random topology\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhanced ADERM by introducing random topology in population communication for improved exploration.", "configspace": "", "generation": 31, "fitness": 0.39220777567699444, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "metadata": {"aucs": [0.8310854814303186, 0.8021400192154636, 0.8093312519597109, 0.8194165561554289, 0.8167031612517514, 0.8278199896888652, 0.820929991571346, 0.8166575400661111, 0.8086867852196814, 0.6646834733913949, 0.697160637613449, 0.6690744441428111, 0.6829113766961574, 0.661556383932112, 0.6673812925205093, 0.675747956452287, 0.6677906017547635, 0.6735031322193995, 0.12150866741565025, 0.10152229097065579, 0.11472990592728693, 0.12296739551665847, 0.10764411475082214, 0.1153518133395024, 0.11917070233249161, 0.11319023461482502, 0.12185519941326473, 0.10863167309168875, 0.11049800021353551, 0.0997601558636596, 0.10489254468988785, 0.12034501238629469, 0.10502664737729561, 0.1062661805946975, 0.11098201193608093, 0.10008371727082488, 0.8928711107051294, 0.8826431696134015, 0.8421305046327836, 0.9244387019292905, 0.9221348108650926, 0.8705055675020414, 0.9241372518353417, 0.9302132725674749, 0.9290611878484266, 0.5126712640090394, 0.5603390553637659, 0.49527387764464514, 0.5538109327170923, 0.5283089970216718, 0.5570091929816723, 0.5454902554529586, 0.4717424350683701, 0.5374082846842203, 0.8013368479128095, 0.7796418989806044, 0.7554355182504967, 0.8096405648304466, 0.8555390177206958, 0.7484273194810624, 0.7982797772675078, 0.8232124766868917, 0.7952718582314287, 0.45276114231915354, 0.17580185659420244, 0.19105849084007454, 0.22471735213938193, 0.2108559239259139, 0.23232792304363215, 0.2068904320773287, 0.4432360799351269, 0.18983277044722946, 0.30596278362638596, 0.1856384469137522, 0.15392782820221362, 0.21912466042971557, 0.26787325238215154, 0.16369371149740364, 0.23549731283637132, 0.21858594758308347, 0.17982411874795556, 0.49349269020439446, 0.4331477881486826, 0.4824034811628618, 0.4784857406974322, 0.4657858368696105, 0.44679946696072315, 0.4735727620240273, 0.48338746926871445, 0.5093444370890448, 0.5492413178765654, 0.5696046870760655, 0.5812982478302533, 0.5707347138499707, 0.5743148640196053, 0.5608474669320599, 0.620081436834601, 0.5929496851757241, 0.6008120827458474, 0.20272141886765338, 0.2269327798962767, 0.24073522524378466, 0.34333667016073166, 0.31675939193026303, 0.21333259483123956, 0.2095654763656194, 0.1896080312003231, 0.14861548033001104, 0.34409608567332695, 0.33576592447165243, 0.3626038550197883, 0.35700686553432337, 0.36970198907355456, 0.33491355846467097, 0.37113559874944335, 0.33968486572610146, 0.35318780482710155, 0.7269667556774599, 0.7207654416926554, 0.7360083140586391, 0.7105153104339951, 0.7099582817606902, 0.7077669319382209, 0.7102975974248785, 0.719767309395408, 0.7392497587894756, 0.1043884967707418, 0.09147927876986783, 0.10255475392762126, 0.11026381876475755, 0.10531325386853674, 0.10037326584905293, 0.09212792233235201, 0.10980547307837973, 0.09210674314111766, 0.22840045528933117, 0.15012649105723563, 0.17741295460208617, 0.1399096704743764, 0.14765135186415024, 0.19078393287110462, 0.2172851475385904, 0.14276579492158237, 0.13949012125987925, 0.43699399424496754, 0.4172933045633256, 0.43536478883888774, 0.44096148371160804, 0.42303538316956246, 0.4503237561481189, 0.4776501697295278, 0.4412449012537645, 0.4311500297341848, 0.3352817457874485, 0.3288192501029511, 0.3537859740619098, 0.3454683219068908, 0.34612403884217147, 0.3061827353661559, 0.3664648015317611, 0.369901467065871, 0.34207159251243635, 0.19381182370960637, 0.2090910353035228, 0.18484618517753226, 0.20896104352033318, 0.18516306948692152, 0.18921386902366877, 0.18558214582802346, 0.1941421364078435, 0.20153091499682874, 0.19336076864331375, 0.19886939862473285, 0.1978695785137602, 0.202658057709044, 0.18428156572133003, 0.20583057096929847, 0.19995625865095823, 0.25570795367580246, 0.18694743935586344, 0.7743184566555441, 0.5985654964317897, 0.5616173864421056, 0.18481793263441026, 0.18771244440259804, 0.19295503613089982, 0.7785532447790875, 0.6338578979501485, 0.7484684709153666, 0.6298345159840714, 0.1999674181004336, 0.7196859193948684, 0.1994360290147259, 0.7539279065464978, 0.1637895608103459, 0.20618154780186748, 0.20368939375750073, 0.529999346552656, 0.19202629571545227, 0.19753339756960786, 0.18278686186048043, 0.18787322746144997, 0.20393620295110026, 0.19140351391200372, 0.1873957353285004, 0.17690715267200308, 0.19110174066561736, 0.08012962992862194, 0.0785191337704999, 0.07652987901493669, 0.07879093525219705, 0.08415703089227533, 0.07501304234891881, 0.08781103697347115, 0.0780853895677377, 0.08242583513472235]}, "mutation_prompt": null}
{"id": "4bb954db-0c2c-49cb-b372-0cecbf695f25", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def _reduce_population(self):  # New method to reduce population size\n        self.population_size = max(5, self.population_size - 1)\n        indices = np.argsort(self.fitness)[:self.population_size]\n        self.population = self.population[indices]\n        self.fitness = self.fitness[indices]\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n            \n            if self.eval_count % (self.budget // 10) == 0:  # Periodically reduce population\n                self._reduce_population()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Enhance adaptive differential evolution with dynamic population size reduction for improved convergence.", "configspace": "", "generation": 32, "fitness": 0.39718532744937946, "feedback": "The algorithm ADERM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "metadata": {"aucs": [0.8297458042463494, 0.8156480002827302, 0.8143894473036027, 0.8213638973173589, 0.8278855043832772, 0.8051116066873488, 0.8196321296912182, 0.8255257236660725, 0.8188025389461273, 0.6819857244062847, 0.6736333566609699, 0.6878050655810275, 0.6791726825534778, 0.6804604691226493, 0.6803607278099388, 0.6920943248535969, 0.6836562785220861, 0.6815167766054107, 0.11931659690405738, 0.1172289943082222, 0.10339605801729779, 0.11045092254378142, 0.11614302152963951, 0.1123404038585315, 0.1273058064156095, 0.1144501291547011, 0.12740282350091436, 0.09893377714571705, 0.1123499378778231, 0.11088285992643576, 0.10656668585397944, 0.12478911762375211, 0.1133647201609157, 0.11043390792648866, 0.10284918460972736, 0.10731258665704424, 0.9443228317890835, 0.9380074864713106, 0.8581222616975699, 0.9038856916925254, 0.9160926925131349, 0.9594155442462438, 0.9403802415858479, 0.9522564639051768, 0.9437097330891902, 0.525009313016245, 0.5118457269556749, 0.4815845019436472, 0.5373397030557419, 0.471789976449591, 0.5185353308116601, 0.5608025250019346, 0.514247370728256, 0.5102076667975377, 0.7974837346192244, 0.7800697867147564, 0.7904599897137514, 0.8136565960396315, 0.7938698572854825, 0.8139048436847278, 0.7882819723124609, 0.7991638782700725, 0.7867459464538453, 0.19417985999883824, 0.2010846719245024, 0.208977961127924, 0.16667251993646548, 0.19906186939947967, 0.23319733215677052, 0.4641489692042742, 0.3935568699790509, 0.4331213021736606, 0.2197222181768751, 0.17051083560722213, 0.20775592807226706, 0.22953980603295, 0.21662876244346263, 0.18259238241267928, 0.1703873764535907, 0.2931786409245878, 0.2041746300063484, 0.4128975676761405, 0.4483671539584203, 0.47835305626004954, 0.43609675570009865, 0.4978201326809182, 0.43271526669775884, 0.4950437675261451, 0.47720020837329735, 0.42036823175462523, 0.5813655513199145, 0.6130753935272687, 0.5761154904640875, 0.5510220852189298, 0.5997574532082599, 0.579512240584326, 0.6398484173382619, 0.5560441590387513, 0.557729464269517, 0.09482148592965134, 0.1336271869596145, 0.2067762831832226, 0.2987721382553641, 0.3102352918424556, 0.3155471589598925, 0.15375567883799668, 0.18953195265721046, 0.13810211960786944, 0.359627020613831, 0.3531014295428201, 0.3722879789943907, 0.3649108346909722, 0.3570663077335843, 0.3491015800202639, 0.33066108112120196, 0.3635576267881403, 0.3803243576039914, 0.7337719379708636, 0.742001778433809, 0.7411444780606073, 0.7428250793750546, 0.73757391644181, 0.7418910568868908, 0.7172159995207952, 0.7048249665606516, 0.7381905794724631, 0.12716356408834872, 0.09291236006257553, 0.102506927278745, 0.1016083805459781, 0.1317765813060804, 0.09688548907068617, 0.09848808532635789, 0.11270260055980574, 0.11186319067676798, 0.16212413840628392, 0.14243389658368655, 0.22221469381853987, 0.12696921258317428, 0.16589868328370283, 0.13708420264789034, 0.17297767338798842, 0.12515885736816723, 0.1315516589912329, 0.406108108863548, 0.4174614354622481, 0.4444905754435988, 0.4520940992602076, 0.42254940338213176, 0.44075385598475714, 0.4768406304744778, 0.48466222481663546, 0.4847729119286832, 0.3787570004609824, 0.3546516690248013, 0.35600845662264313, 0.3367484683681664, 0.3402231198816511, 0.34335524285089525, 0.36292831658963776, 0.37247009535374487, 0.3838455237809446, 0.2038978576651429, 0.22463217393761747, 0.19616214368892604, 0.2183139834062382, 0.18556569767277387, 0.2082935374289745, 0.1846077324151364, 0.18243046541189867, 0.22010577725596603, 0.18442998491849827, 0.3025622028966575, 0.1800939059669372, 0.2408461801860583, 0.1896568287092706, 0.18338929123877856, 0.20088219774647342, 0.2029516571354918, 0.23213088346535538, 0.6999143731044579, 0.7132501272512096, 0.1688265360950476, 0.7360871426745444, 0.716751675635316, 0.7564821985788197, 0.6821453881303693, 0.17921803120211788, 0.7373262207955855, 0.4839285763209237, 0.20443760723073456, 0.8034578739867151, 0.19516544195565244, 0.20374232734466213, 0.19369912840445314, 0.7034414364662376, 0.199312752030111, 0.5497223052146374, 0.19771320767755463, 0.17600142488006476, 0.1905150252820561, 0.1857067704001406, 0.17495083231295994, 0.17711089215565412, 0.1786421858131929, 0.18676389367520452, 0.1840608518637148, 0.0773742464968098, 0.0773335950561228, 0.08684644390454432, 0.08989326258074293, 0.08173719051758399, 0.08135339948508336, 0.0789434526531595, 0.07907687859406975, 0.08053330042211859]}, "mutation_prompt": null}
{"id": "5ee4392c-d6d8-4d41-bb84-30ff0cf0982c", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Introducing self-adaptive differential weights and elitism to enhance convergence and stability.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "metadata": {"aucs": [0.8297458042463494, 0.8156480002827302, 0.8143894473036027, 0.8213638973173589, 0.8278855043832772, 0.8051116066873488, 0.8196321296912182, 0.8255257236660725, 0.8188025389461273, 0.6819857244062847, 0.6736333566609699, 0.6878050655810275, 0.6791726825534778, 0.6804604691226493, 0.6803607278099388, 0.6920943248535969, 0.6836562785220861, 0.6815167766054107, 0.11931659690405738, 0.1172289943082222, 0.10339605801729779, 0.11045092254378142, 0.11614302152963951, 0.1123404038585315, 0.1273058064156095, 0.1144501291547011, 0.12740282350091436, 0.09893377714571705, 0.1123499378778231, 0.11088285992643576, 0.10656668585397944, 0.12478911762375211, 0.1133647201609157, 0.11043390792648866, 0.10284918460972736, 0.10731258665704424, 0.9443228317890835, 0.9380074864713106, 0.8581222616975699, 0.9038856916925254, 0.9160926925131349, 0.9594155442462438, 0.9403802415858479, 0.9522564639051768, 0.9437097330891902, 0.525009313016245, 0.5118457269556749, 0.4815845019436472, 0.5373397030557419, 0.471789976449591, 0.5185353308116601, 0.5608025250019346, 0.514247370728256, 0.5102076667975377, 0.7974837346192244, 0.7800697867147564, 0.7904599897137514, 0.8136565960396315, 0.7938698572854825, 0.8139048436847278, 0.7882819723124609, 0.7991638782700725, 0.7867459464538453, 0.19417985999883824, 0.2010846719245024, 0.208977961127924, 0.16667251993646548, 0.19906186939947967, 0.23319733215677052, 0.4641489692042742, 0.3935568699790509, 0.4331213021736606, 0.2197222181768751, 0.17051083560722213, 0.20775592807226706, 0.22953980603295, 0.21662876244346263, 0.18259238241267928, 0.1703873764535907, 0.2931786409245878, 0.2041746300063484, 0.4128975676761405, 0.4483671539584203, 0.47835305626004954, 0.43609675570009865, 0.4978201326809182, 0.43271526669775884, 0.4950437675261451, 0.47720020837329735, 0.42036823175462523, 0.5813655513199145, 0.6130753935272687, 0.5761154904640875, 0.5510220852189298, 0.5997574532082599, 0.579512240584326, 0.6398484173382619, 0.5560441590387513, 0.557729464269517, 0.09482148592965134, 0.1336271869596145, 0.2067762831832226, 0.2987721382553641, 0.3102352918424556, 0.3155471589598925, 0.15375567883799668, 0.18953195265721046, 0.13810211960786944, 0.359627020613831, 0.3531014295428201, 0.3722879789943907, 0.3649108346909722, 0.3570663077335843, 0.3491015800202639, 0.33066108112120196, 0.3635576267881403, 0.3803243576039914, 0.7337719379708636, 0.742001778433809, 0.7411444780606073, 0.7428250793750546, 0.73757391644181, 0.7418910568868908, 0.7172159995207952, 0.7048249665606516, 0.7381905794724631, 0.12716356408834872, 0.09291236006257553, 0.102506927278745, 0.1016083805459781, 0.1317765813060804, 0.09688548907068617, 0.09848808532635789, 0.11270260055980574, 0.11186319067676798, 0.16212413840628392, 0.14243389658368655, 0.22221469381853987, 0.12696921258317428, 0.16589868328370283, 0.13708420264789034, 0.17297767338798842, 0.12515885736816723, 0.1315516589912329, 0.406108108863548, 0.4174614354622481, 0.4444905754435988, 0.4520940992602076, 0.42254940338213176, 0.44075385598475714, 0.4768406304744778, 0.48466222481663546, 0.4847729119286832, 0.3787570004609824, 0.3546516690248013, 0.35600845662264313, 0.3367484683681664, 0.3402231198816511, 0.34335524285089525, 0.36292831658963776, 0.37247009535374487, 0.3838455237809446, 0.2038978576651429, 0.22463217393761747, 0.19616214368892604, 0.2183139834062382, 0.18556569767277387, 0.2082935374289745, 0.1846077324151364, 0.18243046541189867, 0.22010577725596603, 0.18442998491849827, 0.3025622028966575, 0.1800939059669372, 0.2408461801860583, 0.1896568287092706, 0.18338929123877856, 0.20088219774647342, 0.2029516571354918, 0.23213088346535538, 0.6999143731044579, 0.7132501272512096, 0.1688265360950476, 0.7360871426745444, 0.716751675635316, 0.7564821985788197, 0.6821453881303693, 0.17921803120211788, 0.7373262207955855, 0.4839285763209237, 0.20443760723073456, 0.8034578739867151, 0.19516544195565244, 0.20374232734466213, 0.19369912840445314, 0.7034414364662376, 0.199312752030111, 0.5497223052146374, 0.19771320767755463, 0.17600142488006476, 0.1905150252820561, 0.1857067704001406, 0.17495083231295994, 0.17711089215565412, 0.1786421858131929, 0.18676389367520452, 0.1840608518637148, 0.0773742464968098, 0.0773335950561228, 0.08684644390454432, 0.08989326258074293, 0.08173719051758399, 0.08135339948508336, 0.0789434526531595, 0.07907687859406975, 0.08053330042211859]}, "mutation_prompt": null}
{"id": "68a42b44-b5f6-462d-bb83-b66887853e8a", "solution": "import numpy as np\n\nclass ADERM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ADERM", "description": "Introducing self-adaptive differential weights and elitism to enhance convergence and stability.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "metadata": {"aucs": [0.8297458042463494, 0.8156480002827302, 0.8143894473036027, 0.8213638973173589, 0.8278855043832772, 0.8051116066873488, 0.8196321296912182, 0.8255257236660725, 0.8188025389461273, 0.6819857244062847, 0.6736333566609699, 0.6878050655810275, 0.6791726825534778, 0.6804604691226493, 0.6803607278099388, 0.6920943248535969, 0.6836562785220861, 0.6815167766054107, 0.11931659690405738, 0.1172289943082222, 0.10339605801729779, 0.11045092254378142, 0.11614302152963951, 0.1123404038585315, 0.1273058064156095, 0.1144501291547011, 0.12740282350091436, 0.09893377714571705, 0.1123499378778231, 0.11088285992643576, 0.10656668585397944, 0.12478911762375211, 0.1133647201609157, 0.11043390792648866, 0.10284918460972736, 0.10731258665704424, 0.9443228317890835, 0.9380074864713106, 0.8581222616975699, 0.9038856916925254, 0.9160926925131349, 0.9594155442462438, 0.9403802415858479, 0.9522564639051768, 0.9437097330891902, 0.525009313016245, 0.5118457269556749, 0.4815845019436472, 0.5373397030557419, 0.471789976449591, 0.5185353308116601, 0.5608025250019346, 0.514247370728256, 0.5102076667975377, 0.7974837346192244, 0.7800697867147564, 0.7904599897137514, 0.8136565960396315, 0.7938698572854825, 0.8139048436847278, 0.7882819723124609, 0.7991638782700725, 0.7867459464538453, 0.19417985999883824, 0.2010846719245024, 0.208977961127924, 0.16667251993646548, 0.19906186939947967, 0.23319733215677052, 0.4641489692042742, 0.3935568699790509, 0.4331213021736606, 0.2197222181768751, 0.17051083560722213, 0.20775592807226706, 0.22953980603295, 0.21662876244346263, 0.18259238241267928, 0.1703873764535907, 0.2931786409245878, 0.2041746300063484, 0.4128975676761405, 0.4483671539584203, 0.47835305626004954, 0.43609675570009865, 0.4978201326809182, 0.43271526669775884, 0.4950437675261451, 0.47720020837329735, 0.42036823175462523, 0.5813655513199145, 0.6130753935272687, 0.5761154904640875, 0.5510220852189298, 0.5997574532082599, 0.579512240584326, 0.6398484173382619, 0.5560441590387513, 0.557729464269517, 0.09482148592965134, 0.1336271869596145, 0.2067762831832226, 0.2987721382553641, 0.3102352918424556, 0.3155471589598925, 0.15375567883799668, 0.18953195265721046, 0.13810211960786944, 0.359627020613831, 0.3531014295428201, 0.3722879789943907, 0.3649108346909722, 0.3570663077335843, 0.3491015800202639, 0.33066108112120196, 0.3635576267881403, 0.3803243576039914, 0.7337719379708636, 0.742001778433809, 0.7411444780606073, 0.7428250793750546, 0.73757391644181, 0.7418910568868908, 0.7172159995207952, 0.7048249665606516, 0.7381905794724631, 0.12716356408834872, 0.09291236006257553, 0.102506927278745, 0.1016083805459781, 0.1317765813060804, 0.09688548907068617, 0.09848808532635789, 0.11270260055980574, 0.11186319067676798, 0.16212413840628392, 0.14243389658368655, 0.22221469381853987, 0.12696921258317428, 0.16589868328370283, 0.13708420264789034, 0.17297767338798842, 0.12515885736816723, 0.1315516589912329, 0.406108108863548, 0.4174614354622481, 0.4444905754435988, 0.4520940992602076, 0.42254940338213176, 0.44075385598475714, 0.4768406304744778, 0.48466222481663546, 0.4847729119286832, 0.3787570004609824, 0.3546516690248013, 0.35600845662264313, 0.3367484683681664, 0.3402231198816511, 0.34335524285089525, 0.36292831658963776, 0.37247009535374487, 0.3838455237809446, 0.2038978576651429, 0.22463217393761747, 0.19616214368892604, 0.2183139834062382, 0.18556569767277387, 0.2082935374289745, 0.1846077324151364, 0.18243046541189867, 0.22010577725596603, 0.18442998491849827, 0.3025622028966575, 0.1800939059669372, 0.2408461801860583, 0.1896568287092706, 0.18338929123877856, 0.20088219774647342, 0.2029516571354918, 0.23213088346535538, 0.6999143731044579, 0.7132501272512096, 0.1688265360950476, 0.7360871426745444, 0.716751675635316, 0.7564821985788197, 0.6821453881303693, 0.17921803120211788, 0.7373262207955855, 0.4839285763209237, 0.20443760723073456, 0.8034578739867151, 0.19516544195565244, 0.20374232734466213, 0.19369912840445314, 0.7034414364662376, 0.199312752030111, 0.5497223052146374, 0.19771320767755463, 0.17600142488006476, 0.1905150252820561, 0.1857067704001406, 0.17495083231295994, 0.17711089215565412, 0.1786421858131929, 0.18676389367520452, 0.1840608518637148, 0.0773742464968098, 0.0773335950561228, 0.08684644390454432, 0.08989326258074293, 0.08173719051758399, 0.08135339948508336, 0.0789434526531595, 0.07907687859406975, 0.08053330042211859]}, "mutation_prompt": null}
{"id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 35, "fitness": 0.3994293683788718, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "8e0df880-67dc-4fb8-abac-964ae55f67a7", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "fa0f121d-b146-4857-b72e-bd3446e68364", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "7a86418c-d1fe-4d7b-8106-53d85e9d3e1e", "solution": "import numpy as np\n\nclass ADERMPlusChaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.chaotic_seq = np.random.rand(self.budget)  # Chaotic sequence\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + self.chaotic_seq[self.eval_count % self.budget])  # Chaotic scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + self.chaotic_seq[self.eval_count % self.budget])  # Chaotic crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlusChaotic", "description": "Introduce chaotic-based adaptiveness for control parameters to enhance exploration and convergence.", "configspace": "", "generation": 37, "fitness": 0.34252519845392804, "feedback": "The algorithm ADERMPlusChaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.22.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.6848456495833077, 0.6682579182420445, 0.6831941297696612, 0.708810947907299, 0.6654682339451929, 0.7162767938652299, 0.6852870657189598, 0.6932620588071801, 0.6541044535356243, 0.4760350930763563, 0.4542931513700641, 0.47056380722011537, 0.46201277402170426, 0.46743333651272845, 0.46674946683270113, 0.4763792833070548, 0.4818598825621436, 0.4571209782044612, 0.08472922255959603, 0.08120740251503467, 0.09410918198290297, 0.11165383691091613, 0.10469966597193192, 0.10143579925549662, 0.08829126089757922, 0.0876181293859678, 0.09368120572262162, 0.09237190998644729, 0.09341925352745561, 0.0828637680103862, 0.07956865533012247, 0.0975753604087527, 0.07895315924326352, 0.09662557450546361, 0.08331317999980004, 0.09325192169171226, 0.9040490133798817, 0.4880439241680832, 0.6943096285542167, 0.7059161609970841, 0.9794045298038784, 0.8939311604516277, 0.7545266460196847, 0.9551644914710036, 0.7313623430260242, 0.35410205561325625, 0.37776314134848465, 0.35094136816908017, 0.3360666623415701, 0.35248387929754044, 0.3719924327961892, 0.37735790106854694, 0.3733503424658454, 0.34608335343706453, 0.7377338010342056, 0.7400540269798321, 0.6938237011704151, 0.7493780344938389, 0.7941003308280031, 0.7310801682101304, 0.7162850119668512, 0.7483643353898193, 0.6843226315469905, 0.36383936354678703, 0.37546593523545224, 0.3677186702076728, 0.3199682274439615, 0.3649998538675614, 0.353083010230409, 0.3610599619300272, 0.3175715255404934, 0.3505363941051023, 0.4486701526914135, 0.3812568074737446, 0.4277729689145131, 0.3110624133588441, 0.34358197499935705, 0.31379756420314897, 0.4043337911084631, 0.39420463196179567, 0.37657078706481895, 0.39352968505982555, 0.38024266328109535, 0.384098727520519, 0.42987983482976966, 0.41869277121575743, 0.3804277163260905, 0.3973283858258211, 0.41271502663838444, 0.38117018820988857, 0.5321358357400787, 0.5341628062611063, 0.5260003347345577, 0.5006701055592107, 0.5119498124032378, 0.535132221899093, 0.5307212561728223, 0.5574358264981105, 0.5451613805477182, 0.11972192206166632, 0.12029040045505868, 0.12327421363337965, 0.22774684052659167, 0.22732801798109958, 0.24156672211794017, 0.09730439136764868, 0.1664168338108737, 0.13667390630013598, 0.2861784656524321, 0.2863414743342245, 0.2833068339186471, 0.2903942553025751, 0.2705541614992535, 0.29971920445955047, 0.30093335545006783, 0.28753970973348064, 0.30423495269750567, 0.6263158796629357, 0.6361552613001724, 0.6035007907740566, 0.620550329788635, 0.6072726785267917, 0.6235463499914473, 0.6301439095988746, 0.6038177300428824, 0.6358875484813737, 0.09785227419226716, 0.10440952830392525, 0.08787092741899649, 0.09627536688191862, 0.09510713781214308, 0.10655330673702124, 0.09971237277755751, 0.09283360649008521, 0.0855226611023796, 0.1424709902210023, 0.16054538137285468, 0.14363770442146706, 0.1639126432491681, 0.37221781620046557, 0.19281598170720404, 0.17208770848872013, 0.17971614486737997, 0.21197345758414143, 0.28728034783014966, 0.30202437675101235, 0.3063039112994287, 0.3152948646742193, 0.32067244161640296, 0.30923385577424667, 0.3464755887824953, 0.3594299881862264, 0.332728190159012, 0.25921357284483404, 0.26376362083317095, 0.26447479009725017, 0.24987997663612183, 0.26341133117870263, 0.27106373274846995, 0.28666573552290187, 0.2795723994717779, 0.26178681760441347, 0.1848777867669259, 0.18448212102818629, 0.1952596472516781, 0.16770700493773494, 0.19939316732726398, 0.1828763442148177, 0.18840709792137755, 0.19662589407247366, 0.18495345300708144, 0.18301726660309103, 0.1820545253200313, 0.18054204691738418, 0.18299335414783313, 0.1831207327040173, 0.17057823245301373, 0.1731461098561089, 0.18947193783542626, 0.18110857154449445, 0.6608869032022013, 0.7893131475190095, 0.12310771810679455, 0.17036644182272287, 0.17537601576277284, 0.6583838105323334, 0.7304073101903847, 0.1849275440154159, 0.5268228816757141, 0.19654809093232684, 0.49413635298327996, 0.20375599932070065, 0.7031390120140057, 0.19686656525231505, 0.5238997620735417, 0.20812302456958054, 0.20816176431951772, 0.20702807273261215, 0.1699332213610918, 0.19999686447716236, 0.18112993020941193, 0.17996969708327415, 0.16647789789965717, 0.19215139524868952, 0.17385512373068013, 0.18107525326974727, 0.18373391584181054, 0.06919093996133363, 0.07561058670494236, 0.08286561812473991, 0.06822834624535501, 0.07561940419076252, 0.06335836229289615, 0.06972476272005135, 0.07564667684871096, 0.07723926657206137]}, "mutation_prompt": null}
{"id": "7327f26b-000c-4321-a5db-7022426b7e71", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "8f591f67-185a-48ea-b1f0-509b1a60067f", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "e9e0903a-ec5a-4b28-ba36-896c6d628463", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "bd551e74-2289-409f-b5ed-dcd620102f1a", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "579264b9-45d7-437b-b487-a87be4ec5051", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "d48dcec3-5c0c-4922-abcf-e5b45abfc84f", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "738a5065-e11b-4cb8-95f6-17b7eb03dfb9", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _levy_flight(self, idx):\n        # Levy flight calculation\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        \n        # Levy flight enhancement\n        if np.random.rand() < 0.3:  # 30% chance to apply Levy flight\n            mutant += 0.01 * self._levy_flight(idx)\n        \n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce Lvy flight-based mutation to enhance global exploration capabilities.", "configspace": "", "generation": 44, "fitness": 0.36220008917378027, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.7961063908941513, 0.8105975191445796, 0.8090014488746287, 0.7976531928724986, 0.8074268861348495, 0.7932725334644177, 0.8100970393967503, 0.7870181876196887, 0.794504095603119, 0.6348929066399527, 0.5888386065484996, 0.5945148102365949, 0.6192087193090968, 0.593824420079996, 0.6101833011710742, 0.57090008985922, 0.6071738527294015, 0.6054421304898571, 0.12591908500040028, 0.10881737045249851, 0.13195673919556317, 0.12314285117547641, 0.12942795951907193, 0.12885340367386366, 0.14849034531751293, 0.11778181201002935, 0.10799789165636198, 0.10244115346583349, 0.10595752465976693, 0.10176975773719699, 0.10301150284220151, 0.11737984296549109, 0.1260055057575148, 0.11267401758797457, 0.09999693650524821, 0.10184225351376686, 0.8923116672185293, 0.8735243199756472, 0.9620108783442956, 0.9411486317740532, 0.8854739173889766, 0.9052921737779065, 0.8505217991822434, 0.9077792426173907, 0.9348248702932913, 0.5060213596727561, 0.46948615664693427, 0.43709775631249537, 0.43746988285381705, 0.479085613530845, 0.47495779989052567, 0.4511190396004656, 0.4859473956285498, 0.4147417574333119, 0.8205890262204099, 0.8044495488592969, 0.749415436599577, 0.8070915372233527, 0.7921835208432007, 0.8041797302129946, 0.7832638933499657, 0.7916621993283728, 0.7845525011763503, 0.22254448662185944, 0.1812134553248066, 0.2647054052624557, 0.25988918244948234, 0.26253161944606085, 0.2300521353008892, 0.27750656461926815, 0.2216840747406229, 0.23486065610747953, 0.274426550852209, 0.16586379048719568, 0.32713686753003457, 0.2873382715870534, 0.26193653779941817, 0.22826394741400224, 0.3711238168006915, 0.21768198560645013, 0.19317980594337025, 0.3343966281144962, 0.3527561603381385, 0.36172052862504567, 0.3314916291636557, 0.3470046856020256, 0.3055374706827403, 0.3123422988821468, 0.32927519698438434, 0.3225716226147718, 0.4568313299050426, 0.4886355717741533, 0.4121167912604937, 0.4493812271628067, 0.4708395484069925, 0.45134903996775944, 0.5115805245695096, 0.49082111823018215, 0.45090944690772916, 0.11258883904531014, 0.14005465651458748, 0.13839086776645004, 0.20410682872440888, 0.09970401148376895, 0.12578501192515645, 0.16334674075243205, 0.17957778199143615, 0.17992427713643688, 0.277529849578631, 0.26895430912273455, 0.2780670590336983, 0.3142828344522469, 0.29068871120140816, 0.2975534455602754, 0.28481019172435684, 0.28907321515179263, 0.2639550193848559, 0.6805721213728271, 0.6960632039769509, 0.6689604645044207, 0.6798419279450035, 0.6975869801613941, 0.6697992742280536, 0.6662227723930174, 0.660370115353312, 0.6782723298293305, 0.0945605072495308, 0.10284753395147617, 0.10329737218451207, 0.11115170538778496, 0.10894404654122791, 0.08733934873873583, 0.1020964465923282, 0.10201811398875582, 0.13999092373314148, 0.12776238552161356, 0.12326788496178565, 0.14518347468930826, 0.140756389723659, 0.16693519678512436, 0.14466378074117892, 0.15626070913235524, 0.15279653538863835, 0.1455551588017162, 0.402933076894726, 0.3900381887350576, 0.4070627740203314, 0.40931834738932416, 0.3969310407195169, 0.40879247173632904, 0.4132077739945226, 0.43789968613017405, 0.42700506705263275, 0.31715829802718987, 0.30728654077557804, 0.3074486681597579, 0.3075596757360416, 0.31175009877384485, 0.3098848112741047, 0.3117523262978652, 0.3271936909863854, 0.32578000465862056, 0.21155402667129464, 0.18123171748316624, 0.22585547494836478, 0.18857985137832545, 0.19223109324033505, 0.21051237646265974, 0.2056120291339264, 0.18315539900116462, 0.21960369481344733, 0.2721022194565115, 0.2955455669143071, 0.1898761754979591, 0.21236893381666955, 0.20313964549427632, 0.23362390188170734, 0.18129113621230086, 0.3792120409402372, 0.18517155782826855, 0.7540791974620941, 0.1825528319336731, 0.17291960484521118, 0.7787591384255612, 0.7797884610169046, 0.5835632471008597, 0.18102776964991651, 0.7092105706915359, 0.651735708038194, 0.6813806268910125, 0.16787218430354933, 0.20098155025245212, 0.5276110586372129, 0.2039211421567838, 0.20148271731185807, 0.1518068984281843, 0.15123184616470775, 0.2061379092827873, 0.17224626628272655, 0.18601025791137182, 0.1853893584972386, 0.18313380742568286, 0.18064733985702353, 0.1685254693023377, 0.18934384046741792, 0.19099241799136135, 0.18897340983750854, 0.07213228118844894, 0.07964263042939745, 0.06981835468228181, 0.08650232833854987, 0.08851449705959635, 0.09018578091644724, 0.07765610134160816, 0.08151296827767784, 0.07492623902814122]}, "mutation_prompt": null}
{"id": "6409017e-1d66-408d-b337-2931f6ae75b2", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "c72207dd-f8e9-4852-8e59-ae65af395732", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "70ce8519-c897-4dfb-bbc5-2f128ac183a4", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.2, 0.2))  # More dynamic scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argpartition(self.fitness, 2)[:2]  # Parallel elitism: Preserve top two individuals\n            best_individuals = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i not in best_idx:  # Skip mutation for the best individuals\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance exploration and convergence using dynamic mutation factor and parallel elitism.", "configspace": "", "generation": 47, "fitness": 0.3865492257106007, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8292049733823463, 0.8122700093640336, 0.8311607276853565, 0.8279881470039163, 0.8121793573758974, 0.8184230995914632, 0.8245972403792402, 0.8115834271852448, 0.8103393959750631, 0.6885343702128928, 0.673219484947213, 0.6935060936393168, 0.6777656199069175, 0.6841961785513954, 0.7141943624558285, 0.6869047736607533, 0.6762404111469831, 0.6842391133240933, 0.11341707085291908, 0.10516422506742074, 0.11723193749874095, 0.11360101684087165, 0.12737614812998854, 0.12889715163647164, 0.1148251141006964, 0.11697380460919393, 0.11905684674030981, 0.11523530639142299, 0.12532293335115885, 0.11033127386039232, 0.10291352026894895, 0.09585655547026217, 0.11367292468477441, 0.10871421260711811, 0.10930501286777128, 0.10969196378061752, 0.8531238751969141, 0.8902146773036392, 0.8617334190929286, 0.8846944854374422, 0.9007693100135533, 0.9024052563773166, 0.8960836439595976, 0.8508733362926353, 0.9192895367259424, 0.524975322313851, 0.5243934106188612, 0.535048856179728, 0.4893683774009928, 0.5253963964235169, 0.542309152727867, 0.5191429965781216, 0.5397479911890832, 0.48747347766046567, 0.7795298740013585, 0.8056934846018953, 0.7797679697886829, 0.8071155927129559, 0.7903834673533268, 0.8366538773263318, 0.7760663641142673, 0.7901500399748956, 0.8038371577948902, 0.4885414393279677, 0.22576079991582632, 0.2974938508357178, 0.22886670869515513, 0.15926703150891786, 0.21173399259329606, 0.16522095334148068, 0.26121290782792916, 0.3921523034428307, 0.11583994386722352, 0.5027658639857174, 0.404836084621929, 0.2490674387681342, 0.1876318876907822, 0.22487911181802844, 0.22763734689884774, 0.25188928788768183, 0.2256493377223867, 0.47459127454666583, 0.4207493986404097, 0.47012177861483184, 0.46574964653322215, 0.46440893459322097, 0.46570153927512015, 0.4487445125740609, 0.48419297574270725, 0.4519582744957479, 0.5959581668767044, 0.5943041525144983, 0.607528548516776, 0.4981885870981412, 0.5365636295912891, 0.429500471780778, 0.6202812266667352, 0.6200756244696612, 0.6102783248782802, 0.22981068872381716, 0.06975073395388975, 0.13980698512710876, 0.24088835061730074, 0.25965091954877095, 0.2531880187992279, 0.14284386885838518, 0.13232220756264557, 0.16465822149807574, 0.3490902027871393, 0.34826279394962856, 0.36392194409033196, 0.3535120172706272, 0.39876812174032195, 0.38686322580653665, 0.3471887306431244, 0.34387451382729195, 0.35308701047305247, 0.7311693068028889, 0.7324591359061392, 0.7403334521009665, 0.7494772813579488, 0.776592075295283, 0.7370917137703825, 0.7440763711648609, 0.738196245368522, 0.7645707301299259, 0.1066113028875787, 0.10313653809390111, 0.09630654703369912, 0.10194293854881453, 0.09215009562310739, 0.10908720140016759, 0.10543795107896936, 0.12405918027565, 0.09786732287424615, 0.15523932252322503, 0.13393165174227384, 0.1611372049611386, 0.17877749818940447, 0.1856829645424698, 0.15592560479861461, 0.20638883643371786, 0.15328820022677314, 0.16337741488838586, 0.44543143010770725, 0.4573555285971611, 0.459342531575758, 0.41423972547566623, 0.42044207196233674, 0.4620695552044073, 0.4802076585449939, 0.4974052679979678, 0.4781387971603194, 0.34872305188060093, 0.35270155950477666, 0.3276017571217156, 0.3283466663493013, 0.3310755261738014, 0.3578676042483525, 0.37790394325783006, 0.35083752990684347, 0.37399972488351574, 0.195325212212055, 0.19038559874091177, 0.211328236457333, 0.19749603165681806, 0.19542997992655642, 0.20588240891191512, 0.18932063372281904, 0.2257947262379063, 0.21702579376231412, 0.34028738631378863, 0.18289093580778482, 0.20210510050147723, 0.2212618197024453, 0.2977182609195065, 0.2909840001535061, 0.18706861012610776, 0.18306199497357123, 0.202738838342142, 0.1688599305140409, 0.18573613917273057, 0.18431888690728648, 0.19245897588699168, 0.7994089953483764, 0.16619470055555763, 0.17696830447102496, 0.6060578476300856, 0.7479937086585161, 0.20139288529499055, 0.2039888850193533, 0.7009163409510133, 0.39888030465245905, 0.45554370964309443, 0.20019680802687467, 0.2074942226564479, 0.6049488487790906, 0.20773690550991364, 0.1889907306256038, 0.17821696334038717, 0.18006856028566198, 0.17009165511658597, 0.18248406445038756, 0.1780153021976506, 0.17312565968453486, 0.21057167701558055, 0.1816368615542393, 0.07676118941812982, 0.08390688399275603, 0.08238542841318708, 0.07427003190855119, 0.08144023850143856, 0.07715488557675676, 0.08838885281987208, 0.08058960180501251, 0.07612111352042561]}, "mutation_prompt": null}
{"id": "fcfdb029-dbc8-464a-ab6f-51fa673bcc0c", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "1bbca4aa-451f-4dcb-967c-d00cca866fb7", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "0ed9fa42-3dea-4e88-9ded-d61b8dbfd9c5", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "5db45162-a987-495e-a68d-3e8292454211", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def _update_adaptive_parameters(self):\n        diversity = np.std(self.population, axis=0).mean()\n        self.F = 0.5 * (1 + diversity)  # Adjust F based on diversity feedback\n        self.CR = 0.9 * (1 - diversity)  # Adjust CR inversely to diversity\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  \n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  \n            best_individual = self.population[best_idx]\n\n            self._update_adaptive_parameters()  # Update F and CR based on diversity\n\n            for i in range(self.population_size):\n                if i != best_idx:  \n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance adaptive mechanisms by introducing feedback from the population diversity to adjust mutation and crossover strategies dynamically.", "configspace": "", "generation": 51, "fitness": 0.21088121186706785, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.23.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.7338425168789022, 0.7066984093277988, 0.7216783128147504, 0.7393699745823668, 0.744225677196152, 0.736006943001295, 0.7300910770068666, 0.7418631426159626, 0.7344218906381806, 0.49968738016560443, 0.4458906509466726, 0.4668225920926773, 0.4807203716700682, 0.44996510690248015, 0.46282995406563565, 0.47874117789632886, 0.4751490165112444, 0.5147978597694916, 0.31340669526313236, 0.3241989663892423, 0.2833606128363054, 0.22560861014968214, 0.28611471614129436, 0.2530683138760803, 0.35178621963779577, 0.27655913384859454, 0.24472689439007345, 0.1633947305738056, 0.13743474140697987, 0.1335073120489163, 0.17884442975630477, 0.1537236161660911, 0.12652782481348512, 0.17876525738615967, 0.1741569339229052, 0.2500356697015318, 0.9622946340762875, 0.9470381025815735, 0.9605061929241601, 0.9530345862431695, 0.9600139393578045, 0.9573182426441068, 0.9627205178854845, 0.9641226653087852, 0.9646288582404525, 0.12440717629600673, 0.10751856280192473, 0.08889378677112658, 0.11454484624461969, 0.09173491116035948, 0.10253545102946515, 0.11350433162587326, 0.1109357266480483, 0.11188376849594661, 0.12569889823241465, 0.147258358154443, 0.11646365685197435, 0.1562952719541465, 0.1645781278828966, 0.16903496758422276, 0.13931181940774007, 0.12440984320406223, 0.133201642746146, 0.11240742041642371, 0.09004706451368716, 0.11354215760054942, 0.11002079085282346, 0.11095934470562752, 0.10376597901773499, 0.14020133340318586, 0.12610566222072628, 0.14697271983933458, 0.05544073399366445, 0.0820901134927986, 0.05845208104694233, 0.10839290218739916, 0.09714796281154181, 0.09964885514451127, 0.0947804274802484, 0.05837264956256716, 0.07663201842542056, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05527519144436843, 0.02244217995296438, 0.0613259243174743, 0.022332535388330133, 0.07143221397641142, 0.03396630227815678, 0.02951045991266088, 0.03495436474129532, 0.023774219107329908, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035434361495381594, 0.02445198479930133, 0.022366600091046296, 0.04060706382505619, 0.059151536033896224, 0.05894790958410345, 0.039818838145914914, 0.04327478210206814, 0.050093724291903174, 0.4488234516373968, 0.4225792130948409, 0.4707777014492479, 0.49285438001878445, 0.4603177765701416, 0.5058975632356142, 0.4255509662582665, 0.43716077395505026, 0.5058931415727487, 0.08208750547466659, 0.06704924201439677, 0.07789877134952161, 0.07426488685949184, 0.06225858624218794, 0.07530982024683597, 0.0712176787101575, 0.08164460158344067, 0.0645658530876464, 0.1174358985540701, 0.14111560506783483, 0.11877225063281038, 0.1409979067628503, 0.13850306353847686, 0.12924779418926768, 0.1572691854698931, 0.13137435369566863, 0.11748266826378406, 0.17616235641793443, 0.1753630334184385, 0.18595836501659302, 0.16957816455882235, 0.16610283761263778, 0.16531819975320727, 0.17176784649016175, 0.17896362530073562, 0.17195022832237972, 0.1173883954474042, 0.10084187800020705, 0.13691632600943104, 0.1147118558214908, 0.11572766921196231, 0.11759323136585209, 0.11389548871122535, 0.13191198859991415, 0.12937663558456503, 0.20765690451200614, 0.16857362946661292, 0.17613694041935302, 0.17789916969984865, 0.17853403751588104, 0.1694727543191792, 0.17147687415621526, 0.17997310404237454, 0.1683552630900378, 0.18268138319552718, 0.17329143355541132, 0.2003224762902036, 0.18720890770414111, 0.1863539820251161, 0.1923086996960539, 0.20924231050816844, 0.19537073467382737, 0.1881639550806995, 0.1540931680285781, 0.16430613795342142, 0.19874164074136869, 0.1721792468080512, 0.16111060711633796, 0.18658377150101124, 0.1513645478202934, 0.15715886151213798, 0.21332882418517962, 0.14983506188158702, 0.15669439233978466, 0.1452362673367501, 0.1653327609014863, 0.1272298042014991, 0.15442187402626784, 0.19078462161020848, 0.1647258789012267, 0.2109372567821125, 0.1749626148574256, 0.17432084027165617, 0.19674283905303158, 0.21214358915552634, 0.19254919790771285, 0.18836076777739708, 0.16566436905817195, 0.17085418074008363, 0.20528371880574192, 0.06532171473036374, 0.058675992939070776, 0.05541162089989171, 0.06519640701734242, 0.06883435498528157, 0.06711740451903059, 0.06485006865496523, 0.05686407006406102, 0.06436993612693709]}, "mutation_prompt": null}
{"id": "5c51d923-af13-4098-b654-546d1476795a", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        \n        # Opposition-based learning component\n        opposite = self.lower_bound + self.upper_bound - mutant\n        if np.random.rand() < 0.5:\n            mutant = opposite\n        \n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance mutation strategy with opposition-based learning to improve diversity and convergence speed.", "configspace": "", "generation": 52, "fitness": 0.2813227489036503, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.6351589287546857, 0.6237401172319701, 0.640405552314999, 0.6220615396502948, 0.6428449781702448, 0.6323847409904463, 0.6190424492521711, 0.6344452174533217, 0.6085394026884284, 0.33168903170663866, 0.3482220963170011, 0.3769685490022777, 0.3674731044711146, 0.34496536794766275, 0.3763597382264243, 0.35671187880731403, 0.3609937045186091, 0.34386919749842404, 0.0959052208381016, 0.09975973611473787, 0.09676673545772063, 0.1084308724708728, 0.09350364195733929, 0.09226240657784546, 0.08561533146056588, 0.09647616308215656, 0.11114200777396999, 0.09426679859746434, 0.08987887881224321, 0.08919499749949389, 0.09747077691822903, 0.087543254446115, 0.09356412375064826, 0.08766839544524441, 0.08642397386905265, 0.08254595205503157, 0.8364052991973477, 0.9143611423040617, 0.8216115023241627, 0.8172546528463336, 0.883361137690995, 0.7681440657825296, 0.9261359687270664, 0.9631672588917188, 0.7813072447066451, 0.26127730712549035, 0.2658501151371273, 0.2368947906049882, 0.23959950808749564, 0.2732583346353632, 0.29462877718481395, 0.26790399107979024, 0.26234570649720823, 0.28071955823571226, 0.5833789625835866, 0.5846486745434243, 0.6246505547139525, 0.5550603157667641, 0.59805961986551, 0.6492822580725819, 0.470637159552857, 0.5622568949764571, 0.54630026673101, 0.19531080325483963, 0.2004151053152028, 0.21389710035248455, 0.1620062429145993, 0.1398155063510943, 0.1579104263365103, 0.15948965027942108, 0.18264341698729225, 0.1729555333184335, 0.3083274556078679, 0.2084470403842379, 0.1938029939562853, 0.24688189581472542, 0.2744631436377083, 0.2848435329391126, 0.27347220328004185, 0.3147060872332931, 0.22474360105856472, 0.14906921733745926, 0.17325054301706788, 0.14664756889357544, 0.15219096767551332, 0.16848704057629205, 0.15384883284669615, 0.17896305625807307, 0.11842589514314095, 0.1777411507197436, 0.2663943085378996, 0.25099269570821203, 0.2676923727115783, 0.2513290601196123, 0.33354544558191523, 0.2660247392888655, 0.2710651264507207, 0.2988483826117494, 0.3207524323996235, 0.0476487033562043, 0.07318937445941409, 0.060765584702267006, 0.07583169255848266, 0.08486460640473836, 0.08679953143856689, 0.07939591025843074, 0.05341008071269682, 0.08835021147414135, 0.15625922499367295, 0.17710445470379776, 0.1728412531791702, 0.160236878140815, 0.1621256751695389, 0.15939838768435188, 0.1718749284986617, 0.16454284858544166, 0.17452630379103395, 0.49590933647156077, 0.5090881934310709, 0.5267538324537946, 0.499413637220117, 0.5080649138315095, 0.5078025072992475, 0.5337740628332419, 0.5122732234928191, 0.4999745957266055, 0.08902937366473829, 0.10010737674044301, 0.0818501373853634, 0.10193177196133385, 0.08546106530111097, 0.08227459596257192, 0.10500686965933348, 0.08831393221608519, 0.07802453423611788, 0.14800458981412812, 0.13727149572676534, 0.14860598991505836, 0.17970631261871894, 0.14452367210188444, 0.12465590251397096, 0.1579029847076665, 0.15114368740399353, 0.1421998263795463, 0.2749096959348162, 0.30062823915362624, 0.29881402146861924, 0.2885765880295652, 0.3135481966704202, 0.3070407080080524, 0.28228757759797196, 0.29681725540775417, 0.28916698077192293, 0.19417068905077217, 0.22931393104203557, 0.2280472117624992, 0.21228633691272025, 0.23819696983814898, 0.21992599818096115, 0.22646054479717892, 0.2460810748556641, 0.2413170752768381, 0.20717415466483513, 0.19535752225751757, 0.20444862711718437, 0.2014612401289415, 0.20978652002929055, 0.19389322676516896, 0.19407504221197658, 0.18398095633053047, 0.19838470810366748, 0.1726641985661661, 0.1800367254304741, 0.186595446636869, 0.18194381092677558, 0.1791565743564859, 0.19861569111593214, 0.17575045652718413, 0.1632256068818957, 0.18341781588014794, 0.550820165141541, 0.49075709580381643, 0.4082738599601212, 0.4501054988747334, 0.29921600913801405, 0.5253554267231644, 0.40237458701736917, 0.16459106287305325, 0.4175464745816343, 0.6449999393887287, 0.5416992765542571, 0.5468046818902779, 0.3049964169467375, 0.4843992541969834, 0.36855340855263063, 0.253332932595134, 0.6533052658863255, 0.20731338326770943, 0.176914911798574, 0.1907709749695955, 0.18397544689218437, 0.175208807687121, 0.1776246805313404, 0.2042516405926481, 0.19415298865996566, 0.17792346797850933, 0.18982325457546212, 0.07964930776906554, 0.0738599126186078, 0.07243550102247298, 0.07082133785342415, 0.08648814172151453, 0.08416156549019271, 0.07520023235568873, 0.0866915390424563, 0.08332731747326927]}, "mutation_prompt": null}
{"id": "1ce07f53-9414-4634-875f-00a9c8e9109c", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "919363b6-9a08-4c16-904c-668f29a51983", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "efc0d172-5d42-41d5-b12b-0c731c8945f0", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "e4acc5d0-ad72-4fdb-a954-56298b400501", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "1a39aba3-88b5-4351-9584-44f245d2c855", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, fitness_score):\n        adaptive_CR = self.CR * (0.9 + 0.1 * (self.fitness.min() / (fitness_score + 1e-8)))  # Dynamic adjustment\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant, self.fitness[i])\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Employ dynamic adjustment of crossover probability and fitness-based scaling to improve convergence and exploration.", "configspace": "", "generation": 57, "fitness": 0.3798773074299737, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.827409337594133, 0.8103422997821268, 0.8241340118330887, 0.8303014315302136, 0.8162530609963168, 0.8291931392950262, 0.8092330141121141, 0.8242924550434586, 0.8248794592843467, 0.6707173764035534, 0.6736898695823924, 0.668935065869485, 0.6651604776236013, 0.6823017542410039, 0.6944049191534436, 0.6791012995688441, 0.6715317739794814, 0.6896825812255813, 0.11127972305476252, 0.11593996964623143, 0.11479468663384484, 0.10340270885457825, 0.11690082992220674, 0.11703010813283343, 0.11382102435358687, 0.12026931054671097, 0.11681078866722494, 0.09444213913094013, 0.1070257532460619, 0.10086522403584364, 0.12021426747586372, 0.11857953600377735, 0.12304401118831176, 0.10576242545341286, 0.11039109694258764, 0.10970656100181442, 0.9175269599508256, 0.9395569833109236, 0.9095095415449551, 0.9364296941698103, 0.9829847054916631, 0.8523886275937398, 0.9567333520310427, 0.91259614130654, 0.8299429048980917, 0.38998490798903085, 0.5299933491099653, 0.5118200284637678, 0.5054554933475658, 0.460135910294853, 0.5145172708533706, 0.5263076425180282, 0.5303022264383653, 0.5515855871883228, 0.8075240253546669, 0.8102333625869399, 0.7573155777247401, 0.8032121352733139, 0.752305358019876, 0.7992974800771383, 0.7857374016327712, 0.7799638792044169, 0.8243259433858449, 0.2665250509631746, 0.18903521235518883, 0.19847962395965624, 0.20022523954207383, 0.14747825585164576, 0.17630735709275436, 0.4563929800565425, 0.21895670667859346, 0.4740233471393074, 0.19851482670116627, 0.17883816488026683, 0.20474058478143597, 0.16527943387873634, 0.16327937287922412, 0.18801681833148765, 0.5186693012896556, 0.22228611482095662, 0.34861772774089084, 0.26133958912706146, 0.21511273118339702, 0.2150301840261838, 0.3524819544336105, 0.4125868818638453, 0.32746322114296, 0.22451989840268838, 0.16054678380493137, 0.23597374493830858, 0.524693066895277, 0.5438032033834551, 0.5443298230514089, 0.2904282440890834, 0.21119007997325512, 0.33361148129745266, 0.5690533603261894, 0.5458451687299419, 0.5726174003909958, 0.14024371160845717, 0.19095665435607456, 0.1450707396690223, 0.1236499477187224, 0.16084234166830336, 0.11919440147788174, 0.16334898579491197, 0.13655677242422115, 0.22465767689210814, 0.3224334105498534, 0.3406006153887553, 0.3399753650096867, 0.3268080979651703, 0.3425713553135754, 0.3276159782404372, 0.3460192902295208, 0.33348782600963545, 0.3468191927769273, 0.7195748921490883, 0.7513445660533674, 0.7417254221337732, 0.7296049400953117, 0.7268478317556017, 0.7363328824150563, 0.7271502891547251, 0.7355843050906266, 0.7390095674463497, 0.1099370754680431, 0.09297808735165924, 0.09550498510356464, 0.10460862697771522, 0.11178123955900332, 0.10415477695780773, 0.09910907495011412, 0.10311858914988081, 0.09429374281889069, 0.13807016619918555, 0.14425272211793072, 0.17445623550082623, 0.15218616608718838, 0.14278037456936432, 0.14714312036840116, 0.14321105839251536, 0.14668394176055166, 0.16487270940544818, 0.43668503663738034, 0.40665022957034547, 0.42899990654235476, 0.4479591712423514, 0.4457047782723683, 0.4681243050835078, 0.46328082293911044, 0.48182557409803717, 0.43148157074321813, 0.32257789730920927, 0.29555235750290554, 0.33122547149071824, 0.3278589235072824, 0.29922046690247295, 0.3443160622099073, 0.3472768358725735, 0.38487642680918865, 0.34666180156368964, 0.19180693695716122, 0.19258383281968827, 0.18981967800131638, 0.19946806664219108, 0.2027494783770597, 0.2076142476319982, 0.19850562466718125, 0.18003846250539046, 0.19985271454696485, 0.1915154759290687, 0.22293477397337014, 0.2925533045391189, 0.5486404162589875, 0.211143050838286, 0.26321053298543273, 0.20420521008134396, 0.4550825273979765, 0.18533254491590478, 0.7409789666359567, 0.7027669037250475, 0.18070493961591494, 0.650252821209831, 0.1779385591761673, 0.6121093951276266, 0.7011014998131495, 0.7590551870967694, 0.7821064728486153, 0.8151388040203629, 0.20215788853119077, 0.7160454045987299, 0.1612313512034168, 0.16331554595572906, 0.49914750281047804, 0.20127854147028235, 0.20143227915667583, 0.27714098365346074, 0.18819676534077012, 0.18996486704677507, 0.1845006815450153, 0.1913215731411647, 0.19236661429677626, 0.17407902474728365, 0.1878830822912564, 0.19038879036620016, 0.18368811433649945, 0.0894226048252349, 0.08145478492011338, 0.08392299568901362, 0.06747082627766865, 0.0852695627469886, 0.08428647202509887, 0.07955866503225983, 0.0804070697623136, 0.07508567717199344]}, "mutation_prompt": null}
{"id": "7f3e0f51-0c4c-4801-87a2-92d0d8eff71e", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.2, 0.2))  # Self-adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.1, 0.1))  # Self-adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance the adaptive mutation and crossover by introducing self-adaptive parameters for improved convergence.", "configspace": "", "generation": 58, "fitness": 0.38749692423366966, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.82098358866394, 0.8087720098786642, 0.8065923204485437, 0.8173287530838577, 0.8142787010149781, 0.8115724732885619, 0.8286875098625235, 0.8337389193432054, 0.8047982123437103, 0.6754637927067741, 0.6994957958593839, 0.6765732918306224, 0.6755125110897504, 0.6600503375397362, 0.6921368954545504, 0.6672649399248243, 0.6826749174140421, 0.6589294079789658, 0.12430750715588634, 0.11264566351341387, 0.1102708975171337, 0.09870381739891221, 0.1130897894953945, 0.15463624994610803, 0.11099964428082021, 0.13389849627707717, 0.1091702932720684, 0.10110693568178863, 0.10638571287831, 0.12748428470928175, 0.1160328379955472, 0.09915492395917103, 0.1177767376699036, 0.10835917925965388, 0.10965082225885958, 0.10683269993339417, 0.9280531152991721, 0.9096754660655062, 0.8292174470929214, 0.8024856002168818, 0.8869717283528376, 0.7975569494366478, 0.9276737087429477, 0.8442017873366848, 0.8990447388935586, 0.5648920908934599, 0.47663293835725895, 0.47901094482054407, 0.42793118715909806, 0.48519751215532403, 0.5273063945010255, 0.5203772742557584, 0.5165424952361112, 0.4688974757241796, 0.7696460216765018, 0.802395438336807, 0.7973384756178447, 0.7809478519576004, 0.8407534003240198, 0.8007667935089565, 0.7833514450030232, 0.8077349793397018, 0.82846514083716, 0.35858631684040754, 0.2668359016343934, 0.3165914571965649, 0.17037986958485685, 0.19652687945535974, 0.2537903478973783, 0.34137429613101566, 0.234166736795543, 0.31415486547965077, 0.3353244699112824, 0.19746089334394412, 0.17568117545852402, 0.20374152761548292, 0.17157479577080825, 0.22938246175463362, 0.21369627343240527, 0.22989240881274076, 0.18990127784393218, 0.4878005982106063, 0.45277026226502326, 0.4739941034638564, 0.4243679035057728, 0.4476854447371198, 0.42466773159710813, 0.43562464172163695, 0.43924671729662146, 0.5283650873121857, 0.5713965616140467, 0.6001944778898636, 0.6250479462244911, 0.6105383343420773, 0.6049392200811958, 0.5488024461183825, 0.5945249800850785, 0.6149638688322551, 0.6327538037927463, 0.25827235825070227, 0.26080616149797753, 0.21816947199500147, 0.4111588253060948, 0.23390495982050474, 0.34229942607670305, 0.21673520995440265, 0.1548032860923606, 0.15461849266801453, 0.3573247379983657, 0.3505000477078615, 0.38910194438637646, 0.3564832028730176, 0.37518648219686734, 0.3943060009907896, 0.34350807932954097, 0.3530647081475218, 0.38830520870885543, 0.735783421958869, 0.7557037403334961, 0.7625797427107915, 0.7235669496647554, 0.7379720089884945, 0.7410941420603523, 0.7471137049047472, 0.7344096610578602, 0.7624340856157314, 0.10233961335285802, 0.09022953362370623, 0.11877644377952767, 0.09463894022217068, 0.09280182761936118, 0.12186040056477832, 0.10813926692731124, 0.09314878637121637, 0.09616173746757817, 0.18315840674614114, 0.12809704415549017, 0.1718699657503283, 0.15224935029802056, 0.16900919748420073, 0.16303996607965998, 0.14065722332825625, 0.1568852400967109, 0.1389509032257894, 0.43330920819145946, 0.4243923219290827, 0.46633321647257175, 0.4365791792614616, 0.47788667241163596, 0.4411524832125935, 0.46137802617648827, 0.4691572846023788, 0.4711696921357198, 0.3359398134679785, 0.3538515321084641, 0.36316480882425717, 0.3256784328792188, 0.34719546883195784, 0.35071907271098834, 0.33927019783717394, 0.3667750559382036, 0.3616612343920107, 0.20777359445894517, 0.18059105369244155, 0.22675641588644357, 0.21182457444188052, 0.2057796347715124, 0.1809137006766035, 0.22372661400009264, 0.17465850828045837, 0.1929462395025121, 0.19699309269042564, 0.19167173909963364, 0.19111197034644933, 0.20250373747134287, 0.20065115425589375, 0.1909568147732853, 0.2844577525018466, 0.40404165336662734, 0.1928935900534261, 0.17853690500080444, 0.1913562927043485, 0.50040545101471, 0.7066994838523001, 0.1853401028592826, 0.7514881995510065, 0.16108958926959827, 0.6574666257466412, 0.5386884251008575, 0.6789698598530858, 0.1677268471073019, 0.20027431635972015, 0.5054425027464056, 0.15829702470847928, 0.5450440424621308, 0.15405834206875968, 0.20560199074513585, 0.20791099259949875, 0.18600947118694589, 0.19082410695741425, 0.19385876056496953, 0.1962701134460516, 0.19266680063219455, 0.18814954330539035, 0.18110479848382355, 0.1782875195875716, 0.18774122346730127, 0.070501043674293, 0.08574070586592264, 0.0801445335505594, 0.07305261129995522, 0.0963462355387692, 0.07921311630102568, 0.0791302890127561, 0.08307319021015813, 0.08056377147495875]}, "mutation_prompt": null}
{"id": "f9e8ff05-e96d-43f1-a02d-d5e416e2ef64", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        fitness_diversity = np.std(self.fitness) / (np.mean(self.fitness) + 1e-5)  # Fitness diversity\n        adaptive_F = self.F * (1 + fitness_diversity * np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance exploration by dynamically adjusting mutation strategy based on fitness diversity.", "configspace": "", "generation": 59, "fitness": 0.3792258373654673, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8171881667683009, 0.82299905863243, 0.8307050420082988, 0.815139827212048, 0.833003068145965, 0.8134498456641082, 0.8352532084676227, 0.816281379458196, 0.8196175670420849, 0.6949031354790225, 0.6840055377719403, 0.6813887130381047, 0.6857353850624026, 0.6677386295498885, 0.6733417217704729, 0.6727775657705475, 0.6915081516303245, 0.6660609596356772, 0.11136204785875126, 0.1145858650392032, 0.11621810327107795, 0.11588675621163891, 0.11466078457596673, 0.11234878160474804, 0.13207510984083615, 0.139234486093757, 0.1153713910060784, 0.11283492497140579, 0.11718914151615534, 0.1009866456495021, 0.10591872089743137, 0.12264607246112647, 0.11289618987644678, 0.11297342632454488, 0.10797721496338708, 0.12405685161011881, 0.8990565846533483, 0.950652623974659, 0.9358208650253738, 0.8472668485315707, 0.9209383360772158, 0.9149331734156814, 0.9636112271385422, 0.9488682341596676, 0.9237880350892045, 0.5305224653668721, 0.46178718843327005, 0.48429123759268844, 0.4702316512747263, 0.5294023532536059, 0.542404040498039, 0.5183109766827989, 0.5558707764706192, 0.5062603206747842, 0.7600636200960822, 0.8090865028685003, 0.7297964293130046, 0.8328272480664516, 0.7983754749710369, 0.7808434228757117, 0.7577365991502494, 0.8006034599454903, 0.795030113277976, 0.28185410545342326, 0.2016641453962552, 0.3589828518216396, 0.22050986314182286, 0.13887891206562564, 0.15468642498438434, 0.3929238852749416, 0.2802863558669817, 0.4729489242281194, 0.130304745894396, 0.23732750893151755, 0.3626589219709304, 0.18799414974243545, 0.23545075817589634, 0.1906643061559622, 0.18482698758795735, 0.1836315377473886, 0.2780415583509269, 0.4395897806324778, 0.38702528994211893, 0.4791748535718653, 0.41678995574163646, 0.46995640789984117, 0.41928427013016367, 0.4515777161465142, 0.501104104494697, 0.4650818192243804, 0.6170916481573914, 0.5967351463607754, 0.5701078454798718, 0.5932450134522793, 0.5680239477588669, 0.0964695490510219, 0.5797114906939931, 0.6030304642554405, 0.583807925594312, 0.11334385144731818, 0.1631518924732469, 0.13997472497408947, 0.26065955813692565, 0.2509189523817187, 0.22417318345527615, 0.2541259590991184, 0.14961847238913928, 0.226860212881288, 0.3591951595059737, 0.32197064959781285, 0.35421087886455904, 0.3697871206529847, 0.38614189953260436, 0.36493720093640314, 0.3449408309488313, 0.3532876345001319, 0.3388550342633839, 0.7228398724307028, 0.7229082756953602, 0.7362657924589762, 0.7250121923778021, 0.7117579915320715, 0.7250840856717573, 0.7345088551187666, 0.716154043532435, 0.7319510954613277, 0.09698822015146447, 0.09922767248687636, 0.09865893975563034, 0.1021172931139821, 0.1262318070798898, 0.11292665159399462, 0.09145135154864636, 0.09100877674909391, 0.11266374335775275, 0.18012822954976526, 0.24843723631315062, 0.15292696288941965, 0.16321245534847606, 0.15682372520186438, 0.18376464518690705, 0.13795903361894724, 0.13304196225723686, 0.1290337902070845, 0.43271560121184716, 0.4282788263965229, 0.4466174943543286, 0.43263379543867264, 0.4078167701650429, 0.41417547721699377, 0.4366359657174099, 0.47840553165382693, 0.4324474775563254, 0.32784989871330383, 0.3408031472323908, 0.36870805049541866, 0.34934968365516217, 0.33583323381533825, 0.3567155826935343, 0.33145712669929106, 0.35726147812471787, 0.3642240446271062, 0.20204304605468992, 0.21050136548120013, 0.1926897087962558, 0.20088229136778157, 0.19876192384432556, 0.1843407624027067, 0.18297486325335832, 0.21357650314252785, 0.1931759230659884, 0.21451560218099452, 0.22385956118974815, 0.18461318969651486, 0.21018700274459845, 0.18350643084760776, 0.20622854504850696, 0.2139423727330383, 0.19918214650431987, 0.22553876242834536, 0.1704927844152445, 0.7182810869714136, 0.1903088287780731, 0.7429025741332047, 0.19400696064820588, 0.18857885861457147, 0.17612946379563676, 0.15995411896403489, 0.6439923827886869, 0.2056076403455206, 0.20531731308751588, 0.7832400579296828, 0.18761916911743148, 0.6516020142640875, 0.1906106900703598, 0.18950906386423605, 0.19418103727897928, 0.20922042341183633, 0.1930286843813641, 0.18145586565833993, 0.1901302170577548, 0.1781683407314929, 0.185949777237023, 0.17556142154111698, 0.19641808767678126, 0.18163544127997167, 0.18673129908870556, 0.07766681234267303, 0.07671422780902648, 0.07496069896513313, 0.07886262759111218, 0.08590083519002578, 0.09306166987125308, 0.08055896517565975, 0.08621996011874888, 0.0763719103310796]}, "mutation_prompt": null}
{"id": "1b4eb548-da6f-42cf-96d2-cc273e03b881", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "3499c3eb-5c26-40cd-91d0-19c65a8146a1", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "8eb2ebe8-771b-4444-8996-82e32f84bb9b", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        oscillate_factor = np.sin(0.1 * self.eval_count)  # Oscillating factor\n        adaptive_F = self.F * (1 + oscillate_factor)  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        oscillate_factor = np.sin(0.1 * self.eval_count)  # Oscillating factor\n        adaptive_CR = self.CR * (1 + oscillate_factor)  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    # Local search for refined exploitation\n                    if i % 5 == 0 and trial_fitness < self.fitness[i]:\n                        local_candidate = self._local_search(self.population[i])\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < self.fitness[i]:\n                            self.population[i] = local_candidate\n                            self.fitness[i] = local_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance adaptive parameters with oscillating strategies and integrate local search to refine exploitation.", "configspace": "", "generation": 62, "fitness": 0.33689250885883576, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.22.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.7672858383224002, 0.7434014012708582, 0.7276490504512112, 0.7489165303507999, 0.7420275244899162, 0.7434643303250643, 0.7536373751105134, 0.7440079180697594, 0.7257005206636664, 0.5498096341097816, 0.5381016063236697, 0.5751844756675075, 0.5607936757994774, 0.5603507740810314, 0.5329206923447313, 0.5666946064331118, 0.5367875018091774, 0.5852823560439084, 0.39469978212208956, 0.40163542700042065, 0.39113812768690936, 0.4675772976564614, 0.4081136333340877, 0.41644678428766524, 0.38352140940360524, 0.3663413116260773, 0.431629671349945, 0.33721708466718125, 0.3089408201446281, 0.3161898376703869, 0.2932299861900447, 0.29576314139731097, 0.35918717980550185, 0.35931370521983375, 0.3150353713244701, 0.15811933042022297, 0.941534676153895, 0.9420130886404599, 0.9813810002230405, 0.9761244945097727, 0.9366256486555262, 0.9404806943968911, 0.9438593023616115, 0.9560939666581538, 0.9243288608692843, 0.34706847961655896, 0.33972645410808444, 0.33611427100639857, 0.3360755274048297, 0.31846315135923053, 0.32862557983224683, 0.3287882658824629, 0.31500036805361864, 0.348299488924396, 0.5849443852950174, 0.5628549884277559, 0.47169238901897714, 0.6400768338192315, 0.5920759155412465, 0.5871861033047971, 0.6447849548951301, 0.5698616470751028, 0.5847581429562516, 0.2725590791415562, 0.22320381749615847, 0.27264796693433335, 0.21591055331642728, 0.21449726233803568, 0.2552161097218927, 0.25558566860494514, 0.2687991568576076, 0.2636600293978849, 0.2816319360295856, 0.23292674496037347, 0.19275172474045732, 0.23413153803333053, 0.24147429792458075, 0.22611595501060944, 0.20246234366958482, 0.23584478731198244, 0.2095592533587478, 0.15132732403365512, 0.1417239625461485, 0.14336416320236, 0.12072920990217317, 0.15679054374531354, 0.17124927172005133, 0.14577975971960677, 0.15072236186533605, 0.14960659127120057, 0.24424716167813054, 0.2856188149563318, 0.303677778222491, 0.23317046480862813, 0.25535688976535953, 0.2680460959325559, 0.31515482591445276, 0.3043034777135255, 0.3027090082462067, 0.04613178918474259, 0.05656711293156691, 0.07567282422813948, 0.04939772234660578, 0.0429005482056134, 0.06160948704081981, 0.049152901945927585, 0.04973141765361033, 0.06188831255952032, 0.17634495822501994, 0.18036389772765904, 0.17713922642993907, 0.18998202868719005, 0.1930880303468927, 0.21238383051209198, 0.17792540934398982, 0.19496401218394932, 0.18276738112577273, 0.5497590447377763, 0.5289702718190776, 0.5366889421275952, 0.546484217673958, 0.5426178400179933, 0.5277894620456794, 0.5509904252034208, 0.5537023111092263, 0.5605901918369198, 0.10134061058820643, 0.0928100505311773, 0.09470466969165936, 0.09431572034227742, 0.08319195553930459, 0.08999591487465985, 0.09327774995423677, 0.10555676549470705, 0.10188626353926922, 0.1523667370840176, 0.1449242103587427, 0.19274860037578467, 0.16168262389415922, 0.17581033998906004, 0.15709701584818936, 0.14263588682200556, 0.15033260174921947, 0.16842616571318525, 0.2953894878334634, 0.2896486717427025, 0.33325283160363284, 0.29471277498901005, 0.3066709170230171, 0.33969938145033096, 0.3645579796613202, 0.35913792222374485, 0.3441686732422129, 0.2247638636742305, 0.2431463634065687, 0.23180356226589605, 0.22756778074709405, 0.21505363790724263, 0.24757867076113993, 0.2468873725304005, 0.24341663911651845, 0.24975756092675527, 0.20340915800722636, 0.17592043400327706, 0.1936250527276545, 0.19451846346837576, 0.20815966092270044, 0.1956711072437275, 0.18766130835276895, 0.18001140814602334, 0.20480585352304403, 0.2634950925903615, 0.2191635526078104, 0.21845870012180357, 0.22816140450567668, 0.2756693825083295, 0.2320821620922302, 0.2606041130645568, 0.2876582556814662, 0.2543685298908098, 0.5947329040728238, 0.5293851441929, 0.6453104224876163, 0.6089316291252354, 0.4398904736287076, 0.6299530248464044, 0.5138371429240721, 0.48541916951859043, 0.5085644284518192, 0.5757994627422873, 0.4919239433292192, 0.18984671818563048, 0.4241864226145402, 0.1995123432217467, 0.6577727920264256, 0.6852189861127724, 0.20523042238818534, 0.521654368973536, 0.18533416889942556, 0.17683226067260494, 0.19665023870716314, 0.1775782039093945, 0.19384735483100013, 0.1876734531363019, 0.18952352743844436, 0.18959811182580455, 0.1903044111672546, 0.08400313403842918, 0.08034273082979237, 0.08264529722797198, 0.07814024094184546, 0.08046284743748389, 0.08350344431797108, 0.08578793366407278, 0.0748935898962616, 0.07761563346607614]}, "mutation_prompt": null}
{"id": "c83544ea-44ae-4d0d-95e7-8042e826496d", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutation_noise = np.random.normal(0, 0.1, self.dim)  # Gaussian mutation\n        mutant += mutation_noise\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance exploration by incorporating Gaussian mutation to diversify offspring generation in addition to differential mutation.", "configspace": "", "generation": 63, "fitness": 0.22860514129545687, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.4409486110488068, 0.4878157975207489, 0.4651616981850869, 0.4411827832951928, 0.44165521317276657, 0.4618930582926212, 0.4498168645210452, 0.44434319711878734, 0.4459158001283525, 0.08395419200245846, 0.06961381295883606, 0.07191764520607902, 0.10583366939506555, 0.06910057422840343, 0.0657021746022931, 0.07546030653306424, 0.08753688364974677, 0.09738993545000563, 0.11261443386812464, 0.10061346973712426, 0.10698815196588207, 0.09814924723203489, 0.10327784207468427, 0.12400070597044688, 0.11864778992869418, 0.13270117803358006, 0.10143843934806773, 0.10362657974551914, 0.10140320121149993, 0.09852702627047527, 0.10491058250461682, 0.11098146699662936, 0.10636863168848099, 0.10657577877527669, 0.09292807968244177, 0.09645488287187631, 0.9050557442502439, 0.9181683315405813, 0.8935748611297374, 0.9107110747894462, 0.906504692969579, 0.9087851061843901, 0.9029014104937678, 0.8970331603574813, 0.9122624213134666, 0.287298373966663, 0.2657896427385231, 0.25934640408270104, 0.26345495887575543, 0.27109942116429464, 0.31098892397128797, 0.28327443638616867, 0.2792751902655326, 0.2820825814518765, 0.34872065690302945, 0.3801807573513101, 0.3329493024679163, 0.6510482153077608, 0.6788540317814994, 0.41507588454611033, 0.5804331529930784, 0.44985220555504535, 0.3501851295764422, 0.17185587471986907, 0.14881786528228003, 0.16714517898464598, 0.166514292385595, 0.16088716976436257, 0.1600738354217197, 0.16761077770107824, 0.16294246037040794, 0.15405462163447015, 0.1589869513647365, 0.15821876550646752, 0.1701210019810362, 0.1615938656542676, 0.16576579481432763, 0.17127129163173815, 0.17243491617463935, 0.1729499877705708, 0.16574141993068003, 0.05119127732333417, 0.03916327335915448, 0.05718339372094139, 0.03283898543442121, 0.009861489090950637, 0.036999276060452724, 0.022192133889615606, 0.034961493407274835, 0.03866358361916178, 0.15005281095036516, 0.11345871202178459, 0.1494811035018433, 0.10245887985067526, 0.10200567418303341, 0.12933679177873603, 0.10975453232019994, 0.1165177928800053, 0.09323881121571886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001717447516923487, 0.10901184077617032, 0.11033877951627746, 0.1059505793749207, 0.10670494340943004, 0.11368813182788906, 0.10679056109219842, 0.10597211922106542, 0.10268433432843282, 0.10075680734857906, 0.40127159078790187, 0.42074907857636745, 0.4232679243627139, 0.40958830917146993, 0.40868422303620455, 0.3952717840900637, 0.4119033634136874, 0.42153835522786653, 0.40685566175914467, 0.09868542715704443, 0.10266865320463037, 0.0973549802552045, 0.09079955169427101, 0.09507981875311322, 0.0869604985609369, 0.0925658428979459, 0.08843818976806073, 0.10369720409421712, 0.15339476282932918, 0.18991450663054532, 0.17535540584318554, 0.1801261107255674, 0.14610551855597786, 0.1381932267789372, 0.13231830445394188, 0.15073050579669267, 0.13125459482974622, 0.2835601615945196, 0.2835634227945465, 0.29528649888060177, 0.2881561717941562, 0.28655386381154724, 0.28631261685174536, 0.2982398881934587, 0.29084129082110344, 0.28916530717117583, 0.22972089725167788, 0.21779475857182573, 0.2171839656221829, 0.23071715527473824, 0.20491701152166575, 0.22078014735329365, 0.2326800895822494, 0.2250278688617483, 0.22812567271532014, 0.21125544381181838, 0.18340252814718228, 0.20409828634493, 0.20690934740278888, 0.1852025706898498, 0.1983222120546142, 0.1912986448440993, 0.19124301074638284, 0.22404901136380284, 0.19147502289320562, 0.1873194942245966, 0.20694718759986708, 0.18884330965886043, 0.1758451372454105, 0.17664420798224234, 0.18036131706215242, 0.17994657370394485, 0.20268138108801592, 0.16747737155315923, 0.19640825863195488, 0.1839703551956593, 0.18074746808691344, 0.6266748600583584, 0.5691027593776711, 0.16869183739270321, 0.42496029783407774, 0.5399465052120909, 0.16169153800966363, 0.451227853411038, 0.4409081871375997, 0.385417262445817, 0.44642698661377067, 0.44694933954119465, 0.19800541586150877, 0.210262156523485, 0.20756266119054667, 0.19468020828940558, 0.2012820972866708, 0.2038439561561164, 0.1930706299152244, 0.18684942798284643, 0.19312637851813308, 0.18828768001286167, 0.17935757306123723, 0.1811261238843418, 0.07499857301941015, 0.08036311428386345, 0.08773230611072891, 0.07900867555558455, 0.08208514886249452, 0.07770443454390552, 0.08104200909301307, 0.0847757993833298, 0.0761286960204961]}, "mutation_prompt": null}
{"id": "280706aa-a3b4-4e09-b936-781312af62ea", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        rank_based = (1 + (np.argsort(self.fitness)[idx] / (self.population_size - 1)))  # Rank-based scaling\n        mutant = self.population[a] + adaptive_F * rank_based * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce rank-based selection and self-adaptive mutation strategy to enhance convergence and diversity.", "configspace": "", "generation": 64, "fitness": 0.30108073417656883, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.6783718398812404, 0.6983764338084291, 0.6825430293100236, 0.7307750643641031, 0.7260776213855731, 0.7205055655989236, 0.7216594485167325, 0.6988897864917112, 0.6982261885705474, 0.44969395151207003, 0.48240049491748305, 0.47913826049977915, 0.48328528070558063, 0.47096973595700087, 0.49746093217108, 0.5226615734325952, 0.4817326844423363, 0.4854297821203355, 0.11048992601691787, 0.1047348459503139, 0.11019545199939551, 0.09167105518717122, 0.10309972198800677, 0.0944261967731882, 0.09860091197391863, 0.11188471047693471, 0.11233273710610725, 0.0892359451486544, 0.08785285994868808, 0.09969605886038202, 0.09565778829229199, 0.09127697181462768, 0.10579461700001758, 0.08648900004308613, 0.10102805347789945, 0.10305649638975634, 0.9275798278534831, 0.9641689713162411, 0.9338242351392596, 0.9117418661849727, 0.9427167226734913, 0.9412210066066846, 0.8714091571876402, 0.9491949892811158, 0.9641961814793231, 0.3341584311621456, 0.319766006430832, 0.2987758972760858, 0.35667800704334063, 0.3507706975580449, 0.34922560394188995, 0.330804819981139, 0.33879329678156833, 0.35339401457551356, 0.6528241243173906, 0.6068764148957382, 0.6439509389712506, 0.6679706055618804, 0.6008785056927248, 0.6233634749128552, 0.6360887432309439, 0.6059338588168828, 0.7171345108474354, 0.24190980191471934, 0.26458579642833147, 0.2340484803775753, 0.2755496748486599, 0.21040193519431905, 0.22192978038831712, 0.2681761136846963, 0.25015175219720864, 0.2087332963028894, 0.21024192487073856, 0.2743280518010619, 0.15843526244900075, 0.28357577554464863, 0.22639672956651336, 0.2437084754565041, 0.2157779597404793, 0.24760212740807397, 0.25508412490237364, 0.1989159386930165, 0.18899452964004892, 0.17705305326497967, 0.21221724485255933, 0.21804485290470055, 0.21475085764438717, 0.1890206065367207, 0.1995575188143205, 0.173240365634734, 0.3284580508204764, 0.34179248021801145, 0.33686356934468953, 0.30855820019024827, 0.31305876625372164, 0.32377456617144185, 0.3249724659601734, 0.33202737100323665, 0.36112647248635255, 0.0932561986989211, 0.0778786798526564, 0.032197916181725295, 0.1068560764562877, 0.048688994428088384, 0.055356883032424586, 0.05847658821583113, 0.0886755493239536, 0.04768718854824583, 0.18615941323583607, 0.2030551235746414, 0.18489197152116144, 0.1883634139023167, 0.24387918718547663, 0.23380047065772547, 0.18714187947831284, 0.1869216373722956, 0.18025354596850351, 0.5372009292817691, 0.552157263976444, 0.5493911326849767, 0.5427607907329295, 0.5687732468621334, 0.5675294422480526, 0.5681973462403613, 0.526185166840095, 0.5566474105986955, 0.08560804747454531, 0.08967795789011324, 0.09182906384602996, 0.08361188412692278, 0.08498659129909214, 0.09267927141433685, 0.09177839222108053, 0.09780697965544694, 0.10671704282945083, 0.1668234686983131, 0.15526135456546275, 0.17208251880244607, 0.15728355174927589, 0.13544974261542064, 0.21356605347421054, 0.12971504259087085, 0.15853874328279982, 0.15650679700949532, 0.300579681074027, 0.30356432002561196, 0.32498944352021686, 0.31113061461232094, 0.29020682264165787, 0.2820009840113099, 0.3370602588730549, 0.32086412388408503, 0.3155088212833107, 0.24734645401676214, 0.23177249490391216, 0.2355745422874007, 0.22984836511280493, 0.2200685883959994, 0.22163396958533454, 0.2409891826319579, 0.22662817203822005, 0.22472210126465075, 0.1823056720922107, 0.1968310045659728, 0.18565005113284627, 0.23674207780790413, 0.20020462572418096, 0.17745423150212425, 0.19286182921864903, 0.1813603352436015, 0.20597313400232642, 0.17887418447415382, 0.18163411986214795, 0.18986232337610587, 0.17215657261273776, 0.182039570501909, 0.18508517426483662, 0.17514126656811935, 0.19057893186597008, 0.17871888011359427, 0.1704272122354058, 0.55259214802486, 0.15774688517113833, 0.6791353174771398, 0.17556707627902834, 0.5803802041579473, 0.16903996991323, 0.2302270464534718, 0.45938038598182496, 0.16638398642984498, 0.6002584503254225, 0.19911571385959204, 0.43985368677060666, 0.18429528189116617, 0.19144232301472297, 0.19489537351849606, 0.2016947015926096, 0.6761975958074398, 0.19632765612280578, 0.17373915547529395, 0.17705419054070082, 0.18493572009104942, 0.18796694194017738, 0.20840605058186368, 0.2125835666457636, 0.19127138531536048, 0.18207192452441, 0.07152127871012015, 0.08539891011401668, 0.0638536991646319, 0.08421235084728085, 0.07012216136826499, 0.07519882294166269, 0.0744539962067714, 0.0654058597156425, 0.06778677182919723]}, "mutation_prompt": null}
{"id": "7f628121-cd41-4b98-b6e4-14259f247e6c", "solution": "import numpy as np\n\nclass ADERMPlusImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            if self.eval_count % (self.population_size // 2) == 0:  # Inject diversity\n                worst_idx = np.argmax(self.fitness)\n                self.population[worst_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[worst_idx] = func(self.population[worst_idx])\n                self.eval_count += 1\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlusImproved", "description": "Enhance exploitation by introducing elitist learning and fitness-based immigration.", "configspace": "", "generation": 65, "fitness": 0.3895171410909559, "feedback": "The algorithm ADERMPlusImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8028114187311501, 0.7995419670494608, 0.7933446366975184, 0.8143769352372385, 0.7925050966280113, 0.8258016468920293, 0.8156850207505834, 0.8113177841522223, 0.8238441523986114, 0.6863190866828337, 0.6625858321097912, 0.6639344283101891, 0.6605170623597663, 0.6608988459815067, 0.6629397470502566, 0.6543191127349465, 0.6540316124449485, 0.6887461551260629, 0.13049614297583356, 0.10620172795352589, 0.10966018927172494, 0.09866841057260844, 0.11535773513980163, 0.12491406617112066, 0.11672814802123632, 0.10788595531268708, 0.1210380415518606, 0.11149536409194516, 0.1066639184360485, 0.09374286065651649, 0.1067929978299964, 0.10232970673748254, 0.11900826719777413, 0.0961940660242051, 0.10311299422843623, 0.1060947529590105, 0.9271454475812566, 0.953326534707614, 0.9354858438494057, 0.9381452443228375, 0.8334819751314897, 0.9592032693898855, 0.9304124761233298, 0.9621084707429002, 0.9363442863064759, 0.5049243837470341, 0.5179164496798088, 0.5085786566586041, 0.5054371265773023, 0.4923864878080527, 0.5077981112551633, 0.5316200618603679, 0.4351081416565854, 0.4887864118409847, 0.8005564160568763, 0.7895015541892845, 0.7615769795873116, 0.804549335780155, 0.7994544270544992, 0.7887939859146421, 0.7891831444317183, 0.8045590639433791, 0.7649383075902036, 0.21090838438116288, 0.1773377025481757, 0.3389541121009695, 0.4049812961408066, 0.18730156255007502, 0.22290779902532198, 0.2145057625874338, 0.1773174267528308, 0.20296747611270494, 0.18292788724631526, 0.18954853926799964, 0.24410532993001, 0.225034850907477, 0.44001364854449154, 0.20342484087465096, 0.33585141352107706, 0.23754157611410287, 0.24248867067073598, 0.4587688685494007, 0.4380631577089372, 0.12925340363716642, 0.40204184869163084, 0.40816201374332195, 0.4565387089757892, 0.44903011969302487, 0.4266459608633342, 0.45657250965791596, 0.5633225195654685, 0.5918412196827193, 0.5744402725554763, 0.5746650295123228, 0.5955822092201518, 0.5955158407156558, 0.6020590644201276, 0.5728450607965565, 0.5805952133356443, 0.1485150371506988, 0.168719370425078, 0.08785511736288132, 0.30475337243325007, 0.26851924324159027, 0.22376300145479378, 0.227935484904627, 0.1846159551003519, 0.12745916645377897, 0.3620701781202337, 0.34282620487917004, 0.3503080804795605, 0.3549093759633555, 0.36248201959882376, 0.36710363859030193, 0.3199757926439307, 0.32570649293254705, 0.3414405037725975, 0.6806898264626025, 0.7373191442845873, 0.7277733070655366, 0.7494617832946493, 0.7098597446012667, 0.7382599146881597, 0.7228097808249891, 0.7021853033778939, 0.7256318203668548, 0.099488982737438, 0.11415943406315221, 0.10895080078028074, 0.10447114780505051, 0.11891694931056895, 0.09374844042586805, 0.09479743131558283, 0.1002515173679761, 0.09784760316367902, 0.17048834085633846, 0.15583655881000902, 0.13340005094447027, 0.18072943540273123, 0.1470530983091628, 0.1390765378786606, 0.15520669865001602, 0.13411144906542027, 0.1719034594526354, 0.40982954754320844, 0.43404166331132654, 0.4243621967257807, 0.40609065728512583, 0.43475645500479676, 0.4335711581730043, 0.46014505634755953, 0.4424915537367835, 0.45482841979266075, 0.3393305562155051, 0.3144520768629785, 0.350304928223089, 0.33858634022896206, 0.3234532447361349, 0.33011239761859146, 0.3557082879187349, 0.37806206406816023, 0.35378433801686393, 0.21570872547370012, 0.18726917519504527, 0.19697802509418538, 0.2136021135232532, 0.19171821583500892, 0.19306937573935934, 0.21168084978840185, 0.20072444344447127, 0.19204211558125261, 0.19748841040924003, 0.19359450791872013, 0.21851815668183006, 0.22136748333168277, 0.21871457871266486, 0.22733880503211124, 0.23983388577451936, 0.19429481212871946, 0.20127414012405398, 0.17786462423654104, 0.1498151874430892, 0.16752392220090473, 0.7164214196869672, 0.5906207269251055, 0.7311902088893751, 0.48205122153423785, 0.6876510389278334, 0.7485289182740278, 0.7553166495142443, 0.7310159353875576, 0.7288033064821906, 0.5814114311449038, 0.18948540338548048, 0.19732700926736202, 0.19485716801798358, 0.7295607375994417, 0.20667104244038503, 0.20344258531120785, 0.18492677001615965, 0.18864310374348991, 0.1830614229749542, 0.18527012496424178, 0.1798561338236394, 0.18192845297948324, 0.2074199176655468, 0.18439870797369973, 0.08100693539977788, 0.07299433182060622, 0.08208900846412559, 0.08169239884192192, 0.08526462557174674, 0.07948213434073459, 0.08806956984947178, 0.10081689979927067, 0.0814182614810468]}, "mutation_prompt": null}
{"id": "b7fc323d-7215-4a37-9f89-8ce67f8e37b1", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "8e8a3ed3-9e03-40e2-9859-abe957bf86e9", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx, best_individual):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b = np.random.choice(indices, 2, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))\n        mutant = best_individual + adaptive_F * (self.population[a] - self.population[b])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:\n                    mutant = self._mutate(i, best_individual)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Combine adaptive differential evolution with elite-guided strategy to improve convergence efficiency.", "configspace": "", "generation": 67, "fitness": 0.32905085629146247, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.9424835589154349, 0.942733695972464, 0.9377887219042002, 0.9312070322278856, 0.9429097926801056, 0.9327260842408048, 0.9386199470270425, 0.9422400057329724, 0.9378137584553815, 0.2741800112332561, 0.5304939304177447, 0.07608705563341667, 0.22405417525741056, 0.6657640450061308, 0.12432821812459027, 0.09275080524295987, 0.11986267961232877, 0.3406680005463453, 0.11254508259000284, 0.10543112645751007, 0.07288183357124889, 0.12464518582838846, 0.0854713275346588, 0.06418071331120367, 0.08647846841615714, 0.1632884365970514, 0.16025501020914235, 0.06365752025968163, 0.09747783261070475, 0.11830357350279808, 0.08016671324917246, 0.09627644826358284, 0.12198093949279576, 0.1337178829416662, 0.09689982860653179, 0.0398048293153519, 0.9648742840871377, 0.9766478917172668, 0.9821520993711021, 0.9688057854765529, 0.966626574887998, 0.9438183312717143, 0.9733135494776388, 0.990384673401913, 0.9694041419896292, 0.8422045682671323, 0.8479390984003454, 0.7672356184832325, 0.8193584215066966, 0.8320550171083999, 0.8402228890668966, 0.8497609595260143, 0.7220248121367199, 0.8398386915103824, 0.2307824798409318, 0.39237921324398917, 0.25525865337471376, 0.21062837348575958, 0.21992079563552502, 0.2145553911536494, 0.11209717541543562, 0.1759073497408299, 0.37805950055924054, 0.826980455098192, 0.11706461531031853, 0.15099877265777428, 0.12984813271461482, 0.13327736351947406, 0.6991567650444961, 0.15997386965692317, 0.1506558769263966, 0.6285315941533633, 0.1420419918772805, 0.13976059270310792, 0.1344080834667415, 0.17377688368378263, 0.6620480910138002, 0.14023445313756178, 0.1343719596167099, 0.12813361809293533, 0.11680685403852353, 9.999999999998899e-05, 0.0716065018009624, 0.0734806743092411, 0.0005899024606138559, 0.023541367242344458, 0.007647789051890119, 0.07799510680240052, 0.23363010930595107, 0.09897247055107272, 0.24086439456395115, 0.14217315702245992, 0.15955265847154387, 0.1997134635132879, 0.130901689053172, 0.04353522262449372, 0.20524503476596223, 0.3980287250052865, 0.3161218588746155, 0.12945519890057167, 0.15741766455208128, 0.07770647540491937, 0.18899158710076247, 0.12227992199816584, 0.08530648445554656, 0.1664683202778937, 0.3470108462822157, 0.08001132121454158, 0.33310656902879887, 0.26139170195867323, 0.3066459944415574, 0.2544237505866277, 0.27103219948437607, 0.32762522372320035, 0.3293369967970623, 0.27118269279622, 0.20210011056907184, 0.8001423042752194, 0.917940345766938, 0.611006644087348, 0.6570241287283635, 0.6043941371962247, 0.42772826268012576, 0.6410969878230108, 0.6932202335262782, 0.7366194822757464, 0.16257120994246999, 0.06836609581076514, 0.06691142246869253, 0.07139332138254795, 0.07356168089676596, 0.16190807609320568, 0.1357542148783657, 0.11700106543056699, 0.16217921649852673, 0.17002512754134402, 0.6061267111023816, 0.24316323275033003, 0.25884587762493505, 0.44617629000553616, 0.31530867731321854, 0.1572378062428217, 0.3888180900009264, 0.15986439351363335, 0.6548633046083703, 0.262174444306814, 0.3458469485703135, 0.39442084833449453, 0.1907508138874915, 0.2785855587631766, 0.4017298531636675, 0.5217886074047782, 0.4226612756543726, 0.24149517228052053, 0.2527842402237398, 0.3423375435734045, 0.23295763755013843, 0.22430007626254833, 0.2622809466357251, 0.24949418207198037, 0.31841750054314866, 0.3180027519903994, 0.28193053891417263, 0.1923022892917966, 0.2232579182723875, 0.21462629401418376, 0.2047554082161942, 0.21980156764646597, 0.21915705383407935, 0.19342519661079993, 0.19520551507184158, 0.2116401261796369, 0.21822538333259167, 0.20395285668613627, 0.19124380070584435, 0.18620532322581063, 0.18188189948058375, 0.1999995527665125, 0.21280660096107062, 0.179220882926041, 0.10530194528037262, 0.1765248011641024, 0.1542853963437617, 0.9191593073453129, 0.2011790563451733, 0.20153111780646527, 0.9507698427245984, 0.17267233597322573, 0.9601622513130933, 0.8943693386580049, 0.21413193873579295, 0.07358343508976173, 0.9154887148084274, 0.2985259140557369, 0.15578228631926883, 0.21335765552349661, 0.10516432697214295, 0.10468449823053472, 0.19259618421732816, 0.18571531222248627, 0.17591269973954826, 0.2008324249178437, 0.18267552474740656, 0.21177294804148417, 0.2167108259809214, 0.20056945182512387, 0.19573941331278377, 0.14272637723155002, 0.10531771315051397, 0.07671080237259775, 0.11530567584940776, 0.08772993372556614, 0.09953030960830533, 0.07948394577474305, 0.07835749824394422, 0.10201503665903877]}, "mutation_prompt": null}
{"id": "50be17f1-541c-4d85-84f7-4120901a2ae8", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "cbb2f666-00d0-4a69-abe0-ea6ff3348a0e", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "6090c737-c953-4294-adb8-bf2d82c187bb", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "94f30afd-66df-4af0-a6b3-7616142ea1d7", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "02661126-9b00-4f52-af5c-1f73c00ebaf0", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "af7f4212-1ceb-4fb6-99cc-9741e008fe98", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 + np.random.uniform(-0.05, 0.05))  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive scaling of both dimensions and population size to enhance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8297458042463494, 0.8050307793200254, 0.8208248421719495, 0.8213638973173589, 0.8209013285138569, 0.8241829308565926, 0.8196321296912182, 0.8255257236660725, 0.8106863580942416, 0.7028067741790339, 0.6739057581249288, 0.6822392709476264, 0.6791726825534778, 0.6640517844410306, 0.673888151032318, 0.6748416724057281, 0.6836562785220861, 0.6742447105248237, 0.11931659690405738, 0.13677563357551625, 0.10935527892825825, 0.11045092254378142, 0.11855424726634844, 0.13485905247338736, 0.1273058064156095, 0.1144501291547011, 0.12165127933527964, 0.09893377714571705, 0.1219144172780181, 0.11122310637487154, 0.10656668585397944, 0.12478911762375211, 0.12047135946816812, 0.11043390792648866, 0.10284918460972736, 0.10405432787629432, 0.9584328529718286, 0.9077141708496522, 0.9183385742411201, 0.8967767925813913, 0.9160926925131349, 0.9355292847065211, 0.8181793088389712, 0.9522564639051768, 0.9427884388114414, 0.525009313016245, 0.534649747674131, 0.5329812845361928, 0.5373397030557419, 0.471789976449591, 0.5353552250255859, 0.5322806717122052, 0.5355954180210049, 0.5351631062610528, 0.7974837346192244, 0.8089176137950259, 0.7294938046650503, 0.7944940695598733, 0.810512680692789, 0.8146737481743906, 0.7854411353424215, 0.7882921332358919, 0.8018947069356115, 0.19417985999883824, 0.30497444009045616, 0.2658591123095069, 0.16667251993646548, 0.19906186939947967, 0.5680743837481241, 0.4641489692042742, 0.3935568699790509, 0.21562123534922206, 0.2197222181768751, 0.16957210773936837, 0.4024958887393546, 0.22953980603295, 0.5290228496110323, 0.2545732576988746, 0.1703873764535907, 0.19816126414834745, 0.18817540540381994, 0.4128975676761405, 0.4483671539584203, 0.45781163364591704, 0.43609675570009865, 0.4483637926497185, 0.4604023162684685, 0.44213599381369406, 0.47720020837329735, 0.4517526635151351, 0.5849551404985358, 0.6197175078743253, 0.5897286271480724, 0.5830462694075049, 0.5690179127652069, 0.5902893519644481, 0.6398484173382619, 0.5560441590387513, 0.6037079878427154, 0.09482148592965134, 0.1336271869596145, 0.11886810725378238, 0.2987721382553641, 0.3102352918424556, 0.15873365941844508, 0.22666681727468807, 0.2727642147151089, 0.14833680786971204, 0.359627020613831, 0.3531014295428201, 0.35011032866095015, 0.3649108346909722, 0.3570663077335843, 0.3917938477802694, 0.33234527025627647, 0.33776692437209976, 0.36484461743797114, 0.7337719379708636, 0.7454796202104844, 0.7352717316090014, 0.7428250793750546, 0.7376778102591253, 0.739736147500293, 0.7172159995207952, 0.7048249665606516, 0.7086255309001772, 0.12716356408834872, 0.09707040781721221, 0.10654939630829108, 0.1016083805459781, 0.1317765813060804, 0.0879635754790068, 0.09848808532635789, 0.11270260055980574, 0.09177320049748727, 0.16212413840628392, 0.13453177068892475, 0.13607624244997119, 0.12696921258317428, 0.17580710263467358, 0.15497358691195606, 0.2262664332681068, 0.12515885736816723, 0.14181932176127998, 0.406108108863548, 0.41582874530676883, 0.44998145383435717, 0.4520940992602076, 0.43683318514395253, 0.4414708057551351, 0.4768406304744778, 0.462936308256206, 0.4996026999740458, 0.3787570004609824, 0.33439867741112894, 0.3122983353156037, 0.3367484683681664, 0.3402775276371047, 0.35467311633547793, 0.36292831658963776, 0.3631302509152996, 0.3378136251350141, 0.2038978576651429, 0.22604832474376602, 0.1893335214060453, 0.2183139834062382, 0.19425169781720286, 0.20998912100969713, 0.2098559183727854, 0.2375661422810218, 0.22364062059176537, 0.18442998491849827, 0.22069889747018157, 0.18882606303210336, 0.2408461801860583, 0.1896568287092706, 0.20630807387557115, 0.20088219774647342, 0.4388048616007808, 0.18473241577048904, 0.6999143731044579, 0.6870757897267745, 0.6943956945451193, 0.7360871426745444, 0.5752788076360855, 0.6855343037621939, 0.6539250427199887, 0.17921803120211788, 0.6718310460033614, 0.4839285763209237, 0.20443760723073456, 0.16713829997027352, 0.19516544195565244, 0.20374232734466213, 0.725872376949422, 0.7034414364662376, 0.2068501779730112, 0.2089372564022518, 0.1768280973038041, 0.17600142488006476, 0.1798239532791669, 0.22202690656397883, 0.1761581646658542, 0.18709632671976173, 0.17822188713223897, 0.18579976025040035, 0.1839331787836168, 0.0773742464968098, 0.0794991359699816, 0.07745523506118912, 0.08989326258074293, 0.07541584738907547, 0.07527697501973052, 0.0789434526531595, 0.08230228298198383, 0.07915682890929643]}, "mutation_prompt": null}
{"id": "bf8de8f4-d558-482e-b332-6f94ceca12b5", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        fitness_factor = 1.0 - (self.fitness[idx] / (np.max(self.fitness) + 1e-9))\n        adaptive_F = self.F * (1 + fitness_factor * np.random.uniform(-0.1, 0.1))  # Fitness-based adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance exploration and exploitation by incorporating fitness-based adaptive scaling of differential weight and dynamic crossover probability tuning.", "configspace": "", "generation": 74, "fitness": 0.40210430697257893, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "493d2d9e-bc8c-4af1-a965-054a35089c15", "metadata": {"aucs": [0.8055430147926532, 0.8112131880539091, 0.8125962157647153, 0.806605666247703, 0.8303292005904608, 0.8357459688357702, 0.8172284727956534, 0.8133690329631907, 0.8110400032034218, 0.6767773605495304, 0.6798971038567942, 0.6880217738994392, 0.6900867648700244, 0.7016371337329094, 0.6876944156307121, 0.678143027543868, 0.6786872196743923, 0.6961893159593051, 0.11854601344996096, 0.13282336612953527, 0.11839561895041717, 0.12016474455420534, 0.12399861470816598, 0.12944098217030242, 0.121023674337701, 0.11161162932660262, 0.12085962234768155, 0.10211517975482909, 0.11695477990778558, 0.10953621065621699, 0.12151409261604207, 0.10340253555204693, 0.09938746519763686, 0.11317696774277486, 0.10728441218320384, 0.11041750646532167, 0.8650576672382948, 0.8166855658149987, 0.8653112472909696, 0.8427039381834528, 0.9782767502564349, 0.8018438590659498, 0.953979013879659, 0.8622832145384024, 0.7917103656311206, 0.5188371031207188, 0.5206959381317091, 0.4935848879664346, 0.5190906737262704, 0.4882592752781132, 0.5099759931273042, 0.5133486886270932, 0.5577274819325528, 0.5036802258873718, 0.7746225495741694, 0.8025553863113959, 0.7889395605334948, 0.8354786192886232, 0.844031819367289, 0.8457649678763637, 0.8151464473814295, 0.7981363157942938, 0.7773932210369516, 0.32631330962540184, 0.1651458025617596, 0.4205934785099533, 0.17989553300389127, 0.3977683905620897, 0.2621894987268054, 0.17119245141694062, 0.20960575093264444, 0.3280274923239265, 0.24901185560232575, 0.2062425082060778, 0.16606926138104805, 0.2888899526901799, 0.18761277349180505, 0.3671279374543145, 0.1777662464979043, 0.1901770224090461, 0.47186196041964723, 0.4844790076751119, 0.5069885200467132, 0.43716765545950387, 0.5125881671498799, 0.5124127455565787, 0.3799106209901003, 0.4817539250056304, 0.5376176434240345, 0.5480914198973922, 0.6394206748820219, 0.6476735868369317, 0.604373210568814, 0.6363007595518628, 0.6405257284866239, 0.6026498178069648, 0.6592878317050533, 0.6247081343947787, 0.6586471748561448, 0.10882547638332907, 0.25060883093800645, 0.2576370196533001, 0.28974865726692034, 0.23244535511867215, 0.3365218630771255, 0.13667818526561137, 0.20844065425905745, 0.23782698820503556, 0.3722351524328096, 0.36974938386608913, 0.32964761124186004, 0.37788120213396925, 0.3828223881986106, 0.37233078919927787, 0.3618513254333314, 0.3538459386557009, 0.35495842108977105, 0.7125361311857497, 0.7234188486904609, 0.7533047897242378, 0.7222325706748772, 0.7346861120530505, 0.7312398890997667, 0.753461511973369, 0.7472270872891184, 0.7563397423331566, 0.10349293099611512, 0.11264213409426416, 0.0988115473728256, 0.10517579221959017, 0.0927803790559889, 0.11805814149213256, 0.11097174308160507, 0.09897443447165666, 0.09981087716612458, 0.13762761092538767, 0.14707547162001788, 0.14725151044699947, 0.13574297037779492, 0.18463630069272918, 0.13343930872486087, 0.1641229774118219, 0.19436606535027046, 0.16303295762084125, 0.4294710088386572, 0.46397252637191044, 0.4513442831440977, 0.41585425716431823, 0.47500484447884883, 0.45268751515300265, 0.44775168941284427, 0.4976048938994668, 0.4789698177409012, 0.35682987415843437, 0.351761521528713, 0.34803787913329665, 0.34088468725782073, 0.3251631580998363, 0.33728273595456004, 0.35789698843610995, 0.34640387051622024, 0.36508016960262146, 0.22269558480048468, 0.2038433418675467, 0.18965670113187094, 0.23604920963305098, 0.19919083222597367, 0.20050713459758407, 0.19821822129351607, 0.21863623539212806, 0.19022002734636168, 0.18430240356464145, 0.35094592803444313, 0.20806924887928002, 0.20041620803428162, 0.20009364058825008, 0.18317336351829216, 0.2061815060208958, 0.22892380936649603, 0.2105000031664035, 0.1930642357809298, 0.19896301634963454, 0.18222116419672685, 0.6914348195105048, 0.784818114622395, 0.19511841863329982, 0.7778730526927103, 0.5908215007722417, 0.6765853574435484, 0.8011151736328541, 0.7609019109461307, 0.6931468025192786, 0.16421694163037714, 0.7693513770518473, 0.1812893140564833, 0.2037348643954976, 0.20847054026773681, 0.7234515810914806, 0.19164183308332794, 0.17527403951177534, 0.18884215666973958, 0.19511787562488547, 0.18823725289891502, 0.1949951869712686, 0.20390137303159872, 0.20604689326981718, 0.20143416881304765, 0.07508364088329023, 0.08518562444646083, 0.08266318949315954, 0.07329490611997203, 0.08834798821520073, 0.08420632646676418, 0.08798532754264254, 0.08876029991599077, 0.09012691662342387]}, "mutation_prompt": null}
{"id": "3d69d08f-c2b1-48fb-8a8a-32b31d17b1c8", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        fitness_factor = 1.0 - (self.fitness[idx] / (np.max(self.fitness) + 1e-9))\n        adaptive_F = self.F * (1 + fitness_factor * np.random.uniform(-0.1, 0.1))  # Fitness-based adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance exploration and exploitation by incorporating fitness-based adaptive scaling of differential weight and dynamic crossover probability tuning.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bf8de8f4-d558-482e-b332-6f94ceca12b5", "metadata": {"aucs": [0.8055430147926532, 0.8112131880539091, 0.8125962157647153, 0.806605666247703, 0.8303292005904608, 0.8357459688357702, 0.8172284727956534, 0.8133690329631907, 0.8110400032034218, 0.6767773605495304, 0.6798971038567942, 0.6880217738994392, 0.6900867648700244, 0.7016371337329094, 0.6876944156307121, 0.678143027543868, 0.6786872196743923, 0.6961893159593051, 0.11854601344996096, 0.13282336612953527, 0.11839561895041717, 0.12016474455420534, 0.12399861470816598, 0.12944098217030242, 0.121023674337701, 0.11161162932660262, 0.12085962234768155, 0.10211517975482909, 0.11695477990778558, 0.10953621065621699, 0.12151409261604207, 0.10340253555204693, 0.09938746519763686, 0.11317696774277486, 0.10728441218320384, 0.11041750646532167, 0.8650576672382948, 0.8166855658149987, 0.8653112472909696, 0.8427039381834528, 0.9782767502564349, 0.8018438590659498, 0.953979013879659, 0.8622832145384024, 0.7917103656311206, 0.5188371031207188, 0.5206959381317091, 0.4935848879664346, 0.5190906737262704, 0.4882592752781132, 0.5099759931273042, 0.5133486886270932, 0.5577274819325528, 0.5036802258873718, 0.7746225495741694, 0.8025553863113959, 0.7889395605334948, 0.8354786192886232, 0.844031819367289, 0.8457649678763637, 0.8151464473814295, 0.7981363157942938, 0.7773932210369516, 0.32631330962540184, 0.1651458025617596, 0.4205934785099533, 0.17989553300389127, 0.3977683905620897, 0.2621894987268054, 0.17119245141694062, 0.20960575093264444, 0.3280274923239265, 0.24901185560232575, 0.2062425082060778, 0.16606926138104805, 0.2888899526901799, 0.18761277349180505, 0.3671279374543145, 0.1777662464979043, 0.1901770224090461, 0.47186196041964723, 0.4844790076751119, 0.5069885200467132, 0.43716765545950387, 0.5125881671498799, 0.5124127455565787, 0.3799106209901003, 0.4817539250056304, 0.5376176434240345, 0.5480914198973922, 0.6394206748820219, 0.6476735868369317, 0.604373210568814, 0.6363007595518628, 0.6405257284866239, 0.6026498178069648, 0.6592878317050533, 0.6247081343947787, 0.6586471748561448, 0.10882547638332907, 0.25060883093800645, 0.2576370196533001, 0.28974865726692034, 0.23244535511867215, 0.3365218630771255, 0.13667818526561137, 0.20844065425905745, 0.23782698820503556, 0.3722351524328096, 0.36974938386608913, 0.32964761124186004, 0.37788120213396925, 0.3828223881986106, 0.37233078919927787, 0.3618513254333314, 0.3538459386557009, 0.35495842108977105, 0.7125361311857497, 0.7234188486904609, 0.7533047897242378, 0.7222325706748772, 0.7346861120530505, 0.7312398890997667, 0.753461511973369, 0.7472270872891184, 0.7563397423331566, 0.10349293099611512, 0.11264213409426416, 0.0988115473728256, 0.10517579221959017, 0.0927803790559889, 0.11805814149213256, 0.11097174308160507, 0.09897443447165666, 0.09981087716612458, 0.13762761092538767, 0.14707547162001788, 0.14725151044699947, 0.13574297037779492, 0.18463630069272918, 0.13343930872486087, 0.1641229774118219, 0.19436606535027046, 0.16303295762084125, 0.4294710088386572, 0.46397252637191044, 0.4513442831440977, 0.41585425716431823, 0.47500484447884883, 0.45268751515300265, 0.44775168941284427, 0.4976048938994668, 0.4789698177409012, 0.35682987415843437, 0.351761521528713, 0.34803787913329665, 0.34088468725782073, 0.3251631580998363, 0.33728273595456004, 0.35789698843610995, 0.34640387051622024, 0.36508016960262146, 0.22269558480048468, 0.2038433418675467, 0.18965670113187094, 0.23604920963305098, 0.19919083222597367, 0.20050713459758407, 0.19821822129351607, 0.21863623539212806, 0.19022002734636168, 0.18430240356464145, 0.35094592803444313, 0.20806924887928002, 0.20041620803428162, 0.20009364058825008, 0.18317336351829216, 0.2061815060208958, 0.22892380936649603, 0.2105000031664035, 0.1930642357809298, 0.19896301634963454, 0.18222116419672685, 0.6914348195105048, 0.784818114622395, 0.19511841863329982, 0.7778730526927103, 0.5908215007722417, 0.6765853574435484, 0.8011151736328541, 0.7609019109461307, 0.6931468025192786, 0.16421694163037714, 0.7693513770518473, 0.1812893140564833, 0.2037348643954976, 0.20847054026773681, 0.7234515810914806, 0.19164183308332794, 0.17527403951177534, 0.18884215666973958, 0.19511787562488547, 0.18823725289891502, 0.1949951869712686, 0.20390137303159872, 0.20604689326981718, 0.20143416881304765, 0.07508364088329023, 0.08518562444646083, 0.08266318949315954, 0.07329490611997203, 0.08834798821520073, 0.08420632646676418, 0.08798532754264254, 0.08876029991599077, 0.09012691662342387]}, "mutation_prompt": null}
{"id": "befe2d87-ef7c-4256-b1d1-7c55959882f6", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        fitness_factor = 1.0 - (self.fitness[idx] / (np.max(self.fitness) + 1e-9))\n        adaptive_F = self.F * (1 + fitness_factor * np.random.uniform(-0.1, 0.1))  # Fitness-based adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (self.upper_bound - self.lower_bound)\n        for _ in range(3):  # Perform a limited number of local adjustments\n            trial_candidate = trial + np.random.uniform(-step_size, step_size, self.dim)\n            trial_candidate = np.clip(trial_candidate, self.lower_bound, self.upper_bound)\n            trial_candidate_fitness = func(trial_candidate)\n            self.eval_count += 1\n            if trial_candidate_fitness < func(trial):\n                trial = trial_candidate\n                if self.eval_count >= self.budget:\n                    break\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial = self._local_search(trial, func)  # Apply local search\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce local search in the fitness landscape to exploit promising areas more effectively by refining trial solutions.", "configspace": "", "generation": 76, "fitness": 0.14591636669566108, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.11.", "error": "", "parent_id": "bf8de8f4-d558-482e-b332-6f94ceca12b5", "metadata": {"aucs": [0.29841518360656416, 0.31505332069016156, 0.3009904852710742, 0.3451648309996609, 0.31925256674278846, 0.35168420259320177, 0.3338572418478839, 0.34028783281901454, 0.3325096260216148, 0.05003581503408949, 0.05825192039764093, 0.057132215257221675, 0.08126365636531141, 0.05014903738252341, 0.06776048413407043, 0.05462902750007159, 0.05564364513139075, 0.05684159788450871, 0.0773635837782245, 0.08631552894949113, 0.08973100279113588, 0.08481134062263829, 0.06975085453330898, 0.07505187253720447, 0.08127130772509084, 0.09751877271198428, 0.07650495739694785, 0.0506405359252482, 0.04854096767737481, 0.06531236658319106, 0.056894008804833196, 0.06346534384883362, 0.056207921742115974, 0.06506485675168039, 0.05828341956376426, 0.060637948538681985, 0.4250498629681657, 0.6704665707035752, 0.6960757187254115, 0.5983877438588998, 0.5813736883175615, 0.33523274692920946, 0.4472980194520457, 0.39413169723149444, 0.5471436110649895, 0.12169612262720197, 0.09608298283652061, 0.10534920542688875, 0.1360796235493814, 0.09375822220375707, 0.13295302896590133, 0.15243511343788652, 0.1355107955271, 0.11418968118413919, 0.22454537253948958, 0.2243358983581749, 0.18153496584343187, 0.20988995528081278, 0.23059417174895303, 0.23326166817485838, 0.1857043875062261, 0.19594024403310695, 0.21445580609308112, 0.08690010665686076, 0.06238693937686424, 0.07529177382696617, 0.11671407411670165, 0.07576685383424742, 0.06846145388010627, 0.09731977996633834, 0.07276377255619138, 0.08976563907767299, 0.07824831684273392, 0.0640832542988874, 0.06878945854450791, 0.09160515376147593, 0.08134162239777509, 0.07745984103341741, 0.09342215544074572, 0.09011972672420854, 0.059678835523677254, 0.008193752631940554, 0.00712948621601317, 0.003521646195472572, 0.013914431848860431, 0.01934199235346734, 0.009694102694605355, 0.018219477864313216, 0.022502529098861856, 0.014629925527622989, 0.13987776861934031, 0.14497455637266, 0.1331824466058803, 0.11346239513135514, 0.09861170428518617, 0.15743542209505745, 0.16028044623743776, 0.12462841145453418, 0.12733839880385, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002654422011725277, 0.03963984860676795, 0.05306088115126972, 0.05899185082447567, 0.0614221048085275, 0.03478770926859254, 0.05033474396547244, 0.0719568292606666, 0.04611310019894832, 0.06224376379743046, 0.2830728229569094, 0.30577165222603486, 0.316730320767305, 0.3025957204257368, 0.3061739101578448, 0.29595118611430593, 0.31224045369177067, 0.29910164521468774, 0.3132203430326296, 0.06910097585491837, 0.07720204673846287, 0.09712348338417509, 0.0871605186476403, 0.06442783832851806, 0.07254896383905474, 0.07360552714523494, 0.08121142462149566, 0.06999263757015384, 0.1388750698854908, 0.11509226401670225, 0.12800020990291383, 0.13450753458719422, 0.13534640707234558, 0.13281429917204712, 0.13336454119139962, 0.14827655710267684, 0.13296389385222684, 0.20418697394974994, 0.19327950359150015, 0.2157870303087016, 0.18794033097893947, 0.19507321456600846, 0.19728297700009712, 0.20666479021227446, 0.22960421185416613, 0.19335499469663542, 0.1505237960239436, 0.1516390233410515, 0.13124040615625332, 0.1491096035045304, 0.12609144583455256, 0.14336340592390717, 0.152566193825033, 0.1721669633497006, 0.16139122601843958, 0.19521136520422877, 0.15554005114962077, 0.16737466009368251, 0.19882521584603308, 0.16327313978065472, 0.1824832104556403, 0.17860160130576075, 0.17985234521889015, 0.21785786376319616, 0.15206058859772054, 0.15846961379529223, 0.1646584240949771, 0.14979954865804157, 0.16057862175371118, 0.15578335234434448, 0.15959578044408518, 0.15308418521794698, 0.16429309855532914, 0.21639488116150662, 0.1391775993256852, 0.15327540517679916, 0.13330671415683593, 0.17245762460922365, 0.15431335093666343, 0.2128361402857798, 0.12645642818190095, 0.17701533467212138, 0.24376736659159437, 0.15221004127799864, 0.14917702152428902, 0.15085497297176376, 0.12836513909265956, 0.13350283064637047, 0.09659345326802127, 0.10366370149793402, 0.15811205806959883, 0.18468348729432704, 0.17717472075975293, 0.18181142684305207, 0.17396568663508716, 0.17840956990136403, 0.17621796072310303, 0.19333948046794236, 0.17857646005909023, 0.17569776072712973, 0.06549675948248224, 0.06848106772287188, 0.06498009283546102, 0.0650418004972314, 0.0657014519467175, 0.06525106673855385, 0.06553454460624031, 0.06264085876263303, 0.06592983117052409]}, "mutation_prompt": null}
{"id": "b29c92d2-6eb3-48a7-ab16-bbe7615ce7f1", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        fitness_factor = 1.0 - (self.fitness[idx] / (np.max(self.fitness) + 1e-9))\n        adaptive_F = self.F * (1 + fitness_factor * np.random.uniform(-0.1, 0.1))  # Fitness-based adaptive scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance exploration and exploitation by incorporating fitness-based adaptive scaling of differential weight and dynamic crossover probability tuning.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bf8de8f4-d558-482e-b332-6f94ceca12b5", "metadata": {"aucs": [0.8055430147926532, 0.8112131880539091, 0.8125962157647153, 0.806605666247703, 0.8303292005904608, 0.8357459688357702, 0.8172284727956534, 0.8133690329631907, 0.8110400032034218, 0.6767773605495304, 0.6798971038567942, 0.6880217738994392, 0.6900867648700244, 0.7016371337329094, 0.6876944156307121, 0.678143027543868, 0.6786872196743923, 0.6961893159593051, 0.11854601344996096, 0.13282336612953527, 0.11839561895041717, 0.12016474455420534, 0.12399861470816598, 0.12944098217030242, 0.121023674337701, 0.11161162932660262, 0.12085962234768155, 0.10211517975482909, 0.11695477990778558, 0.10953621065621699, 0.12151409261604207, 0.10340253555204693, 0.09938746519763686, 0.11317696774277486, 0.10728441218320384, 0.11041750646532167, 0.8650576672382948, 0.8166855658149987, 0.8653112472909696, 0.8427039381834528, 0.9782767502564349, 0.8018438590659498, 0.953979013879659, 0.8622832145384024, 0.7917103656311206, 0.5188371031207188, 0.5206959381317091, 0.4935848879664346, 0.5190906737262704, 0.4882592752781132, 0.5099759931273042, 0.5133486886270932, 0.5577274819325528, 0.5036802258873718, 0.7746225495741694, 0.8025553863113959, 0.7889395605334948, 0.8354786192886232, 0.844031819367289, 0.8457649678763637, 0.8151464473814295, 0.7981363157942938, 0.7773932210369516, 0.32631330962540184, 0.1651458025617596, 0.4205934785099533, 0.17989553300389127, 0.3977683905620897, 0.2621894987268054, 0.17119245141694062, 0.20960575093264444, 0.3280274923239265, 0.24901185560232575, 0.2062425082060778, 0.16606926138104805, 0.2888899526901799, 0.18761277349180505, 0.3671279374543145, 0.1777662464979043, 0.1901770224090461, 0.47186196041964723, 0.4844790076751119, 0.5069885200467132, 0.43716765545950387, 0.5125881671498799, 0.5124127455565787, 0.3799106209901003, 0.4817539250056304, 0.5376176434240345, 0.5480914198973922, 0.6394206748820219, 0.6476735868369317, 0.604373210568814, 0.6363007595518628, 0.6405257284866239, 0.6026498178069648, 0.6592878317050533, 0.6247081343947787, 0.6586471748561448, 0.10882547638332907, 0.25060883093800645, 0.2576370196533001, 0.28974865726692034, 0.23244535511867215, 0.3365218630771255, 0.13667818526561137, 0.20844065425905745, 0.23782698820503556, 0.3722351524328096, 0.36974938386608913, 0.32964761124186004, 0.37788120213396925, 0.3828223881986106, 0.37233078919927787, 0.3618513254333314, 0.3538459386557009, 0.35495842108977105, 0.7125361311857497, 0.7234188486904609, 0.7533047897242378, 0.7222325706748772, 0.7346861120530505, 0.7312398890997667, 0.753461511973369, 0.7472270872891184, 0.7563397423331566, 0.10349293099611512, 0.11264213409426416, 0.0988115473728256, 0.10517579221959017, 0.0927803790559889, 0.11805814149213256, 0.11097174308160507, 0.09897443447165666, 0.09981087716612458, 0.13762761092538767, 0.14707547162001788, 0.14725151044699947, 0.13574297037779492, 0.18463630069272918, 0.13343930872486087, 0.1641229774118219, 0.19436606535027046, 0.16303295762084125, 0.4294710088386572, 0.46397252637191044, 0.4513442831440977, 0.41585425716431823, 0.47500484447884883, 0.45268751515300265, 0.44775168941284427, 0.4976048938994668, 0.4789698177409012, 0.35682987415843437, 0.351761521528713, 0.34803787913329665, 0.34088468725782073, 0.3251631580998363, 0.33728273595456004, 0.35789698843610995, 0.34640387051622024, 0.36508016960262146, 0.22269558480048468, 0.2038433418675467, 0.18965670113187094, 0.23604920963305098, 0.19919083222597367, 0.20050713459758407, 0.19821822129351607, 0.21863623539212806, 0.19022002734636168, 0.18430240356464145, 0.35094592803444313, 0.20806924887928002, 0.20041620803428162, 0.20009364058825008, 0.18317336351829216, 0.2061815060208958, 0.22892380936649603, 0.2105000031664035, 0.1930642357809298, 0.19896301634963454, 0.18222116419672685, 0.6914348195105048, 0.784818114622395, 0.19511841863329982, 0.7778730526927103, 0.5908215007722417, 0.6765853574435484, 0.8011151736328541, 0.7609019109461307, 0.6931468025192786, 0.16421694163037714, 0.7693513770518473, 0.1812893140564833, 0.2037348643954976, 0.20847054026773681, 0.7234515810914806, 0.19164183308332794, 0.17527403951177534, 0.18884215666973958, 0.19511787562488547, 0.18823725289891502, 0.1949951869712686, 0.20390137303159872, 0.20604689326981718, 0.20143416881304765, 0.07508364088329023, 0.08518562444646083, 0.08266318949315954, 0.07329490611997203, 0.08834798821520073, 0.08420632646676418, 0.08798532754264254, 0.08876029991599077, 0.09012691662342387]}, "mutation_prompt": null}
{"id": "6e62542d-d670-4ead-9b7b-b46dca87946f", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.memory_F = np.zeros(self.population_size)  # Track historical F values\n        self.memory_CR = np.zeros(self.population_size)  # Track historical CR values\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        fitness_factor = 1.0 - (self.fitness[idx] / (np.max(self.fitness) + 1e-9))\n        adaptive_F = self.F * (1 + fitness_factor * np.random.uniform(-0.1, 0.1))  # Fitness-based adaptive scaling\n        self.memory_F[idx] = adaptive_F  # Update historical memory\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        self.memory_CR[:] = adaptive_CR  # Update historical memory for CR\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce historical memory and adaptive scaling for both differential weight and crossover based on relative fitness progression.", "configspace": "", "generation": 78, "fitness": 0.40210430697257893, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "bf8de8f4-d558-482e-b332-6f94ceca12b5", "metadata": {"aucs": [0.8055430147926532, 0.8112131880539091, 0.8125962157647153, 0.806605666247703, 0.8303292005904608, 0.8357459688357702, 0.8172284727956534, 0.8133690329631907, 0.8110400032034218, 0.6767773605495304, 0.6798971038567942, 0.6880217738994392, 0.6900867648700244, 0.7016371337329094, 0.6876944156307121, 0.678143027543868, 0.6786872196743923, 0.6961893159593051, 0.11854601344996096, 0.13282336612953527, 0.11839561895041717, 0.12016474455420534, 0.12399861470816598, 0.12944098217030242, 0.121023674337701, 0.11161162932660262, 0.12085962234768155, 0.10211517975482909, 0.11695477990778558, 0.10953621065621699, 0.12151409261604207, 0.10340253555204693, 0.09938746519763686, 0.11317696774277486, 0.10728441218320384, 0.11041750646532167, 0.8650576672382948, 0.8166855658149987, 0.8653112472909696, 0.8427039381834528, 0.9782767502564349, 0.8018438590659498, 0.953979013879659, 0.8622832145384024, 0.7917103656311206, 0.5188371031207188, 0.5206959381317091, 0.4935848879664346, 0.5190906737262704, 0.4882592752781132, 0.5099759931273042, 0.5133486886270932, 0.5577274819325528, 0.5036802258873718, 0.7746225495741694, 0.8025553863113959, 0.7889395605334948, 0.8354786192886232, 0.844031819367289, 0.8457649678763637, 0.8151464473814295, 0.7981363157942938, 0.7773932210369516, 0.32631330962540184, 0.1651458025617596, 0.4205934785099533, 0.17989553300389127, 0.3977683905620897, 0.2621894987268054, 0.17119245141694062, 0.20960575093264444, 0.3280274923239265, 0.24901185560232575, 0.2062425082060778, 0.16606926138104805, 0.2888899526901799, 0.18761277349180505, 0.3671279374543145, 0.1777662464979043, 0.1901770224090461, 0.47186196041964723, 0.4844790076751119, 0.5069885200467132, 0.43716765545950387, 0.5125881671498799, 0.5124127455565787, 0.3799106209901003, 0.4817539250056304, 0.5376176434240345, 0.5480914198973922, 0.6394206748820219, 0.6476735868369317, 0.604373210568814, 0.6363007595518628, 0.6405257284866239, 0.6026498178069648, 0.6592878317050533, 0.6247081343947787, 0.6586471748561448, 0.10882547638332907, 0.25060883093800645, 0.2576370196533001, 0.28974865726692034, 0.23244535511867215, 0.3365218630771255, 0.13667818526561137, 0.20844065425905745, 0.23782698820503556, 0.3722351524328096, 0.36974938386608913, 0.32964761124186004, 0.37788120213396925, 0.3828223881986106, 0.37233078919927787, 0.3618513254333314, 0.3538459386557009, 0.35495842108977105, 0.7125361311857497, 0.7234188486904609, 0.7533047897242378, 0.7222325706748772, 0.7346861120530505, 0.7312398890997667, 0.753461511973369, 0.7472270872891184, 0.7563397423331566, 0.10349293099611512, 0.11264213409426416, 0.0988115473728256, 0.10517579221959017, 0.0927803790559889, 0.11805814149213256, 0.11097174308160507, 0.09897443447165666, 0.09981087716612458, 0.13762761092538767, 0.14707547162001788, 0.14725151044699947, 0.13574297037779492, 0.18463630069272918, 0.13343930872486087, 0.1641229774118219, 0.19436606535027046, 0.16303295762084125, 0.4294710088386572, 0.46397252637191044, 0.4513442831440977, 0.41585425716431823, 0.47500484447884883, 0.45268751515300265, 0.44775168941284427, 0.4976048938994668, 0.4789698177409012, 0.35682987415843437, 0.351761521528713, 0.34803787913329665, 0.34088468725782073, 0.3251631580998363, 0.33728273595456004, 0.35789698843610995, 0.34640387051622024, 0.36508016960262146, 0.22269558480048468, 0.2038433418675467, 0.18965670113187094, 0.23604920963305098, 0.19919083222597367, 0.20050713459758407, 0.19821822129351607, 0.21863623539212806, 0.19022002734636168, 0.18430240356464145, 0.35094592803444313, 0.20806924887928002, 0.20041620803428162, 0.20009364058825008, 0.18317336351829216, 0.2061815060208958, 0.22892380936649603, 0.2105000031664035, 0.1930642357809298, 0.19896301634963454, 0.18222116419672685, 0.6914348195105048, 0.784818114622395, 0.19511841863329982, 0.7778730526927103, 0.5908215007722417, 0.6765853574435484, 0.8011151736328541, 0.7609019109461307, 0.6931468025192786, 0.16421694163037714, 0.7693513770518473, 0.1812893140564833, 0.2037348643954976, 0.20847054026773681, 0.7234515810914806, 0.19164183308332794, 0.17527403951177534, 0.18884215666973958, 0.19511787562488547, 0.18823725289891502, 0.1949951869712686, 0.20390137303159872, 0.20604689326981718, 0.20143416881304765, 0.07508364088329023, 0.08518562444646083, 0.08266318949315954, 0.07329490611997203, 0.08834798821520073, 0.08420632646676418, 0.08798532754264254, 0.08876029991599077, 0.09012691662342387]}, "mutation_prompt": null}
{"id": "3ce532ce-5a79-471e-a158-260db813e6ac", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1))  # Fitness diversity-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce adaptive population resizing and fitness diversity-based mutation scaling to balance exploration and exploitation dynamically.", "configspace": "", "generation": 79, "fitness": 0.41727280975521985, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "bf8de8f4-d558-482e-b332-6f94ceca12b5", "metadata": {"aucs": [0.8098078374659212, 0.8303544630989396, 0.8292693127374776, 0.8325032048588561, 0.8210523580808842, 0.8228125002992775, 0.8077391606653921, 0.823621501653043, 0.8166928099150027, 0.6830402589052041, 0.6896860695424089, 0.6775480084037016, 0.6771778184611419, 0.6669891975217315, 0.6875846354892796, 0.7054709865181725, 0.6946286931696638, 0.6582423831489908, 0.2953625028023491, 0.12261808169509636, 0.36999243546095584, 0.11200509295346839, 0.1117996163852436, 0.19207023311806082, 0.12699336141775475, 0.1389724179756726, 0.1837105904858375, 0.1134614461653013, 0.10536023677987816, 0.13423436664132082, 0.11897767143038906, 0.1317825908234036, 0.10882977814355344, 0.114781618902427, 0.11240222861408278, 0.11873096003570627, 0.8068876940695531, 0.8427753291414396, 0.8365140810817451, 0.8416284632320211, 0.9782562965608698, 0.8233862819776179, 0.9597991083340015, 0.9032262885987301, 0.8991043356528089, 0.5813749670528581, 0.5351545616760298, 0.5507988248747662, 0.4978348296055135, 0.6110214826339933, 0.597700038262455, 0.4235243197439188, 0.5211406242845074, 0.43998900840968813, 0.7619523515810388, 0.8092670658059735, 0.8046651747979717, 0.7860588195036191, 0.8103287093732183, 0.8066337136195466, 0.8103876094591191, 0.8278971600339634, 0.7716187632514498, 0.19386326055208358, 0.1874803920689797, 0.22842743827457723, 0.15990619000259598, 0.2381954154140844, 0.3658320909112306, 0.16967146964961577, 0.24005837092273863, 0.583321019587981, 0.26085590493606237, 0.17334806509753575, 0.2347722691729739, 0.31055766487246206, 0.19206125546437391, 0.2767933420378411, 0.5938469500368919, 0.199532872875807, 0.19893969183150606, 0.5592589782375468, 0.4546878774449792, 0.409204830531415, 0.5580505365860694, 0.5620838188935494, 0.4780864019992024, 0.5528641672710144, 0.5810217510048759, 0.5172919409554523, 0.6559609663053592, 0.6546331670267542, 0.6540957219747419, 0.5967624510633658, 0.6419711685601335, 0.5993174985254999, 0.6118807851519563, 0.6053025006164502, 0.648445471950504, 0.22786027829181732, 0.09684136183724912, 0.12932872951912655, 0.43373173279770905, 0.17046764493539468, 0.3130059163015537, 0.13184160094924535, 0.254236844276709, 0.16878943361632914, 0.3761995719929262, 0.38212862643075385, 0.3745592616057536, 0.47580751478531524, 0.39982074971453996, 0.37346754433374185, 0.36476882661727894, 0.3520390451042773, 0.40903193060901644, 0.7512928414878763, 0.7614529959825274, 0.7429856999658786, 0.741067618910772, 0.7150444474326443, 0.7293042711729166, 0.7775520406839811, 0.7489544912375024, 0.7549546810165869, 0.0934553733885004, 0.09313745067922297, 0.10272791578735874, 0.112902735003238, 0.10907332041525752, 0.1153298063902628, 0.10391315637104015, 0.11340433902287861, 0.11880746272530018, 0.1607338943173403, 0.16871268693929542, 0.130232388148676, 0.17086872191742875, 0.1484118286798648, 0.19734467532097, 0.23623129487000083, 0.1923246960161238, 0.213011682823123, 0.5314483897853208, 0.510207483724002, 0.5127383529696892, 0.5437790419153945, 0.48681940498207776, 0.49444034425038796, 0.490139733479971, 0.5494538920220959, 0.5582908857483818, 0.37992617387853633, 0.3747720479359886, 0.37798953990001016, 0.37812840302619255, 0.3876867972669581, 0.3892631825488613, 0.41580851482101866, 0.4436397429923401, 0.4406696780078241, 0.1932944651600964, 0.20546037343372137, 0.20070554747303337, 0.21934740860948365, 0.1780824122346778, 0.19363479233394176, 0.19514918283322724, 0.17822315906972286, 0.19689977440258766, 0.19458116639495937, 0.28925490554681077, 0.3316911003641225, 0.189761377757526, 0.20178421644862332, 0.3462611984356345, 0.20876469262181763, 0.447229377523386, 0.21762325062110333, 0.19495289627546097, 0.20140799991768554, 0.773799507670992, 0.6815823946864488, 0.7530251906976784, 0.6674621384450807, 0.7665864642588639, 0.6149726993874972, 0.7474294645220818, 0.7711141965083264, 0.1973688496458147, 0.6895622630574595, 0.1643038061457992, 0.7664857587456637, 0.1835138056208937, 0.7104289649647325, 0.12558537876061604, 0.20781891841201516, 0.1848049134907016, 0.2011079844482594, 0.18834048477182308, 0.19010716431064767, 0.17842998719565362, 0.19385570922185436, 0.2003776726598071, 0.17846877360694258, 0.1947188360294464, 0.08030521662878709, 0.08969720404797177, 0.07898542812924114, 0.08376890888367339, 0.09486307031074448, 0.08693033039987785, 0.09826582156395669, 0.08251020552375155, 0.08426332704418305]}, "mutation_prompt": null}
{"id": "d9137b15-be6e-48a8-a949-4b076ef76b71", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        mutation_probs = np.exp(-self.fitness[indices] / np.mean(self.fitness))  # Fitness-based mutation probability\n        mutation_probs /= np.sum(mutation_probs)\n        selected_indices = np.random.choice(indices, 3, replace=False, p=mutation_probs)\n        a, b, c = selected_indices\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1))\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance mutation operator with a fitness-based probabilistic approach to improve convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {}, "mutation_prompt": null}
{"id": "557f00e6-3f79-4880-9798-b7f61362d980", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1))  # Fitness diversity-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce adaptive population resizing and fitness diversity-based mutation scaling to balance exploration and exploitation dynamically.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.8098078374659212, 0.8303544630989396, 0.8292693127374776, 0.8325032048588561, 0.8210523580808842, 0.8228125002992775, 0.8077391606653921, 0.823621501653043, 0.8166928099150027, 0.6830402589052041, 0.6896860695424089, 0.6775480084037016, 0.6771778184611419, 0.6669891975217315, 0.6875846354892796, 0.7054709865181725, 0.6946286931696638, 0.6582423831489908, 0.2953625028023491, 0.12261808169509636, 0.36999243546095584, 0.11200509295346839, 0.1117996163852436, 0.19207023311806082, 0.12699336141775475, 0.1389724179756726, 0.1837105904858375, 0.1134614461653013, 0.10536023677987816, 0.13423436664132082, 0.11897767143038906, 0.1317825908234036, 0.10882977814355344, 0.114781618902427, 0.11240222861408278, 0.11873096003570627, 0.8068876940695531, 0.8427753291414396, 0.8365140810817451, 0.8416284632320211, 0.9782562965608698, 0.8233862819776179, 0.9597991083340015, 0.9032262885987301, 0.8991043356528089, 0.5813749670528581, 0.5351545616760298, 0.5507988248747662, 0.4978348296055135, 0.6110214826339933, 0.597700038262455, 0.4235243197439188, 0.5211406242845074, 0.43998900840968813, 0.7619523515810388, 0.8092670658059735, 0.8046651747979717, 0.7860588195036191, 0.8103287093732183, 0.8066337136195466, 0.8103876094591191, 0.8278971600339634, 0.7716187632514498, 0.19386326055208358, 0.1874803920689797, 0.22842743827457723, 0.15990619000259598, 0.2381954154140844, 0.3658320909112306, 0.16967146964961577, 0.24005837092273863, 0.583321019587981, 0.26085590493606237, 0.17334806509753575, 0.2347722691729739, 0.31055766487246206, 0.19206125546437391, 0.2767933420378411, 0.5938469500368919, 0.199532872875807, 0.19893969183150606, 0.5592589782375468, 0.4546878774449792, 0.409204830531415, 0.5580505365860694, 0.5620838188935494, 0.4780864019992024, 0.5528641672710144, 0.5810217510048759, 0.5172919409554523, 0.6559609663053592, 0.6546331670267542, 0.6540957219747419, 0.5967624510633658, 0.6419711685601335, 0.5993174985254999, 0.6118807851519563, 0.6053025006164502, 0.648445471950504, 0.22786027829181732, 0.09684136183724912, 0.12932872951912655, 0.43373173279770905, 0.17046764493539468, 0.3130059163015537, 0.13184160094924535, 0.254236844276709, 0.16878943361632914, 0.3761995719929262, 0.38212862643075385, 0.3745592616057536, 0.47580751478531524, 0.39982074971453996, 0.37346754433374185, 0.36476882661727894, 0.3520390451042773, 0.40903193060901644, 0.7512928414878763, 0.7614529959825274, 0.7429856999658786, 0.741067618910772, 0.7150444474326443, 0.7293042711729166, 0.7775520406839811, 0.7489544912375024, 0.7549546810165869, 0.0934553733885004, 0.09313745067922297, 0.10272791578735874, 0.112902735003238, 0.10907332041525752, 0.1153298063902628, 0.10391315637104015, 0.11340433902287861, 0.11880746272530018, 0.1607338943173403, 0.16871268693929542, 0.130232388148676, 0.17086872191742875, 0.1484118286798648, 0.19734467532097, 0.23623129487000083, 0.1923246960161238, 0.213011682823123, 0.5314483897853208, 0.510207483724002, 0.5127383529696892, 0.5437790419153945, 0.48681940498207776, 0.49444034425038796, 0.490139733479971, 0.5494538920220959, 0.5582908857483818, 0.37992617387853633, 0.3747720479359886, 0.37798953990001016, 0.37812840302619255, 0.3876867972669581, 0.3892631825488613, 0.41580851482101866, 0.4436397429923401, 0.4406696780078241, 0.1932944651600964, 0.20546037343372137, 0.20070554747303337, 0.21934740860948365, 0.1780824122346778, 0.19363479233394176, 0.19514918283322724, 0.17822315906972286, 0.19689977440258766, 0.19458116639495937, 0.28925490554681077, 0.3316911003641225, 0.189761377757526, 0.20178421644862332, 0.3462611984356345, 0.20876469262181763, 0.447229377523386, 0.21762325062110333, 0.19495289627546097, 0.20140799991768554, 0.773799507670992, 0.6815823946864488, 0.7530251906976784, 0.6674621384450807, 0.7665864642588639, 0.6149726993874972, 0.7474294645220818, 0.7711141965083264, 0.1973688496458147, 0.6895622630574595, 0.1643038061457992, 0.7664857587456637, 0.1835138056208937, 0.7104289649647325, 0.12558537876061604, 0.20781891841201516, 0.1848049134907016, 0.2011079844482594, 0.18834048477182308, 0.19010716431064767, 0.17842998719565362, 0.19385570922185436, 0.2003776726598071, 0.17846877360694258, 0.1947188360294464, 0.08030521662878709, 0.08969720404797177, 0.07898542812924114, 0.08376890888367339, 0.09486307031074448, 0.08693033039987785, 0.09826582156395669, 0.08251020552375155, 0.08426332704418305]}, "mutation_prompt": null}
{"id": "587c618e-3c4c-4c60-bf69-30003f64993f", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.restart_threshold = 0.05 * self.budget  # Restart threshold\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1)) \n        adaptive_F *= np.exp(-diversity_factor)  # Adaptive learning rate for mutation scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n            if self.eval_count % self.restart_threshold == 0:  # Restart mechanism\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.fitness = np.array([func(ind) for ind in self.population])\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Employ adaptive learning rates for mutation scaling and introduce a restart mechanism for increased exploration.", "configspace": "", "generation": 82, "fitness": 0.29508681000767895, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.7638817012352369, 0.7527224991223342, 0.7696972894087335, 0.7671673562966757, 0.7483072383132612, 0.764565160753209, 0.7780412584273304, 0.7521881088267279, 0.750871571428998, 0.389586406850028, 0.3682887197375052, 0.12216561279678462, 0.2572384900533784, 0.05889174294727817, 0.06805692230178051, 0.2776845655177699, 0.1252417304022514, 0.22196203990906793, 0.11751429489389353, 0.12005313643617643, 0.1198809655089974, 0.15570069033744727, 0.13063099421340363, 0.11523421389089672, 0.1043755483079698, 0.28745920981542894, 0.11184552561869254, 0.11646583832465607, 0.1206670973031514, 0.08338479187794201, 0.10206250015574458, 0.10062207680400226, 0.11684006178160455, 0.09771280154468676, 0.1132480377391154, 0.09359309068095523, 0.9449087722449806, 0.9163419448218986, 0.9218351578505763, 0.924630612102886, 0.9695817395148174, 0.8870049889795544, 0.9595148163191146, 0.889189132409289, 0.8992878442506825, 0.48588128733881275, 0.48313348498195363, 0.2999209130383904, 0.41412885153069523, 0.32730527882053106, 0.39506511227501484, 0.39747674589897863, 0.11592008640483731, 0.15804130088807578, 0.855262177276287, 0.6490120981073078, 0.8193670205373695, 0.8616745777746102, 0.8373006704246877, 0.6838394427399743, 0.5718472399233419, 0.6385994890268751, 0.6422557753798668, 0.30803715399041054, 0.4511184238749394, 0.21322073425053045, 0.07295509080222706, 9.999999999998899e-05, 0.0761548346696429, 0.18895020439897225, 0.26180450043949643, 0.2270216542555702, 0.2077158719393557, 0.22546820480784602, 0.1896866324020433, 0.2043101240178964, 0.15870401700838743, 0.20820937181385035, 0.15286535805864054, 0.20019015592230482, 0.19101745985784568, 0.0974995609074395, 0.039730826686916965, 0.02944786869174454, 0.09238752683692741, 0.07747153782062632, 0.14095453939118796, 0.06098365922911453, 0.3618534607763947, 0.005749896178928404, 0.20759143570531924, 0.14766197737650621, 0.392256869379071, 0.08168192083494308, 0.06874958733678982, 0.11322156605789446, 0.3300139324851724, 0.31018270078175425, 0.21359814735638338, 0.07052733914203524, 0.07410027246966622, 0.06261965580503293, 0.08812674394983555, 0.011139371860197977, 0.1493244735014898, 0.14764388352404534, 0.21564903075904107, 0.25784779280750425, 0.28010305730134677, 0.25417126670965395, 0.22674761980938973, 0.044366055361631185, 0.18529411968310272, 0.12685607813060507, 0.12325774396166966, 0.1780510429750355, 0.10123927872989313, 0.6184333077634403, 0.6458307628342776, 0.6516120057487262, 0.6787962075564518, 0.6086284665775827, 0.6153051621218351, 0.6610864381359381, 0.6735040162164849, 0.669983827907462, 0.0995075694148927, 0.09284832652883146, 0.09106315382961094, 0.10756566758524055, 0.09987317608881918, 0.10590787436685756, 0.06618561287184144, 0.05759891855755972, 0.07571009261052042, 0.14075337069585325, 0.15162311214658453, 0.1700815957386138, 0.17565435197114954, 0.14466199264818802, 0.14413148150635535, 0.13183966699978877, 0.1563605715930213, 0.12802393956097968, 0.362357830021676, 0.3492889838138161, 0.3557252062966171, 0.42275483543032655, 0.3924830864081379, 0.41626839627521117, 0.42644559148336647, 0.4334214715556832, 0.4323187306790549, 0.12423890527399584, 0.12549221448955172, 0.18667252165222348, 0.3169254636765074, 0.33356006133482285, 0.27565088838774077, 0.3099057156339874, 0.3323888667736167, 0.2918440403378032, 0.18179675443384258, 0.22111345207241262, 0.21124084614683947, 0.1931217366795135, 0.1880226263264979, 0.21651813962582012, 0.19966695091807285, 0.19240116258897577, 0.20776466551457506, 0.20610604751046369, 0.25763339506539173, 0.1773164606663009, 0.30664497264124235, 0.365592175079559, 0.21257320193700135, 0.26773064625046195, 0.3626417058306398, 0.25344988661999834, 0.1856296306164108, 0.1873273026254545, 0.30562518369819136, 0.167392173276388, 0.27913415522333185, 0.4405911213338838, 0.5600997248057455, 0.21124146289007828, 0.508910966108945, 0.6054950760820421, 0.32904163606289016, 0.5318653034031046, 0.22562966450040356, 0.1892546383637742, 0.19609189731503063, 0.19579735944510845, 0.18219609357202615, 0.16836055581614895, 0.18545827376244906, 0.19553610518913078, 0.21337277335914928, 0.18092595535309386, 0.18267021296620523, 0.18190553110429042, 0.17070528887731728, 0.18171441236171526, 0.18964555429280772, 0.07747022018934335, 0.0729386510956036, 0.07772615351833612, 0.08329920380062106, 0.08324281689406199, 0.07673670136966226, 0.07870931471105613, 0.08296776715837328, 0.08458629225904879]}, "mutation_prompt": null}
{"id": "6238e5bb-3743-4f2e-9dd2-bf55a94fbcd1", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1))  # Fitness diversity-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce adaptive population resizing and fitness diversity-based mutation scaling to balance exploration and exploitation dynamically.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.8098078374659212, 0.8303544630989396, 0.8292693127374776, 0.8325032048588561, 0.8210523580808842, 0.8228125002992775, 0.8077391606653921, 0.823621501653043, 0.8166928099150027, 0.6830402589052041, 0.6896860695424089, 0.6775480084037016, 0.6771778184611419, 0.6669891975217315, 0.6875846354892796, 0.7054709865181725, 0.6946286931696638, 0.6582423831489908, 0.2953625028023491, 0.12261808169509636, 0.36999243546095584, 0.11200509295346839, 0.1117996163852436, 0.19207023311806082, 0.12699336141775475, 0.1389724179756726, 0.1837105904858375, 0.1134614461653013, 0.10536023677987816, 0.13423436664132082, 0.11897767143038906, 0.1317825908234036, 0.10882977814355344, 0.114781618902427, 0.11240222861408278, 0.11873096003570627, 0.8068876940695531, 0.8427753291414396, 0.8365140810817451, 0.8416284632320211, 0.9782562965608698, 0.8233862819776179, 0.9597991083340015, 0.9032262885987301, 0.8991043356528089, 0.5813749670528581, 0.5351545616760298, 0.5507988248747662, 0.4978348296055135, 0.6110214826339933, 0.597700038262455, 0.4235243197439188, 0.5211406242845074, 0.43998900840968813, 0.7619523515810388, 0.8092670658059735, 0.8046651747979717, 0.7860588195036191, 0.8103287093732183, 0.8066337136195466, 0.8103876094591191, 0.8278971600339634, 0.7716187632514498, 0.19386326055208358, 0.1874803920689797, 0.22842743827457723, 0.15990619000259598, 0.2381954154140844, 0.3658320909112306, 0.16967146964961577, 0.24005837092273863, 0.583321019587981, 0.26085590493606237, 0.17334806509753575, 0.2347722691729739, 0.31055766487246206, 0.19206125546437391, 0.2767933420378411, 0.5938469500368919, 0.199532872875807, 0.19893969183150606, 0.5592589782375468, 0.4546878774449792, 0.409204830531415, 0.5580505365860694, 0.5620838188935494, 0.4780864019992024, 0.5528641672710144, 0.5810217510048759, 0.5172919409554523, 0.6559609663053592, 0.6546331670267542, 0.6540957219747419, 0.5967624510633658, 0.6419711685601335, 0.5993174985254999, 0.6118807851519563, 0.6053025006164502, 0.648445471950504, 0.22786027829181732, 0.09684136183724912, 0.12932872951912655, 0.43373173279770905, 0.17046764493539468, 0.3130059163015537, 0.13184160094924535, 0.254236844276709, 0.16878943361632914, 0.3761995719929262, 0.38212862643075385, 0.3745592616057536, 0.47580751478531524, 0.39982074971453996, 0.37346754433374185, 0.36476882661727894, 0.3520390451042773, 0.40903193060901644, 0.7512928414878763, 0.7614529959825274, 0.7429856999658786, 0.741067618910772, 0.7150444474326443, 0.7293042711729166, 0.7775520406839811, 0.7489544912375024, 0.7549546810165869, 0.0934553733885004, 0.09313745067922297, 0.10272791578735874, 0.112902735003238, 0.10907332041525752, 0.1153298063902628, 0.10391315637104015, 0.11340433902287861, 0.11880746272530018, 0.1607338943173403, 0.16871268693929542, 0.130232388148676, 0.17086872191742875, 0.1484118286798648, 0.19734467532097, 0.23623129487000083, 0.1923246960161238, 0.213011682823123, 0.5314483897853208, 0.510207483724002, 0.5127383529696892, 0.5437790419153945, 0.48681940498207776, 0.49444034425038796, 0.490139733479971, 0.5494538920220959, 0.5582908857483818, 0.37992617387853633, 0.3747720479359886, 0.37798953990001016, 0.37812840302619255, 0.3876867972669581, 0.3892631825488613, 0.41580851482101866, 0.4436397429923401, 0.4406696780078241, 0.1932944651600964, 0.20546037343372137, 0.20070554747303337, 0.21934740860948365, 0.1780824122346778, 0.19363479233394176, 0.19514918283322724, 0.17822315906972286, 0.19689977440258766, 0.19458116639495937, 0.28925490554681077, 0.3316911003641225, 0.189761377757526, 0.20178421644862332, 0.3462611984356345, 0.20876469262181763, 0.447229377523386, 0.21762325062110333, 0.19495289627546097, 0.20140799991768554, 0.773799507670992, 0.6815823946864488, 0.7530251906976784, 0.6674621384450807, 0.7665864642588639, 0.6149726993874972, 0.7474294645220818, 0.7711141965083264, 0.1973688496458147, 0.6895622630574595, 0.1643038061457992, 0.7664857587456637, 0.1835138056208937, 0.7104289649647325, 0.12558537876061604, 0.20781891841201516, 0.1848049134907016, 0.2011079844482594, 0.18834048477182308, 0.19010716431064767, 0.17842998719565362, 0.19385570922185436, 0.2003776726598071, 0.17846877360694258, 0.1947188360294464, 0.08030521662878709, 0.08969720404797177, 0.07898542812924114, 0.08376890888367339, 0.09486307031074448, 0.08693033039987785, 0.09826582156395669, 0.08251020552375155, 0.08426332704418305]}, "mutation_prompt": null}
{"id": "b45e996c-8b48-4546-93b0-abcfa0f8b44d", "solution": "import numpy as np\n\nclass ADERMPlusEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        elite_factor = np.min(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1) + elite_factor)  # Elite-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.8, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlusEnhanced", "description": "Enhance adaptive control by introducing elite-based scaling and dynamic crossover probability to improve convergence.", "configspace": "", "generation": 84, "fitness": 0.23093421814479242, "feedback": "The algorithm ADERMPlusEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.5557932292592149, 0.4866042793410509, 0.5192812885592593, 0.5645910024551183, 0.5000785917915986, 0.5426917789783652, 0.5387912680382366, 0.545421833272187, 0.562603868675908, 0.036251383876825805, 0.028528372565541527, 0.07299588039878613, 0.049040494672279, 0.07112937475815595, 0.08820630390670425, 0.062432315102288305, 0.050423274587058975, 0.15565401381567112, 0.1203881080927045, 0.12075996235879305, 0.12056059282430431, 0.14973220702777557, 0.17124690255719455, 0.1111860393920886, 0.12976341393523072, 0.10204396926085624, 0.1585986306270748, 0.09214013266199961, 0.08192761093154055, 0.0792050448620708, 0.15282336996497903, 0.10649402434321076, 0.12620207805258088, 0.11718656131845784, 0.09500548887278837, 0.09476473072680325, 0.9572368937641372, 0.9575671631666632, 0.9317584035119051, 0.9633570462674785, 0.9880075926052758, 0.9457098117450695, 0.9821299601377794, 0.9819978529025973, 0.9614077201654402, 0.29065712281090783, 0.2740697383598464, 0.28209800647287453, 0.25953817901857323, 0.2555214332994905, 0.2775355902507731, 0.23505905684240702, 0.26347986275407054, 0.24346841641203454, 0.2595289952640747, 0.2678438923852787, 0.5223442782783283, 0.5025630506164653, 0.40485793563799677, 0.46526917247658317, 0.507351466105717, 0.5822695931524507, 0.4985272436406355, 0.21557784440505057, 0.17434920203128768, 0.1921858545061792, 0.06729663175173461, 0.03675723421714605, 0.07435322655001442, 0.230576217317506, 0.21428302814223288, 0.2114774282187778, 0.18580090078753497, 0.1847865417843949, 0.13937184637000044, 0.25566377842038845, 0.2243467299373606, 0.1866324811905381, 0.21634892753615387, 0.1976723104479503, 0.234568501435915, 0.07627225811644334, 0.09630163702538452, 0.07848037073938507, 0.1900038684276094, 0.1773151688619964, 0.19059886766476097, 0.021442672148295205, 0.06397318879126557, 0.061372893171931175, 0.302717745792651, 0.27895859333581285, 0.2804354050820326, 0.12821755774854882, 0.09040167062617288, 0.101895139049623, 0.2928544271980257, 0.3243062480246218, 0.3332950731415424, 9.999999999998899e-05, 0.013810030000246498, 0.003033798434099344, 0.06323134095644722, 0.049807391738858287, 0.03255150158138853, 0.1447049573821403, 0.11535273232933285, 0.09996260714019334, 0.15169960637394342, 0.1288849836351792, 0.1358409248869642, 0.08146532920421634, 0.04385450258728141, 0.056178048296964156, 0.00780212731867902, 0.002414857318716712, 0.03332514402308773, 0.3773011973229099, 0.3900794729819792, 0.4201314059956863, 0.3910266532870509, 0.41378576271570455, 0.40206635141541425, 0.3962289572642044, 0.40832316738902974, 0.3855311988021014, 0.08087524970286886, 0.07852686204296389, 0.11165385099961145, 0.0912108974921303, 0.09009617569225703, 0.12812742421815115, 0.06267435155444545, 0.05312170175131936, 0.0588277106034224, 0.17765778133870003, 0.183829419779727, 0.13312614483996787, 0.14916882169761014, 0.15738930783234284, 0.2762094229679183, 0.255895297611632, 0.21874119760864041, 0.13199648245502194, 0.19411375847602608, 0.1968876921245435, 0.22114348699860087, 0.23581975955821477, 0.24306489741387938, 0.22234971622974276, 0.2640027841177083, 0.2687403220445158, 0.2680377744004525, 0.1135459482979555, 0.11382785088937086, 0.10805630380262132, 0.19548149801957937, 0.17978090705098826, 0.1832310155908996, 0.18967023439050257, 0.1897362885206434, 0.1809754021322143, 0.19750259629706834, 0.17178281705836218, 0.18301450459526059, 0.17568137140075957, 0.1730474630709561, 0.16220566471589737, 0.16535917351832907, 0.1878854825061288, 0.19859608119196537, 0.15503828404757347, 0.1633968395871862, 0.15709406143349025, 0.17562108425951906, 0.19231164772707288, 0.17760242887187183, 0.18747247806380085, 0.20884732235302095, 0.19295820542371622, 0.1872980355009236, 0.18206225198146286, 0.1590215714049067, 0.18975590630132755, 0.20446708005425862, 0.18089052849700327, 0.35537365409481314, 0.4533974425072169, 0.3723408110087604, 0.31114025983424276, 0.376962083834105, 0.3470385389744819, 0.22534733611759294, 0.33216802430008596, 0.2074572875432109, 0.18513439593029557, 0.1962105384661036, 0.18900616688348937, 0.17665763409108348, 0.18355941585702662, 0.18805400435198483, 0.1699686521832895, 0.18239990338344836, 0.18625973990785893, 0.21401408905693464, 0.20932570541256978, 0.19710665426511587, 0.0658878697627342, 0.06581604242371086, 0.05667197450988137, 0.06586393055790773, 0.05955136020160279, 0.06941934972444264, 0.06934567771152511, 0.0723286236529801, 0.06038891232997157]}, "mutation_prompt": null}
{"id": "9c5d3919-3bbd-4539-9095-7d413e74f06b", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.learning_rate = 0.1  # Adaptive learning rate\n        self.convergence_speed = 0.05  # New convergence speed factor\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1))  # Fitness diversity-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def _update_learning_rate(self):\n        if self.eval_count > self.budget / 2:\n            self.learning_rate = max(0.05, self.learning_rate * self.convergence_speed)\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            self._update_learning_rate()  # Update learning rate adaptively\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Integrate adaptive learning rates and a convergence speed factor to improve dynamic exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.41727280975521985, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.8098078374659212, 0.8303544630989396, 0.8292693127374776, 0.8325032048588561, 0.8210523580808842, 0.8228125002992775, 0.8077391606653921, 0.823621501653043, 0.8166928099150027, 0.6830402589052041, 0.6896860695424089, 0.6775480084037016, 0.6771778184611419, 0.6669891975217315, 0.6875846354892796, 0.7054709865181725, 0.6946286931696638, 0.6582423831489908, 0.2953625028023491, 0.12261808169509636, 0.36999243546095584, 0.11200509295346839, 0.1117996163852436, 0.19207023311806082, 0.12699336141775475, 0.1389724179756726, 0.1837105904858375, 0.1134614461653013, 0.10536023677987816, 0.13423436664132082, 0.11897767143038906, 0.1317825908234036, 0.10882977814355344, 0.114781618902427, 0.11240222861408278, 0.11873096003570627, 0.8068876940695531, 0.8427753291414396, 0.8365140810817451, 0.8416284632320211, 0.9782562965608698, 0.8233862819776179, 0.9597991083340015, 0.9032262885987301, 0.8991043356528089, 0.5813749670528581, 0.5351545616760298, 0.5507988248747662, 0.4978348296055135, 0.6110214826339933, 0.597700038262455, 0.4235243197439188, 0.5211406242845074, 0.43998900840968813, 0.7619523515810388, 0.8092670658059735, 0.8046651747979717, 0.7860588195036191, 0.8103287093732183, 0.8066337136195466, 0.8103876094591191, 0.8278971600339634, 0.7716187632514498, 0.19386326055208358, 0.1874803920689797, 0.22842743827457723, 0.15990619000259598, 0.2381954154140844, 0.3658320909112306, 0.16967146964961577, 0.24005837092273863, 0.583321019587981, 0.26085590493606237, 0.17334806509753575, 0.2347722691729739, 0.31055766487246206, 0.19206125546437391, 0.2767933420378411, 0.5938469500368919, 0.199532872875807, 0.19893969183150606, 0.5592589782375468, 0.4546878774449792, 0.409204830531415, 0.5580505365860694, 0.5620838188935494, 0.4780864019992024, 0.5528641672710144, 0.5810217510048759, 0.5172919409554523, 0.6559609663053592, 0.6546331670267542, 0.6540957219747419, 0.5967624510633658, 0.6419711685601335, 0.5993174985254999, 0.6118807851519563, 0.6053025006164502, 0.648445471950504, 0.22786027829181732, 0.09684136183724912, 0.12932872951912655, 0.43373173279770905, 0.17046764493539468, 0.3130059163015537, 0.13184160094924535, 0.254236844276709, 0.16878943361632914, 0.3761995719929262, 0.38212862643075385, 0.3745592616057536, 0.47580751478531524, 0.39982074971453996, 0.37346754433374185, 0.36476882661727894, 0.3520390451042773, 0.40903193060901644, 0.7512928414878763, 0.7614529959825274, 0.7429856999658786, 0.741067618910772, 0.7150444474326443, 0.7293042711729166, 0.7775520406839811, 0.7489544912375024, 0.7549546810165869, 0.0934553733885004, 0.09313745067922297, 0.10272791578735874, 0.112902735003238, 0.10907332041525752, 0.1153298063902628, 0.10391315637104015, 0.11340433902287861, 0.11880746272530018, 0.1607338943173403, 0.16871268693929542, 0.130232388148676, 0.17086872191742875, 0.1484118286798648, 0.19734467532097, 0.23623129487000083, 0.1923246960161238, 0.213011682823123, 0.5314483897853208, 0.510207483724002, 0.5127383529696892, 0.5437790419153945, 0.48681940498207776, 0.49444034425038796, 0.490139733479971, 0.5494538920220959, 0.5582908857483818, 0.37992617387853633, 0.3747720479359886, 0.37798953990001016, 0.37812840302619255, 0.3876867972669581, 0.3892631825488613, 0.41580851482101866, 0.4436397429923401, 0.4406696780078241, 0.1932944651600964, 0.20546037343372137, 0.20070554747303337, 0.21934740860948365, 0.1780824122346778, 0.19363479233394176, 0.19514918283322724, 0.17822315906972286, 0.19689977440258766, 0.19458116639495937, 0.28925490554681077, 0.3316911003641225, 0.189761377757526, 0.20178421644862332, 0.3462611984356345, 0.20876469262181763, 0.447229377523386, 0.21762325062110333, 0.19495289627546097, 0.20140799991768554, 0.773799507670992, 0.6815823946864488, 0.7530251906976784, 0.6674621384450807, 0.7665864642588639, 0.6149726993874972, 0.7474294645220818, 0.7711141965083264, 0.1973688496458147, 0.6895622630574595, 0.1643038061457992, 0.7664857587456637, 0.1835138056208937, 0.7104289649647325, 0.12558537876061604, 0.20781891841201516, 0.1848049134907016, 0.2011079844482594, 0.18834048477182308, 0.19010716431064767, 0.17842998719565362, 0.19385570922185436, 0.2003776726598071, 0.17846877360694258, 0.1947188360294464, 0.08030521662878709, 0.08969720404797177, 0.07898542812924114, 0.08376890888367339, 0.09486307031074448, 0.08693033039987785, 0.09826582156395669, 0.08251020552375155, 0.08426332704418305]}, "mutation_prompt": null}
{"id": "81606538-c5de-470c-8775-25af426c4941", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1))  # Fitness diversity-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        # Local search enhancement\n        local_step = diversity_factor * np.random.uniform(-0.01, 0.01, self.dim)\n        mutant += local_step\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance exploitation by integrating a local search mechanism with adaptive step size to the mutation process.", "configspace": "", "generation": 86, "fitness": 0.3800908977401907, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.8189485136212831, 0.8243056156087114, 0.8334192756416414, 0.8236578816113985, 0.8312188693858924, 0.808313295530363, 0.8169697220486287, 0.822314902622562, 0.8228993053715888, 0.5137431853097096, 0.4090233254324267, 0.6219024482334435, 0.06035275055575007, 0.42444779752200645, 0.3375177302233183, 0.42452750261448924, 0.42142540241489757, 0.5048619834550414, 0.23649166082800044, 0.1708794302914084, 0.13914490914741962, 0.244762459811375, 0.2850859250157036, 0.19712464084972403, 0.1588110230022769, 0.24109246785959026, 0.15523792431399142, 0.13331495535651539, 0.10867779134059474, 0.13178603438310188, 0.1099973877724304, 0.11236698640061749, 0.13120003487212106, 0.11574862565473465, 0.10511223964682015, 0.13583781449991006, 0.8406517181612675, 0.9031252900501646, 0.875295348320289, 0.8709124590695384, 0.9142236768595107, 0.9174551575855895, 0.787181533717051, 0.9510473219425266, 0.9248604140609888, 0.4343150336450966, 0.5122945942323889, 0.5805314533140755, 0.5329734459567259, 0.5687246207801252, 0.5663420676660103, 0.46396727655195713, 0.6037564129319388, 0.5212643396315637, 0.8103944452667124, 0.7923962311010542, 0.8169133767307439, 0.8180531964038716, 0.7972776793393247, 0.8244822129188228, 0.818919049254323, 0.7953022301855157, 0.7865824642861359, 0.3131882935931498, 0.2027120189081173, 0.17969171036853038, 0.20006019278073162, 0.10950568714266407, 0.2549469062852401, 0.29605429079923473, 0.5782685931283233, 0.22417163410905183, 0.12223052570077975, 0.16769474881431579, 0.12973878922884918, 0.16647521737952609, 0.46378556139656657, 0.22090724814278828, 0.3079697868297029, 0.21851175388917066, 0.1952028482925442, 0.08865346791382012, 0.08236937447228687, 0.09106096931283769, 0.4164349225490317, 0.5573282643896118, 0.49812845959320096, 0.5188602194180932, 0.014537535587294204, 0.0627451610103299, 0.5429679679418897, 0.6360775043922999, 0.6285008394499648, 0.2645190391504232, 0.35442031448399836, 0.3428900870449698, 0.6580260905545956, 0.6440472521609855, 0.6332115440919164, 0.05445060556750758, 0.07859410508111542, 0.02177648390450726, 0.02739701212875989, 0.04570464108100136, 0.035437747267247355, 0.11407871121134283, 0.15841346045296578, 0.14796343624267405, 0.42051973314357105, 0.3671670517424339, 0.44630124875631383, 0.42114147355890863, 0.1893368193002195, 0.20835636887219677, 0.34607997472715046, 0.28404856613379836, 0.4760103556326264, 0.7449884864376253, 0.7385301569781431, 0.7440881429237611, 0.7418903469682299, 0.68019068337306, 0.7416592635564049, 0.743267713794021, 0.7626156302217146, 0.7355189342923565, 0.11568949516080718, 0.11936783799989747, 0.09803135091504755, 0.1214878984484099, 0.09587798474282294, 0.12800109982990016, 0.09402415952668908, 0.09578538136202441, 0.11650117120158432, 0.194121837323727, 0.138709041605803, 0.14754180549317952, 0.13516086559506735, 0.13782092842520577, 0.14439826310149784, 0.14126101213082298, 0.13885633240699513, 0.18659025265518892, 0.4934481717710334, 0.5337311025512315, 0.5480069128632556, 0.48016850178871917, 0.503480410101218, 0.5309926534228853, 0.529851078939735, 0.5439901912675995, 0.5401098779425402, 0.38204932214853615, 0.3745060421575921, 0.35220072757893217, 0.37187973722291157, 0.41312115199220667, 0.36736947674939724, 0.40066051817501347, 0.4180829071421577, 0.41580525678178903, 0.19135300309971792, 0.21565913245415436, 0.18882397124364136, 0.20295900768532948, 0.1975038070184001, 0.2114418683447168, 0.19100161508496583, 0.2578643883130116, 0.2168067275175264, 0.28607535695498487, 0.2786550126978574, 0.3586198795356641, 0.22805398130763632, 0.39084862009799326, 0.43556608095666227, 0.3280711484544283, 0.20973874504292989, 0.42535931989616127, 0.777428056647123, 0.18045121279502074, 0.6359983819441035, 0.7182382987539726, 0.6548130109819441, 0.18846649920096992, 0.7472214903246651, 0.5465181956779888, 0.16122761073490488, 0.7292041658573698, 0.799223075830925, 0.203814297084969, 0.19802790696170336, 0.20332179159955444, 0.1986964534793968, 0.7797536411833355, 0.3097247408335202, 0.20675405823113802, 0.20645126500100464, 0.1805339697885181, 0.19414644904093592, 0.1953318999146516, 0.241183426320548, 0.17702356801514796, 0.210385163110421, 0.1959864450417591, 0.1928796893946142, 0.09160705706017602, 0.07826030394646755, 0.09837171887231433, 0.08774606756093528, 0.0823172884485528, 0.08385044686892851, 0.08650733238866104, 0.08442998990558337, 0.087469676982881]}, "mutation_prompt": null}
{"id": "ba145891-e709-46cd-a166-eb90086aaf26", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n        self.success_history = []\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        novelty_factor = np.std(self.population, axis=0).mean()  # Novelty-driven factor\n        adaptive_F = self.F * (1 + novelty_factor * np.random.uniform(-0.1, 0.1))\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        success_rate = np.mean(self.success_history) if self.success_history else 0.5\n        adaptive_CR = self.CR * success_rate  # Adaptive based on historical success\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n                    success = trial_fitness < self.fitness[i]\n                    self.success_history.append(success)\n\n                    if success:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Enhance exploration by introducing a novelty-driven mutation factor and adaptive crossover strategy based on historical success.", "configspace": "", "generation": 87, "fitness": 0.2693058116283585, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.7637473939029873, 0.7694907430595571, 0.7737619979721186, 0.7856062364308205, 0.7889368748294074, 0.7895878606085385, 0.7783284894418274, 0.7865785807524007, 0.7832811295036542, 0.6148707382766038, 0.6096490298395776, 0.642440192525017, 0.5984992762569228, 0.6410796558468355, 0.6154126822298549, 0.6164088211115126, 0.6178787141828186, 0.6182474699780004, 0.515154842325726, 0.5239158153511725, 0.5336239097494415, 0.5210516571037143, 0.5351067076717437, 0.5288670003021602, 0.5400627271473945, 0.5420976628572357, 0.5417289976271618, 0.48914928450067796, 0.48642989818880356, 0.5051107054915869, 0.49785397612633864, 0.48711455988631414, 0.45032613032054225, 0.47020091183619706, 0.47988133818919587, 0.5049116984196425, 0.9600443825150478, 0.9351742143905378, 0.9236012609594222, 0.948364759225742, 0.9526311272318224, 0.915192666203909, 0.9409631071613069, 0.951595384986446, 0.9231601449953235, 0.19841094043281715, 0.21222403245434085, 0.2116333663003671, 0.2383079348166427, 0.23517398747296892, 0.2124488135960173, 0.1902920291104392, 0.18129721660707943, 0.19509403392134284, 0.16888479616016217, 0.1370560798243189, 0.15180872118092503, 0.256350105669642, 0.2730010345030499, 0.21325099417703508, 0.21248240183265565, 0.20635271710919456, 0.2054991120869999, 0.1725440297267229, 0.17702679744784322, 0.16609180131665124, 0.16146600909700304, 0.1770189117739599, 0.19553764075470093, 0.15313321783517475, 0.17485342569266993, 0.16112760036702334, 0.12861518161172336, 0.1289813141894992, 0.15731506701176967, 0.15707498999054892, 0.1422290832157167, 0.12901713159501327, 0.12077184090959747, 0.12550846172272467, 0.1329889400057569, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0717704517789658, 0.08395184364103858, 0.06444996554596949, 0.09346865254238113, 0.05536224093413511, 0.041930680891112515, 0.0768345199333389, 0.053898297248988314, 0.07296578638566376, 9.999999999998899e-05, 9.999999999998899e-05, 0.0028208275136044625, 0.007235038782135383, 0.02277911673188504, 0.020154445095382445, 9.999999999998899e-05, 0.008841251868790256, 0.0002535859401874285, 0.08012689458794375, 0.07553739395094705, 0.08309446713098823, 0.08651457997347045, 0.0806185892872916, 0.0910996363270069, 0.10994433622636446, 0.08506479428804792, 0.08467482211152022, 0.4393291120022632, 0.4374779577169823, 0.43772957257605694, 0.4198961448522618, 0.4132400417831201, 0.4378664758444478, 0.4415557212562168, 0.44180207986298825, 0.46812675680598903, 0.1004379900952912, 0.09853395416836408, 0.09356248713450244, 0.09485798390617983, 0.08982595655750647, 0.10572869959712772, 0.09607586671971946, 0.10250551140336939, 0.10557109887956972, 0.150181124690692, 0.1712161172774166, 0.1595660965353789, 0.15140874516580094, 0.17318551953254557, 0.15758859315775675, 0.13892448161585924, 0.14463335625314921, 0.15076194368752271, 0.21011837658633425, 0.22520298649789838, 0.22404675753031678, 0.21719385711301953, 0.22054928371460913, 0.23680984973118935, 0.24184872134061597, 0.2561401341879772, 0.223471988442417, 0.16328143268634554, 0.1600984739787591, 0.1684399098228474, 0.16756576938516643, 0.15427625900744546, 0.16409566955416954, 0.19526423586363928, 0.1680186104496475, 0.14836759402848698, 0.19675425750012465, 0.1957319000095985, 0.19207809008545895, 0.19252333053582693, 0.2240743816755587, 0.21831089267745474, 0.19961063349757235, 0.19158292741936478, 0.21811175943555605, 0.21155793006853574, 0.20430605645202427, 0.20291448589459637, 0.21065652340094887, 0.22120296631808356, 0.22250559165404016, 0.24115385091223585, 0.25574286624989506, 0.22665973963106456, 0.16550591894764421, 0.175588448332901, 0.2546092828527966, 0.28690889911395556, 0.25308033383903705, 0.2826949702917595, 0.200960744898112, 0.1521671272824231, 0.27127741437248365, 0.20379087352919245, 0.23520828316497766, 0.246684943769504, 0.20498464377735104, 0.29175513177412127, 0.20984665862423257, 0.17691747961142323, 0.2202276189608613, 0.24962042712299737, 0.19227888767357093, 0.17163299422166545, 0.19792791777526486, 0.18122660094041887, 0.18633054302266316, 0.20417083057101792, 0.1931658278932492, 0.17514271514006907, 0.20765353109646756, 0.07488281559690457, 0.0757276986674027, 0.0758732703604339, 0.07651043683631686, 0.07513089084983549, 0.07263177135663823, 0.07418845825238751, 0.06591864699062522, 0.0833920540475015]}, "mutation_prompt": null}
{"id": "e52e581d-defd-41a5-8d05-d1497b4339b0", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1))  # Fitness diversity-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce adaptive population resizing and fitness diversity-based mutation scaling to balance exploration and exploitation dynamically.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.8098078374659212, 0.8303544630989396, 0.8292693127374776, 0.8325032048588561, 0.8210523580808842, 0.8228125002992775, 0.8077391606653921, 0.823621501653043, 0.8166928099150027, 0.6830402589052041, 0.6896860695424089, 0.6775480084037016, 0.6771778184611419, 0.6669891975217315, 0.6875846354892796, 0.7054709865181725, 0.6946286931696638, 0.6582423831489908, 0.2953625028023491, 0.12261808169509636, 0.36999243546095584, 0.11200509295346839, 0.1117996163852436, 0.19207023311806082, 0.12699336141775475, 0.1389724179756726, 0.1837105904858375, 0.1134614461653013, 0.10536023677987816, 0.13423436664132082, 0.11897767143038906, 0.1317825908234036, 0.10882977814355344, 0.114781618902427, 0.11240222861408278, 0.11873096003570627, 0.8068876940695531, 0.8427753291414396, 0.8365140810817451, 0.8416284632320211, 0.9782562965608698, 0.8233862819776179, 0.9597991083340015, 0.9032262885987301, 0.8991043356528089, 0.5813749670528581, 0.5351545616760298, 0.5507988248747662, 0.4978348296055135, 0.6110214826339933, 0.597700038262455, 0.4235243197439188, 0.5211406242845074, 0.43998900840968813, 0.7619523515810388, 0.8092670658059735, 0.8046651747979717, 0.7860588195036191, 0.8103287093732183, 0.8066337136195466, 0.8103876094591191, 0.8278971600339634, 0.7716187632514498, 0.19386326055208358, 0.1874803920689797, 0.22842743827457723, 0.15990619000259598, 0.2381954154140844, 0.3658320909112306, 0.16967146964961577, 0.24005837092273863, 0.583321019587981, 0.26085590493606237, 0.17334806509753575, 0.2347722691729739, 0.31055766487246206, 0.19206125546437391, 0.2767933420378411, 0.5938469500368919, 0.199532872875807, 0.19893969183150606, 0.5592589782375468, 0.4546878774449792, 0.409204830531415, 0.5580505365860694, 0.5620838188935494, 0.4780864019992024, 0.5528641672710144, 0.5810217510048759, 0.5172919409554523, 0.6559609663053592, 0.6546331670267542, 0.6540957219747419, 0.5967624510633658, 0.6419711685601335, 0.5993174985254999, 0.6118807851519563, 0.6053025006164502, 0.648445471950504, 0.22786027829181732, 0.09684136183724912, 0.12932872951912655, 0.43373173279770905, 0.17046764493539468, 0.3130059163015537, 0.13184160094924535, 0.254236844276709, 0.16878943361632914, 0.3761995719929262, 0.38212862643075385, 0.3745592616057536, 0.47580751478531524, 0.39982074971453996, 0.37346754433374185, 0.36476882661727894, 0.3520390451042773, 0.40903193060901644, 0.7512928414878763, 0.7614529959825274, 0.7429856999658786, 0.741067618910772, 0.7150444474326443, 0.7293042711729166, 0.7775520406839811, 0.7489544912375024, 0.7549546810165869, 0.0934553733885004, 0.09313745067922297, 0.10272791578735874, 0.112902735003238, 0.10907332041525752, 0.1153298063902628, 0.10391315637104015, 0.11340433902287861, 0.11880746272530018, 0.1607338943173403, 0.16871268693929542, 0.130232388148676, 0.17086872191742875, 0.1484118286798648, 0.19734467532097, 0.23623129487000083, 0.1923246960161238, 0.213011682823123, 0.5314483897853208, 0.510207483724002, 0.5127383529696892, 0.5437790419153945, 0.48681940498207776, 0.49444034425038796, 0.490139733479971, 0.5494538920220959, 0.5582908857483818, 0.37992617387853633, 0.3747720479359886, 0.37798953990001016, 0.37812840302619255, 0.3876867972669581, 0.3892631825488613, 0.41580851482101866, 0.4436397429923401, 0.4406696780078241, 0.1932944651600964, 0.20546037343372137, 0.20070554747303337, 0.21934740860948365, 0.1780824122346778, 0.19363479233394176, 0.19514918283322724, 0.17822315906972286, 0.19689977440258766, 0.19458116639495937, 0.28925490554681077, 0.3316911003641225, 0.189761377757526, 0.20178421644862332, 0.3462611984356345, 0.20876469262181763, 0.447229377523386, 0.21762325062110333, 0.19495289627546097, 0.20140799991768554, 0.773799507670992, 0.6815823946864488, 0.7530251906976784, 0.6674621384450807, 0.7665864642588639, 0.6149726993874972, 0.7474294645220818, 0.7711141965083264, 0.1973688496458147, 0.6895622630574595, 0.1643038061457992, 0.7664857587456637, 0.1835138056208937, 0.7104289649647325, 0.12558537876061604, 0.20781891841201516, 0.1848049134907016, 0.2011079844482594, 0.18834048477182308, 0.19010716431064767, 0.17842998719565362, 0.19385570922185436, 0.2003776726598071, 0.17846877360694258, 0.1947188360294464, 0.08030521662878709, 0.08969720404797177, 0.07898542812924114, 0.08376890888367339, 0.09486307031074448, 0.08693033039987785, 0.09826582156395669, 0.08251020552375155, 0.08426332704418305]}, "mutation_prompt": null}
{"id": "b11031dc-adb7-426f-97b1-ceeb627494f4", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        fitness_ranking = np.argsort(self.fitness)\n        rank_factor = (self.population_size - np.where(fitness_ranking == idx)[0][0]) / self.population_size\n        adaptive_F = self.F * (1 + rank_factor * np.random.uniform(-0.1, 0.1))  # Fitness ranking-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Incorporate a dynamic mutation strategy based on fitness ranking to enhance adaptability in function landscapes.", "configspace": "", "generation": 89, "fitness": 0.4102102720062003, "feedback": "The algorithm ADERMPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.8238864666454253, 0.8356625296072038, 0.7983026299008609, 0.8077903559449426, 0.8188686548462846, 0.8068994198822564, 0.8175488426426527, 0.8217546062799336, 0.8283275479222215, 0.6738652174858615, 0.6807480556258909, 0.6673517146328226, 0.6838684578645492, 0.6760421133289907, 0.6897550042081717, 0.6755821491155685, 0.6701016598030063, 0.682771099148572, 0.19238956428691267, 0.1392624126108023, 0.22801394034802025, 0.14282635927793708, 0.2792064279288222, 0.1243421100238351, 0.20277343429578443, 0.1376341631932675, 0.2754314629364295, 0.11505313883636259, 0.13292352977128374, 0.1447966974956233, 0.21539522174584647, 0.11173624601044196, 0.13208244692024473, 0.11871312123220834, 0.11265763750265245, 0.11665281024834107, 0.8292067511741542, 0.923776540685697, 0.8213702217078445, 0.9328039568344462, 0.9780920194424959, 0.8610088112725541, 0.9541265647614824, 0.8457940039950012, 0.7721798259806509, 0.5591833163356996, 0.5825311794812984, 0.5170767724727917, 0.5448937722163867, 0.6021810955386508, 0.5494208672806653, 0.5961230886123096, 0.5769955228331733, 0.5646802648296053, 0.8252018996325524, 0.8236836089266942, 0.7831544057179772, 0.8303265737969757, 0.824447266784802, 0.8265319686902973, 0.8138992398017437, 0.8552527283946401, 0.8409564110804446, 0.12618109211517636, 0.5546097199849171, 0.20220195942162467, 0.2094182375069754, 0.21405270501530094, 0.2549469068252448, 0.16334683014028029, 0.18777266671287174, 0.23624180837059772, 0.1471708589198022, 0.18650051979308957, 0.4402692608823543, 0.19295053541592821, 0.19463757824050387, 0.3013790587217442, 0.15720393219608375, 0.1778974283218262, 0.21274322550936808, 0.5536509490636307, 0.5189639317362713, 0.4599587350751534, 0.41684194039410527, 0.5008053335036301, 0.4352035500485242, 0.5272199162789949, 0.5368159907981416, 0.4862999314806956, 0.6203414521758014, 0.672981403466143, 0.5942759268918321, 0.6261968855615772, 0.5636884785296098, 0.6427194848058588, 0.6362351994058548, 0.6478807173698165, 0.6237968708523384, 0.13581469614322872, 0.1997480197449547, 0.19964749809235316, 0.22135012197195159, 0.37610807094959164, 0.3057864646790245, 0.2598160858587305, 0.168078559995533, 0.17987012761571297, 0.372043521861129, 0.32096910811004165, 0.35579873717695165, 0.37693762132088804, 0.4668894895405826, 0.3934729226027257, 0.41794456728553975, 0.3391295046072047, 0.4191708483370652, 0.7263050880786673, 0.742582243850356, 0.7761472634768101, 0.7394374501262455, 0.7493579812568583, 0.7403100482766796, 0.7987383266633439, 0.7326415268203774, 0.7640788006896229, 0.0980251956535374, 0.11478286999448306, 0.10095521475963887, 0.1075939304711323, 0.10866697192148367, 0.11312934657103946, 0.12971255153278793, 0.11139652840925574, 0.09715703941465381, 0.14133632577409483, 0.1507067194313042, 0.20997110344747993, 0.14227506582368843, 0.14393722728986436, 0.19848234828530908, 0.1326182511049101, 0.16841112595380114, 0.19074858108382686, 0.5228068828290358, 0.5205319764829821, 0.4603174237029106, 0.5508207222657278, 0.5474331664615177, 0.49005014416044723, 0.5258734262903635, 0.4647077219178024, 0.5460209734188308, 0.3794473665159409, 0.37825794532184565, 0.41892101696348516, 0.39906958009712334, 0.3777793292765328, 0.3818042953942684, 0.40507813356968136, 0.4363065644751889, 0.4068214027413455, 0.1951848042467602, 0.1972320652139603, 0.1936855539423954, 0.21098567792701484, 0.19281581124647262, 0.18901611217257763, 0.20324585015269414, 0.18730537282076654, 0.18758772126892487, 0.33073312333929894, 0.19709533733484164, 0.38547643446122015, 0.35464177114993545, 0.19581693458888072, 0.2980707310749722, 0.33808908999588694, 0.1989609775801997, 0.19495034614729012, 0.1947403802706018, 0.1816797000539585, 0.8133114344368715, 0.18424547966565785, 0.18465689598099244, 0.19541165875540667, 0.7367615790789293, 0.6343054872390328, 0.7182090134294359, 0.7796875271620112, 0.2001744432708903, 0.7086531146038152, 0.16248721045743952, 0.6284882139413893, 0.735631799551954, 0.20581183915790657, 0.2008361683900719, 0.46942136376874455, 0.17470115849452283, 0.20126120810202952, 0.19262684907490168, 0.19863626092486197, 0.1706507072913499, 0.18127379155564172, 0.1841230776594054, 0.18672430083741032, 0.19188257412725906, 0.07560258567313272, 0.08201180946393305, 0.09209747748008268, 0.09001307149922722, 0.08568221279286758, 0.0810019468896086, 0.07903009866651378, 0.08332414231507779, 0.07992234331000969]}, "mutation_prompt": null}
{"id": "d58d4786-85e0-47a8-901a-7383eba13da8", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1))  # Fitness diversity-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce adaptive population resizing and fitness diversity-based mutation scaling to balance exploration and exploitation dynamically.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.8098078374659212, 0.8303544630989396, 0.8292693127374776, 0.8325032048588561, 0.8210523580808842, 0.8228125002992775, 0.8077391606653921, 0.823621501653043, 0.8166928099150027, 0.6830402589052041, 0.6896860695424089, 0.6775480084037016, 0.6771778184611419, 0.6669891975217315, 0.6875846354892796, 0.7054709865181725, 0.6946286931696638, 0.6582423831489908, 0.2953625028023491, 0.12261808169509636, 0.36999243546095584, 0.11200509295346839, 0.1117996163852436, 0.19207023311806082, 0.12699336141775475, 0.1389724179756726, 0.1837105904858375, 0.1134614461653013, 0.10536023677987816, 0.13423436664132082, 0.11897767143038906, 0.1317825908234036, 0.10882977814355344, 0.114781618902427, 0.11240222861408278, 0.11873096003570627, 0.8068876940695531, 0.8427753291414396, 0.8365140810817451, 0.8416284632320211, 0.9782562965608698, 0.8233862819776179, 0.9597991083340015, 0.9032262885987301, 0.8991043356528089, 0.5813749670528581, 0.5351545616760298, 0.5507988248747662, 0.4978348296055135, 0.6110214826339933, 0.597700038262455, 0.4235243197439188, 0.5211406242845074, 0.43998900840968813, 0.7619523515810388, 0.8092670658059735, 0.8046651747979717, 0.7860588195036191, 0.8103287093732183, 0.8066337136195466, 0.8103876094591191, 0.8278971600339634, 0.7716187632514498, 0.19386326055208358, 0.1874803920689797, 0.22842743827457723, 0.15990619000259598, 0.2381954154140844, 0.3658320909112306, 0.16967146964961577, 0.24005837092273863, 0.583321019587981, 0.26085590493606237, 0.17334806509753575, 0.2347722691729739, 0.31055766487246206, 0.19206125546437391, 0.2767933420378411, 0.5938469500368919, 0.199532872875807, 0.19893969183150606, 0.5592589782375468, 0.4546878774449792, 0.409204830531415, 0.5580505365860694, 0.5620838188935494, 0.4780864019992024, 0.5528641672710144, 0.5810217510048759, 0.5172919409554523, 0.6559609663053592, 0.6546331670267542, 0.6540957219747419, 0.5967624510633658, 0.6419711685601335, 0.5993174985254999, 0.6118807851519563, 0.6053025006164502, 0.648445471950504, 0.22786027829181732, 0.09684136183724912, 0.12932872951912655, 0.43373173279770905, 0.17046764493539468, 0.3130059163015537, 0.13184160094924535, 0.254236844276709, 0.16878943361632914, 0.3761995719929262, 0.38212862643075385, 0.3745592616057536, 0.47580751478531524, 0.39982074971453996, 0.37346754433374185, 0.36476882661727894, 0.3520390451042773, 0.40903193060901644, 0.7512928414878763, 0.7614529959825274, 0.7429856999658786, 0.741067618910772, 0.7150444474326443, 0.7293042711729166, 0.7775520406839811, 0.7489544912375024, 0.7549546810165869, 0.0934553733885004, 0.09313745067922297, 0.10272791578735874, 0.112902735003238, 0.10907332041525752, 0.1153298063902628, 0.10391315637104015, 0.11340433902287861, 0.11880746272530018, 0.1607338943173403, 0.16871268693929542, 0.130232388148676, 0.17086872191742875, 0.1484118286798648, 0.19734467532097, 0.23623129487000083, 0.1923246960161238, 0.213011682823123, 0.5314483897853208, 0.510207483724002, 0.5127383529696892, 0.5437790419153945, 0.48681940498207776, 0.49444034425038796, 0.490139733479971, 0.5494538920220959, 0.5582908857483818, 0.37992617387853633, 0.3747720479359886, 0.37798953990001016, 0.37812840302619255, 0.3876867972669581, 0.3892631825488613, 0.41580851482101866, 0.4436397429923401, 0.4406696780078241, 0.1932944651600964, 0.20546037343372137, 0.20070554747303337, 0.21934740860948365, 0.1780824122346778, 0.19363479233394176, 0.19514918283322724, 0.17822315906972286, 0.19689977440258766, 0.19458116639495937, 0.28925490554681077, 0.3316911003641225, 0.189761377757526, 0.20178421644862332, 0.3462611984356345, 0.20876469262181763, 0.447229377523386, 0.21762325062110333, 0.19495289627546097, 0.20140799991768554, 0.773799507670992, 0.6815823946864488, 0.7530251906976784, 0.6674621384450807, 0.7665864642588639, 0.6149726993874972, 0.7474294645220818, 0.7711141965083264, 0.1973688496458147, 0.6895622630574595, 0.1643038061457992, 0.7664857587456637, 0.1835138056208937, 0.7104289649647325, 0.12558537876061604, 0.20781891841201516, 0.1848049134907016, 0.2011079844482594, 0.18834048477182308, 0.19010716431064767, 0.17842998719565362, 0.19385570922185436, 0.2003776726598071, 0.17846877360694258, 0.1947188360294464, 0.08030521662878709, 0.08969720404797177, 0.07898542812924114, 0.08376890888367339, 0.09486307031074448, 0.08693033039987785, 0.09826582156395669, 0.08251020552375155, 0.08426332704418305]}, "mutation_prompt": null}
{"id": "5b7511ae-1f63-4bd8-b774-2376b33156ff", "solution": "import numpy as np\n\nclass ADERMPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        adaptive_F = self.F * (1 + diversity_factor * np.random.uniform(-0.1, 0.1))  # Fitness diversity-based scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlus", "description": "Introduce adaptive population resizing and fitness diversity-based mutation scaling to balance exploration and exploitation dynamically.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.8098078374659212, 0.8303544630989396, 0.8292693127374776, 0.8325032048588561, 0.8210523580808842, 0.8228125002992775, 0.8077391606653921, 0.823621501653043, 0.8166928099150027, 0.6830402589052041, 0.6896860695424089, 0.6775480084037016, 0.6771778184611419, 0.6669891975217315, 0.6875846354892796, 0.7054709865181725, 0.6946286931696638, 0.6582423831489908, 0.2953625028023491, 0.12261808169509636, 0.36999243546095584, 0.11200509295346839, 0.1117996163852436, 0.19207023311806082, 0.12699336141775475, 0.1389724179756726, 0.1837105904858375, 0.1134614461653013, 0.10536023677987816, 0.13423436664132082, 0.11897767143038906, 0.1317825908234036, 0.10882977814355344, 0.114781618902427, 0.11240222861408278, 0.11873096003570627, 0.8068876940695531, 0.8427753291414396, 0.8365140810817451, 0.8416284632320211, 0.9782562965608698, 0.8233862819776179, 0.9597991083340015, 0.9032262885987301, 0.8991043356528089, 0.5813749670528581, 0.5351545616760298, 0.5507988248747662, 0.4978348296055135, 0.6110214826339933, 0.597700038262455, 0.4235243197439188, 0.5211406242845074, 0.43998900840968813, 0.7619523515810388, 0.8092670658059735, 0.8046651747979717, 0.7860588195036191, 0.8103287093732183, 0.8066337136195466, 0.8103876094591191, 0.8278971600339634, 0.7716187632514498, 0.19386326055208358, 0.1874803920689797, 0.22842743827457723, 0.15990619000259598, 0.2381954154140844, 0.3658320909112306, 0.16967146964961577, 0.24005837092273863, 0.583321019587981, 0.26085590493606237, 0.17334806509753575, 0.2347722691729739, 0.31055766487246206, 0.19206125546437391, 0.2767933420378411, 0.5938469500368919, 0.199532872875807, 0.19893969183150606, 0.5592589782375468, 0.4546878774449792, 0.409204830531415, 0.5580505365860694, 0.5620838188935494, 0.4780864019992024, 0.5528641672710144, 0.5810217510048759, 0.5172919409554523, 0.6559609663053592, 0.6546331670267542, 0.6540957219747419, 0.5967624510633658, 0.6419711685601335, 0.5993174985254999, 0.6118807851519563, 0.6053025006164502, 0.648445471950504, 0.22786027829181732, 0.09684136183724912, 0.12932872951912655, 0.43373173279770905, 0.17046764493539468, 0.3130059163015537, 0.13184160094924535, 0.254236844276709, 0.16878943361632914, 0.3761995719929262, 0.38212862643075385, 0.3745592616057536, 0.47580751478531524, 0.39982074971453996, 0.37346754433374185, 0.36476882661727894, 0.3520390451042773, 0.40903193060901644, 0.7512928414878763, 0.7614529959825274, 0.7429856999658786, 0.741067618910772, 0.7150444474326443, 0.7293042711729166, 0.7775520406839811, 0.7489544912375024, 0.7549546810165869, 0.0934553733885004, 0.09313745067922297, 0.10272791578735874, 0.112902735003238, 0.10907332041525752, 0.1153298063902628, 0.10391315637104015, 0.11340433902287861, 0.11880746272530018, 0.1607338943173403, 0.16871268693929542, 0.130232388148676, 0.17086872191742875, 0.1484118286798648, 0.19734467532097, 0.23623129487000083, 0.1923246960161238, 0.213011682823123, 0.5314483897853208, 0.510207483724002, 0.5127383529696892, 0.5437790419153945, 0.48681940498207776, 0.49444034425038796, 0.490139733479971, 0.5494538920220959, 0.5582908857483818, 0.37992617387853633, 0.3747720479359886, 0.37798953990001016, 0.37812840302619255, 0.3876867972669581, 0.3892631825488613, 0.41580851482101866, 0.4436397429923401, 0.4406696780078241, 0.1932944651600964, 0.20546037343372137, 0.20070554747303337, 0.21934740860948365, 0.1780824122346778, 0.19363479233394176, 0.19514918283322724, 0.17822315906972286, 0.19689977440258766, 0.19458116639495937, 0.28925490554681077, 0.3316911003641225, 0.189761377757526, 0.20178421644862332, 0.3462611984356345, 0.20876469262181763, 0.447229377523386, 0.21762325062110333, 0.19495289627546097, 0.20140799991768554, 0.773799507670992, 0.6815823946864488, 0.7530251906976784, 0.6674621384450807, 0.7665864642588639, 0.6149726993874972, 0.7474294645220818, 0.7711141965083264, 0.1973688496458147, 0.6895622630574595, 0.1643038061457992, 0.7664857587456637, 0.1835138056208937, 0.7104289649647325, 0.12558537876061604, 0.20781891841201516, 0.1848049134907016, 0.2011079844482594, 0.18834048477182308, 0.19010716431064767, 0.17842998719565362, 0.19385570922185436, 0.2003776726598071, 0.17846877360694258, 0.1947188360294464, 0.08030521662878709, 0.08969720404797177, 0.07898542812924114, 0.08376890888367339, 0.09486307031074448, 0.08693033039987785, 0.09826582156395669, 0.08251020552375155, 0.08426332704418305]}, "mutation_prompt": null}
{"id": "6d26d2df-1d21-4a84-80bb-26f81ef6ced2", "solution": "import numpy as np\n\nclass ADERMPlusRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.eval_count = 0\n\n    def _mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        convergence_factor = (self.budget - self.eval_count) / self.budget  # Convergence pace factor\n        adaptive_F = self.F * (1 + diversity_factor * convergence_factor * np.random.uniform(-0.1, 0.1))  # Enhanced scaling\n        mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_range = np.linspace(0.85, 0.95, num=10)\n        adaptive_CR = crossover_range[int((self.budget - self.eval_count) / self.budget * 9)]  # Dynamic crossover tuning\n        crossover = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        dim_scale_factor = np.random.uniform(0.8, 1.2)  # Adaptive dimension scaling\n        scaled_dim = max(1, int(self.dim * dim_scale_factor))\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness)  # Elitism: Preserve the best individual\n            best_individual = self.population[best_idx]\n\n            for i in range(self.population_size):\n                if i != best_idx:  # Skip mutation for the best individual\n                    mutant = self._mutate(i)\n                    trial = self._crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.eval_count += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                    if self.eval_count >= self.budget:\n                        break\n\n            if self.eval_count > self.budget / 2:  # Adaptive population resizing\n                self.population_size = max(int(0.5 * self.initial_population_size), 4)\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx][:scaled_dim]", "name": "ADERMPlusRefined", "description": "Introduce an adaptive mutation strategy based on both fitness diversity and convergence pace to enhance exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.4225037713042671, "feedback": "The algorithm ADERMPlusRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "3ce532ce-5a79-471e-a158-260db813e6ac", "metadata": {"aucs": [0.8231362855887352, 0.8244487449293458, 0.8140072028285428, 0.8290238327000712, 0.8323564915213046, 0.8241095471821717, 0.8080792978667317, 0.8244194010217758, 0.8187013651687424, 0.6856860790064726, 0.6778339790573613, 0.6726945942611902, 0.6676126593975495, 0.6702772965966056, 0.6822481076085761, 0.6823225232908736, 0.7000092637299824, 0.7210109004126716, 0.16213702159780552, 0.3610929672142602, 0.3127398471005506, 0.12542983611335767, 0.15326566506836192, 0.16343283241464746, 0.17853212689395137, 0.15893836782505077, 0.11441631932630825, 0.09900359261178471, 0.13672937988266654, 0.11539527967545038, 0.11833873054172073, 0.12370217316989296, 0.12249644713095875, 0.10455204157208953, 0.1168350054994578, 0.12721149506469065, 0.8347122070569345, 0.8282026084342832, 0.9087090661104954, 0.841655107916557, 0.9782568566610835, 0.8493640824360034, 0.9597988618632576, 0.9036228049445737, 0.8904838787084371, 0.5866784261266661, 0.444282949004405, 0.541493589399872, 0.607706622107751, 0.5572182224308214, 0.5460149387720403, 0.6048600444174915, 0.5587246024006765, 0.5742283682505929, 0.803027917592471, 0.7990318520147517, 0.8302387275766809, 0.8297819817075072, 0.7971386442475598, 0.8433204247022567, 0.8063799923161646, 0.7941533914826316, 0.805303144742569, 0.18009658981008303, 0.22746673662105688, 0.35804410391001995, 0.2673464492508012, 0.25388282706130305, 0.5112963878433927, 0.18189656428863554, 0.2259671464761276, 0.2531544110982451, 0.20380157996771608, 0.23320413618597735, 0.22348135420426118, 0.2336909969052815, 0.2615045021510479, 0.2559958715463543, 0.579062781775747, 0.16827737536887855, 0.2407285627281971, 0.5623763203559234, 0.5129688132403616, 0.5262588775403985, 0.5662322802689879, 0.49384150120944437, 0.5300605567320056, 0.5854691496670166, 0.44518008144990884, 0.525024547449407, 0.6554980750935853, 0.6189191971731924, 0.6467987031774992, 0.6438160050407404, 0.6422175929572577, 0.5370675641645049, 0.6366261288329742, 0.6725633583457014, 0.6507155071050088, 0.17060105750957077, 0.13860641133864005, 0.14350994395067462, 0.292293904595442, 0.2503159435746667, 0.3671046483043625, 0.14118042586910873, 0.24523788390111312, 0.1818759261201096, 0.36810907013533856, 0.36062806687890436, 0.42064928688351466, 0.4540976315581754, 0.4002690924126492, 0.387591468591142, 0.3853828884884333, 0.4603691268301602, 0.34061923771436753, 0.7502078853563192, 0.7406191642185075, 0.7549326960101445, 0.7288286905707526, 0.7350273654712145, 0.7561299492054002, 0.7729550642983658, 0.7559623761545503, 0.748071474045833, 0.3645790804821155, 0.1146932762811419, 0.10153436512671488, 0.10470404623956331, 0.10693243997284352, 0.11960037529042233, 0.11643753748317232, 0.11426079789109278, 0.11872373636671074, 0.14871437928129494, 0.1643677031876698, 0.16116702085787094, 0.15731897447482768, 0.13341811129708325, 0.17180363145128574, 0.1663565556382982, 0.1451348545561899, 0.16818183757211247, 0.49429667424216517, 0.5075513673202916, 0.48694066347485687, 0.5168647757274161, 0.4837524974063909, 0.5442615424818102, 0.49893212438383894, 0.5611910432300338, 0.5239832244533302, 0.38034134323674773, 0.4068391713605174, 0.39371491104245826, 0.35108529185427184, 0.3634587208015352, 0.3906564320571799, 0.4446624392179539, 0.4357448553658021, 0.43451601848438304, 0.1841320278005253, 0.1888783236500915, 0.18387650548349543, 0.1936446882500641, 0.2045807148657871, 0.1841996666177026, 0.21358309419057797, 0.1889304681118812, 0.1943924537732421, 0.2328833235521427, 0.4183872786028012, 0.3993689457581161, 0.28004784511337444, 0.385043338608945, 0.37124077813580825, 0.3813739700708818, 0.3655620445058908, 0.3234234771818195, 0.19493865787868958, 0.1997822485865247, 0.7325051647702192, 0.7569920897320219, 0.7549684557347547, 0.7185861908331576, 0.7685274844345822, 0.6125150215659769, 0.7512708343614961, 0.7631073639340884, 0.1973669437179838, 0.7093032987610015, 0.1643033405835045, 0.767801496755403, 0.18321983882806958, 0.1531480183624222, 0.12560894709190396, 0.20751494755976674, 0.19712653973101324, 0.18531840591148296, 0.19436034734155905, 0.18268837471819355, 0.17603161168114312, 0.2025863438200467, 0.20360132895944605, 0.19838491836114003, 0.1898412024638344, 0.07496958638924078, 0.08077240037021804, 0.08855604809329176, 0.08719884086738616, 0.08727217367555329, 0.07840243233023958, 0.08297358042750635, 0.08393264691519287, 0.07674138102834227]}, "mutation_prompt": null}
