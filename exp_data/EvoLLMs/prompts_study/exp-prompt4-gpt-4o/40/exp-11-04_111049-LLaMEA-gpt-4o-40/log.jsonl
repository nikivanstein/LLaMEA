{"id": "4cc63190-54e1-4c20-a0ed-d2ee84b58eb0", "solution": "import numpy as np\n\nclass ADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2  # Start with a moderate success rate\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + 0.05)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - 0.05)\n\n                self.mutation_factor = 0.5 + 0.5 * self.success_rate\n                self.crossover_rate = 0.9 * self.success_rate\n\n        return self.best_solution", "name": "ADEOptimizer", "description": "Adaptive Differential Evolution with Success-Based Parameter Adaptation for Efficient Global Optimization.", "configspace": "", "generation": 0, "fitness": 0.2476819193964172, "feedback": "The algorithm ADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7392009611730366, 0.7512671002420502, 0.7445460396758353, 0.748846030871073, 0.7452236635689544, 0.7523311172067474, 0.739628343926622, 0.7386643979881814, 0.7482641610321219, 0.5508390511431761, 0.54078331815292, 0.5154331994696084, 0.5362075896103047, 0.5491429252508813, 0.5455012531924386, 0.4863357375666203, 0.5571792348745751, 0.5652725851406667, 0.46127489415486, 0.48216120229969406, 0.5157607333046526, 0.42263399277795644, 0.45440625549182345, 0.49225768820752214, 0.46325198484406105, 0.4792702852618689, 0.487293439905496, 0.3958245731624147, 0.41258235394455034, 0.3844861192170588, 0.3679846212601119, 0.39821228406612896, 0.37565560947953325, 0.39280182328227764, 0.3669237937927431, 0.39652013177346535, 0.9562070152596391, 0.9703155304587913, 0.9764460169899214, 0.9663877587015401, 0.9703114000557636, 0.9605451512290806, 0.9625365051659976, 0.9693468661524668, 0.9707922120300461, 0.1626328929403661, 0.12033168020274765, 0.1491757969591515, 0.1555766337816512, 0.12899927803653422, 0.17353038112619856, 0.1478890346871039, 0.14157489142319812, 0.1184988725600915, 0.12842376283856105, 0.1317525456680787, 0.1377342141057628, 0.1893131809929235, 0.20610651577494088, 0.1827863990754679, 0.1978214666980802, 0.1917243571352526, 0.21801856901482752, 0.120399598362108, 0.1712310190012255, 0.15032505305116306, 0.14995657597771128, 0.1387636568222348, 0.1563980722616256, 0.14143145401910262, 0.14486081485346547, 0.14982038892133132, 0.10268174153968124, 0.12209893020896456, 0.1083058399686726, 0.13231571098427908, 0.1267032374587701, 0.1227444400764387, 0.11043222408051712, 0.1142623533162872, 0.1227257216644273, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0724568910924912, 0.0549174427364284, 0.05323988561595183, 0.03892198748797382, 0.05234514772590371, 0.05660870505687143, 0.06925156052172565, 0.05376550618024445, 0.051624433565098826, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019897323416322443, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.055938862613508666, 0.06869930543796965, 0.06385380078687797, 0.06694187447067801, 0.09136608553023873, 0.0729026218923986, 0.06937481093131792, 0.07292100108487976, 0.06411814006284389, 0.3997925278057676, 0.4193757344950605, 0.3844288429404934, 0.42342666783575156, 0.37667519457565113, 0.385740308358654, 0.3927428940486668, 0.3908392380789981, 0.38459502160808234, 0.10698892266904236, 0.09109210485250063, 0.08900012454191164, 0.08205389964472942, 0.1257871294017967, 0.10423373934059532, 0.0752901532682907, 0.08163142572826787, 0.10054437565143781, 0.16567294393449283, 0.14618386008050144, 0.15036303322828792, 0.17354120055067013, 0.1524618534832347, 0.15011395804507865, 0.20212348045498918, 0.15745321139611257, 0.14584866342386194, 0.19039391056183808, 0.22223623694979133, 0.19361593515515674, 0.19286556481632755, 0.20342402177174113, 0.21770485346901258, 0.2094982562569605, 0.20544147694041737, 0.2143350431427129, 0.13301112535378035, 0.146699421271961, 0.14422172470296046, 0.1434605163233431, 0.16445404697991595, 0.15742342791170394, 0.14613355400082362, 0.14748230435319942, 0.15944550187223872, 0.19579132980827718, 0.19302159559170573, 0.19306343969286222, 0.20571781269885192, 0.1827641731403956, 0.17899187391624405, 0.17350605966226706, 0.2075368092827229, 0.19276602726084524, 0.23410835074048575, 0.20721657043415498, 0.21299341320540044, 0.20813971057752068, 0.23558789845601746, 0.22103893000925012, 0.21302283066913097, 0.22189677325814994, 0.20129655712067296, 0.23486259053259007, 0.2355176799172647, 0.2135698260565292, 0.2982186227304747, 0.17472162622793608, 0.2440042756461397, 0.24411278177798856, 0.20246396398001876, 0.22126023294539698, 0.2692375539296259, 0.15860994775050952, 0.1754903720042117, 0.2115095770338138, 0.1864052568556528, 0.20694719809817297, 0.2715603184398533, 0.22202887829980167, 0.17814970871206992, 0.17591077994176085, 0.17890808143736736, 0.1938338212508881, 0.21510812916314903, 0.17640645908734442, 0.20205430293035676, 0.20326061678405494, 0.1928001789899214, 0.19671856618066075, 0.07545280698587098, 0.07614678548071574, 0.0835220586366695, 0.06821308238813673, 0.07572143873429027, 0.07474533184270526, 0.0642897472979086, 0.08305564626855955, 0.07902670540668766]}, "mutation_prompt": null}
{"id": "855359d2-ccf0-478d-b54f-24f7a750de52", "solution": "import numpy as np\n\nclass ADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2  # Start with a moderate success rate\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + 0.05)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - 0.05)\n\n                self.mutation_factor = 0.5 + 0.5 * self.success_rate\n                self.crossover_rate = 0.9 * self.success_rate\n\n        return self.best_solution", "name": "ADEOptimizer", "description": "Adaptive Differential Evolution with Success-Based Parameter Adaptation for Efficient Global Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4cc63190-54e1-4c20-a0ed-d2ee84b58eb0", "metadata": {"aucs": [0.7392009611730366, 0.7512671002420502, 0.7445460396758353, 0.748846030871073, 0.7452236635689544, 0.7523311172067474, 0.739628343926622, 0.7386643979881814, 0.7482641610321219, 0.5508390511431761, 0.54078331815292, 0.5154331994696084, 0.5362075896103047, 0.5491429252508813, 0.5455012531924386, 0.4863357375666203, 0.5571792348745751, 0.5652725851406667, 0.46127489415486, 0.48216120229969406, 0.5157607333046526, 0.42263399277795644, 0.45440625549182345, 0.49225768820752214, 0.46325198484406105, 0.4792702852618689, 0.487293439905496, 0.3958245731624147, 0.41258235394455034, 0.3844861192170588, 0.3679846212601119, 0.39821228406612896, 0.37565560947953325, 0.39280182328227764, 0.3669237937927431, 0.39652013177346535, 0.9562070152596391, 0.9703155304587913, 0.9764460169899214, 0.9663877587015401, 0.9703114000557636, 0.9605451512290806, 0.9625365051659976, 0.9693468661524668, 0.9707922120300461, 0.1626328929403661, 0.12033168020274765, 0.1491757969591515, 0.1555766337816512, 0.12899927803653422, 0.17353038112619856, 0.1478890346871039, 0.14157489142319812, 0.1184988725600915, 0.12842376283856105, 0.1317525456680787, 0.1377342141057628, 0.1893131809929235, 0.20610651577494088, 0.1827863990754679, 0.1978214666980802, 0.1917243571352526, 0.21801856901482752, 0.120399598362108, 0.1712310190012255, 0.15032505305116306, 0.14995657597771128, 0.1387636568222348, 0.1563980722616256, 0.14143145401910262, 0.14486081485346547, 0.14982038892133132, 0.10268174153968124, 0.12209893020896456, 0.1083058399686726, 0.13231571098427908, 0.1267032374587701, 0.1227444400764387, 0.11043222408051712, 0.1142623533162872, 0.1227257216644273, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0724568910924912, 0.0549174427364284, 0.05323988561595183, 0.03892198748797382, 0.05234514772590371, 0.05660870505687143, 0.06925156052172565, 0.05376550618024445, 0.051624433565098826, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019897323416322443, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.055938862613508666, 0.06869930543796965, 0.06385380078687797, 0.06694187447067801, 0.09136608553023873, 0.0729026218923986, 0.06937481093131792, 0.07292100108487976, 0.06411814006284389, 0.3997925278057676, 0.4193757344950605, 0.3844288429404934, 0.42342666783575156, 0.37667519457565113, 0.385740308358654, 0.3927428940486668, 0.3908392380789981, 0.38459502160808234, 0.10698892266904236, 0.09109210485250063, 0.08900012454191164, 0.08205389964472942, 0.1257871294017967, 0.10423373934059532, 0.0752901532682907, 0.08163142572826787, 0.10054437565143781, 0.16567294393449283, 0.14618386008050144, 0.15036303322828792, 0.17354120055067013, 0.1524618534832347, 0.15011395804507865, 0.20212348045498918, 0.15745321139611257, 0.14584866342386194, 0.19039391056183808, 0.22223623694979133, 0.19361593515515674, 0.19286556481632755, 0.20342402177174113, 0.21770485346901258, 0.2094982562569605, 0.20544147694041737, 0.2143350431427129, 0.13301112535378035, 0.146699421271961, 0.14422172470296046, 0.1434605163233431, 0.16445404697991595, 0.15742342791170394, 0.14613355400082362, 0.14748230435319942, 0.15944550187223872, 0.19579132980827718, 0.19302159559170573, 0.19306343969286222, 0.20571781269885192, 0.1827641731403956, 0.17899187391624405, 0.17350605966226706, 0.2075368092827229, 0.19276602726084524, 0.23410835074048575, 0.20721657043415498, 0.21299341320540044, 0.20813971057752068, 0.23558789845601746, 0.22103893000925012, 0.21302283066913097, 0.22189677325814994, 0.20129655712067296, 0.23486259053259007, 0.2355176799172647, 0.2135698260565292, 0.2982186227304747, 0.17472162622793608, 0.2440042756461397, 0.24411278177798856, 0.20246396398001876, 0.22126023294539698, 0.2692375539296259, 0.15860994775050952, 0.1754903720042117, 0.2115095770338138, 0.1864052568556528, 0.20694719809817297, 0.2715603184398533, 0.22202887829980167, 0.17814970871206992, 0.17591077994176085, 0.17890808143736736, 0.1938338212508881, 0.21510812916314903, 0.17640645908734442, 0.20205430293035676, 0.20326061678405494, 0.1928001789899214, 0.19671856618066075, 0.07545280698587098, 0.07614678548071574, 0.0835220586366695, 0.06821308238813673, 0.07572143873429027, 0.07474533184270526, 0.0642897472979086, 0.08305564626855955, 0.07902670540668766]}, "mutation_prompt": null}
{"id": "45caa909-9f0e-405b-8598-3ba3a9ba5b66", "solution": "import numpy as np\n\nclass ADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(10 * dim, budget // 10)  # Adjusted population size\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.diversity_threshold = 1e-5  # New diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def maintain_diversity(self):\n        # New method to maintain diversity\n        diversity = np.std(self.population, axis=0).mean()\n        if diversity < self.diversity_threshold:\n            self.population = np.random.uniform(\n                self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n            self.fitness.fill(np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjusted increment\n                else:\n                    self.success_rate = max(0.1, self.success_rate - 0.03)  # Adjusted decrement\n\n                # Adjust mutation and crossover rates based on success rate\n                self.mutation_factor = 0.5 + 0.5 * self.success_rate\n                self.crossover_rate = 0.9 * self.success_rate\n\n            self.maintain_diversity()  # Invoke diversity maintenance\n\n        return self.best_solution", "name": "ADEOptimizer", "description": "Adaptive Differential Evolution with Adaptive Population Size and Enhanced Diversity Maintenance for Improved Global Optimization.", "configspace": "", "generation": 2, "fitness": 0.2476224008754133, "feedback": "The algorithm ADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "4cc63190-54e1-4c20-a0ed-d2ee84b58eb0", "metadata": {"aucs": [0.7404651198394928, 0.7452178893257605, 0.7458614121384628, 0.7466411137191897, 0.7485914605997155, 0.7513323953326381, 0.7472289122661702, 0.7547054421470271, 0.7703003429110927, 0.5118039142520711, 0.5406711917050097, 0.5473285288606914, 0.5217185339762138, 0.5655916663131061, 0.5650493849699432, 0.5572258477495102, 0.5558595632445766, 0.5664304477225964, 0.4635082580381974, 0.4657449744594754, 0.47985809497960386, 0.5016594368856504, 0.4888728008297828, 0.45778277810399537, 0.4826544901488231, 0.46023605792701694, 0.46673144697310687, 0.3718415627998124, 0.40629185080706587, 0.16314472935341218, 0.36704031186939623, 0.40177560267174117, 0.4146890250249239, 0.34085478391121027, 0.37265473244710157, 0.4015921383616866, 0.9711696848803292, 0.9752679412317258, 0.9826513874050224, 0.9757814659953448, 0.9515293798957006, 0.9538498779667043, 0.9723131406549042, 0.9802118468200409, 0.9388895513360261, 0.13531185390953926, 0.12601274833072496, 0.14979858453103678, 0.12713749528831708, 0.12824901805228128, 0.1392009091275973, 0.13436727184635167, 0.12724285099619592, 0.14153605895736, 0.14279818195405225, 0.14898588871921725, 0.14661548978127614, 0.20821055788587273, 0.2229333652911487, 0.29746349976685993, 0.21164328442373959, 0.19231380048298885, 0.19151318040788123, 0.14685171637865768, 0.16209615078474604, 0.1504145445048427, 0.1601681623848784, 0.14379253128541225, 0.16319310133895926, 0.18739485089212282, 0.16152772617440536, 0.15076157618444885, 0.11688836459520247, 0.08693118326135596, 0.14894532117651182, 0.1298504427308842, 0.10949325817143185, 0.14312114061229464, 0.12071616927478424, 0.11200934241894667, 0.12169246009907986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05105555243715676, 0.06629925346046983, 0.06073604960157586, 0.04342581600769935, 0.060611799491712914, 0.05227249792008892, 0.06284982487214597, 0.05782718821120092, 0.04045179492672357, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005852150103357379, 9.999999999998899e-05, 9.999999999998899e-05, 0.015902571691312595, 9.999999999998899e-05, 0.06815803626088346, 0.09709571311100185, 0.06109952040202371, 0.06893476856362946, 0.06267290329284969, 0.052916481833467865, 0.06872214654525943, 0.08284313454055592, 0.08169525015539769, 0.41136789817542596, 0.3760753150035022, 0.42105370764475514, 0.38157472324071073, 0.3770538495639625, 0.3895537997874988, 0.3897660974766741, 0.3811148183148316, 0.3978611445145298, 0.10298176866430131, 0.09043893846551176, 0.10866703274234168, 0.08855019795998254, 0.09516206901154767, 0.10250069793803085, 0.08199403543730222, 0.09356030685409822, 0.07686006818858737, 0.18986218435957558, 0.14337230937637835, 0.1441183930806954, 0.15059225284695454, 0.1501108387411041, 0.1660108311749069, 0.14880560125367248, 0.14727108276421697, 0.1553352655446213, 0.19779816681719942, 0.19938565871004998, 0.1988974958754388, 0.20719609687017237, 0.18795370967050262, 0.2062136955778865, 0.21528211101563177, 0.20512990445518808, 0.20565964352705446, 0.1382948882717303, 0.16635351671098253, 0.144470872622386, 0.1369554943624245, 0.13625485793041026, 0.15923236737916524, 0.15192326765286346, 0.14434136661650898, 0.16819468440516427, 0.19830934338234096, 0.17732107562830168, 0.19258159254112717, 0.1777735301274963, 0.21573065003542202, 0.20472909456753785, 0.19718915591905128, 0.1848104462653951, 0.1876646442623925, 0.2205483954683135, 0.24683491664036694, 0.2426104165541203, 0.24261617732564666, 0.22195130179326006, 0.20391605558807668, 0.2334849557323594, 0.20151368892026933, 0.22605744353270352, 0.2504499198276763, 0.23034062363139018, 0.30447952799727396, 0.18232913689360775, 0.1667693352782459, 0.25997382182268447, 0.3442835917050445, 0.16935094187547695, 0.24604945255008603, 0.16311018806830002, 0.1776097233944407, 0.2549613060437441, 0.16075922293851397, 0.18019362614782664, 0.19220005968545484, 0.18795379387481903, 0.22573964779724087, 0.20212103258098757, 0.1763644400834986, 0.18682652527672194, 0.18987272765126972, 0.17773710682400523, 0.18496961127764677, 0.1838952459488129, 0.1790801230561132, 0.19735756571862006, 0.20182866631232832, 0.0722653411568126, 0.08610689205645927, 0.07425369968942142, 0.06994634007705647, 0.08124342031532616, 0.06851949582568795, 0.07348214195557534, 0.06953138011772719, 0.06686194845172244]}, "mutation_prompt": null}
{"id": "573eb415-7169-418d-9c3f-cdbf204ca739", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + 0.05)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - 0.05)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + 0.2 * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Control Parameters and Archive-based Mutation.", "configspace": "", "generation": 3, "fitness": 0.25972495693367736, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "4cc63190-54e1-4c20-a0ed-d2ee84b58eb0", "metadata": {"aucs": [0.7516755449105236, 0.7442278165617984, 0.7471623912102993, 0.747605276203352, 0.7600426149137091, 0.7237632411819501, 0.7381384588073262, 0.73751285164682, 0.7285374689632258, 0.550146896906207, 0.5282445285157091, 0.5250723449310928, 0.5237211015419367, 0.5429466712174269, 0.5463197139780188, 0.5375357537821106, 0.5365764545288071, 0.54496887356409, 0.1287509254639695, 0.12188042807542265, 0.11550016087176285, 0.12495453029397863, 0.10312663771413022, 0.11940042288109931, 0.12022711255443885, 0.12579033390400707, 0.12370514723531245, 0.09222611417765114, 0.10004388925705188, 0.10450882803597616, 0.09626983829239177, 0.10544568293413537, 0.10293174329709476, 0.0974485947075232, 0.10334672158759806, 0.1048032015599134, 0.8125111942344663, 0.6354000106532487, 0.4694938123992187, 0.5469017470341366, 0.8096321892543427, 0.5406179255875952, 0.4351844720442165, 0.5552332151273496, 0.4774192136658747, 0.19864397448755566, 0.19955791524988775, 0.22470681364216394, 0.23526222008581765, 0.18594180039946917, 0.1674150077311779, 0.22728072890959206, 0.23711776863025147, 0.19693956600561413, 0.6285168737537319, 0.586143583563602, 0.5568631477549439, 0.5744551915369679, 0.5992148231725507, 0.6627636372546144, 0.6100883143128941, 0.6483939240961583, 0.6237675188375487, 0.1706270919415327, 0.14964037553375875, 0.14842803532569282, 0.14465240097711918, 0.148583289654596, 0.15750938509252554, 0.1610546454057421, 0.18324611265459112, 0.14331071287865393, 0.1855769655498114, 0.16198541325568616, 0.15649564053419307, 0.1765944560732816, 0.14982708890947727, 0.14465309804152637, 0.15584312457385552, 0.16812252308326037, 0.1587235484852756, 0.09279264492214201, 0.09843587084368755, 0.07026518214736266, 0.11113354362139216, 0.09591920135636411, 0.09338852713966639, 0.09728438765156022, 0.1015932291280276, 0.10050844185759555, 0.2258450244008452, 0.20025654154349226, 0.2224619514711913, 0.1793934164104568, 0.18842251392479514, 0.1684169428163157, 0.23020588375303996, 0.22686593979321612, 0.2298795108936711, 0.05215170205956543, 0.05930906144510373, 0.05181893244454183, 0.046221155249893675, 0.04308152956025957, 0.07088312467438773, 0.06307400991612244, 0.057436891285545966, 0.047904094851167756, 0.163562352944013, 0.1657430295529777, 0.16568229710354376, 0.18445519413784162, 0.18357670381458913, 0.18501374636303147, 0.1608795413373979, 0.1727366155910669, 0.17417105454935333, 0.5376440435340148, 0.5233533243011663, 0.5464956660906921, 0.5343879810964982, 0.5299914402474069, 0.5258129680406454, 0.5281363487791562, 0.5217871979782072, 0.5436864011784825, 0.08871472570228567, 0.10558678829987678, 0.09375416989515184, 0.10042610456733203, 0.1071982007172233, 0.09048261475067298, 0.08601240971298085, 0.09824859098002303, 0.10988267800957785, 0.1430880581011259, 0.13975305722142517, 0.13845369255233586, 0.13327270470212693, 0.14852432318547348, 0.13124138953221587, 0.15869256179392144, 0.1542301977435756, 0.1321547074285221, 0.31357916459753155, 0.31264072940156407, 0.30808097497833764, 0.33369409045602216, 0.3211010216560596, 0.34119387871057183, 0.35627671166284614, 0.33476349391513505, 0.3540600779002697, 0.2333119335847429, 0.22144610232507933, 0.23887754908917236, 0.23956657916210422, 0.22044315013140425, 0.23613778274517538, 0.24475338589584084, 0.2684777155739273, 0.25934147231427074, 0.2001239624348482, 0.19348341958426207, 0.2043116968072488, 0.19321644881962807, 0.19260667273346166, 0.19233168217725094, 0.20068984481966123, 0.23585098378686553, 0.1976255730702855, 0.18425309705299597, 0.20372579366044163, 0.17553970854148082, 0.1904919965536419, 0.17638602908354206, 0.17213363767368095, 0.17915877894772658, 0.18182958388111625, 0.17982584039014204, 0.24047718931724205, 0.1861481355468949, 0.16082850291210837, 0.2207300266369795, 0.51354337737014, 0.2629236590952714, 0.22446448425684362, 0.49370269633168595, 0.25921945285982384, 0.1917042259532774, 0.20865072557717845, 0.2364235442690258, 0.1845347358159869, 0.2092271243633661, 0.18229348114474586, 0.19775463243339741, 0.19793705321299337, 0.23760535178987652, 0.17600795937365055, 0.17866532951400182, 0.17179952720352065, 0.18315286615146065, 0.17065683243223906, 0.18991210600176267, 0.21021796283966165, 0.17605219332372313, 0.18291315269906483, 0.0802488381839197, 0.07972940757644298, 0.0724618126707075, 0.08021077554892786, 0.0890238276509997, 0.07663274043666402, 0.07772503978911938, 0.08113163881061713, 0.07786877416188631]}, "mutation_prompt": null}
{"id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 4, "fitness": 0.3253038438015079, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "573eb415-7169-418d-9c3f-cdbf204ca739", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "22f7ffe9-9ddb-43b9-a7ee-17936273644d", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "fc0750b1-ce8a-4a5d-8617-e6fd5f991542", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05  # Dynamic adjustment rate\n        self.local_search_prob = 0.1  # Probability of local search\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, solution, func):\n        for _ in range(5):  # Perform a small number of local search steps\n            step = np.random.uniform(-0.1, 0.1, self.dim)  # Small perturbation\n            candidate = np.clip(solution + step, self.lower_bound, self.upper_bound)\n            candidate_fitness = func(candidate)\n            if candidate_fitness < func(solution):\n                solution = candidate\n        return solution\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                if np.random.rand() < self.local_search_prob:\n                    self.population[i] = self.local_search(self.population[i], func)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Introduce strategic perturbation and local search to boost exploration and exploitation balance in EnhancedADEOptimizer.", "configspace": "", "generation": 6, "fitness": 0.2354856696812662, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.15.", "error": "", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.6312403955517998, 0.5924883075590825, 0.615752414168363, 0.5965766094926181, 0.5903245715844874, 0.5417469928002928, 0.576232135749388, 0.5541362760240789, 0.5694222607709046, 0.2690830314651105, 0.28010405687863305, 0.2731521843039143, 0.27821333098020096, 0.3096188188487544, 0.2466239547105451, 0.1579688526186772, 0.26692479280265047, 9.999999999998899e-05, 0.10761472605700362, 0.11027208182263004, 0.11086662831446226, 0.11721828840196102, 0.11329494677142704, 0.11582900721434175, 0.12017537068963868, 0.11597020193316043, 0.13159146311545988, 0.09107728123412895, 0.08041193969054894, 0.09186989357353503, 0.08761276757171477, 0.08451189582570695, 0.09527145482033861, 0.0809057570252466, 0.07865653414189966, 0.08406672303373797, 0.2819963302602905, 0.3264318127386616, 0.2223454955577857, 0.4825469942844737, 0.39077725477635195, 0.3607184430540251, 0.3425799699876617, 0.366810046323259, 0.2271942950228476, 0.1672469047921582, 0.15466945168479573, 0.2012517769365797, 0.17249766982022907, 0.18454232767662737, 0.1758026990371211, 0.16124614480815813, 0.17688578927021226, 0.17454550846587025, 0.5789449959519075, 0.6454876432078036, 0.6145573777700795, 0.6300493649829411, 0.6139250760794059, 0.6248716578855003, 0.5993005227131835, 0.5702612018713189, 0.3861743306292885, 0.12446100085785461, 0.16398098424489238, 0.1317620203210894, 0.1308337151714417, 0.14573723830897212, 0.14099843331657635, 0.13470529534035613, 0.14010147823195362, 0.1443987656884076, 0.135233376639868, 0.1379801731793443, 0.13035867931245815, 0.15002687179739638, 0.13376217839487525, 0.17068597899377236, 0.1363559720845502, 0.1419037413886386, 0.1418417587268208, 0.18489162765634137, 0.216350686451098, 0.20245301005057792, 0.20579634551103054, 0.1626623743666823, 0.1819045118198217, 0.19582828623622595, 0.20222658290941276, 0.22553535291465254, 0.3482806799856738, 0.35418958024596814, 0.26604747315020083, 0.177530387410619, 0.29397975914961383, 0.1607178478346073, 0.3726800331493124, 0.3216855730308529, 0.33745946150652995, 0.07817255853487481, 0.038735474747652154, 0.038570910414128745, 0.05279428139117592, 0.06295626810320953, 0.07456764864383625, 0.05716016186734052, 0.08491634317310304, 0.0813131183447049, 0.188926113486235, 0.19181342495453202, 0.19684510692238477, 0.17400006931627465, 0.16716535180757397, 0.1956025237857435, 0.061819485527651374, 0.15564274455901683, 0.16177737290082428, 0.5011847654793941, 0.5049211185068478, 0.535905838965536, 0.4886796627094362, 0.4931649026137638, 0.49726314606862476, 0.5121162807885847, 0.5273143968266985, 0.5152152860977008, 0.11083540019435711, 0.09792048677467668, 0.11676063287933558, 0.12891805904447462, 0.11718636099441915, 0.11042661098356588, 0.11829361713712538, 0.11055480028607578, 0.1185027738109411, 0.19008717112434825, 0.18343935206699458, 0.16736066878177203, 0.15635605742685588, 0.1642497475017921, 0.15780058311939027, 0.16560400593335511, 0.16996582631155266, 0.20053890983061395, 0.29846674886087654, 0.27359009184106287, 0.2897780097678364, 0.29686079856233805, 0.29109516764751775, 0.30590182902287466, 0.3032679149237759, 0.2987770637623094, 0.2929275793027075, 0.23373105506773495, 0.2404996533954762, 0.24227191606852738, 0.22377637697408836, 0.2113029835914998, 0.23459944030236723, 0.22886224476135608, 0.22445508326760788, 0.2308672187573071, 0.20127305879544943, 0.20438092544172604, 0.22540237650920947, 0.2098156227089767, 0.20035532343459472, 0.1929272189993796, 0.21723128582393914, 0.18096824347039464, 0.179860921596512, 0.189381359097894, 0.1741937975792649, 0.17053125179904582, 0.17448750250373646, 0.17201649793161267, 0.1761906753188407, 0.17579624076013856, 0.17487562790794986, 0.18132612306572116, 0.3676694980065768, 0.1712359098681796, 0.17123173627312716, 0.2382316757866889, 0.25416043544768563, 0.6222645236967996, 0.2753687134615569, 0.40901621647999054, 0.41765475704052546, 0.4323259320159081, 0.21814072550277064, 0.262064792849377, 0.23909334843903807, 0.2227464382816876, 0.15715537110111322, 0.31325742377865395, 0.19143666079288957, 0.15471642452367274, 0.17111436947340464, 0.21234257074565288, 0.17820825695990805, 0.20194487582605358, 0.1877087100152417, 0.20359909237446605, 0.17813603893812635, 0.18883047426073196, 0.19292490070055512, 0.08101959563005767, 0.08623773832467418, 0.0811268741980703, 0.07786251965789692, 0.07724659124040534, 0.07595549157657733, 0.0818126056257712, 0.0828366491504201, 0.09690179523562314]}, "mutation_prompt": null}
{"id": "b823d774-973e-4de7-bee2-b1af8406f4f3", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "5fb6da90-3f10-4ec1-aebe-5b20d2e6afeb", "solution": "import numpy as np\nfrom sklearn.neural_network import MLPRegressor\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.model = MLPRegressor(hidden_layer_sizes=(10,), max_iter=500, random_state=42)\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def learn_from_archive(self):\n        if len(self.archive) > 10:\n            X = np.array(self.archive)\n            y = -np.array([func(x) for x in X])\n            self.model.fit(X, y)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:  # Introduce a neural guided mutation\n                    guide = self.model.predict(self.population[i].reshape(1, -1))\n                    self.population[i] = np.clip(self.population[i] + 0.1 * guide, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.learn_from_archive()  # New learning step\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Hybrid Adaptive Differential Evolution with Neural Informed Mutation for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {}, "mutation_prompt": null}
{"id": "95ac7e86-c7cb-40eb-b0ca-784648004d23", "solution": "import numpy as np\n\nclass HybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.6  # Refined initial mutation factor\n        self.crossover_rate = 0.7  # Refined crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.07  # Adjusted dynamic rate\n        self.elite_archive = []  # New elite archive for top solutions\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutation_factor_adaptive = 0.5 + self.success_rate * np.random.rand()\n            mutant = np.clip(a + mutation_factor_adaptive * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.4 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.6 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "HybridDEOptimizer", "description": "Hybrid Differential Evolution with Archive and Adaptive Control for Enhanced Global Search Efficiency.", "configspace": "", "generation": 9, "fitness": 0.28798685487990255, "feedback": "The algorithm HybridDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7990935629490411, 0.8025820356853621, 0.7996313091474612, 0.7933530365803637, 0.7332696709828749, 0.7786612572419145, 0.7876189575949379, 0.775063434865534, 0.7748587194307139, 0.6308839475580013, 0.6282840848424394, 0.6248473014419891, 0.6244956755397626, 0.5863252084569763, 0.608465225775406, 0.2033709327511879, 0.6392906980267687, 0.6249130950511981, 0.12724909635258863, 0.14086704260106686, 0.12908405712109539, 0.1228627895758283, 0.11061756495735098, 0.1286538468312074, 0.13210134467042556, 0.1318770765110432, 0.12067478864520176, 0.09344030831093864, 0.0990059096038336, 0.11630013989783261, 0.10247679896153694, 0.0924840744217087, 0.0902071547533958, 0.09781231042758698, 0.09719899918939989, 0.10123807184515066, 0.23693044648029749, 0.26009589487788765, 0.2657098109981877, 0.18884181516508292, 0.23392506895305465, 0.2152964805577967, 0.2359923604748445, 0.24166781402635273, 0.24062567531075496, 0.12100257248501345, 0.10419925755957848, 0.10972436214948267, 0.09526786499576723, 0.08728995002514806, 0.07739624612538465, 0.1349912795995537, 0.15652846517257535, 0.15845260579546994, 0.8170754802384199, 0.7152855298813257, 0.8149361088601127, 0.7898695854958881, 0.830315620893824, 0.804237257052681, 0.22496223086218647, 0.8206161310256159, 0.787660712802317, 0.14547701488981946, 0.14569925871118705, 0.1520339147634966, 0.2684285756300744, 0.16467243310911073, 0.14206340781108806, 0.14352042764029826, 0.1462436628995727, 0.14835860618380048, 0.1282658511183563, 0.14164469378675948, 0.13254461486339153, 0.1892636847718251, 0.14117975501601354, 0.16612909718796032, 0.15539641139378724, 0.13805997504637413, 0.1517947602051103, 0.13540174172282204, 0.0941864558432286, 0.5170405981747735, 0.5320118311163813, 0.2556461344206067, 0.1259942834224712, 0.15877915447985436, 0.040698413734488126, 0.14642552959782185, 0.26379842620434846, 0.2732229186585353, 0.2094222144744725, 0.16276143844264712, 0.6278500787071952, 0.11011058520428596, 0.2602653156356902, 0.5577544756819773, 0.33095587989372666, 0.13995238201215876, 0.23822865277240102, 0.22404503677358933, 0.1874307332824977, 0.15637376488173504, 0.1608347844432143, 0.1241326903271962, 9.999999999998899e-05, 9.999999999998899e-05, 0.42021989222768497, 0.37302290035319174, 0.3811015556900932, 0.23151700250150742, 0.11584800448773969, 0.2519205156531722, 0.15564083752657643, 0.21018226665404716, 0.3665935513409644, 0.7281053340201886, 0.7499852978484947, 0.7045323418728224, 0.7491074328255853, 0.5845294947416033, 0.6916799188642154, 0.6025038787383488, 0.747021980270243, 0.6814383350717355, 0.1048272524044942, 0.10024754331682728, 0.11127012126827973, 0.11000645792333874, 0.10622304744298983, 0.10690570655157428, 0.1214636340242845, 0.11156822959355561, 0.09208259877403202, 0.14818791252799857, 0.13769003583987616, 0.13075979776376478, 0.12969523717034137, 0.13787447551486298, 0.1464715935212373, 0.17977192358757987, 0.14090973855820554, 0.14960271943177217, 0.4666080654007555, 0.4545956301335554, 0.4721307527732648, 0.46754840593163094, 0.4568390464505174, 0.4605167732770654, 0.45699888052813087, 0.436855161997871, 0.48606615923733076, 0.3606774461862384, 0.3282433148762792, 0.34813280349259057, 0.3886316155027406, 0.34698502266018905, 0.3444484127670424, 0.40144462076740994, 0.2814132583152976, 0.3847144845213418, 0.21670179394266242, 0.22062904322125987, 0.20990823235798206, 0.21019514397923877, 0.21614619804402935, 0.21012589984359642, 0.22093796853254088, 0.23674724700981997, 0.22659188379882245, 0.18222907818313483, 0.1781488582112235, 0.18548605295275478, 0.1874657394190815, 0.18296725126502522, 0.1769497933876797, 0.17994965698261056, 0.1714172483621762, 0.19673958403887348, 0.18349676079293153, 0.19970185752194658, 0.18317485223237018, 0.6316992681090521, 0.19018838715891428, 0.1872443802868976, 0.6338308171463067, 0.327485676134315, 0.4226215631008371, 0.1990989874589465, 0.2282356862360112, 0.19977926971936144, 0.16731258468659727, 0.19992935177281357, 0.1625639473327376, 0.15884359199122333, 0.19321350251864156, 0.3874080711018041, 0.17788673891545093, 0.18479543031294743, 0.18531023396161894, 0.20777735489879023, 0.17091451866720941, 0.1839450289815423, 0.19130425269125761, 0.19373889235717667, 0.2084972764892159, 0.09011072599712844, 0.08934624648991762, 0.09961307615120785, 0.10558610762980392, 0.10164482421973209, 0.08490428104718617, 0.08313206367936932, 0.09405529338298368, 0.08171883722983475]}, "mutation_prompt": null}
{"id": "2dfb89bf-118d-441d-9e0d-078212c28437", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.diversity_threshold = 1e-5  # New diversity control threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def diversity_control(self):\n        # Calculate the population diversity\n        diversity = np.mean(np.std(self.population, axis=0))\n        # Trigger a restart if diversity is below threshold\n        if diversity < self.diversity_threshold:\n            self.initialize_population()\n            self.evaluate_population = None  # Re-evaluate population\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                else:\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n            self.diversity_control()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Diversity Control and Self-Adaptive Mechanisms for Robust Optimization.", "configspace": "", "generation": 10, "fitness": 0.3145670290271919, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7690122296158509, 0.7801493277264206, 0.765018626241568, 0.7583774970141589, 0.7621444569888367, 0.7199272544159772, 0.7682680893681227, 0.759972279893896, 0.762233395612287, 0.5560713697355614, 0.5702746656786397, 0.5681155238763419, 0.5778901824695061, 0.5785505638399397, 0.6002574382568684, 0.5669700322500084, 0.5609626075819585, 0.5937633016535595, 0.11064059940582427, 0.10105184760879149, 0.10680018830089577, 0.128870721764494, 0.10009969553005904, 0.10826937682734084, 0.11591438282702782, 0.11886153410812317, 0.1057308109587346, 0.08886060843777999, 0.08422530917682525, 0.1002014031946652, 0.08881540822935463, 0.09739482298595936, 0.08597409312791626, 0.08920234068938115, 0.11153459557119072, 0.08838507328443468, 0.229692488931606, 0.2332136575586613, 0.2599300669388065, 0.22900609437731034, 0.24943579317730113, 0.22410634615964098, 0.25388834337548194, 0.25022518618068856, 0.19132525680885504, 0.1103559652892292, 0.18121833463141745, 0.1283389343875131, 0.10257545338279028, 0.14880476050272007, 0.13215601784503506, 0.19043470334942625, 0.16785969827661462, 0.1753720054176391, 0.7524574130388886, 0.7573527227047544, 0.7816947407264432, 0.7557018850364423, 0.7536762253747249, 0.7598459329411253, 0.6879502956855957, 0.7446872934245752, 0.7557794293760749, 0.13821188864974487, 0.14342140897030964, 0.1532745593973155, 0.18921149905240187, 0.19408893351068746, 0.14221439913510603, 0.16719063768537867, 0.16504786650965597, 0.15374782031947432, 0.16960605305364207, 0.14145847262171407, 0.17280738576340826, 0.14557646767624333, 0.14818646493958765, 0.16902670572694256, 0.18573887714925474, 0.1481142846182011, 0.15936435899689383, 0.49948435273428216, 0.44672941077223627, 0.45049110939492076, 0.484012277710161, 0.48087532274552947, 0.4617910857295967, 0.5062471110522966, 0.47524672757631325, 0.49863135723391383, 0.6157662124283017, 0.6122968215533127, 0.5932362984700909, 0.5417307273489356, 0.257834366274033, 0.1948256534816356, 0.21134856390883483, 0.564732156608279, 0.5716558896740164, 0.13471051175811666, 0.1801846118612197, 0.13588673297789555, 0.25810000576371317, 0.2277479405822953, 0.18720113640750602, 0.13269138238935652, 0.12644798504026256, 0.13194273355895625, 0.3445312772223268, 0.3319105201026765, 0.30191569594064027, 0.3354612537730819, 0.34298564687458866, 0.3355921587475309, 0.2974072047483862, 0.31665432644585934, 0.3240606825589455, 0.7114402494313039, 0.6993198740683906, 0.707068897075026, 0.6872074949218949, 0.7100163225876724, 0.6942459032785091, 0.7130451895916472, 0.705970651749257, 0.6929514145267628, 0.09325127840854164, 0.0964967575375596, 0.10232730216600483, 0.10437523916455993, 0.09525099329883213, 0.10297570456065586, 0.09752949247633058, 0.10745144626977676, 0.09404744593849124, 0.15934841255070564, 0.1420651000849612, 0.14901675853533647, 0.15090485982515944, 0.14613683659667454, 0.1277089555975326, 0.1474332195616369, 0.13581200132536764, 0.1244273821550067, 0.3719047754431746, 0.3955523571116877, 0.37428006281300463, 0.3795068559464656, 0.4014152532516355, 0.38719166251438186, 0.3948244835021256, 0.40461159389836177, 0.38136084155464256, 0.29305716105951085, 0.3073897209552655, 0.2886453988077379, 0.29459618155760103, 0.30497289040973763, 0.2905163373654326, 0.29919040056794033, 0.3079609074532671, 0.3082212681874291, 0.20075610311104786, 0.1889794613073872, 0.20808704242585996, 0.19180268672248946, 0.19507074159485882, 0.1926789938431056, 0.1981345052932626, 0.2019931795854114, 0.2032485898584626, 0.18394348517397097, 0.18293733014447666, 0.17193244130163965, 0.1763236319400343, 0.19338512207073877, 0.1811374151277113, 0.184570490546354, 0.17524799181730466, 0.17628938649852421, 0.1717759843754718, 0.5470985781624421, 0.665789625436992, 0.5264386380666408, 0.588624370521163, 0.565725371083248, 0.6573049634848166, 0.6635382717558435, 0.5735702872745401, 0.663941111843773, 0.20020063238540975, 0.589091383721905, 0.19471880209843395, 0.175987249073856, 0.2038888843149449, 0.20686377370863618, 0.20314046238743988, 0.2316628134698946, 0.1814526161832536, 0.18158243394219253, 0.18813533573417418, 0.1846903857212866, 0.17772448658831996, 0.18843989937793193, 0.17081951070316426, 0.1794612033298989, 0.18322553700367716, 0.08003419830795522, 0.08256359822863746, 0.08230467674822162, 0.08583683928811392, 0.08396589893487394, 0.07995267489741231, 0.07691064491384236, 0.08147097939127512, 0.08447217899446113]}, "mutation_prompt": null}
{"id": "d033b9f3-2b1a-4660-a48e-902ebadfdffe", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "92b0aac9-e935-4898-ad4e-9dff01762ed9", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n        # New diversity preservation parameter\n        self.diversity_threshold = 0.1\n        self.strategy_weights = np.array([0.4, 0.6])  # Probabilities for strategy selection\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx, strategy):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        if strategy == 0:  # Original mutation with archive\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            if self.archive:\n                d = self.archive[np.random.randint(len(self.archive))]\n                mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n            else:\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:  # New diversity-driven mutation strategy\n            a, b = self.population[np.random.choice(indices, 2, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - self.best_solution), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def update_strategy_weights(self, success):\n        # Adjust strategy usage based on success\n        if success:\n            self.strategy_weights[0] += self.dynamic_adjustment\n            self.strategy_weights[1] -= self.dynamic_adjustment\n        else:\n            self.strategy_weights[1] += self.dynamic_adjustment\n            self.strategy_weights[0] -= self.dynamic_adjustment\n        self.strategy_weights = np.clip(self.strategy_weights, 0.3, 0.7)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                strategy = np.random.choice([0, 1], p=self.strategy_weights)\n                mutant = self.mutate(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.update_strategy_weights(success=True)\n                else:\n                    self.update_strategy_weights(success=False)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Coevolutionary Differential Evolution with Dynamic Strategy Adaptation and Diversity Maintenance for Robust Optimization.", "configspace": "", "generation": 12, "fitness": 0.23060462734366013, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.17.", "error": "", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7794753251855808, 0.7758856513902648, 0.7112596704632661, 0.5122493076495105, 0.6976459068137759, 0.3672002265922547, 0.32577092054480616, 0.566848376361859, 0.1913165418422318, 0.04308120021342421, 0.46708312316536305, 0.6020271675684181, 0.053929990841931286, 0.6242810701838772, 0.23683247328163104, 0.5625264777228596, 0.07272401776723514, 9.999999999998899e-05, 0.09652788991762373, 0.14417093307432804, 0.09771164374031271, 0.10646015681336307, 0.11589229178036553, 0.10947764473682076, 0.12333197573077392, 0.11896365080804372, 0.11883444637393659, 0.08736725901622355, 0.07561856665423661, 0.09111766856810011, 0.08379328353678939, 0.09037139493778246, 0.08555630853948226, 0.08281123294031856, 0.08895454992624197, 0.08982603257895827, 0.2047867561237635, 0.20058844081026694, 0.18562335713756306, 0.21035013311495177, 0.19730702869586525, 0.18067845642778957, 0.19985144018787637, 0.177584497908994, 0.19601956158033573, 0.06839683143244057, 0.059107801114472336, 0.13631066050387874, 0.09156122723865134, 0.05041700579568276, 0.05313077226393437, 0.08760871402792092, 0.13764854187541475, 0.11389647331353714, 0.32468856616826647, 0.812785103837126, 0.21928022609266995, 0.2784545482429748, 0.7330129726257522, 0.5101081160449199, 0.5550611475017144, 0.22541332422158045, 0.20448649831314714, 0.17164701287121353, 0.21895107292113458, 0.11813754588004743, 0.19823661013592442, 0.12717723703678163, 0.12939848678073518, 0.13452375649590176, 0.14431745490651315, 0.4159603843146046, 0.20278705047254275, 0.10165493709103668, 0.14514255552209965, 0.14216890886205402, 0.15499571972197324, 0.1410210445267439, 0.17573400046766852, 0.1329178886575081, 0.15127948539470437, 0.3616716461549956, 0.22737127976116767, 0.08065618118826223, 0.1877082104155443, 0.06760124266929579, 0.06141710727816352, 0.08793067820820288, 9.999999999998899e-05, 0.18707005315667813, 0.17223879467284553, 0.23713895482668412, 0.18425826673357393, 0.11793020508342866, 0.1738789481704034, 0.14563113754829649, 0.33759452962112135, 0.31898216961465065, 0.617121485058326, 0.12447700953516683, 0.21742871340891912, 0.1524002213064648, 0.07570986060352336, 0.08421429822692372, 0.02164121675927111, 0.09520734362618, 0.1554098762898466, 0.08374388352729367, 0.1566504091853136, 0.3297877744783516, 0.3824288019582631, 0.10762971277810407, 0.279466506773941, 0.12007647969394963, 0.10440519281109295, 0.12367275751256823, 0.31450913493966226, 0.5149884444945616, 0.6296365180624706, 0.3031311110987879, 0.6844963929115486, 0.42495255223098216, 0.4443945919462138, 0.6085678997663883, 0.586504482587872, 0.3703057235969146, 0.08621979992487228, 0.08994672997958242, 0.10038792801092655, 0.0849565461211329, 0.10632664420348226, 0.12809531263904006, 0.08836328911642499, 0.11537006597618749, 0.10842114577436279, 0.1247382359860365, 0.1554319190513861, 0.13315484689721757, 0.1508796479570026, 0.16309317760490372, 0.14269912339503166, 0.14588539783135146, 0.14158813966660677, 0.1654210628782734, 0.32270902212751684, 0.38419969006002386, 0.37263135458686425, 0.3419421959598825, 0.43185921065216515, 0.39408615980991324, 0.3692305524525362, 0.34519283825726865, 0.38242199978751745, 0.25870337896073015, 0.2951361277997794, 0.3091730482186371, 0.32830313095002517, 0.2712263956038813, 0.2696283616092896, 0.3265732834444227, 0.26754744565038713, 0.27570333933629887, 0.17931797565605923, 0.19354547853413173, 0.2023472862478508, 0.21166160112505905, 0.19660097382765418, 0.1995869967707793, 0.21360955590389374, 0.1994856433626957, 0.21172165894514017, 0.1844620500739348, 0.17741224337770367, 0.18302508275987917, 0.18377491098648902, 0.1803274636277158, 0.2062006974182462, 0.20541744339781354, 0.1949944343987804, 0.2026440209214012, 0.16678743441552446, 0.18781252985455665, 0.6122454576972667, 0.33214170008841015, 0.15856410642603858, 0.33736294670836386, 0.36878981256721144, 0.15576683853070172, 0.4752737893845359, 0.16525936828557897, 0.5030465092161772, 0.7503515614194531, 0.1879327041267902, 0.4390524251607577, 0.36785529733397215, 0.1996523342364407, 0.1916532074480043, 0.22389659285770946, 0.19693715634691145, 0.18037869824711794, 0.20008627093169806, 0.2028622378200058, 0.178163570269668, 0.18477685983964565, 0.1776459408841119, 0.19571872659184741, 0.19565836987790475, 0.06658474125608771, 0.09395045274539571, 0.07644168779474492, 0.07738184704025919, 0.07640567887684302, 0.07492181017655353, 0.07916319757399015, 0.07289625703612401, 0.07442778935311511]}, "mutation_prompt": null}
{"id": "a1b896ab-f0fa-45d0-bfe4-16b7b38369ca", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "19688852-390d-4121-923e-a2999b1ae229", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "1ec13050-26df-4310-8a2d-ed25afb1be7a", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "51fb0946-9eb0-42ae-a631-0e611c86e81b", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.diversity_threshold = 0.1  # New: Threshold to adjust diversity\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + 0.5*(d - a)), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adjust_population_diversity(self):\n        population_std = np.std(self.population, axis=0)\n        if np.any(population_std < self.diversity_threshold):\n            # Create random individuals for diversity\n            random_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 5, self.dim))\n            for rnd_ind in random_individuals:\n                if len(self.archive) > self.population_size:\n                    self.archive.pop(0)\n                self.archive.append(rnd_ind)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.adjust_population_diversity()  # New: Adjust population diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution leveraging Dynamic Control of Population Diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.29676031116194534, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7700942535676985, 0.7803577801113174, 0.7628061399029742, 0.7613314551163972, 0.775921732551095, 0.7486594506086828, 0.7814936071349678, 0.7666114631720757, 0.7767327036002662, 0.518978363347916, 0.5102165538804404, 0.4931342911123595, 0.4910400500413963, 0.5126780632774199, 0.5063877428400427, 0.4678762299640701, 0.4891147895649859, 0.5401460896469055, 0.10701637730863167, 0.1180451935872745, 0.10863872318919543, 0.1094225316096128, 0.11415305891004668, 0.10964370558212488, 0.12524234673581724, 0.11435018877528513, 0.10873326737403222, 0.08546467795252033, 0.08686186071887547, 0.09401628026211328, 0.10195135740037786, 0.08591915154041674, 0.09121375388347808, 0.10111939008478876, 0.09305869534624311, 0.09586743487748628, 0.2822918778851966, 0.30397193968485114, 0.23803260872384335, 0.2683484798349792, 0.2971865731794856, 0.28066536727982017, 0.23388484254772868, 0.26331449201158574, 0.24383242308281083, 0.19654249595291262, 0.18145407919847367, 0.22033603650792088, 0.1650360621164031, 0.18333961365085583, 0.21262377574946656, 0.20593814042046044, 0.18006724379079564, 0.18984464313232552, 0.8305263216808617, 0.7990944325832099, 0.8819179120838978, 0.7679820006562903, 0.8329215193183287, 0.8442717589397588, 0.7476094765543844, 0.38208702538722905, 0.7513166125063571, 0.1425193665627188, 0.17650683569808845, 0.16457117825602896, 0.18146681833099088, 0.1497147658114929, 0.2550719469130682, 0.1433851471092219, 0.15017413020623693, 0.1426490807852282, 0.1275825391157357, 0.1538468250893682, 0.14393258451506985, 0.19923625284046897, 0.15038260714670015, 0.14998753516079455, 0.1442390245804125, 0.1570043832641651, 0.1350018259783745, 0.4345393547971599, 0.4315222136139165, 0.3578082742532832, 0.16664951739645695, 0.4983502682003744, 0.5353253543259475, 0.46191287897486655, 0.46282003439827823, 0.4658644998806163, 0.6276725633261108, 0.234858220973168, 0.5848920798081995, 0.1761783133271323, 0.6308066635706995, 0.20742607377710187, 0.5873023420265626, 0.6055338279808111, 0.5875937168651273, 0.1226890380906982, 0.08148066249954466, 0.06412808726306363, 0.34021419664749897, 0.2339684113780901, 0.12010403608874332, 0.0885132780511676, 0.03902475737475619, 0.06809596535826168, 0.2964394267110103, 0.2704100969193449, 0.29551701631768623, 0.28106007484583817, 0.27458961875121646, 0.3087722435943776, 0.2959321976297683, 0.2964735009314595, 0.31587951208785015, 0.6813315205837336, 0.6020220744859464, 0.6501269427469261, 0.6420537902285479, 0.6529696568037103, 0.6789913615423722, 0.6904976603115129, 0.693329998746999, 0.6508112715599494, 0.11364263283182297, 0.11423148322183585, 0.09781304190993634, 0.09978804414606168, 0.1034532400604532, 0.10952693650508916, 0.11726526106918211, 0.1191030467979115, 0.11470900209604373, 0.13678469235525248, 0.12053036066139211, 0.16720448313839975, 0.1361418140754619, 0.15282035922948745, 0.15907326304125657, 0.14041311754888997, 0.1648106811785206, 0.1304596152902876, 0.34617891267235523, 0.35282936282393973, 0.31640542876840894, 0.3133820192004949, 0.3223697215516117, 0.3319536226564692, 0.28886701303411344, 0.32534784461537025, 0.3286807204423471, 0.22422584468128193, 0.24298340046261624, 0.22823313588591287, 0.2447735491488735, 0.24305607751264113, 0.24735064467095735, 0.23983862899755337, 0.24969869915252918, 0.2607793552644393, 0.19829354517972264, 0.20803584268664976, 0.2239616511118635, 0.2032899766330134, 0.19865670822455384, 0.22887782505744103, 0.20852469338045854, 0.22256001007225645, 0.2077952184719778, 0.17717494878806206, 0.18449257065090963, 0.18962041340386693, 0.19215871760769754, 0.18360370882117372, 0.1753172936270052, 0.1802614660206283, 0.19314788101057156, 0.17471177080067612, 0.18005899253230384, 0.14968924659247074, 0.19100719025899526, 0.1650031076214049, 0.36005367054566983, 0.7306501571926421, 0.4929989947704245, 0.6211082824493583, 0.16474277933178305, 0.17400901945745995, 0.21597041748366486, 0.7975821518777173, 0.1660120844940538, 0.1644928041832382, 0.1986410999983016, 0.15367930740140268, 0.12490024201901762, 0.700168389627124, 0.1994309635148911, 0.18047303602999198, 0.18186518841951527, 0.19154087956349253, 0.1867153019214859, 0.17838396485061747, 0.18758825489235365, 0.2038765008442498, 0.18845011644688447, 0.08104094450885035, 0.08896702908603205, 0.0743484529211117, 0.0826450636888234, 0.0779166297084466, 0.08555146037841643, 0.08517392503493848, 0.08999369414962133, 0.08179661748610745]}, "mutation_prompt": null}
{"id": "fbf8781e-2fc5-49c4-8495-2ce349030324", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "aea6b766-9ab9-4eda-8100-6d3cd1c84f3f", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "71ad3188-797a-4aa1-b032-34805c516bf7", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "2c0f6626-ddea-4b60-a1d0-1829911aefba", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "079aaf50-8064-4ac4-bdef-37dadacbea75", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "6fe85093-a1b8-49e4-b32d-b403c52cc8c4", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def chaotic_sequence(self, size):\n        sequence = np.zeros(size)\n        sequence[0] = np.random.rand()\n        for i in range(1, size):\n            sequence[i] = 4 * sequence[i-1] * (1 - sequence[i-1])\n        return sequence\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=L.shape)\n        v = np.random.normal(0, 1, size=L.shape)\n        step = u / np.abs(v)**(1 / beta)\n        return L + 0.01 * step\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            if self.archive:\n                d = self.archive[np.random.randint(len(self.archive))]\n                mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n            else:\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            chaotic_factor = self.chaotic_sequence(self.dim)\n            mutant = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        mutant = self.levy_flight(mutant)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Incorporate chaotic sequences and Lvy flights to enhance solution exploration in Adaptive Differential Evolution.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {}, "mutation_prompt": null}
{"id": "8f6d60cc-9596-4b80-8ee7-cce06775bcb4", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5  # Adjusted initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []  # Archive for storing inferior solutions\n        self.dynamic_adjustment = 0.05  # New dynamic adjustment rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()  # Dynamic adjustment\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Dynamic adjustment\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Differential Evolution with Archive and Success-Based Dynamic Parameters for Enhanced Performance.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7854981268869449, 0.7962780996021366, 0.7853660405327159, 0.7881777966480009, 0.7935862806833089, 0.7448812544641439, 0.7939451812158737, 0.7741916043865494, 0.7417504424563581, 0.5950406925684372, 0.6022939749684059, 0.6109209959150246, 0.6188923796799732, 0.6151526146323276, 0.5954307572737284, 0.621899862147326, 0.6049656830013839, 0.5946176390842868, 0.11598995019653724, 0.11422827319764983, 0.11594840724631772, 0.11922939738850058, 0.11565104904639634, 0.1132310785433911, 0.12000136602660183, 0.11872478338039583, 0.12155394683861365, 0.08619954778025718, 0.09650656930501389, 0.10866651000789684, 0.11110876255226865, 0.09132767145972231, 0.08773186940730626, 0.08337261884298208, 0.09146669669633978, 0.08884285733702413, 0.24228811598072852, 0.24119771633605624, 0.24902403300604614, 0.23639985612047254, 0.21384685150541316, 0.22811716025761564, 0.20695136584883222, 0.24484573358875106, 0.2496322385348615, 0.1326238613353775, 0.13085255200550727, 0.1256742980210792, 0.10568742361935679, 0.12742093054086912, 0.14214588563495234, 0.17890313827022242, 0.1836944847884714, 0.1705542750634691, 0.7948173401924014, 0.7959805771108863, 0.7964205658642498, 0.8056250302286128, 0.7865417402786536, 0.790552288537632, 0.701455775102799, 0.7540732009542008, 0.796491504228063, 0.13507935084044842, 0.15739123893763096, 0.14326878353364414, 0.14141907244662866, 0.16608780545797985, 0.14530526660198206, 0.13529535624827638, 0.18953851716823855, 0.14692592221371636, 0.1505260264449918, 0.16080070562182702, 0.17230436084983958, 0.14519185642554877, 0.15517452779384255, 0.15428733834021602, 0.19344873193655854, 0.15981098611570765, 0.14232895291205316, 0.5605052433096448, 0.39004137008114537, 0.48375251228622806, 0.5275739566378228, 0.5459523152032291, 0.1916487924082052, 0.5592001562855715, 0.5692709120595325, 0.5477526285116832, 0.6130616082619478, 0.6446306277671541, 0.6178133076805536, 0.1243775281572207, 0.6272454816827389, 0.40910754836613805, 0.6274155922223127, 0.341456209024107, 0.6281535074113327, 0.13645306461441564, 0.20518194837831882, 0.1968246642646766, 0.20636750924006841, 0.16540867514132296, 0.24073730032004315, 0.2212651317707105, 0.2530551884320905, 0.15464364350252235, 0.4032463388823554, 0.4057274472596938, 0.4041418677053753, 0.3933394975576021, 0.37763442701350347, 0.4274313018862518, 0.3914406839479969, 0.38040242829663706, 0.29450513862827954, 0.734351753834642, 0.7374173171071235, 0.7191298688323716, 0.7601884464466331, 0.7244938597348933, 0.48170256587597693, 0.7398895610249641, 0.7326728281915691, 0.7326978504250912, 0.09853163579043722, 0.107731561964026, 0.11127706536280746, 0.10194411573108031, 0.10674699557669287, 0.11341298521059939, 0.10957547507921606, 0.10183613869812902, 0.10423885740807148, 0.1521292094237955, 0.19534499102898895, 0.12206148898305058, 0.15645032769036482, 0.12896464701772925, 0.13749959309277637, 0.15284596247327886, 0.16593384692305613, 0.1290417953607077, 0.4225270822870222, 0.42201462636605713, 0.42562590504766273, 0.4004108519649362, 0.4184237465026591, 0.42608279373517244, 0.4194146367852227, 0.4394459887043143, 0.43404642498587687, 0.32746989538409377, 0.326150973709014, 0.3213091030731553, 0.2906953770834416, 0.3443802349795624, 0.33194569466967494, 0.3501852416861775, 0.3117881447779254, 0.33713442499263657, 0.2133475382101322, 0.23127972760330062, 0.20674470879268014, 0.20718289173010584, 0.22060723113249014, 0.20405520600686333, 0.196140245939047, 0.2260153464511624, 0.24641952628969133, 0.17769123416162425, 0.18200752251478902, 0.18839588868567092, 0.18948518224107658, 0.17406386090342008, 0.17977684164478125, 0.17216017999765443, 0.17817098847518087, 0.18162909817882988, 0.6907783443149305, 0.18151736176155409, 0.7814591465596575, 0.18254051285400186, 0.7216018213429123, 0.1833834272066378, 0.38527495560432923, 0.6923159295988197, 0.45736431880988715, 0.6775200358532666, 0.21800490608918344, 0.6990246248988619, 0.19922548723738254, 0.19704563838412337, 0.15985049035113896, 0.14649887573932696, 0.21030069247573824, 0.20766875340987534, 0.2006821222447036, 0.183894410816144, 0.20140069576834851, 0.18965820116954923, 0.17659018615361388, 0.17874972542472478, 0.17543220324642894, 0.18500080494316773, 0.18860532796009621, 0.08603198853682792, 0.0808536598336792, 0.08130244319207292, 0.08894290257521809, 0.08878015248497229, 0.07342332094728476, 0.08699680827337108, 0.08731988904725674, 0.08281590759216417]}, "mutation_prompt": null}
{"id": "b5a562b0-606b-4212-abfe-9a6bb2c1a497", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.learning_memory = []  # Memory for adaptive learning\n        self.min_population_size = 4  # Minimum population size\n        self.evaluations = 0\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adjust_population_size(self):\n        if self.success_rate > 0.5 and self.population_size > self.min_population_size:\n            self.population_size -= 1\n        elif self.success_rate < 0.2 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.learning_memory.append((self.population[i], trial))\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                else:\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n            self.mutation_factor = 0.5 + self.dynamic_adjustment * np.random.rand()\n            self.crossover_rate = 0.7 + (1 - self.dynamic_adjustment) * np.random.rand()\n\n            self.adjust_population_size()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer_v2", "description": "EnhancedADEOptimizer_v2: Integrating Adaptive Population Sizing and Learning Memory to Dynamically Adjust Strategies for Improved Optimization.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedADEOptimizer_v2' object has no attribute 'success_rate'\").", "error": "AttributeError(\"'EnhancedADEOptimizer_v2' object has no attribute 'success_rate'\")", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {}, "mutation_prompt": null}
{"id": "fba67b89-9534-4935-8676-51dd7d902498", "solution": "import numpy as np\n\nclass EnhancedADEOptimizerPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.diversity_threshold = 0.1  # New parameter for diversity handling\n        self.no_change_counter_limit = 50  # For stagnation detection\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n        # Ensuring mutation diversity\n        if np.random.rand() < self.diversity_threshold:\n            mutant += np.random.normal(0, 0.1, self.dim)\n\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        no_change_counter = 0  # Counter for stagnation\n\n        while evaluations < self.budget:\n            prev_best_fitness = self.best_fitness\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        no_change_counter = 0\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    no_change_counter += 1\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n            if no_change_counter > self.no_change_counter_limit:\n                self.initialize_population()  # Reset to introduce diversity\n                no_change_counter = 0\n\n        return self.best_solution", "name": "EnhancedADEOptimizerPlus", "description": "EnhancedADEOptimizerPlus introduces population diversity preservation and adaptive mechanisms to improve exploration and exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.09228295893409381, "feedback": "The algorithm EnhancedADEOptimizerPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.1607765621811773, 0.1855543726229062, 0.16790906972833108, 0.14539855826641213, 0.183812567081735, 0.13620238001997664, 0.13831079356599763, 0.1468132392257081, 0.15391354715025696, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046026611625560876, 0.032786288908365324, 0.04995928316919984, 0.04483791726331843, 0.03321040276703646, 0.034836822530850964, 0.04047290649520652, 0.02517802962106619, 0.037671341916618806, 0.03680089334052283, 0.02835221740192906, 0.029664367022227633, 0.021390047163232673, 0.01918820539721733, 0.03481690175963448, 0.017539932688373505, 0.026079685491442017, 0.026022229974334232, 0.1362062831928551, 0.7163005778089486, 0.19832831398351247, 0.11221534582608839, 0.17478080392330198, 0.7490202348151642, 0.1254303798039722, 0.14339200768954707, 0.15747082490603537, 0.05670345939198085, 0.08551086737311397, 0.07034360157214448, 0.05946983672077344, 0.07283138997089356, 0.052081460894532916, 0.07720042380804792, 0.05195554070098929, 0.07261587036966466, 0.11990143414393661, 0.0969896514975056, 0.12448047101085835, 0.08199157197293372, 0.12286436423115699, 0.11146398682179715, 0.09306846291119841, 0.17196201767245856, 0.10369336657382244, 9.999999999998899e-05, 0.00016209704168468342, 0.004155090139891904, 0.0007647902074983115, 9.999999999998899e-05, 9.999999999998899e-05, 0.004139549018660871, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014437591012829154, 9.999999999998899e-05, 0.005465500792304012, 0.009868148973473767, 0.01628663361874516, 9.999999999998899e-05, 9.999999999998899e-05, 0.020833997848475727, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036772137373961455, 0.0234424849386925, 0.0701545903595645, 0.06990156057131902, 0.06005799811041035, 0.026891802570515377, 0.048223211843547276, 0.014500561611005103, 0.046563173536687597, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16808309406490174, 0.17172812575786123, 0.1837277922742374, 0.19782329134400156, 0.16544488110807776, 0.16390433182134312, 0.1784626428535483, 0.16546461247078892, 0.193652574060023, 0.03491925583313571, 0.04023386724794109, 0.03046593314188062, 0.030501862514471734, 0.05150382541009024, 0.05065710853394778, 0.037722065611525246, 0.0667760404735398, 0.040651631680036604, 0.1482011369561098, 0.1432377872265752, 0.13652231414870697, 0.14924901576111294, 0.1309024064190435, 0.17447308729234978, 0.14899272430766364, 0.16373386622554786, 0.12418003246169551, 0.1479495463809839, 0.14925232892671414, 0.15937849287598693, 0.16205856904687022, 0.16044064164685967, 0.17197905484913556, 0.15654385686253192, 0.16563088328970366, 0.15072718640426175, 0.10649055461723678, 0.09451370577431994, 0.09964312350677262, 0.09959579133377228, 0.13479010798106605, 0.10492771334025075, 0.10982222341940906, 0.10695316157447832, 0.09812352054439366, 0.14769827113279166, 0.16486196433317568, 0.14205007734933572, 0.15465659434489643, 0.14265582259037857, 0.13604417277090908, 0.17139953750808723, 0.17605057355604892, 0.16732087562464604, 0.13325854857432717, 0.16852263004972534, 0.14659054431179208, 0.12262720009905248, 0.1542488999292695, 0.14358752409834397, 0.1429590522980847, 0.14797854145341882, 0.11351458638933787, 0.17692616365143554, 0.16135502432444504, 0.13654193295915318, 0.15564380339505735, 0.15330741738108478, 0.14332864333383366, 0.1665245034674634, 0.13424173289188435, 0.15896644955574024, 0.2909984364937396, 0.14202828224782038, 0.1314447716083419, 0.15432155383927637, 0.11921201032643258, 0.16481875405314328, 0.12850983372341818, 0.1646994920068957, 0.1670309236557388, 0.18158210044737988, 0.19595804878384337, 0.18219232810570551, 0.18257775904218032, 0.18876637402478325, 0.18519250503650553, 0.1829897583712352, 0.17492914362617062, 0.20785675722381813, 0.06035132567832824, 0.047367485517082475, 0.04843582381133982, 0.053454681204943344, 0.05894960337578525, 0.043602782844226584, 0.045677618925971775, 0.04727974672549551, 0.044069560692445164]}, "mutation_prompt": null}
{"id": "1e8cb351-b7fd-4e05-83cf-9c77a19f9ecc", "solution": "import numpy as np\n\nclass EnhancedDynamicDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.memory = []  # Added adaptive memory to store best solutions\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n                    self.memory.append(self.best_solution.copy())  # Store best solution\n\n    def mutate(self, target_idx):\n        indices = np.arange(self.population_size)\n        indices = np.delete(indices, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        if self.memory:\n            e = self.memory[np.random.randint(len(self.memory))]\n            mutant = np.clip(mutant + 0.1 * (e - a), self.lower_bound, self.upper_bound)  # Selective learning\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    if self.fitness[i] != np.inf:\n                        self.archive.append(self.population[i].copy())\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory.append(self.best_solution.copy())  # Store new best solution\n                    self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                else:\n                    self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                    if len(self.archive) > self.population_size:\n                        self.archive.pop(0)\n\n                self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n        return self.best_solution", "name": "EnhancedDynamicDEOptimizer", "description": "Enhanced Dynamic Differential Evolution with Adaptive Memory and Selective Learning for Improved Convergence.", "configspace": "", "generation": 26, "fitness": 0.25076926449199183, "feedback": "The algorithm EnhancedDynamicDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.18.", "error": "", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.6825445427494701, 0.708809606324108, 0.6747338028582661, 0.6460989004453812, 0.6650666957183156, 0.6110779034519986, 0.6729157749813637, 0.3865085879954291, 0.678481960069616, 0.3127707252172539, 0.3238198634324606, 0.3316759566951748, 0.37374112439732954, 0.3867612480160536, 0.11209208166968765, 0.2551673100213928, 0.17655757850998366, 0.27185084000764714, 0.13656635039514864, 0.11169323561563538, 0.1082369321091271, 0.10545285108543467, 0.11724540590087107, 0.11192072245395124, 0.12069086440063548, 0.12969203089860581, 0.10299327523433499, 0.08900411744087033, 0.08434050891939748, 0.10371037894820223, 0.08883257959281343, 0.08941346597628763, 0.08928971478773218, 0.07172155697942528, 0.09014885845079712, 0.09504114889627324, 0.17447970246594302, 0.17018604339030952, 0.13569933956979985, 0.16084138355498967, 0.1579756893866111, 0.13430706999383424, 0.16892873829805444, 0.13778178626793391, 0.13239764353088246, 0.10582394356533764, 0.13617459280427124, 0.12065156194832338, 0.11027472080650347, 0.1164193102671992, 0.10621677656618611, 0.1524553164883693, 0.1343820142376948, 0.19222273259833578, 0.7160690169043005, 0.7556611087427012, 0.7321240216551963, 0.7618283783273777, 0.7291490226149392, 0.7860606508870447, 0.3103574497232612, 0.273248360282188, 0.6444552356093696, 0.14070417140721947, 0.17287753939778472, 0.1596854217358541, 0.15167095701865618, 0.2242690734051873, 0.2081416757903206, 0.16128518187442964, 0.1718851082060453, 0.20742533535334784, 0.144163952077903, 0.1777128490370946, 0.16327299061540357, 0.14534177174625584, 0.13894632311846367, 0.1585133490714732, 0.19667437129576604, 0.16084973342132158, 0.17085815122565473, 9.999999999998899e-05, 0.19249639449020128, 0.22851535109464216, 0.30717173304979595, 0.27846563212071784, 0.11770647479550311, 0.3671404565380417, 0.07975516256645154, 0.25643654169731445, 0.419719513604486, 0.4456261791069379, 0.48031620640621797, 0.23067951306028744, 0.2211374091491406, 0.11716176214364915, 0.4226750144821615, 0.2858475494802234, 0.24911763686657296, 0.08263072408503958, 0.11486992633884219, 0.0710393640272794, 0.058123712686350304, 0.10630750385925258, 0.09498148939052009, 0.07610984267557219, 0.06600929691754465, 0.1144905309829013, 0.12570734066471012, 0.2330305118672924, 0.2138497436746133, 0.18833614449203528, 0.18287804096112847, 0.22499621860847097, 0.21206567588963243, 0.20728821731099134, 0.10112946679166257, 0.5835232093445031, 0.5524838799327881, 0.5522865788087719, 0.520999491338049, 0.5497163444293549, 0.5461473311259882, 0.5579771492757853, 0.5594045204934166, 0.5800597826311289, 0.10668654507107989, 0.12218354646647533, 0.08799105514023686, 0.10159128986717236, 0.08996118265174446, 0.09635842492106661, 0.1037125958687386, 0.11525031930861496, 0.11659676733541402, 0.15940128653418584, 0.17061874688954282, 0.14362885507057022, 0.15437520326593968, 0.16628713428329722, 0.1510414096443825, 0.1324736133122404, 0.14622340486649787, 0.14521580310492122, 0.3005838852339028, 0.2973162537351518, 0.3262981919052155, 0.3309169633656841, 0.37268435894332086, 0.3187440088160999, 0.3066287557972228, 0.3449464214745158, 0.293417181888616, 0.26954656985173764, 0.24604556296389113, 0.25726536290966395, 0.2650153975594324, 0.2930309238934422, 0.28772137085113814, 0.274578956401653, 0.2980054179208811, 0.24007207223899685, 0.22735261479274227, 0.21461121655100546, 0.20864224715398105, 0.20136351364049887, 0.20823930313694838, 0.20072229363760097, 0.2270973692764494, 0.2094910788345452, 0.2048108134477491, 0.18354095077906418, 0.1717624570731081, 0.17731644387633527, 0.17844517830280016, 0.19731149075990762, 0.1775484985217658, 0.17376221179879536, 0.1814784377004266, 0.17922369676380934, 0.2673632115108079, 0.6956478742080687, 0.727286635743043, 0.22182047361490054, 0.5909744273719916, 0.543532276458334, 0.6389460132306644, 0.15137377881600989, 0.4541857595489771, 0.3851846892638947, 0.40661040049041597, 0.3958894237346037, 0.5321082501616311, 0.1991733762466562, 0.16390299152473964, 0.20419634771365347, 0.20145392612879165, 0.20210635253481424, 0.18722457535172699, 0.1902355724484922, 0.18492880580148907, 0.19539288046813164, 0.18455888251934294, 0.18939281666699959, 0.18535228531601433, 0.18474124714281126, 0.18991440634847134, 0.07808331454375694, 0.0842388991642703, 0.08272625262378375, 0.08584907576345324, 0.09321628321942865, 0.07458510928915474, 0.07836423356008548, 0.07932161145755612, 0.07751537869546332]}, "mutation_prompt": null}
{"id": "eb76d8a6-ba16-4231-8020-859b57bc38e6", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = 5 * dim  # New island model setup\n        self.num_islands = 2  # Introducing island model\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        # Introduce migration between islands\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Island Model for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 27, "fitness": 0.3265188282662888, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "7c92e787-24d2-45f1-97b1-d8919bdf199a", "metadata": {"aucs": [0.7929951845817022, 0.7837934006878865, 0.7822796523603337, 0.7585498998159714, 0.7168773308733365, 0.7080247919013243, 0.7846131861148478, 0.7694681815994835, 0.7643043429250183, 0.5946980934889776, 0.5915832271838116, 0.6007408721146188, 0.5816447007225756, 0.6040294700259998, 0.6074855238831196, 0.5968793597796229, 0.5847480998454583, 0.5344321450518319, 0.111286537517159, 0.11665315988214375, 0.1175937047639074, 0.10771498764871634, 0.12827011364577023, 0.10743948514713952, 0.11978096849291764, 0.10445226533263907, 0.10548226605229616, 0.09305510310894693, 0.08913440188953758, 0.08705755095014278, 0.08457632611756294, 0.09502027545357705, 0.09446774647741074, 0.09050436059755262, 0.0944323440560314, 0.0933380567126143, 0.9206166284126098, 0.7648438307935856, 0.25219283751709687, 0.2796827836597021, 0.2627807922854185, 0.31688311159123306, 0.2526116515141723, 0.25459475557047295, 0.3533698098750637, 0.18190094977395121, 0.19096600233462757, 0.12505287820568523, 0.10454416709260606, 0.17162586657216194, 0.17752296793546263, 0.14929738744078347, 0.1912545114234061, 0.2005049590652579, 0.7719222750431669, 0.7612864123667572, 0.78977899681998, 0.7844286918006673, 0.7839401097884844, 0.770464954073135, 0.7821356588477252, 0.7809068876242958, 0.7616487011423377, 0.1428332456282354, 0.1566694952241513, 0.14835502029485037, 0.15041044795948078, 0.13677129110041186, 0.1417130372555443, 0.159074679108129, 0.1727324031106604, 0.14824292415731766, 0.1635036620244399, 0.14018139620339576, 0.1784384447680566, 0.17027301423762198, 0.15529034222710814, 0.15607645652684732, 0.14492190647849745, 0.16951182001084997, 0.15728373426995568, 0.44625552656190726, 0.48716977469577616, 0.37311955471156866, 0.5412402442269273, 0.5117124285856001, 0.497760781398476, 0.5445509437775742, 0.5054353448302134, 0.4755906015414638, 0.6199376681309543, 0.5934297352146569, 0.6029058562658197, 0.5310081174464074, 0.3366798368036502, 0.4164832905622988, 0.5914970537621079, 0.5934560391178163, 0.6179305713049634, 0.15279551770677535, 0.157990429340085, 0.16031280771350287, 0.24127541874962022, 0.2597458608079344, 0.19609628602942297, 0.1595007001710057, 0.17967406408080255, 0.16398043705983, 0.3618914682800123, 0.3259391946043769, 0.35405828355661606, 0.3747930965936227, 0.3530275875739429, 0.3827749408189103, 0.3601697319510404, 0.36934760698329705, 0.3507803378465131, 0.7327834230809158, 0.7259268563253478, 0.7368721210432574, 0.7192396141832658, 0.7299410514827942, 0.6939728169960673, 0.7088911387632915, 0.7284726316852042, 0.7200742263359838, 0.09818722894873977, 0.11153594409191248, 0.10406717413746536, 0.11126501193060778, 0.11463577804566571, 0.1054427315376637, 0.10201344513355926, 0.11886004503995895, 0.098855947649649, 0.13544384031919976, 0.13016538435860747, 0.16446458893535165, 0.13796344205352784, 0.12713881623090129, 0.1423674632811075, 0.1455831317513303, 0.1346166697158424, 0.13857598216873268, 0.40495939642987355, 0.4068198185322176, 0.3791371589720336, 0.410449345047743, 0.3875730119916837, 0.4063744345336836, 0.38436924372613945, 0.40615490160685674, 0.3955881589710576, 0.30940016888843924, 0.2999141954086283, 0.31726107021459216, 0.3068955132369693, 0.3096954976017663, 0.30540271612937964, 0.31855066871499516, 0.3269264123661838, 0.3356266426882252, 0.20256725038754075, 0.2103169749601156, 0.21683335776484614, 0.22882440754324862, 0.2304721896915758, 0.2052615268249144, 0.2100596549329734, 0.22303843652378508, 0.23571305497507866, 0.1809861971957767, 0.17570164237427377, 0.1692168820349358, 0.169936047350001, 0.18796105459205448, 0.19025187157820578, 0.18429999737989122, 0.17433308366039324, 0.17509808504517277, 0.7000353443220216, 0.28483387286844386, 0.20313167392846687, 0.21220836591931724, 0.6725350720116592, 0.583932780064981, 0.5952678892760381, 0.17532766249253784, 0.4697759873489862, 0.2010162208133428, 0.20016815991011105, 0.22764357955066206, 0.452399608460997, 0.1954471887830408, 0.5905781864502069, 0.20026605664832875, 0.11092144409193028, 0.19083761317944625, 0.177594820434254, 0.1804049900512631, 0.1930069031141205, 0.20019394569319848, 0.19058926284483346, 0.17612005314831025, 0.18069789668586567, 0.19137056755448023, 0.1752841899505534, 0.08956626502835263, 0.09249617240819175, 0.0854722067090643, 0.08121617872334952, 0.08942611255047506, 0.08533401793553819, 0.0921605188852136, 0.08399287705309177, 0.08072049076363796]}, "mutation_prompt": null}
{"id": "33c2e578-e2b9-4485-a3c8-f68f497e1dbb", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = 5 * dim\n        self.num_islands = 2\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.migration_interval = 10  # New migration interval\n        self.mutation_adaptive = True  # Use adaptive mutation\n        self.current_generation = 0\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        # Enhanced migration with adaptive frequency\n        if self.current_generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    # Adjust mutation factor adaptively\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    if self.mutation_adaptive:\n                        self.mutation_factor *= (1.0 + (self.current_generation / (self.budget / self.population_size)))\n\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n                self.current_generation += 1\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Island Migration and Adaptive Memory Utilization.", "configspace": "", "generation": 28, "fitness": 0.18352896869486895, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.13.", "error": "", "parent_id": "eb76d8a6-ba16-4231-8020-859b57bc38e6", "metadata": {"aucs": [0.45075677478131093, 0.4727616142098976, 0.44388831175371335, 0.41477893026354606, 0.40296283788501763, 0.40789622565751593, 0.4247258994360259, 0.40863142884281867, 0.3654891084336509, 0.12853851077119183, 0.14667669829402785, 0.1430582223318999, 0.18298977719731546, 0.12776421759435175, 0.15044581206021757, 0.13377338688839957, 0.14288564317300845, 0.1670412676787828, 0.09112464340351256, 0.09556373386087946, 0.09575011772410924, 0.08562999997641141, 0.0861552589431247, 0.08660588895203059, 0.08208294703823904, 0.09186886056221644, 0.08722335022536243, 0.0784024805157909, 0.080334133299785, 0.07997245876224202, 0.0731490251369481, 0.07921629483406756, 0.07991361460242696, 0.06866939371742031, 0.06696519553541058, 0.06787035218405146, 0.4233235464429699, 0.6165750034778146, 0.5372171534279713, 0.6841955889906046, 0.48873567324023703, 0.4908374061570867, 0.48668858560884254, 0.8765832208199703, 0.6287536874836204, 0.1449810540016233, 0.14296929921186818, 0.14666454998457845, 0.16474212886955375, 0.14708816655593038, 0.15724885314933257, 0.1505267834554035, 0.1768120999463132, 0.15355922037845338, 0.2936351957935788, 0.25990866300801485, 0.2672257876131304, 0.28134344567771896, 0.29412274638523317, 0.2757261103449028, 0.3194171786571586, 0.2920554361171327, 0.27210704214692105, 0.1324015637695768, 0.13104514052980665, 0.1491190091472494, 0.1465138837654837, 0.13514726548162959, 0.11782912071917728, 0.12526495428330853, 0.12350806473921494, 0.126565287642325, 0.1482923205321287, 0.14446499601601648, 0.11759470245126813, 0.13066237794419033, 0.11775825337294377, 0.13319302049488047, 0.14435809706457225, 0.16105573781597926, 0.10800250267897304, 0.044295784971393526, 0.048951584140555116, 0.06986162148698072, 0.04524001690058177, 0.060006805419874354, 0.05197429853025115, 0.05162013163410972, 0.06355742657731933, 0.06610889305866585, 0.18078601453820375, 0.20844258660038706, 0.18096579471222485, 0.16476315916673323, 0.1439382544421436, 0.18173770038847703, 0.22356946904199704, 0.1787168464204011, 0.1941480968432555, 9.999999999998899e-05, 9.999999999998899e-05, 0.010634240294848718, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1047825799437313, 0.08944853138356978, 0.1061544797668319, 0.08755267140809975, 0.10080035090494277, 0.09427857839709763, 0.10048019808692754, 0.09230187470793227, 0.07119346171281726, 0.3821690900558401, 0.402171878113485, 0.37898339397194036, 0.3607610888918451, 0.36974482957703037, 0.3870333142871356, 0.35090581216238403, 0.3933972886658581, 0.3883262184830887, 0.08517571066771157, 0.09393379714127914, 0.07586616189917383, 0.08690899855901912, 0.07875003384003854, 0.08087638197509861, 0.08272712729647069, 0.07678458089411233, 0.08393740406951788, 0.15343335896902122, 0.13795358533793622, 0.13697993037098022, 0.13241205679270385, 0.12896979941067088, 0.14540353945330553, 0.1867826968860531, 0.15113701959201586, 0.13147909166560678, 0.24691642669375846, 0.22686593569440794, 0.2244669949431155, 0.2544460702074198, 0.21642939934672345, 0.2208897332095735, 0.2347975843324377, 0.2306995584714263, 0.2503049525176735, 0.17987263974338674, 0.21026193014503958, 0.1943156442651084, 0.17849932757083675, 0.17128866572506563, 0.1720508081641614, 0.17072057040979238, 0.16664317031556553, 0.16013874452417254, 0.18280366869284648, 0.16965102617037464, 0.23108434502328679, 0.20564358152468343, 0.21207920792128254, 0.19195164201187986, 0.17988368300011937, 0.18350290914237555, 0.180452308131979, 0.16850992760053163, 0.1768253683804487, 0.17226668938394274, 0.17760265742541248, 0.17330057024490997, 0.17277881673647522, 0.17665426939295648, 0.16840343284017922, 0.17495480455720824, 0.3014306531774673, 0.19861834403871104, 0.15906892774900827, 0.17284880792615787, 0.18415028749027407, 0.27221740339207623, 0.15305134159572864, 0.1855182119262877, 0.22492264796899464, 0.18390417382677615, 0.2065993723432814, 0.24573216334396397, 0.1944686710793262, 0.17754542102844284, 0.225379934732027, 0.1862600407391144, 0.19183874490643216, 0.20054092321732075, 0.19877807555420957, 0.19723981442256022, 0.18561178697937109, 0.17599171243095157, 0.18569257488053237, 0.18694938717494392, 0.19562335874672476, 0.18158939079447167, 0.19517339223538055, 0.07460751448709524, 0.07582613346142297, 0.06921926642839515, 0.07409095199282734, 0.06912824469340872, 0.06809968747073747, 0.06972136889604386, 0.06721738490114093, 0.062146075168440396]}, "mutation_prompt": null}
{"id": "08a1418c-e4eb-4a4d-a961-6d0da7552810", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = 5 * dim\n        self.num_islands = 2\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.crowding_distance = np.zeros(self.population_size)\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def calculate_crowding_distance(self):\n        for i in range(self.population_size):\n            dist = 0\n            for j in range(self.population_size):\n                if i != j:\n                    dist += np.linalg.norm(self.population[i] - self.population[j])\n            self.crowding_distance[i] = dist\n\n    def migrate(self):\n        self.calculate_crowding_distance()\n        for i in range(self.num_islands - 1):\n            swap_idx = np.argmax(self.crowding_distance[i * self.sub_population_size:(i + 1) * self.sub_population_size])\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Island-Based Differential Evolution with Dynamic Crowding Distance for Enhanced Diversity and Convergence.", "configspace": "", "generation": 29, "fitness": 0.32389518511409965, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "eb76d8a6-ba16-4231-8020-859b57bc38e6", "metadata": {"aucs": [0.7967463456065881, 0.7937039334901853, 0.7796116750489366, 0.7645947927060438, 0.7356867981954452, 0.7583957413020952, 0.7762691730812181, 0.7471326109505164, 0.730258437376428, 0.5899419941417863, 0.590899461039804, 0.6116884185987481, 0.5846626376120432, 0.5959569932250244, 0.6198267001948555, 0.5722007719289046, 0.6049063651219371, 0.5634305199067013, 0.1145405782984753, 0.11124266857637177, 0.13550844225699699, 0.13342238653432814, 0.10955988812576511, 0.13388053613690132, 0.14418368199217402, 0.12204126313355279, 0.11023273775727505, 0.09004797236756112, 0.08791396195573875, 0.09281574884320054, 0.09219810337340273, 0.08496319650732753, 0.09248459440888945, 0.09696409256939642, 0.07935707609952913, 0.09340776271205964, 0.22859209156767968, 0.25778900309155883, 0.24124725872171615, 0.21782536480119574, 0.2617170495257237, 0.2784943638071308, 0.24503711930752659, 0.28797593574431635, 0.8577132353253539, 0.12255572778689128, 0.1696361272832395, 0.18687162193978357, 0.11643876646146423, 0.1486379208980505, 0.16710569489453597, 0.19434829186544667, 0.15912057164246396, 0.18057188455938833, 0.7909224456584792, 0.7848509784043443, 0.7735733219689847, 0.7939658564363512, 0.774335722205014, 0.8064720459908021, 0.7746448393824348, 0.7696202991696467, 0.8077444247239438, 0.14880474614354278, 0.15496283377263664, 0.13196683711807433, 0.13495718900060694, 0.16753116091576958, 0.16385045399549092, 0.15916733220625445, 0.1616180440167445, 0.16581098881267464, 0.16045188317870418, 0.13599446033026086, 0.14260760725496513, 0.17806026014392373, 0.1659682742950641, 0.1428738859514671, 0.13695459853468528, 0.19291009174870566, 0.16333849757628993, 0.3426704467964775, 0.4488048691573755, 0.4937106061502057, 0.541412804727424, 0.5177254589882385, 0.4788549659106056, 0.5111101346110976, 0.1996068952663934, 0.5262462821290446, 0.6098099311290676, 0.623125938833494, 0.6350162067667975, 0.5958042964169464, 0.5442437641351718, 0.15023842349110184, 0.6312196650401118, 0.4488803019168176, 0.6368023274455987, 0.22912493097598985, 0.17039277294836652, 0.14608250282365554, 0.3242614620966615, 0.2517852573663629, 0.1960147130038784, 0.19714207281051987, 0.18660690306706607, 0.18422296418019857, 0.37534744818087906, 0.37746866220572284, 0.3905981425253813, 0.37269274753337145, 0.3546445470043238, 0.38496614795659967, 0.32355254248948906, 0.31818468458662585, 0.3391579120611986, 0.7265950479865761, 0.6456594609406499, 0.7163578950727711, 0.5740597806987853, 0.7199847079273218, 0.6957355411986543, 0.741726532163224, 0.723868344084948, 0.7212256686311707, 0.11422776974185922, 0.11217386113057892, 0.11933952095668576, 0.09743944733760868, 0.08975228964547766, 0.11664028085403311, 0.12055656747408194, 0.10388039658426373, 0.10348056999528321, 0.13713377968770113, 0.13270405021843312, 0.13096362139997075, 0.13486203502179628, 0.13851511316422382, 0.13391907693947047, 0.13204749623714507, 0.14053609769365938, 0.13250864039458743, 0.41240425263406644, 0.4102892953180569, 0.4087463730703367, 0.421954639502665, 0.42514429579085145, 0.4264567184393414, 0.41177327041615885, 0.3927089451945016, 0.4128001523906164, 0.31913932185884375, 0.3356362158388597, 0.32623224875749, 0.3398745225152042, 0.33134294153731547, 0.2949209588867089, 0.34776734618170546, 0.3090995176938405, 0.3036545196610224, 0.21041199212551298, 0.22278140900212284, 0.20560812908553605, 0.2339829085701296, 0.20116072742212576, 0.2029588552322572, 0.20188159991585375, 0.21143612211940022, 0.21021130617409578, 0.1888057123856881, 0.1844746468296461, 0.17399957830816315, 0.18019192970662368, 0.17422741469629976, 0.17710735515380926, 0.18729107287537117, 0.17342051045381346, 0.1725011575527835, 0.18132393995615081, 0.7707385349310443, 0.17634316319421373, 0.6127153533532197, 0.6660704670398441, 0.3157941289680355, 0.5179648205891212, 0.708496878830587, 0.1677495088283767, 0.1972758677841756, 0.20416893041392814, 0.6669223666057141, 0.19880946726198623, 0.2093084253687041, 0.18080529181278404, 0.19713814347424352, 0.35363819694259924, 0.20560472247387085, 0.17477631022018436, 0.1916303045736073, 0.18868492087111566, 0.1802332795415612, 0.1956097758884071, 0.1840763010266192, 0.18855173721187146, 0.17366419409824374, 0.18036986591379078, 0.09520504883259395, 0.08427507667176759, 0.08007258282818841, 0.09373298005151987, 0.0781683346966412, 0.08136259629470421, 0.08955287312720683, 0.08916334413692129, 0.07922579229041782]}, "mutation_prompt": null}
{"id": "56b2e641-ee8f-40b3-9a92-a81109de3fe4", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = 5 * dim\n        self.num_islands = 3  # Increased number of islands\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.7  # Higher initial mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.migration_rate = 0.2  # New migration rate control\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive:\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        # Randomized migration between islands\n        for i in range(self.num_islands):\n            if np.random.rand() < self.migration_rate:\n                source_idx = np.random.randint(0, self.sub_population_size)\n                dest_island_idx = np.random.choice(\n                    [x for x in range(self.num_islands) if x != i])\n                dest_idx = np.random.randint(0, self.sub_population_size)\n                source_island_start = i * self.sub_population_size\n                dest_island_start = dest_island_idx * self.sub_population_size\n                self.population[[source_island_start + source_idx, dest_island_start + dest_idx]] = \\\n                    self.population[[dest_island_start + dest_idx, source_island_start + source_idx]]\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.4 + self.success_rate * np.random.rand()  # Adjusted range\n                    self.crossover_rate = 0.6 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Randomized Island Communication and Adaptive Parameters for Improved Convergence.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 68 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 68 is out of bounds for axis 0 with size 50')", "parent_id": "eb76d8a6-ba16-4231-8020-859b57bc38e6", "metadata": {}, "mutation_prompt": null}
{"id": "68cc3336-8235-47d3-ba26-75e7cac636d3", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)  # Dynamic island size\n        self.num_islands = max(1, self.population_size // self.sub_population_size)  # Dynamic island count\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive and np.random.rand() < 0.5:  # Reinforced diversity with archive usage\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Island Size and Reinforced Diversity for Superior Balance and Performance.", "configspace": "", "generation": 31, "fitness": 0.3875941586408021, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "eb76d8a6-ba16-4231-8020-859b57bc38e6", "metadata": {"aucs": [0.7786795625615666, 0.782839751029915, 0.845736926547094, 0.7756774182624969, 0.7612211053616394, 0.8553120725231607, 0.7583536871827146, 0.7828096863485887, 0.8673599587611345, 0.5903658521939935, 0.5685873421864466, 0.7651559497626321, 0.6054447400180938, 0.5893635029910967, 0.7667006301980935, 0.586173318996829, 0.5987217878640485, 0.7698882093886523, 0.1025785597144504, 0.10845719419540578, 0.1400574619329623, 0.09830575914709039, 0.11369053052625822, 0.13452153961009594, 0.11331383349711543, 0.1120669935633718, 0.12327962903016909, 0.09211151901703074, 0.09450610891112299, 0.12169099501264902, 0.09541994073427429, 0.0954181913451353, 0.10184486537712856, 0.0932046904401157, 0.09384006403978806, 0.0966949884327789, 0.7291757796864998, 0.9474780229575087, 0.7797147497127013, 0.7927657331790345, 0.774472437803218, 0.910957465585182, 0.8334676487033209, 0.5347513685451819, 0.9771467447007507, 0.32706439236802676, 0.32683563858645903, 0.35230838755828986, 0.31265746011099593, 0.3483656944142848, 0.41192022321859334, 0.34276293640856537, 0.3334247063074318, 0.1759319331450513, 0.7921217950125583, 0.7707031624827557, 0.8511072828720243, 0.7455968656000549, 0.7797938117585378, 0.8787970506983165, 0.7467761081943499, 0.8379220886714938, 0.8838950245004201, 0.25012602277489027, 0.18663267747214274, 0.15030516359212875, 0.21653286942430472, 0.22106525543614375, 0.18316118414156413, 0.27428520823088, 0.172260743717778, 0.1938472160787864, 0.17192371072734391, 0.21875595485941013, 0.17436581340148072, 0.16455106213364523, 0.27454154214739734, 0.1673293373566459, 0.2055375632113342, 0.1925009146511254, 0.15402583845471962, 0.5121307113321613, 0.5015117534613878, 0.717565710125837, 0.5353592814052132, 0.47855063172390133, 0.6946901725936863, 0.4586713176705708, 0.5189932202693408, 0.6801900845189297, 0.6121752323215262, 0.6024302887991009, 0.7675175176105523, 0.5790464465835583, 0.5871503593116465, 0.7672802862936962, 0.6398785808656184, 0.6117202774914672, 0.775717728492691, 0.18717590020873598, 0.13477480973920153, 0.1849781733170507, 0.34144862757123295, 0.3292489326996625, 0.18068781670239753, 0.22068518226751788, 0.14623017390322657, 0.2496747137393841, 0.3504205069955667, 0.3678475178254085, 0.6080981602099309, 0.37202935302519735, 0.3667973861612195, 0.6207071698574771, 0.37967498054424464, 0.3631097591303746, 0.6234707678563145, 0.692326765444723, 0.7077141639269737, 0.834670711156692, 0.6906301099852727, 0.7054975801397961, 0.8245661655610896, 0.7044074464831501, 0.710765243365729, 0.5317111488814936, 0.09898055816339035, 0.1016417240487264, 0.11119176259125452, 0.10488950448198697, 0.09865625822270196, 0.13236995229720339, 0.11165115410386606, 0.10094717822640364, 0.12556401771676118, 0.17357950245404896, 0.16190162490624171, 0.18280205042332298, 0.15550556190710207, 0.13703074880561927, 0.1591469152677062, 0.13133742175435015, 0.1398289576050673, 0.13792471188072397, 0.39271534656433016, 0.3612474367458419, 0.5643791589114331, 0.3955229194127182, 0.3996690116103089, 0.5800445883527261, 0.3908038868996071, 0.3665091823262212, 0.6055595858229528, 0.34101578337642036, 0.316400007735255, 0.4570720717997887, 0.30697478190129424, 0.3036130996143014, 0.505359692623862, 0.31882218230433446, 0.32189878525370264, 0.5800103792572331, 0.21031026936244546, 0.21075425869355202, 0.196750576181703, 0.20448016265525926, 0.19224664058984997, 0.23015704284829974, 0.1999945069792063, 0.19081112172976622, 0.20077463707115106, 0.18039257531546538, 0.18699627062341584, 0.20188790667080303, 0.17477450504919356, 0.1828815116282192, 0.21596442179949826, 0.1864269160544808, 0.1798399516080934, 0.5580762800618172, 0.15160418216146132, 0.6630363555702439, 0.7970148044977275, 0.18344714082948899, 0.5359376772917112, 0.8146134555870654, 0.5771198422359575, 0.5251758056685729, 0.8049501335784583, 0.202066409597494, 0.19977005286117677, 0.8481613171555179, 0.18912739705261028, 0.20066536783875655, 0.5125161498225291, 0.40981342888526184, 0.20118370656376472, 0.12759304180648923, 0.18715351370383193, 0.1971062809910592, 0.2044031203176997, 0.18289307231272744, 0.19304166481783946, 0.20401053673383862, 0.18702310547403833, 0.17467885137714578, 0.18468939539988927, 0.08816519018698488, 0.09064645892503598, 0.09545290630078429, 0.0789670789557616, 0.0783374619548537, 0.08818504086387424, 0.07935793267883151, 0.07878061907798861, 0.08857688217733317]}, "mutation_prompt": null}
{"id": "96b808c5-1328-4308-a201-eac942c3cdac", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)  # Dynamic island size\n        self.num_islands = max(1, self.population_size // self.sub_population_size)  # Dynamic island count\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if self.archive and np.random.rand() < 0.5:  # Reinforced diversity with archive usage\n            d = self.archive[np.random.randint(len(self.archive))]\n            mutant = np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Island Size and Reinforced Diversity for Superior Balance and Performance.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "68cc3336-8235-47d3-ba26-75e7cac636d3", "metadata": {"aucs": [0.7786795625615666, 0.782839751029915, 0.845736926547094, 0.7756774182624969, 0.7612211053616394, 0.8553120725231607, 0.7583536871827146, 0.7828096863485887, 0.8673599587611345, 0.5903658521939935, 0.5685873421864466, 0.7651559497626321, 0.6054447400180938, 0.5893635029910967, 0.7667006301980935, 0.586173318996829, 0.5987217878640485, 0.7698882093886523, 0.1025785597144504, 0.10845719419540578, 0.1400574619329623, 0.09830575914709039, 0.11369053052625822, 0.13452153961009594, 0.11331383349711543, 0.1120669935633718, 0.12327962903016909, 0.09211151901703074, 0.09450610891112299, 0.12169099501264902, 0.09541994073427429, 0.0954181913451353, 0.10184486537712856, 0.0932046904401157, 0.09384006403978806, 0.0966949884327789, 0.7291757796864998, 0.9474780229575087, 0.7797147497127013, 0.7927657331790345, 0.774472437803218, 0.910957465585182, 0.8334676487033209, 0.5347513685451819, 0.9771467447007507, 0.32706439236802676, 0.32683563858645903, 0.35230838755828986, 0.31265746011099593, 0.3483656944142848, 0.41192022321859334, 0.34276293640856537, 0.3334247063074318, 0.1759319331450513, 0.7921217950125583, 0.7707031624827557, 0.8511072828720243, 0.7455968656000549, 0.7797938117585378, 0.8787970506983165, 0.7467761081943499, 0.8379220886714938, 0.8838950245004201, 0.25012602277489027, 0.18663267747214274, 0.15030516359212875, 0.21653286942430472, 0.22106525543614375, 0.18316118414156413, 0.27428520823088, 0.172260743717778, 0.1938472160787864, 0.17192371072734391, 0.21875595485941013, 0.17436581340148072, 0.16455106213364523, 0.27454154214739734, 0.1673293373566459, 0.2055375632113342, 0.1925009146511254, 0.15402583845471962, 0.5121307113321613, 0.5015117534613878, 0.717565710125837, 0.5353592814052132, 0.47855063172390133, 0.6946901725936863, 0.4586713176705708, 0.5189932202693408, 0.6801900845189297, 0.6121752323215262, 0.6024302887991009, 0.7675175176105523, 0.5790464465835583, 0.5871503593116465, 0.7672802862936962, 0.6398785808656184, 0.6117202774914672, 0.775717728492691, 0.18717590020873598, 0.13477480973920153, 0.1849781733170507, 0.34144862757123295, 0.3292489326996625, 0.18068781670239753, 0.22068518226751788, 0.14623017390322657, 0.2496747137393841, 0.3504205069955667, 0.3678475178254085, 0.6080981602099309, 0.37202935302519735, 0.3667973861612195, 0.6207071698574771, 0.37967498054424464, 0.3631097591303746, 0.6234707678563145, 0.692326765444723, 0.7077141639269737, 0.834670711156692, 0.6906301099852727, 0.7054975801397961, 0.8245661655610896, 0.7044074464831501, 0.710765243365729, 0.5317111488814936, 0.09898055816339035, 0.1016417240487264, 0.11119176259125452, 0.10488950448198697, 0.09865625822270196, 0.13236995229720339, 0.11165115410386606, 0.10094717822640364, 0.12556401771676118, 0.17357950245404896, 0.16190162490624171, 0.18280205042332298, 0.15550556190710207, 0.13703074880561927, 0.1591469152677062, 0.13133742175435015, 0.1398289576050673, 0.13792471188072397, 0.39271534656433016, 0.3612474367458419, 0.5643791589114331, 0.3955229194127182, 0.3996690116103089, 0.5800445883527261, 0.3908038868996071, 0.3665091823262212, 0.6055595858229528, 0.34101578337642036, 0.316400007735255, 0.4570720717997887, 0.30697478190129424, 0.3036130996143014, 0.505359692623862, 0.31882218230433446, 0.32189878525370264, 0.5800103792572331, 0.21031026936244546, 0.21075425869355202, 0.196750576181703, 0.20448016265525926, 0.19224664058984997, 0.23015704284829974, 0.1999945069792063, 0.19081112172976622, 0.20077463707115106, 0.18039257531546538, 0.18699627062341584, 0.20188790667080303, 0.17477450504919356, 0.1828815116282192, 0.21596442179949826, 0.1864269160544808, 0.1798399516080934, 0.5580762800618172, 0.15160418216146132, 0.6630363555702439, 0.7970148044977275, 0.18344714082948899, 0.5359376772917112, 0.8146134555870654, 0.5771198422359575, 0.5251758056685729, 0.8049501335784583, 0.202066409597494, 0.19977005286117677, 0.8481613171555179, 0.18912739705261028, 0.20066536783875655, 0.5125161498225291, 0.40981342888526184, 0.20118370656376472, 0.12759304180648923, 0.18715351370383193, 0.1971062809910592, 0.2044031203176997, 0.18289307231272744, 0.19304166481783946, 0.20401053673383862, 0.18702310547403833, 0.17467885137714578, 0.18468939539988927, 0.08816519018698488, 0.09064645892503598, 0.09545290630078429, 0.0789670789557616, 0.0783374619548537, 0.08818504086387424, 0.07935793267883151, 0.07878061907798861, 0.08857688217733317]}, "mutation_prompt": null}
{"id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]  # Probabilities for two mutation strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def mutate_rand_2(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c, d, e = self.population[np.random.choice(indices, 5, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_1(target_idx, island_idx)\n        else:\n            return self.mutate_rand_2(target_idx, island_idx)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Multi-strategy Search and Improved Diversity Control for Robust Optimization.", "configspace": "", "generation": 33, "fitness": 0.4078542233931533, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "68cc3336-8235-47d3-ba26-75e7cac636d3", "metadata": {"aucs": [0.753914445845947, 0.7607421709679577, 0.8723585659187068, 0.77168778946172, 0.779979852528486, 0.8791619256127765, 0.7637539919479309, 0.7738542732983293, 0.8818608887224373, 0.5847799447381963, 0.5874511761972718, 0.7864219382321587, 0.5848529743428241, 0.590271640620517, 0.7881485614259377, 0.5915744190892062, 0.5729533213924918, 0.7887909369514692, 0.11040713121791668, 0.10443505833640065, 0.1450805050432069, 0.12077030086123797, 0.10131220399958651, 0.5406693349421186, 0.11876575916456844, 0.10484135807191775, 0.14508155455788196, 0.09549296596256152, 0.08741951540022097, 0.13868724894036333, 0.08721965221241412, 0.10256297100062761, 0.10477691015508572, 0.1056407179425698, 0.0900005620656239, 0.1066989065090096, 0.9440560421123306, 0.9668068570255623, 0.9860007362206574, 0.9573107768841729, 0.9221990077918412, 0.9708011512945222, 0.9318243438929413, 0.9723307142432756, 0.9684864929186484, 0.475447892918305, 0.46528171383096795, 0.6273833513454726, 0.49345572931666204, 0.49126573234579707, 0.6952849591361081, 0.49858702024401536, 0.42688862309442144, 0.6407796268203647, 0.8032355011624649, 0.7232626300373761, 0.88282455513876, 0.76953966349408, 0.7656209258363847, 0.8997305190352884, 0.7714184735376715, 0.7514748033926235, 0.8990885843277077, 0.29487876982077255, 0.4341322737511536, 0.2445098787146308, 0.3043552059625725, 0.3331178623087224, 0.48467642790245835, 0.4837292436752595, 0.45318132991591864, 0.2155816033562552, 0.39546589456811543, 0.26652238609007806, 0.19232845408985144, 0.2925849546687348, 0.503180714689474, 0.2676110813395993, 0.44263666119253153, 0.2808488539683762, 0.4603997499124606, 0.48320608538159926, 0.47402380104650843, 0.7483926466919377, 0.4389792782289206, 0.5091540520814708, 0.7626100904612526, 0.49336641589637176, 0.46854534347687526, 0.7350998825055539, 0.5951269811526407, 0.6043693791243137, 0.7868656767140639, 0.5980264811100539, 0.5394248245308388, 0.3482664550083291, 0.6282810679126802, 0.6359911546113559, 0.7940047793236806, 0.23134005240760902, 0.2366061812987864, 0.13413636143266883, 0.19406446787816145, 0.29367805062630825, 0.14845055052658152, 0.11014985719818837, 0.17631413747301228, 0.14945837999358014, 0.3368936438069702, 0.35680149405589023, 0.6813029274538971, 0.3757484623230749, 0.4012683910537803, 0.6445290976907565, 0.3398840343108054, 0.35261851477940276, 0.6535125251881865, 0.7210698313367292, 0.7041817503206054, 0.8225177106287858, 0.7312887535780497, 0.6914380694050581, 0.8406803356078824, 0.6980256994486351, 0.6920363753764791, 0.8444156358535203, 0.10156487913641832, 0.10470202415974816, 0.1291243567452086, 0.0950641570014864, 0.12405237166744687, 0.1070646205391016, 0.12023590693515507, 0.10701928513337666, 0.12278018807721258, 0.16539734701128728, 0.14100093217626541, 0.20717521579500908, 0.21218805789978623, 0.1556177095675032, 0.29085982646161623, 0.16028928540885812, 0.18310274228839962, 0.3035171274186371, 0.42235028107198014, 0.4075142454538423, 0.6240252178192112, 0.36062192241765234, 0.3748601985696831, 0.6065310540135285, 0.3879908187075777, 0.38892448718062156, 0.6588352486041009, 0.3136396737089664, 0.3297315533537919, 0.5145818569205077, 0.3131820114931626, 0.27617843555094745, 0.49439745622638676, 0.3561978153539511, 0.32220668459156343, 0.5530310531591313, 0.2209098426826286, 0.19615358116990023, 0.1919390347106008, 0.18240479869388382, 0.2000215595236967, 0.19898598956801283, 0.20548519435213441, 0.20011057251402276, 0.2307154337507712, 0.18207303009940545, 0.19133554988551682, 0.2309948652396382, 0.17822047274564135, 0.17154452851258595, 0.19204465062560383, 0.17965294112191477, 0.18350736343753138, 0.236015971449403, 0.15180528782134572, 0.8133872722672517, 0.19391300885054163, 0.18528689484234973, 0.16564060533399383, 0.21020361442573599, 0.7723410366967813, 0.17577545172073483, 0.836690652608315, 0.163230926573258, 0.16362451528943234, 0.8855314733563443, 0.14894713342939392, 0.21404289740584248, 0.1661414069968017, 0.20633658735852745, 0.20827340310061204, 0.12728064325788113, 0.18846199345705172, 0.205591400353762, 0.175155241046676, 0.19396270734952958, 0.19463244862704876, 0.18153419477319688, 0.17641631901552224, 0.18356165720879913, 0.17818782893194618, 0.07912724966533258, 0.07730219323836995, 0.08215565681124204, 0.07903789161708197, 0.08425025102615413, 0.08850590077326981, 0.07811555753281774, 0.09029576793173688, 0.08539882120950038]}, "mutation_prompt": null}
{"id": "cdbd8f92-008d-4354-8a6f-c6d25c9145ac", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced for focused search\n        self.sub_population_size = np.random.randint(3 * dim, 5 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.6  # Fine-tuned for exploration\n        self.crossover_rate = 0.9  # Fine-tuned for higher recombination\n        self.success_rate = 0.25\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.1  # Increased adjustment for faster convergence\n        self.strategy_prob = [0.6, 0.4]  # Adjusted probabilities for mutation strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def mutate_best_2(self, island_idx):  # New mutation method based on best\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(self.best_solution + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands):\n            swap_idx = np.random.randint(0, self.sub_population_size, size=2)  # Random pair swap\n            island_a_start = i * self.sub_population_size\n            self.population[[island_a_start + swap_idx[0], island_a_start + swap_idx[1]]] = \\\n                self.population[[island_a_start + swap_idx[1], island_a_start + swap_idx[0]]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_1(target_idx, island_idx)\n        else:\n            return self.mutate_best_2(island_idx)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.6 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "A refined Adaptive Differential Evolution with Dynamic Island Migration, Adaptive Mutation, and Archive-Based Diversity Enhancement.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {}, "mutation_prompt": null}
{"id": "6bba1c23-a031-466c-a9b8-8aae1c8f132f", "solution": "import numpy as np\n\nclass EnhancedHybridDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.sub_population_size = np.random.randint(5 * dim, 7 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.3\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.1\n        self.strategy_prob = [0.6, 0.4]\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_best_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b = self.population[np.random.choice(indices, 2, replace=False)]\n        return np.clip(self.best_solution + self.mutation_factor * (a - b), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_best_1(target_idx, island_idx)\n        else:\n            return self.mutate_rand_2(target_idx, island_idx)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.6 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedHybridDEOptimizer", "description": "Enhanced Hybrid Differential Evolution with Adaptive Island Management and Self-Adaptive Parameter Tuning for Improved Global Optimization.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {}, "mutation_prompt": null}
{"id": "6a10e307-0970-4641-9da6-94417bf4e3ca", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.segments = np.array_split(np.arange(self.population_size), self.num_islands)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_1(self, segment_idx, target_idx):\n        indices = np.delete(segment_idx, target_idx)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def mutate_rand_2(self, segment_idx, target_idx):\n        indices = np.delete(segment_idx, target_idx)\n        a, b, c, d, e = self.population[np.random.choice(indices, 5, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, len(self.segments[i]))\n            island_a_idx = self.segments[i][swap_idx]\n            island_b_idx = self.segments[i+1][swap_idx % len(self.segments[i+1])]\n            self.population[[island_a_idx, island_b_idx]] = \\\n                self.population[[island_b_idx, island_a_idx]]\n\n    def select_mutation_strategy(self, target_idx, segment_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_1(segment_idx, target_idx)\n        else:\n            return self.mutate_rand_2(segment_idx, target_idx)\n\n    def adjust_strategy_prob(self, success):\n        self.strategy_prob[0] += self.dynamic_adjustment * (success - 0.5)\n        self.strategy_prob[0] = np.clip(self.strategy_prob[0], 0.1, 0.9)\n        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx, segment in enumerate(self.segments):\n                for i in segment:\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, segment)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.adjust_strategy_prob(success=1)\n                    else:\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n                        self.adjust_strategy_prob(success=0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Population Segmentation and Adaptive Strategy Balancing for Improved Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 25')", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {}, "mutation_prompt": null}
{"id": "e7815b51-6686-481b-9437-0837db0cbd1b", "solution": "import numpy as np\n\nclass ImprovedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5] \n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def mutate_best_2(self, target_idx, island_idx):\n        best_indices = np.argsort(self.fitness)[:2]\n        a, b = self.population[best_indices]\n        c, d = self.population[np.random.choice(self.population_size, 2, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_1(target_idx, island_idx)\n        else:\n            return self.mutate_best_2(target_idx, island_idx)\n    \n    def adjust_dynamic_parameters(self):\n        fitness_std = np.std(self.fitness)\n        self.dynamic_adjustment = min(0.1, 1.0 / (1.0 + fitness_std))\n        self.mutation_factor += self.dynamic_adjustment\n        self.crossover_rate -= self.dynamic_adjustment / 2\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.adjust_dynamic_parameters()\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                self.migrate()\n\n        return self.best_solution", "name": "ImprovedADEOptimizer", "description": "Adaptive Hybrid Differential Evolution with Dynamic Island Migration and Fitness Diversity Control for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 37, "fitness": 0.16002047443824663, "feedback": "The algorithm ImprovedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.18.", "error": "", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {"aucs": [0.25209683702959496, 0.2553299990685798, 0.32654485583120085, 0.2664042088076155, 0.3667637579905215, 0.30608869401048777, 0.2802705916625964, 0.2534250823776092, 0.3788103800901206, 0.17127930299037852, 0.20469721796632934, 0.007870400324527016, 0.17672564629441545, 0.1826655482108519, 0.04715603977539873, 0.15374259183934014, 0.19276130296186123, 0.06784050006170184, 0.09979466947787641, 0.1020335394492462, 0.123658332434051, 0.1040426461606272, 0.1030314094876954, 0.11682897824855298, 0.1070977663480599, 0.10182780510581946, 0.11359447456686189, 0.09555644424055665, 0.08038725202941355, 0.07369935014067253, 0.10017328020737537, 0.08827954984410191, 0.09060177309090856, 0.09191679975079292, 0.09135601938338023, 0.10217842370954, 0.9527105018533452, 0.9632496442544153, 0.9914283868918254, 0.9570989330290511, 0.987145031029171, 0.9900288034574313, 0.9587551425521952, 0.9462640936338295, 0.9781054125913473, 0.10500390323065967, 0.14936311544894287, 0.10084994496680755, 0.11431885703243228, 0.1142894720305665, 0.04993453805642456, 0.11612478109129643, 0.11418107851625281, 0.09370509196464405, 0.1495173068226382, 0.1565897223421584, 0.13080488250877775, 0.14115005369173883, 0.17226330447357774, 0.13287106924031244, 0.1722609226721421, 0.15123679017337288, 0.13619435747684006, 0.11560498264752472, 0.12794138831236201, 0.049280210352240617, 0.11592803950496344, 0.12134447485123034, 0.04639593026979438, 0.13335713332845223, 0.14694250979455192, 0.0837050832782219, 0.10962299239562612, 0.11588079787899064, 0.01918967756309231, 0.1466130251108272, 0.17341995265911114, 0.041888584725289224, 0.12900210089832576, 0.09477045045664745, 0.022268893222591957, 0.017536296695402798, 0.00892044307555806, 9.999999999998899e-05, 0.041820470520996245, 0.007332955138401487, 9.999999999998899e-05, 0.026194228676776565, 0.014175889342494141, 9.999999999998899e-05, 0.10087922898049784, 0.08850160982268485, 0.013226447435891742, 0.0762586964620976, 0.07683122101407258, 0.03154484902954613, 0.13316098483136996, 0.10462808860884654, 0.031166930257695458, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006613123384207609, 0.0021613095962609297, 9.999999999998899e-05, 0.0016766811303303708, 0.042143440873288585, 9.999999999998899e-05, 0.04615008892534844, 0.03922056386160966, 0.01701672633004292, 0.04851777739170393, 0.04636490400608495, 9.999999999998899e-05, 0.03959046241751607, 0.04759078215534007, 0.011950111227347904, 0.2495752854744394, 0.21796081859235794, 0.3101793877899891, 0.22935313733094087, 0.2313920650361353, 0.29247621398862533, 0.23271111419887303, 0.23343280819000123, 0.24980564518129977, 0.07526361774996859, 0.07518623636893185, 0.05433847983467455, 0.0672173647108697, 0.06165249180216015, 0.057053425363891797, 0.06393819192082917, 0.07944416888863393, 0.08503505967956859, 0.12924676944375746, 0.13978509450123744, 0.10571097819574848, 0.14977919806692386, 0.13339155507748546, 0.14273525863326486, 0.15286579713328574, 0.15291804496988448, 0.12992242138099153, 0.17514045228190023, 0.1631187884648696, 0.16890691902940858, 0.15876052424475906, 0.18688305444490005, 0.14978808401056776, 0.17420409903167877, 0.1682744437024667, 0.16921964377503207, 0.13155165087543264, 0.1013156250761742, 0.09866050169137253, 0.12342858279419111, 0.13446513378659797, 0.1277897818562007, 0.12320372013335834, 0.11799346232892927, 0.15471200581060984, 0.1614331642303245, 0.1581732202395415, 0.1561637029656291, 0.21789178363953887, 0.170976201908145, 0.15320600842502408, 0.17302235814597466, 0.15286752649413615, 0.15600362358404385, 0.17747526850792417, 0.18545935200994967, 0.16849660497097552, 0.17287440709573088, 0.1764116302999621, 0.18450366230446003, 0.1898221807978201, 0.19079185512597086, 0.17288580201534098, 0.16383108600205998, 0.16269985495514738, 0.14571297653405313, 0.14387478444983826, 0.12991971738981578, 0.14484759464657382, 0.17027581888404042, 0.16451735162033054, 0.20289233569035847, 0.21834285494645245, 0.20168523391032478, 0.12093139651140206, 0.11016711795193845, 0.13845619601957038, 0.13144519411873623, 0.20940820244284208, 0.17430475414904123, 0.17437210372725698, 0.1895988300290583, 0.1777015389816956, 0.16810301944842, 0.16428990304049074, 0.19163119438324805, 0.18117904687591624, 0.19349109459063085, 0.18970953332195806, 0.21902554233001637, 0.052741632075165024, 0.05853913161588986, 0.05788029460892263, 0.05959642067905535, 0.07129618659516257, 0.057192848158929666, 0.05429252918478289, 0.061287000292166494, 0.04372955245415633]}, "mutation_prompt": null}
{"id": "645067aa-7b93-41ee-9198-87108ef0bd19", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]  # Probabilities for two mutation strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def mutate_rand_2(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c, d, e = self.population[np.random.choice(indices, 5, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_1(target_idx, island_idx)\n        else:\n            return self.mutate_rand_2(target_idx, island_idx)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Multi-strategy Search and Improved Diversity Control for Robust Optimization.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {"aucs": [0.753914445845947, 0.7607421709679577, 0.8723585659187068, 0.77168778946172, 0.779979852528486, 0.8791619256127765, 0.7637539919479309, 0.7738542732983293, 0.8818608887224373, 0.5847799447381963, 0.5874511761972718, 0.7864219382321587, 0.5848529743428241, 0.590271640620517, 0.7881485614259377, 0.5915744190892062, 0.5729533213924918, 0.7887909369514692, 0.11040713121791668, 0.10443505833640065, 0.1450805050432069, 0.12077030086123797, 0.10131220399958651, 0.5406693349421186, 0.11876575916456844, 0.10484135807191775, 0.14508155455788196, 0.09549296596256152, 0.08741951540022097, 0.13868724894036333, 0.08721965221241412, 0.10256297100062761, 0.10477691015508572, 0.1056407179425698, 0.0900005620656239, 0.1066989065090096, 0.9440560421123306, 0.9668068570255623, 0.9860007362206574, 0.9573107768841729, 0.9221990077918412, 0.9708011512945222, 0.9318243438929413, 0.9723307142432756, 0.9684864929186484, 0.475447892918305, 0.46528171383096795, 0.6273833513454726, 0.49345572931666204, 0.49126573234579707, 0.6952849591361081, 0.49858702024401536, 0.42688862309442144, 0.6407796268203647, 0.8032355011624649, 0.7232626300373761, 0.88282455513876, 0.76953966349408, 0.7656209258363847, 0.8997305190352884, 0.7714184735376715, 0.7514748033926235, 0.8990885843277077, 0.29487876982077255, 0.4341322737511536, 0.2445098787146308, 0.3043552059625725, 0.3331178623087224, 0.48467642790245835, 0.4837292436752595, 0.45318132991591864, 0.2155816033562552, 0.39546589456811543, 0.26652238609007806, 0.19232845408985144, 0.2925849546687348, 0.503180714689474, 0.2676110813395993, 0.44263666119253153, 0.2808488539683762, 0.4603997499124606, 0.48320608538159926, 0.47402380104650843, 0.7483926466919377, 0.4389792782289206, 0.5091540520814708, 0.7626100904612526, 0.49336641589637176, 0.46854534347687526, 0.7350998825055539, 0.5951269811526407, 0.6043693791243137, 0.7868656767140639, 0.5980264811100539, 0.5394248245308388, 0.3482664550083291, 0.6282810679126802, 0.6359911546113559, 0.7940047793236806, 0.23134005240760902, 0.2366061812987864, 0.13413636143266883, 0.19406446787816145, 0.29367805062630825, 0.14845055052658152, 0.11014985719818837, 0.17631413747301228, 0.14945837999358014, 0.3368936438069702, 0.35680149405589023, 0.6813029274538971, 0.3757484623230749, 0.4012683910537803, 0.6445290976907565, 0.3398840343108054, 0.35261851477940276, 0.6535125251881865, 0.7210698313367292, 0.7041817503206054, 0.8225177106287858, 0.7312887535780497, 0.6914380694050581, 0.8406803356078824, 0.6980256994486351, 0.6920363753764791, 0.8444156358535203, 0.10156487913641832, 0.10470202415974816, 0.1291243567452086, 0.0950641570014864, 0.12405237166744687, 0.1070646205391016, 0.12023590693515507, 0.10701928513337666, 0.12278018807721258, 0.16539734701128728, 0.14100093217626541, 0.20717521579500908, 0.21218805789978623, 0.1556177095675032, 0.29085982646161623, 0.16028928540885812, 0.18310274228839962, 0.3035171274186371, 0.42235028107198014, 0.4075142454538423, 0.6240252178192112, 0.36062192241765234, 0.3748601985696831, 0.6065310540135285, 0.3879908187075777, 0.38892448718062156, 0.6588352486041009, 0.3136396737089664, 0.3297315533537919, 0.5145818569205077, 0.3131820114931626, 0.27617843555094745, 0.49439745622638676, 0.3561978153539511, 0.32220668459156343, 0.5530310531591313, 0.2209098426826286, 0.19615358116990023, 0.1919390347106008, 0.18240479869388382, 0.2000215595236967, 0.19898598956801283, 0.20548519435213441, 0.20011057251402276, 0.2307154337507712, 0.18207303009940545, 0.19133554988551682, 0.2309948652396382, 0.17822047274564135, 0.17154452851258595, 0.19204465062560383, 0.17965294112191477, 0.18350736343753138, 0.236015971449403, 0.15180528782134572, 0.8133872722672517, 0.19391300885054163, 0.18528689484234973, 0.16564060533399383, 0.21020361442573599, 0.7723410366967813, 0.17577545172073483, 0.836690652608315, 0.163230926573258, 0.16362451528943234, 0.8855314733563443, 0.14894713342939392, 0.21404289740584248, 0.1661414069968017, 0.20633658735852745, 0.20827340310061204, 0.12728064325788113, 0.18846199345705172, 0.205591400353762, 0.175155241046676, 0.19396270734952958, 0.19463244862704876, 0.18153419477319688, 0.17641631901552224, 0.18356165720879913, 0.17818782893194618, 0.07912724966533258, 0.07730219323836995, 0.08215565681124204, 0.07903789161708197, 0.08425025102615413, 0.08850590077326981, 0.07811555753281774, 0.09029576793173688, 0.08539882120950038]}, "mutation_prompt": null}
{"id": "34897ecb-73f5-4710-8ecb-e4263df7d005", "solution": "import numpy as np\n\nclass HybridADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size\n        self.sub_population_size = np.random.randint(5 * dim, 7 * dim)  # Adjusted range\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9  # Increased initial crossover rate\n        self.success_rate = 0.3  # Adjust success rate\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.1  # Increased adjustment rate\n        self.strategy_prob = [0.4, 0.6]  # Changed strategy probabilities\n        self.adaptive_archive_size = 20  # New parameter for archive control\n        self.niching_factor = 0.1  # New parameter for niche creation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        selected = np.random.choice(indices, 3, replace=False)\n        a, b, c = self.population[selected]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def mutate_rand_2(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        selected = np.random.choice(indices, 5, replace=False)\n        a, b, c, d, e = self.population[selected]\n        return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def niche_creation(self):\n        for i in range(self.population_size):\n            for j in range(i + 1, self.population_size):\n                if np.linalg.norm(self.population[i] - self.population[j]) < self.niching_factor:\n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                    self.population[j] = np.clip(self.population[j] + perturbation, self.lower_bound, self.upper_bound)\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_1(target_idx, island_idx)\n        else:\n            return self.mutate_rand_2(target_idx, island_idx)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.niche_creation()  # Apply niche creation\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        if len(self.archive) > self.adaptive_archive_size:  # Control archive size\n                            self.archive.pop(0)\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.4 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.6 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "HybridADEOptimizer", "description": "Hybrid Adaptive Differential Evolution with Dynamic Niching and Enhanced Selection for Improved Convergence and Diversity.", "configspace": "", "generation": 39, "fitness": 0.25909419453905286, "feedback": "The algorithm HybridADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {"aucs": [0.42804226123345457, 0.4471236317389573, 0.4575954900919321, 0.4343033390653501, 0.46137728326096816, 0.4584304841096871, 0.44535544208104916, 0.43419994133380047, 0.47421877553532144, 0.20669561054940788, 0.2122198457047192, 0.16429358514484516, 0.20268832602057718, 0.19074154176319225, 0.2329083690177518, 0.25028321530381115, 0.1844183609064427, 0.24623280542164827, 0.10732142671427336, 0.10309052236950034, 0.15390465665849185, 0.1139616993371736, 0.11755379597526239, 0.1342376525628779, 0.11836978717268853, 0.11522012061991482, 0.15262504227119933, 0.0970327641425065, 0.09744827344277363, 0.12654913347890429, 0.10460597292706386, 0.09666633970508787, 0.1145485871017452, 0.09317827326402184, 0.10622795710168143, 0.11850482195368273, 0.9605879849966277, 0.9785198524125346, 0.9605896366038261, 0.3579443731091769, 0.8871673213152507, 0.954036180184997, 0.5089901128708578, 0.9183024728036147, 0.9334099631678341, 0.28510772858974875, 0.26617257010416684, 0.3203639831474212, 0.2803454118080606, 0.26520389531746347, 0.2934260243033153, 0.2771126890349659, 0.2929622864147363, 0.32716830431903055, 0.5772746951341384, 0.3562115248163439, 0.8669692615653968, 0.6928392802927288, 0.47359135576979006, 0.8784632465001062, 0.7073189329103275, 0.7042419791247533, 0.38439256750669815, 0.16729067099200257, 0.16539514336159755, 0.2297526098006053, 0.1745431405605563, 0.18126778151381973, 0.18983614155427475, 0.19017632400902018, 0.1962839811066257, 0.18811987954443476, 0.16816901834509712, 0.1350411799048692, 0.12719396449290088, 0.18280803753582564, 0.17686148222607678, 0.20834615499225972, 0.16165546033769929, 0.1615196802337019, 0.217824345794966, 0.1764799445374139, 0.1767545395865785, 0.27268437356402153, 0.16899314402761934, 0.16648036236193697, 0.12291485916563183, 0.18621150081853888, 0.1931633864479847, 0.22852710897844986, 0.35214632189611983, 0.334609584545827, 0.3267699879430943, 0.3047090265623802, 0.3590370302649557, 0.390007506399928, 0.32947803266124753, 0.3195415756974128, 0.3212614971184884, 9.999999999998899e-05, 0.015995030543588862, 0.010422335679991401, 0.00012779051792877194, 0.007480969722393649, 0.0022407634048097202, 9.999999999998899e-05, 9.999999999998899e-05, 0.026706121249564396, 0.1343712672496502, 0.1152259346777651, 0.14077818483952742, 0.12956228521661706, 0.12323524692953214, 0.13734373714277515, 0.11812603675410227, 0.12014435124261724, 0.12872888453161757, 0.41992035001037276, 0.42801395211906657, 0.4373624451495626, 0.45819513541249635, 0.40800996252481814, 0.4586645113962837, 0.43546511881000893, 0.4154727949900625, 0.45385580594777275, 0.09992600320437683, 0.09392557384192057, 0.1132067839152211, 0.10714766359360006, 0.08972824948871372, 0.11649398481275253, 0.10319424683061384, 0.08823950639378941, 0.13194398255910056, 0.14764904345950725, 0.14193272070292096, 0.20578883343358834, 0.1554025700344499, 0.1407346426778875, 0.2013145392011817, 0.1524065305990876, 0.1477729979672917, 0.22069152692225247, 0.2868228229733518, 0.2893718674735748, 0.3179065914306388, 0.28899803516418066, 0.2939621621376366, 0.30894488299828216, 0.294793728718432, 0.2924640985185767, 0.31244832836809844, 0.2387798998710604, 0.22699181653072575, 0.26898755412425834, 0.23250660812733026, 0.22958283029641224, 0.24899792673236232, 0.23272543680403823, 0.23876366183700404, 0.2564175178868323, 0.20173848026747565, 0.23740088491021405, 0.20809220826495234, 0.1896035390315962, 0.21170039370232552, 0.212861507630569, 0.21066185458600695, 0.19326942544794734, 0.20923006963261725, 0.20226924497814736, 0.20554754761402672, 0.28054568906732513, 0.18779077189872495, 0.19123368246371142, 0.23413662849539907, 0.1809218102153084, 0.19661656965931518, 0.27251658234351894, 0.1715816392430377, 0.16833104495658557, 0.736338389958012, 0.4386116283733634, 0.1829093496882902, 0.17780621853960143, 0.5479048155432251, 0.17094532262173545, 0.17096680174098933, 0.1642247929242332, 0.4603811221083359, 0.19158449223496332, 0.6401284767084523, 0.19631581246687202, 0.5767751794195461, 0.20792372053827712, 0.20659274827456509, 0.20767427399521887, 0.1905472438044582, 0.18856377565566163, 0.1847874861484745, 0.19144623438085695, 0.18151528738842904, 0.1842214379889089, 0.1988841280725978, 0.18858133089220674, 0.18140588696088233, 0.06943870990482082, 0.07473734870145632, 0.08604947906320326, 0.07747504983904985, 0.07991629576043446, 0.08698116024300018, 0.08581468693567018, 0.07906006425589218, 0.08632996111130908]}, "mutation_prompt": null}
{"id": "77132436-8ba7-487f-aa78-ef26dbe3958f", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]  # Probabilities for two mutation strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def mutate_rand_2(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c, d, e = self.population[np.random.choice(indices, 5, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_1(target_idx, island_idx)\n        else:\n            return self.mutate_rand_2(target_idx, island_idx)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Multi-strategy Search and Improved Diversity Control for Robust Optimization.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {"aucs": [0.753914445845947, 0.7607421709679577, 0.8723585659187068, 0.77168778946172, 0.779979852528486, 0.8791619256127765, 0.7637539919479309, 0.7738542732983293, 0.8818608887224373, 0.5847799447381963, 0.5874511761972718, 0.7864219382321587, 0.5848529743428241, 0.590271640620517, 0.7881485614259377, 0.5915744190892062, 0.5729533213924918, 0.7887909369514692, 0.11040713121791668, 0.10443505833640065, 0.1450805050432069, 0.12077030086123797, 0.10131220399958651, 0.5406693349421186, 0.11876575916456844, 0.10484135807191775, 0.14508155455788196, 0.09549296596256152, 0.08741951540022097, 0.13868724894036333, 0.08721965221241412, 0.10256297100062761, 0.10477691015508572, 0.1056407179425698, 0.0900005620656239, 0.1066989065090096, 0.9440560421123306, 0.9668068570255623, 0.9860007362206574, 0.9573107768841729, 0.9221990077918412, 0.9708011512945222, 0.9318243438929413, 0.9723307142432756, 0.9684864929186484, 0.475447892918305, 0.46528171383096795, 0.6273833513454726, 0.49345572931666204, 0.49126573234579707, 0.6952849591361081, 0.49858702024401536, 0.42688862309442144, 0.6407796268203647, 0.8032355011624649, 0.7232626300373761, 0.88282455513876, 0.76953966349408, 0.7656209258363847, 0.8997305190352884, 0.7714184735376715, 0.7514748033926235, 0.8990885843277077, 0.29487876982077255, 0.4341322737511536, 0.2445098787146308, 0.3043552059625725, 0.3331178623087224, 0.48467642790245835, 0.4837292436752595, 0.45318132991591864, 0.2155816033562552, 0.39546589456811543, 0.26652238609007806, 0.19232845408985144, 0.2925849546687348, 0.503180714689474, 0.2676110813395993, 0.44263666119253153, 0.2808488539683762, 0.4603997499124606, 0.48320608538159926, 0.47402380104650843, 0.7483926466919377, 0.4389792782289206, 0.5091540520814708, 0.7626100904612526, 0.49336641589637176, 0.46854534347687526, 0.7350998825055539, 0.5951269811526407, 0.6043693791243137, 0.7868656767140639, 0.5980264811100539, 0.5394248245308388, 0.3482664550083291, 0.6282810679126802, 0.6359911546113559, 0.7940047793236806, 0.23134005240760902, 0.2366061812987864, 0.13413636143266883, 0.19406446787816145, 0.29367805062630825, 0.14845055052658152, 0.11014985719818837, 0.17631413747301228, 0.14945837999358014, 0.3368936438069702, 0.35680149405589023, 0.6813029274538971, 0.3757484623230749, 0.4012683910537803, 0.6445290976907565, 0.3398840343108054, 0.35261851477940276, 0.6535125251881865, 0.7210698313367292, 0.7041817503206054, 0.8225177106287858, 0.7312887535780497, 0.6914380694050581, 0.8406803356078824, 0.6980256994486351, 0.6920363753764791, 0.8444156358535203, 0.10156487913641832, 0.10470202415974816, 0.1291243567452086, 0.0950641570014864, 0.12405237166744687, 0.1070646205391016, 0.12023590693515507, 0.10701928513337666, 0.12278018807721258, 0.16539734701128728, 0.14100093217626541, 0.20717521579500908, 0.21218805789978623, 0.1556177095675032, 0.29085982646161623, 0.16028928540885812, 0.18310274228839962, 0.3035171274186371, 0.42235028107198014, 0.4075142454538423, 0.6240252178192112, 0.36062192241765234, 0.3748601985696831, 0.6065310540135285, 0.3879908187075777, 0.38892448718062156, 0.6588352486041009, 0.3136396737089664, 0.3297315533537919, 0.5145818569205077, 0.3131820114931626, 0.27617843555094745, 0.49439745622638676, 0.3561978153539511, 0.32220668459156343, 0.5530310531591313, 0.2209098426826286, 0.19615358116990023, 0.1919390347106008, 0.18240479869388382, 0.2000215595236967, 0.19898598956801283, 0.20548519435213441, 0.20011057251402276, 0.2307154337507712, 0.18207303009940545, 0.19133554988551682, 0.2309948652396382, 0.17822047274564135, 0.17154452851258595, 0.19204465062560383, 0.17965294112191477, 0.18350736343753138, 0.236015971449403, 0.15180528782134572, 0.8133872722672517, 0.19391300885054163, 0.18528689484234973, 0.16564060533399383, 0.21020361442573599, 0.7723410366967813, 0.17577545172073483, 0.836690652608315, 0.163230926573258, 0.16362451528943234, 0.8855314733563443, 0.14894713342939392, 0.21404289740584248, 0.1661414069968017, 0.20633658735852745, 0.20827340310061204, 0.12728064325788113, 0.18846199345705172, 0.205591400353762, 0.175155241046676, 0.19396270734952958, 0.19463244862704876, 0.18153419477319688, 0.17641631901552224, 0.18356165720879913, 0.17818782893194618, 0.07912724966533258, 0.07730219323836995, 0.08215565681124204, 0.07903789161708197, 0.08425025102615413, 0.08850590077326981, 0.07811555753281774, 0.09029576793173688, 0.08539882120950038]}, "mutation_prompt": null}
{"id": "a182f7b6-2091-401e-a78d-3a0e992b829c", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.history_success_rate = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def mutate_rand_2(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c, d, e = self.population[np.random.choice(indices, 5, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        if np.random.rand() < 0.3:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_1(target_idx, island_idx)\n        else:\n            return self.mutate_rand_2(target_idx, island_idx)\n\n    def adapt_strategy_probabilities(self):\n        if len(self.history_success_rate) > 5:\n            recent_rate = np.mean(self.history_success_rate[-5:])\n            if recent_rate > 0.5:\n                self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + 0.1)\n            else:\n                self.strategy_prob[0] = max(0.1, self.strategy_prob[0] - 0.1)\n            self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.history_success_rate.append(1.0)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        self.history_success_rate.append(0.0)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            \n            self.adapt_strategy_probabilities()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Island-based Differential Evolution with Dynamic Strategy Balancing for Enhanced Performance.", "configspace": "", "generation": 41, "fitness": 0.3289521583327794, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {"aucs": [0.6559336509637945, 0.6701819420197805, 0.7984268201125424, 0.675021368409639, 0.6847555115684401, 0.8221868503033285, 0.6810356337646473, 0.6185657248218459, 0.8232938924433246, 0.4321274914809017, 0.3938518403155651, 0.6607183578647862, 0.4100223611930681, 0.4658927772022967, 0.6787069683217335, 0.4016426704200249, 0.40003741188863884, 0.6852197568187378, 0.08666790845495709, 0.0896690549714001, 0.10640268113846618, 0.09062077030408822, 0.11164521632144897, 0.09429257223472665, 0.09524067482338738, 0.09547296472856237, 0.09698699931799604, 0.07208148870859354, 0.07589079961360679, 0.09865866208025509, 0.07979170710428696, 0.08025542036564692, 0.10635557417859764, 0.08096025474809632, 0.07988685829297426, 0.08489938882686165, 0.9873753377321229, 0.9740584513611417, 0.9792264090781726, 0.9820740394182358, 0.939894292591716, 0.9612553172381804, 0.9788629509690164, 0.9138381687509602, 0.9594077706793456, 0.3157672513770041, 0.3118978872358278, 0.5456926886222757, 0.31768426069916345, 0.3133635013130758, 0.5974532627407656, 0.32260425226596967, 0.30711499877432735, 0.5477094394963702, 0.6008805217554587, 0.6201145663348926, 0.8358251121593065, 0.6198588746049782, 0.5971777895256749, 0.8037075989161168, 0.6627659743280878, 0.7251040773082591, 0.715593082035493, 0.18667684079513014, 0.24087969204730575, 0.575051835393481, 0.19090598456419405, 0.22708855987637988, 0.5007442671688633, 0.2661168020246597, 0.2566001238345017, 0.504693356978211, 0.1643201595001399, 0.282984541738584, 0.11853236637686937, 0.23031768780216766, 0.23318481812414726, 0.561551620995576, 0.22805100685804958, 0.2207261733508512, 0.5161001667913564, 0.2657112159130737, 0.2558961222613335, 0.5617784442310361, 0.2672479465813622, 0.27509569342123397, 0.5596781837544258, 0.2603554062725003, 0.2527775745233093, 0.5621695959218999, 0.3706916156273494, 0.4005982598797171, 0.6705423982528409, 0.4070728593524412, 0.3711402922599095, 0.6375589876705796, 0.395089039495645, 0.3984894826453156, 0.7134038073158147, 0.07191825638167593, 0.035300163594108924, 0.24431272382643132, 0.03494540528022294, 0.11747482154718747, 0.4905157014403987, 0.11431414156017561, 0.11337809380734165, 0.26012926344579024, 0.22807622822074214, 0.23048605776980702, 0.42064452028176746, 0.21775529321849196, 0.2453589699423271, 0.4603198535463523, 0.20570909034498341, 0.22439282551999384, 0.4479549214201892, 0.50175516256553, 0.5677284805190062, 0.739796909880686, 0.55332148292248, 0.563972642207971, 0.7483861985326197, 0.5329602989912199, 0.6072147370333871, 0.7501139196667711, 0.09333021213547799, 0.09494448499489172, 0.08974939513114244, 0.07935209216343042, 0.08475293286093089, 0.10867553289516507, 0.08725273690138169, 0.0977394152129687, 0.09002012243390745, 0.1455221947486196, 0.1455087226170002, 0.2980925627403449, 0.1299798559513642, 0.1308755371109026, 0.1469770779290257, 0.140389001987701, 0.12955133996462298, 0.15372719932406076, 0.2508697770065018, 0.28210357940737985, 0.39031098164403777, 0.2729533750993006, 0.2766767157945186, 0.34876911944217526, 0.2957171098902056, 0.2786650658721974, 0.41931012231724507, 0.22202758954928692, 0.2256368103281461, 0.3406068277638368, 0.21307760224353856, 0.23382325080992405, 0.3246391549582355, 0.23584207022428183, 0.22471995337732886, 0.3289120308727539, 0.19117677415776146, 0.18590939584512545, 0.1949569152231273, 0.1797376234986492, 0.20847638426947246, 0.17783830315344784, 0.20752766125749023, 0.17691477775224107, 0.20498503573906235, 0.17102749305444975, 0.17461167257878574, 0.1729782677369872, 0.1738125345316206, 0.17038203820286402, 0.17892584120926291, 0.17784170861933035, 0.1910298707758492, 0.17154959174668127, 0.16639123386164645, 0.4091155704997085, 0.20654235006666, 0.16132570527544499, 0.17675258276727868, 0.1771173546828122, 0.18270533453144921, 0.3090746732226184, 0.19248261071146522, 0.19111493168771043, 0.1835727728868788, 0.12579867284055635, 0.19166616395996583, 0.24820325627582263, 0.19975040582819203, 0.5716127992614388, 0.20621453982267857, 0.21012468049932653, 0.17873639164214639, 0.18482515266750466, 0.18633701418953075, 0.18381977769843438, 0.18744108104381463, 0.18996128652301958, 0.17221222708100836, 0.1982126477155184, 0.20409984447197527, 0.07745853889197729, 0.07831600302088759, 0.07410075474721922, 0.06759758395928239, 0.06382064160210155, 0.07812501610692357, 0.06915266864487235, 0.0876449434914588, 0.06368854813808522]}, "mutation_prompt": null}
{"id": "103604ac-7671-4465-849f-541891d4bb48", "solution": "import numpy as np\n\nclass EnhancedADEOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly larger population size\n        self.sub_population_size = np.random.randint(3 * dim, 4 * dim)  # Adjusted sub-population size\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.6, 0.4]  # Adjusted strategy probabilities\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_best_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        best_idx = np.argmin(self.fitness[start:end]) + start\n        a, b = self.population[np.random.choice(indices, 2, replace=False)]\n        return np.clip(self.population[best_idx] + self.mutation_factor * (a - b), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        migration_size = max(1, self.sub_population_size // 10)\n        for i in range(self.num_islands - 1):\n            swap_indices = np.random.choice(np.arange(self.sub_population_size), migration_size, replace=False)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            for idx in swap_indices:\n                idx_a = island_a_start + idx\n                idx_b = island_b_start + idx\n                self.population[[idx_a, idx_b]] = self.population[[idx_b, idx_a]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_best_1(target_idx, island_idx)\n        else:\n            return self.mutate_rand_1(target_idx, island_idx)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.6 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.75 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizerV2", "description": "Enhanced Differential Evolution with Dynamic Island Connectivity and Adaptive Strategy Selection for Better Convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedADEOptimizerV2' object has no attribute 'mutate_rand_1'\").", "error": "AttributeError(\"'EnhancedADEOptimizerV2' object has no attribute 'mutate_rand_1'\")", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {}, "mutation_prompt": null}
{"id": "f238ffdb-5d83-446d-bbd3-e168340716bd", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_best_1(self, target_idx, island_idx, best):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b = self.population[np.random.choice(indices, 2, replace=False)]\n        return np.clip(best + self.mutation_factor * (a - b), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        fitness_sorted_indices = np.argsort(self.fitness)\n        for i in range(self.num_islands - 1):\n            swap_idx = fitness_sorted_indices[i * self.sub_population_size]\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            best_idx = np.argmin(self.fitness[island_idx * self.sub_population_size: (island_idx + 1) * self.sub_population_size])\n            best = self.population[island_idx * self.sub_population_size + best_idx]\n            return self.mutate_rand_best_1(target_idx, island_idx, best)\n        else:\n            return self.mutate_rand_2(target_idx, island_idx)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Island Migration and Fitness-Based Repartitioning for Improved Black Box Optimization.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedADEOptimizer' object has no attribute 'mutate_rand_2'\").", "error": "AttributeError(\"'EnhancedADEOptimizer' object has no attribute 'mutate_rand_2'\")", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {}, "mutation_prompt": null}
{"id": "90b4c363-76ba-49b1-b1e3-3b4ad6e4a63d", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]  # Probabilities for two mutation strategies\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_rand_1(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def mutate_rand_2(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c, d, e = self.population[np.random.choice(indices, 5, replace=False)]\n        return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def select_mutation_strategy(self, target_idx, island_idx):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate_rand_1(target_idx, island_idx)\n        else:\n            return self.mutate_rand_2(target_idx, island_idx)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.select_mutation_strategy(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if self.fitness[i] != np.inf:\n                            self.archive.append(self.population[i].copy())\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.strategy_prob[0] = min(1.0, self.strategy_prob[0] + self.dynamic_adjustment)\n                        self.strategy_prob[1] = 1.0 - self.strategy_prob[0]\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n                        if len(self.archive) > self.population_size:\n                            self.archive.pop(0)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Multi-strategy Search and Improved Diversity Control for Robust Optimization.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {"aucs": [0.753914445845947, 0.7607421709679577, 0.8723585659187068, 0.77168778946172, 0.779979852528486, 0.8791619256127765, 0.7637539919479309, 0.7738542732983293, 0.8818608887224373, 0.5847799447381963, 0.5874511761972718, 0.7864219382321587, 0.5848529743428241, 0.590271640620517, 0.7881485614259377, 0.5915744190892062, 0.5729533213924918, 0.7887909369514692, 0.11040713121791668, 0.10443505833640065, 0.1450805050432069, 0.12077030086123797, 0.10131220399958651, 0.5406693349421186, 0.11876575916456844, 0.10484135807191775, 0.14508155455788196, 0.09549296596256152, 0.08741951540022097, 0.13868724894036333, 0.08721965221241412, 0.10256297100062761, 0.10477691015508572, 0.1056407179425698, 0.0900005620656239, 0.1066989065090096, 0.9440560421123306, 0.9668068570255623, 0.9860007362206574, 0.9573107768841729, 0.9221990077918412, 0.9708011512945222, 0.9318243438929413, 0.9723307142432756, 0.9684864929186484, 0.475447892918305, 0.46528171383096795, 0.6273833513454726, 0.49345572931666204, 0.49126573234579707, 0.6952849591361081, 0.49858702024401536, 0.42688862309442144, 0.6407796268203647, 0.8032355011624649, 0.7232626300373761, 0.88282455513876, 0.76953966349408, 0.7656209258363847, 0.8997305190352884, 0.7714184735376715, 0.7514748033926235, 0.8990885843277077, 0.29487876982077255, 0.4341322737511536, 0.2445098787146308, 0.3043552059625725, 0.3331178623087224, 0.48467642790245835, 0.4837292436752595, 0.45318132991591864, 0.2155816033562552, 0.39546589456811543, 0.26652238609007806, 0.19232845408985144, 0.2925849546687348, 0.503180714689474, 0.2676110813395993, 0.44263666119253153, 0.2808488539683762, 0.4603997499124606, 0.48320608538159926, 0.47402380104650843, 0.7483926466919377, 0.4389792782289206, 0.5091540520814708, 0.7626100904612526, 0.49336641589637176, 0.46854534347687526, 0.7350998825055539, 0.5951269811526407, 0.6043693791243137, 0.7868656767140639, 0.5980264811100539, 0.5394248245308388, 0.3482664550083291, 0.6282810679126802, 0.6359911546113559, 0.7940047793236806, 0.23134005240760902, 0.2366061812987864, 0.13413636143266883, 0.19406446787816145, 0.29367805062630825, 0.14845055052658152, 0.11014985719818837, 0.17631413747301228, 0.14945837999358014, 0.3368936438069702, 0.35680149405589023, 0.6813029274538971, 0.3757484623230749, 0.4012683910537803, 0.6445290976907565, 0.3398840343108054, 0.35261851477940276, 0.6535125251881865, 0.7210698313367292, 0.7041817503206054, 0.8225177106287858, 0.7312887535780497, 0.6914380694050581, 0.8406803356078824, 0.6980256994486351, 0.6920363753764791, 0.8444156358535203, 0.10156487913641832, 0.10470202415974816, 0.1291243567452086, 0.0950641570014864, 0.12405237166744687, 0.1070646205391016, 0.12023590693515507, 0.10701928513337666, 0.12278018807721258, 0.16539734701128728, 0.14100093217626541, 0.20717521579500908, 0.21218805789978623, 0.1556177095675032, 0.29085982646161623, 0.16028928540885812, 0.18310274228839962, 0.3035171274186371, 0.42235028107198014, 0.4075142454538423, 0.6240252178192112, 0.36062192241765234, 0.3748601985696831, 0.6065310540135285, 0.3879908187075777, 0.38892448718062156, 0.6588352486041009, 0.3136396737089664, 0.3297315533537919, 0.5145818569205077, 0.3131820114931626, 0.27617843555094745, 0.49439745622638676, 0.3561978153539511, 0.32220668459156343, 0.5530310531591313, 0.2209098426826286, 0.19615358116990023, 0.1919390347106008, 0.18240479869388382, 0.2000215595236967, 0.19898598956801283, 0.20548519435213441, 0.20011057251402276, 0.2307154337507712, 0.18207303009940545, 0.19133554988551682, 0.2309948652396382, 0.17822047274564135, 0.17154452851258595, 0.19204465062560383, 0.17965294112191477, 0.18350736343753138, 0.236015971449403, 0.15180528782134572, 0.8133872722672517, 0.19391300885054163, 0.18528689484234973, 0.16564060533399383, 0.21020361442573599, 0.7723410366967813, 0.17577545172073483, 0.836690652608315, 0.163230926573258, 0.16362451528943234, 0.8855314733563443, 0.14894713342939392, 0.21404289740584248, 0.1661414069968017, 0.20633658735852745, 0.20827340310061204, 0.12728064325788113, 0.18846199345705172, 0.205591400353762, 0.175155241046676, 0.19396270734952958, 0.19463244862704876, 0.18153419477319688, 0.17641631901552224, 0.18356165720879913, 0.17818782893194618, 0.07912724966533258, 0.07730219323836995, 0.08215565681124204, 0.07903789161708197, 0.08425025102615413, 0.08850590077326981, 0.07811555753281774, 0.09029576793173688, 0.08539882120950038]}, "mutation_prompt": null}
{"id": "ed638585-e633-4803-ab26-56d09ac2ecbc", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        d, e = self.population[np.random.choice(indices, 2, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:  # adaptive condition for migration\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Improved EnhancedADEOptimizer with adaptive island migration, dynamic population resizing, and hybrid mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 45, "fitness": 0.4129195005494149, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "2c9af5c3-33ec-46d1-b8ee-36de36dc6d90", "metadata": {"aucs": [0.7368966111869191, 0.7440849871061967, 0.8539727080293766, 0.7622146518865868, 0.7591398276616362, 0.833199649228056, 0.7510755106762401, 0.7503697499066501, 0.8570212044557686, 0.5765881015844903, 0.5913727589564637, 0.7545823192809689, 0.5474655897568057, 0.5838416982473877, 0.759932103678294, 0.5573678039402132, 0.591128087483482, 0.7500387773903777, 0.1222099270550141, 0.09455726573704648, 0.12382653467526838, 0.11512354618895349, 0.10303455103655013, 0.13809606916828365, 0.10065900092357372, 0.09935901452908402, 0.16945956262740458, 0.08915253872764461, 0.09571413871271195, 0.12411034726069192, 0.09758903712556544, 0.0950247302352194, 0.10819930592649452, 0.08983438137338162, 0.1067630990648466, 0.09247590163629338, 0.9654379612296383, 0.9240798278453911, 0.9326776129222655, 0.925546842402201, 0.9832650718480725, 0.9485545374632092, 0.9577293886123366, 0.8831334554133152, 0.9306162208407494, 0.4438966767802912, 0.40353430513241006, 0.6764082703256935, 0.4109493752974075, 0.36653834747042024, 0.6235712046827024, 0.43131530360120096, 0.4134338339018806, 0.5972056319271211, 0.7219686151358564, 0.7288698136793652, 0.8754995432335061, 0.7861844914808533, 0.7879520201675931, 0.8376913916452701, 0.7784072695275815, 0.8011759269310857, 0.8522034229978712, 0.41437877132095435, 0.24010599560587353, 0.5604115556987506, 0.3337517205865218, 0.31201043747286605, 0.6226160552162199, 0.4910304211957779, 0.4834640220802121, 0.6211489706746545, 0.22296951768769713, 0.5075521196202772, 0.4864202759395331, 0.28181006148639376, 0.4754677034527589, 0.598985960872233, 0.30861426372917145, 0.4624748974274795, 0.5013229774039298, 0.39601681141345346, 0.49250109675102316, 0.6756822021228317, 0.4567677198272707, 0.48108384473206267, 0.6703969809139142, 0.5034359893458187, 0.4266886698207256, 0.6765203257158063, 0.5858156237977883, 0.6116069116830429, 0.7532803748602398, 0.5914884484021348, 0.5469219119857451, 0.7847057695905129, 0.577517473797156, 0.603301585274569, 0.7628154508319862, 0.12944185918457551, 0.17201416549859783, 0.3545259522513057, 0.302777718496162, 0.31973454993384687, 0.5837671055423894, 0.20376237337082947, 0.16998374599099353, 0.30545208377751565, 0.36012039139180296, 0.36277289228308396, 0.5732530830373751, 0.3193862001876083, 0.3282872302829307, 0.5799101133150308, 0.32934602394986046, 0.3512869752880139, 0.5539226110560115, 0.6648416101260098, 0.6899966503801618, 0.8237562466424401, 0.6806920691802083, 0.6777470846607361, 0.8116855354128427, 0.6750962490143414, 0.6874541033711337, 0.8247366546057482, 0.10037978691779148, 0.09412531563738757, 0.11336686232042137, 0.11551497243036446, 0.11119857723685422, 0.10638450276632794, 0.10886993611786311, 0.08932039341838083, 0.11399418367328162, 0.18199747492619678, 0.22724653736865053, 0.17584424478849647, 0.1499298925050906, 0.15759764487892558, 0.19747353179390548, 0.1846533018650276, 0.20519132541421659, 0.21375634073783745, 0.38355423487391904, 0.34069925502920784, 0.530536092585407, 0.37357597379897167, 0.34838775528907373, 0.5487503278050498, 0.37999854812140765, 0.36292377010440313, 0.5381669376888765, 0.3134350901346217, 0.3063227700232527, 0.3919914559805735, 0.2854459279617273, 0.2844246177723265, 0.41824473752869684, 0.32106189620968695, 0.3055325145894271, 0.42364203089459673, 0.2037366640726852, 0.1919885222014427, 0.19230142787582816, 0.1932635637007798, 0.1998181007264429, 0.21352064263721837, 0.18295721844652035, 0.1831473610331642, 0.19689871392009273, 0.18998019831812196, 0.18432177516798864, 0.48090063079854795, 0.24132200142050042, 0.18305287579474405, 0.4906449237811199, 0.19138917647394937, 0.19880610787664277, 0.19757156448086466, 0.16373899329714636, 0.7431196657021171, 0.8415465887920471, 0.6378222202469532, 0.18585588604524306, 0.16570742704340669, 0.17625683046616492, 0.5999315601867822, 0.846677361217001, 0.16372486556703825, 0.20075204174324257, 0.16545829152168479, 0.7300418298186296, 0.19615681434775056, 0.20382201493012686, 0.7339735164533581, 0.15068284068296656, 0.20698991678143108, 0.1953824159457075, 0.18105298740885778, 0.17777411636223184, 0.17492560659387346, 0.18462625618444062, 0.18966199503634718, 0.1759488874955163, 0.20078075473829826, 0.18859749896920874, 0.06369915271314108, 0.07995125699244054, 0.07873194309504183, 0.08230011998620812, 0.07866898473714046, 0.0849933329448499, 0.08034570109457195, 0.08203720021640781, 0.089553361877174]}, "mutation_prompt": null}
{"id": "f5fea5f8-39d4-4ce4-aa1a-26b44f7df750", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        d, e = self.population[np.random.choice(indices, 2, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:  # adaptive condition for migration\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Improved EnhancedADEOptimizer with adaptive island migration, dynamic population resizing, and hybrid mutation strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ed638585-e633-4803-ab26-56d09ac2ecbc", "metadata": {"aucs": [0.7368966111869191, 0.7440849871061967, 0.8539727080293766, 0.7622146518865868, 0.7591398276616362, 0.833199649228056, 0.7510755106762401, 0.7503697499066501, 0.8570212044557686, 0.5765881015844903, 0.5913727589564637, 0.7545823192809689, 0.5474655897568057, 0.5838416982473877, 0.759932103678294, 0.5573678039402132, 0.591128087483482, 0.7500387773903777, 0.1222099270550141, 0.09455726573704648, 0.12382653467526838, 0.11512354618895349, 0.10303455103655013, 0.13809606916828365, 0.10065900092357372, 0.09935901452908402, 0.16945956262740458, 0.08915253872764461, 0.09571413871271195, 0.12411034726069192, 0.09758903712556544, 0.0950247302352194, 0.10819930592649452, 0.08983438137338162, 0.1067630990648466, 0.09247590163629338, 0.9654379612296383, 0.9240798278453911, 0.9326776129222655, 0.925546842402201, 0.9832650718480725, 0.9485545374632092, 0.9577293886123366, 0.8831334554133152, 0.9306162208407494, 0.4438966767802912, 0.40353430513241006, 0.6764082703256935, 0.4109493752974075, 0.36653834747042024, 0.6235712046827024, 0.43131530360120096, 0.4134338339018806, 0.5972056319271211, 0.7219686151358564, 0.7288698136793652, 0.8754995432335061, 0.7861844914808533, 0.7879520201675931, 0.8376913916452701, 0.7784072695275815, 0.8011759269310857, 0.8522034229978712, 0.41437877132095435, 0.24010599560587353, 0.5604115556987506, 0.3337517205865218, 0.31201043747286605, 0.6226160552162199, 0.4910304211957779, 0.4834640220802121, 0.6211489706746545, 0.22296951768769713, 0.5075521196202772, 0.4864202759395331, 0.28181006148639376, 0.4754677034527589, 0.598985960872233, 0.30861426372917145, 0.4624748974274795, 0.5013229774039298, 0.39601681141345346, 0.49250109675102316, 0.6756822021228317, 0.4567677198272707, 0.48108384473206267, 0.6703969809139142, 0.5034359893458187, 0.4266886698207256, 0.6765203257158063, 0.5858156237977883, 0.6116069116830429, 0.7532803748602398, 0.5914884484021348, 0.5469219119857451, 0.7847057695905129, 0.577517473797156, 0.603301585274569, 0.7628154508319862, 0.12944185918457551, 0.17201416549859783, 0.3545259522513057, 0.302777718496162, 0.31973454993384687, 0.5837671055423894, 0.20376237337082947, 0.16998374599099353, 0.30545208377751565, 0.36012039139180296, 0.36277289228308396, 0.5732530830373751, 0.3193862001876083, 0.3282872302829307, 0.5799101133150308, 0.32934602394986046, 0.3512869752880139, 0.5539226110560115, 0.6648416101260098, 0.6899966503801618, 0.8237562466424401, 0.6806920691802083, 0.6777470846607361, 0.8116855354128427, 0.6750962490143414, 0.6874541033711337, 0.8247366546057482, 0.10037978691779148, 0.09412531563738757, 0.11336686232042137, 0.11551497243036446, 0.11119857723685422, 0.10638450276632794, 0.10886993611786311, 0.08932039341838083, 0.11399418367328162, 0.18199747492619678, 0.22724653736865053, 0.17584424478849647, 0.1499298925050906, 0.15759764487892558, 0.19747353179390548, 0.1846533018650276, 0.20519132541421659, 0.21375634073783745, 0.38355423487391904, 0.34069925502920784, 0.530536092585407, 0.37357597379897167, 0.34838775528907373, 0.5487503278050498, 0.37999854812140765, 0.36292377010440313, 0.5381669376888765, 0.3134350901346217, 0.3063227700232527, 0.3919914559805735, 0.2854459279617273, 0.2844246177723265, 0.41824473752869684, 0.32106189620968695, 0.3055325145894271, 0.42364203089459673, 0.2037366640726852, 0.1919885222014427, 0.19230142787582816, 0.1932635637007798, 0.1998181007264429, 0.21352064263721837, 0.18295721844652035, 0.1831473610331642, 0.19689871392009273, 0.18998019831812196, 0.18432177516798864, 0.48090063079854795, 0.24132200142050042, 0.18305287579474405, 0.4906449237811199, 0.19138917647394937, 0.19880610787664277, 0.19757156448086466, 0.16373899329714636, 0.7431196657021171, 0.8415465887920471, 0.6378222202469532, 0.18585588604524306, 0.16570742704340669, 0.17625683046616492, 0.5999315601867822, 0.846677361217001, 0.16372486556703825, 0.20075204174324257, 0.16545829152168479, 0.7300418298186296, 0.19615681434775056, 0.20382201493012686, 0.7339735164533581, 0.15068284068296656, 0.20698991678143108, 0.1953824159457075, 0.18105298740885778, 0.17777411636223184, 0.17492560659387346, 0.18462625618444062, 0.18966199503634718, 0.1759488874955163, 0.20078075473829826, 0.18859749896920874, 0.06369915271314108, 0.07995125699244054, 0.07873194309504183, 0.08230011998620812, 0.07866898473714046, 0.0849933329448499, 0.08034570109457195, 0.08203720021640781, 0.089553361877174]}, "mutation_prompt": null}
{"id": "f5573043-357b-49ef-b528-bdf73e411c81", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        selected_indices = np.random.choice(indices, 5, replace=False)\n        a, b, c, d, e = self.population[selected_indices]\n        if np.random.rand() < 0.7:\n            return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(b + self.mutation_factor * (c - a + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx_a = np.random.randint(0, self.sub_population_size)\n            swap_idx_b = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.4:  # adaptive condition for migration\n                self.population[[island_a_start + swap_idx_a, island_b_start + swap_idx_b]] = \\\n                    self.population[[island_b_start + swap_idx_b, island_a_start + swap_idx_a]]\n\n    def resize_population(self):\n        if self.success_rate > 0.6 and self.population_size < 15 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.4 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.6 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Optimized EnhancedADEOptimizer with adaptive selection pressure, dynamic migration strategies, and improved mutation for faster convergence.", "configspace": "", "generation": 47, "fitness": 0.39129008016846917, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "ed638585-e633-4803-ab26-56d09ac2ecbc", "metadata": {"aucs": [0.7377335535924038, 0.7332469029660946, 0.8409556699894125, 0.7540426404658135, 0.7555019201744824, 0.8497558185597325, 0.7510600721526279, 0.7502055644787327, 0.8366902748624011, 0.5573328646033535, 0.5570159341776044, 0.7510424939641653, 0.5393337977409228, 0.5608602402354272, 0.7467979022629752, 0.5748095811990827, 0.555271661310863, 0.7376106855347098, 0.10754962798147605, 0.09502646321579633, 0.10652562642395458, 0.10569776933395092, 0.10637852091253353, 0.11641591143896968, 0.11563917622710884, 0.10156064337019177, 0.11702613536889528, 0.09144704240086143, 0.09362249293645342, 0.10060997149239559, 0.09927748440016182, 0.10121376561320272, 0.11322276165735623, 0.09534654034713153, 0.0965898935989955, 0.09138699170308151, 0.8704911055853062, 0.9638902090198695, 0.9884572115037303, 0.9248539816954052, 0.9908843712129047, 0.9767737563172215, 0.9660324472936229, 0.9961870934894964, 0.9813793651133191, 0.4026860523446206, 0.39326088313628216, 0.6344487915560766, 0.4231000516674044, 0.3889767341125263, 0.6172526229631596, 0.38918836536810164, 0.42792534623547285, 0.6274979923487995, 0.7371302595498479, 0.6943177463663999, 0.8454790242000925, 0.7464685497558681, 0.7509641134969884, 0.8441809948266888, 0.7856665911867421, 0.7246547694622081, 0.8230482579857191, 0.20478161057758615, 0.2156857976500809, 0.49621080363640035, 0.30272735439964715, 0.2525625203631192, 0.5770893265332822, 0.2799513158744742, 0.42296787055147966, 0.5913644128307225, 0.5203868705613153, 0.5068626702903112, 0.7046117609288756, 0.3502980464301215, 0.46207767569266855, 0.5715610780008009, 0.23553101148081823, 0.4249175988181709, 0.5739682352813934, 0.45864702098917554, 0.41325358478388263, 0.6687153362450795, 0.4276243604997436, 0.4218095029520932, 0.6365725049610438, 0.40204649511085766, 0.3902478818832853, 0.623716804333719, 0.5868984406211042, 0.4978407866469782, 0.7218388095534247, 0.5168246834129315, 0.5506633146561537, 0.6996523621443749, 0.47106484868499265, 0.5280649310753798, 0.7318034424591635, 0.1630555148543119, 0.11838609869767514, 0.18605740597586662, 0.24286114663554115, 0.2645048575869229, 0.5146327064914926, 0.22153282862896118, 0.17940862089249532, 0.15015165749317316, 0.31604058609359076, 0.305040759944028, 0.5178700476066298, 0.290317234935912, 0.32369848565728454, 0.5791729472920093, 0.3038607113775128, 0.2834889127091593, 0.5367012271394358, 0.6665041631271866, 0.6470809378199682, 0.826300600601544, 0.6459615747481052, 0.6295937556252862, 0.8141666576789224, 0.6794457138506325, 0.674640674702593, 0.7882796843070399, 0.08730247047386785, 0.1001866147374616, 0.09985249819005271, 0.08478850553974093, 0.08139016963617374, 0.09587175934905368, 0.09476051975967059, 0.08554474127867362, 0.09268304010438255, 0.18056799295595227, 0.19890684935146996, 0.13844864771477805, 0.1577514150113688, 0.14463179338844567, 0.14602238530396083, 0.148927827009254, 0.1422206914610351, 0.16419344241513012, 0.33969816467245706, 0.37223634434912933, 0.45944315949201253, 0.33850509693532793, 0.3480670641441407, 0.5068074327947006, 0.37623037448098406, 0.38923123836998286, 0.50214506110629, 0.28532252075391473, 0.2909056628253891, 0.3665584480251932, 0.2448920438056008, 0.23133872885800633, 0.35480447525079783, 0.2921039807868515, 0.2818011696535955, 0.35670292259544, 0.19839113690148036, 0.17916736209145934, 0.17816117229097583, 0.2000379610093994, 0.18914836050904227, 0.18120552762629982, 0.19172455643025899, 0.22725080042959656, 0.2140801629445781, 0.19997565931965144, 0.2178960325735152, 0.18113238866492742, 0.1885471092307709, 0.17007255120736808, 0.18424481655068548, 0.17989489122977853, 0.19092884567412183, 0.1890422935808268, 0.1494566560175986, 0.7394681297300789, 0.168112970953341, 0.246064844513167, 0.17758354252473363, 0.19330978837488733, 0.6995254281957433, 0.5460370914327082, 0.7566322533424777, 0.19945795563772106, 0.60961042168028, 0.1267537927590281, 0.3890311610325692, 0.19777883660205575, 0.7120598128843192, 0.20631381922890046, 0.2009732728485184, 0.12690286127674977, 0.19561561913049996, 0.19597064234490424, 0.1713743341336298, 0.18479265132623945, 0.1750261432647916, 0.19664112582322268, 0.18994017318896883, 0.18969031072394382, 0.18544681113035388, 0.07736869405238089, 0.07429985466387912, 0.07575464080496708, 0.08156083537179437, 0.07839765428093581, 0.08448402717972459, 0.06779506794100487, 0.06633698140455013, 0.07274456186852729]}, "mutation_prompt": null}
{"id": "cf41f6d6-10ab-49de-9041-530b51f821d6", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.chaos_sequence = self.generate_chaos_sequence()\n\n    def generate_chaos_sequence(self):\n        sequence = np.zeros(self.population_size)\n        x = 0.7  # initial value\n        for i in range(self.population_size):\n            x = 4.0 * x * (1 - x)\n            sequence[i] = x\n        return sequence\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, 1, size) * sigma\n        v = np.random.normal(0, 1, size)\n        return u / (np.abs(v) ** (1 / beta))\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        chaos_offsets = self.chaos_sequence[:, np.newaxis] * (self.upper_bound - self.lower_bound)\n        self.population = (self.population + chaos_offsets) % (self.upper_bound - self.lower_bound)\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            flight_step = self.levy_flight(self.dim)\n            return np.clip(a + self.mutation_factor * (b - c) + flight_step, self.lower_bound, self.upper_bound)\n        else:\n            d, e = self.population[np.random.choice(indices, 2, replace=False)]\n            return np.clip(a + self.mutation_factor * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.success_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Integrate chaotic initialization, Lvy flight mutation, and adaptive crossover for improved exploration and adaptability in EnhancedADEOptimizer.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "ed638585-e633-4803-ab26-56d09ac2ecbc", "metadata": {}, "mutation_prompt": null}
{"id": "c5a9673e-2a37-4481-9eae-09fce4262245", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Parallel Island-Model Differential Evolution with Adaptive Exploration-Exploitation Balance and Dynamic Strategy Tuning for Robust Black-Box Optimization.", "configspace": "", "generation": 49, "fitness": 0.422059778732907, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "ed638585-e633-4803-ab26-56d09ac2ecbc", "metadata": {"aucs": [0.7701071698121904, 0.7739622398414179, 0.8714863254814004, 0.7644806417267163, 0.774563337676615, 0.8685119973335337, 0.7652790004613379, 0.7814822833354831, 0.8546881901665065, 0.6302027081325128, 0.6175776207900061, 0.7703862189286983, 0.6134682417693413, 0.6522481094569965, 0.7890536898017617, 0.6206741110287015, 0.5822343818457505, 0.7869456776604898, 0.10605966319776183, 0.11101679445112134, 0.11003396155233114, 0.10769548354265335, 0.11482233401313768, 0.11289613556784661, 0.099844927001432, 0.12563814325001055, 0.11761188491814678, 0.09174195359018744, 0.08916492082012228, 0.1306006782443857, 0.0891303103454546, 0.096917437405592, 0.12937545515090876, 0.11183011950207689, 0.0985403120979288, 0.10834604135349857, 0.9680842512766984, 0.9597530626457279, 0.9774143756099978, 0.9107636650862225, 0.9660858701250786, 0.9019438444876235, 0.9790748141586113, 0.993277024665623, 0.8939944707163148, 0.5007467396621678, 0.42480374597410786, 0.6898191001886748, 0.4441662815484486, 0.45872775694294055, 0.6849709286870931, 0.4620857008039344, 0.5070446251602969, 0.6876766899224829, 0.7553030270633238, 0.8299118667818861, 0.8491664533603884, 0.806682645045464, 0.7815327251279295, 0.8724555458960916, 0.8072478801149642, 0.7834960553417012, 0.8554441738667322, 0.4912628710217254, 0.3883424050160095, 0.6548001629609108, 0.48273854152266604, 0.32487738069556427, 0.44792661852011517, 0.2290596160240287, 0.38142520451972883, 0.47019559126272703, 0.5097109739626867, 0.43428965107794115, 0.49176014115450895, 0.408876176309513, 0.26183965587550917, 0.38238718004071925, 0.350249999384173, 0.3673232719971957, 0.6277896794095454, 0.5371863005697226, 0.5566951132017592, 0.6988253387434802, 0.5424806097935073, 0.5238668397881219, 0.7249874158397731, 0.5564845310378335, 0.5109536089265343, 0.7193020747647232, 0.6545902721327256, 0.6021196711359166, 0.7688136036914077, 0.6189269386134515, 0.5943080328099177, 0.7904922941835997, 0.6211769499045658, 0.6357482065378157, 0.7641221186900573, 0.11480518271755813, 0.11414539968148552, 0.40093975758540557, 0.2907084258449413, 0.3042929987265688, 0.21780575781015432, 0.2176695441821349, 0.21489687181130102, 0.13094590349721802, 0.3841075355050473, 0.37922150809824573, 0.5966413297478814, 0.3790496435431765, 0.3835962355423743, 0.6022134905862802, 0.354603132268125, 0.3622470747075818, 0.5879385912921968, 0.683330709884076, 0.7213155056954439, 0.8412439289080881, 0.7435578651469985, 0.6945418592198886, 0.8396501927623691, 0.6950013823539862, 0.7135454289236298, 0.8376527022398077, 0.103244107663093, 0.10781988266048814, 0.09751045496095123, 0.08903040686699626, 0.10543508734032092, 0.12175857370142129, 0.11463487351992607, 0.10836745867418651, 0.12377608631529491, 0.13125618767516334, 0.17755804474298953, 0.1818818144030243, 0.1422768009754669, 0.16372656786233541, 0.21211802851844264, 0.1933011467050122, 0.15694534694120177, 0.10735396813153986, 0.41117216608031426, 0.40273361225194804, 0.5763011883103508, 0.4170108140086727, 0.38915853215018237, 0.6177715718916028, 0.4027728793864713, 0.39308993951233084, 0.561570098197945, 0.3113082101950042, 0.3323855392018682, 0.47191089735077496, 0.3505943169001037, 0.32475647192612267, 0.4471117644280508, 0.30036367454341706, 0.32225393200166597, 0.5300166281334366, 0.19377873681222713, 0.2226917386048468, 0.18532927273657096, 0.19610958104092957, 0.18720509574243194, 0.20221607714372725, 0.1970297207727144, 0.1970886765816463, 0.20066193409671573, 0.21456615012177893, 0.18897225706716558, 0.21233762312483773, 0.19144465671121103, 0.19626050114082016, 0.27715587916166673, 0.1932395329690858, 0.1840760293541055, 0.4113565692272232, 0.20115898022052547, 0.17001358082116425, 0.254703124627388, 0.6646530545188332, 0.19029371382469273, 0.14886927502712755, 0.17629566421443343, 0.19005030372706522, 0.8628212470883423, 0.7496217492721532, 0.20526577452428174, 0.796680478826322, 0.19386712133111372, 0.1981691851650187, 0.16573179227735746, 0.2047232510345144, 0.760491955913571, 0.8945551109770997, 0.18672574586773805, 0.17965527835884965, 0.17995149081537543, 0.18822153025398125, 0.19048790536427307, 0.1846891428677664, 0.18367109929624292, 0.1894012448581499, 0.16827720255066891, 0.07764811688226325, 0.07938583764107898, 0.07886560583209268, 0.0762006939959281, 0.08282881343598603, 0.08040276663321622, 0.07872540689227658, 0.07619988721633231, 0.08191714670013694]}, "mutation_prompt": null}
{"id": "64a427a4-423e-42cb-8b76-fbe1361f6f93", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.local_search_prob = 0.3\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def local_search(self, individual):\n        step_size = self.local_learning_rate * (self.upper_bound - self.lower_bound)\n        return np.clip(individual + np.random.uniform(-step_size, step_size, self.dim), self.lower_bound, self.upper_bound)\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n                    if np.random.rand() < self.local_search_prob:\n                        trial = self.local_search(trial)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Adaptive Memetic Differential Evolution with Dynamic Population Management and Hybrid Strategies for Enhanced Black-Box Optimization Performance.", "configspace": "", "generation": 50, "fitness": 0.3693126320343313, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "c5a9673e-2a37-4481-9eae-09fce4262245", "metadata": {"aucs": [0.6773025949629763, 0.6904089798015319, 0.7917921554331259, 0.7121044692946963, 0.6778204046781224, 0.7924330969625847, 0.6528874559583859, 0.7210946136064922, 0.7999998702688809, 0.47857758389842653, 0.44272019959886044, 0.5949800795509904, 0.4446638777806097, 0.4495788632088078, 0.6930320801182712, 0.4619889343018494, 0.42488063902484474, 0.652516548420677, 0.10515979091935657, 0.10224474904370073, 0.09687171494260816, 0.11000516408655858, 0.08395591981941541, 0.09618169721152281, 0.09008521495736699, 0.09003544310176481, 0.09555253447163581, 0.08798154436731898, 0.09176339354816043, 0.09537036585235803, 0.09187359081063473, 0.09073786624545532, 0.08871150226215996, 0.09665208983720075, 0.09847070948438941, 0.09795657747220354, 0.9766485292186662, 0.9778969674453893, 0.9775867982898763, 0.9399592862816112, 0.9414389975490337, 0.9737562424622609, 0.9487540107843236, 0.9760530514387094, 0.9729984830051932, 0.33222433805053264, 0.34189319967079523, 0.4815399217328167, 0.33807397344685886, 0.33666737456891027, 0.5549883440177745, 0.3530093661282031, 0.33843539912532516, 0.5586293395049822, 0.7182516499877596, 0.6871935985283305, 0.7566631339935046, 0.7255924826872258, 0.6935709298105089, 0.8077274760001132, 0.6627013017837149, 0.697512177483099, 0.7948642142146807, 0.23169706698494907, 0.17914463165888994, 0.3871431367371473, 0.1751621286302648, 0.19288452824014568, 0.5493783194127391, 0.22205698115680816, 0.17314526694761212, 0.27341315331266136, 0.19868385048914927, 0.15158652951750884, 0.5517030279698412, 0.22062248668599826, 0.29038105432822714, 0.24262068025971517, 0.2660629614598311, 0.1731755260330039, 0.2565436326540561, 0.28744984374900695, 0.2996785669338683, 0.5982536998665235, 0.3023945481464525, 0.3327405797696269, 0.5455929621826758, 0.3123419571003767, 0.3122675923320596, 0.5621763454491926, 0.5398577302248417, 0.4747287186840383, 0.659898558522273, 0.4349173397760081, 0.4829151925690992, 0.6642376436837579, 0.5245301684169659, 0.49583807091246856, 0.6832473631510474, 0.09231097155281875, 0.07989448913702601, 0.22812341295464833, 0.17011434022100802, 0.1695406127429997, 0.4643315363705769, 0.1536379189388798, 0.18856138933609268, 0.16804768221717437, 0.2728396534888925, 0.2532391395437873, 0.45498760560896934, 0.2664364359157415, 0.2409334954825738, 0.48434149111001823, 0.2934677038786998, 0.25260371971637774, 0.4471905908838517, 0.5796881995449867, 0.6150955388429129, 0.7680712644174879, 0.5755463990375835, 0.5965978679011892, 0.7579765716228848, 0.6099833743947689, 0.6085661134167195, 0.7659341045219837, 0.10320194683277983, 0.08068934638468439, 0.11309023952927988, 0.10523356935722405, 0.09590180772658152, 0.09702635880653965, 0.0986428395871537, 0.09438895944952852, 0.11695261669545287, 0.14945914432284357, 0.23805193566184712, 0.22347359786108012, 0.13407085002497754, 0.1555816122378133, 0.17216532195385081, 0.14330764253157435, 0.15975405271182697, 0.1655690132824006, 0.3411456472693971, 0.32827202732635774, 0.43205907944831123, 0.34004445024265917, 0.32459411333538823, 0.415911243692317, 0.3379986038936268, 0.31985061029553197, 0.4205076770646462, 0.25270268822216535, 0.3041304938588272, 0.3594394023941131, 0.2616602155478277, 0.2588018415704795, 0.3276899765004403, 0.27898112550864074, 0.26152456522147494, 0.3430913964332374, 0.18488754175034716, 0.1881599633251555, 0.1874563913352093, 0.18363034133766032, 0.1751172642785256, 0.18821698669936604, 0.18602554985649788, 0.18663553085399653, 0.19251600237957223, 0.2502833565287427, 0.22097865609731338, 0.22697192236159502, 0.1829632797141153, 0.1950780692463523, 0.1876637630520691, 0.21246751039198652, 0.16986031848559346, 0.18060998930476346, 0.733962163227087, 0.16416294469088355, 0.551338186864827, 0.6613165789892471, 0.6527875277767392, 0.18462272454640627, 0.6695294885874825, 0.6846418957468119, 0.6969227489224081, 0.5789441043165755, 0.20241344566122754, 0.8500629462225306, 0.6570472588442384, 0.5588806627867258, 0.744526583827877, 0.5856064700167936, 0.7044818190965567, 0.15299859814522643, 0.18913616561681068, 0.18292872729017673, 0.1871366066471435, 0.1766982436958453, 0.18400986341945214, 0.18166776488020087, 0.18793731889814091, 0.18635229207813586, 0.1737669164247081, 0.08859022381146753, 0.07415726775986098, 0.07410328638546038, 0.07808465514482743, 0.0816175406923696, 0.07878158284435832, 0.0727815089363456, 0.0729665008626913, 0.07252108671254331]}, "mutation_prompt": null}
{"id": "39ddd10f-0842-4baf-902c-f66216c7e193", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Parallel Island-Model Differential Evolution with Adaptive Exploration-Exploitation Balance and Dynamic Strategy Tuning for Robust Black-Box Optimization.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c5a9673e-2a37-4481-9eae-09fce4262245", "metadata": {"aucs": [0.7701071698121904, 0.7739622398414179, 0.8714863254814004, 0.7644806417267163, 0.774563337676615, 0.8685119973335337, 0.7652790004613379, 0.7814822833354831, 0.8546881901665065, 0.6302027081325128, 0.6175776207900061, 0.7703862189286983, 0.6134682417693413, 0.6522481094569965, 0.7890536898017617, 0.6206741110287015, 0.5822343818457505, 0.7869456776604898, 0.10605966319776183, 0.11101679445112134, 0.11003396155233114, 0.10769548354265335, 0.11482233401313768, 0.11289613556784661, 0.099844927001432, 0.12563814325001055, 0.11761188491814678, 0.09174195359018744, 0.08916492082012228, 0.1306006782443857, 0.0891303103454546, 0.096917437405592, 0.12937545515090876, 0.11183011950207689, 0.0985403120979288, 0.10834604135349857, 0.9680842512766984, 0.9597530626457279, 0.9774143756099978, 0.9107636650862225, 0.9660858701250786, 0.9019438444876235, 0.9790748141586113, 0.993277024665623, 0.8939944707163148, 0.5007467396621678, 0.42480374597410786, 0.6898191001886748, 0.4441662815484486, 0.45872775694294055, 0.6849709286870931, 0.4620857008039344, 0.5070446251602969, 0.6876766899224829, 0.7553030270633238, 0.8299118667818861, 0.8491664533603884, 0.806682645045464, 0.7815327251279295, 0.8724555458960916, 0.8072478801149642, 0.7834960553417012, 0.8554441738667322, 0.4912628710217254, 0.3883424050160095, 0.6548001629609108, 0.48273854152266604, 0.32487738069556427, 0.44792661852011517, 0.2290596160240287, 0.38142520451972883, 0.47019559126272703, 0.5097109739626867, 0.43428965107794115, 0.49176014115450895, 0.408876176309513, 0.26183965587550917, 0.38238718004071925, 0.350249999384173, 0.3673232719971957, 0.6277896794095454, 0.5371863005697226, 0.5566951132017592, 0.6988253387434802, 0.5424806097935073, 0.5238668397881219, 0.7249874158397731, 0.5564845310378335, 0.5109536089265343, 0.7193020747647232, 0.6545902721327256, 0.6021196711359166, 0.7688136036914077, 0.6189269386134515, 0.5943080328099177, 0.7904922941835997, 0.6211769499045658, 0.6357482065378157, 0.7641221186900573, 0.11480518271755813, 0.11414539968148552, 0.40093975758540557, 0.2907084258449413, 0.3042929987265688, 0.21780575781015432, 0.2176695441821349, 0.21489687181130102, 0.13094590349721802, 0.3841075355050473, 0.37922150809824573, 0.5966413297478814, 0.3790496435431765, 0.3835962355423743, 0.6022134905862802, 0.354603132268125, 0.3622470747075818, 0.5879385912921968, 0.683330709884076, 0.7213155056954439, 0.8412439289080881, 0.7435578651469985, 0.6945418592198886, 0.8396501927623691, 0.6950013823539862, 0.7135454289236298, 0.8376527022398077, 0.103244107663093, 0.10781988266048814, 0.09751045496095123, 0.08903040686699626, 0.10543508734032092, 0.12175857370142129, 0.11463487351992607, 0.10836745867418651, 0.12377608631529491, 0.13125618767516334, 0.17755804474298953, 0.1818818144030243, 0.1422768009754669, 0.16372656786233541, 0.21211802851844264, 0.1933011467050122, 0.15694534694120177, 0.10735396813153986, 0.41117216608031426, 0.40273361225194804, 0.5763011883103508, 0.4170108140086727, 0.38915853215018237, 0.6177715718916028, 0.4027728793864713, 0.39308993951233084, 0.561570098197945, 0.3113082101950042, 0.3323855392018682, 0.47191089735077496, 0.3505943169001037, 0.32475647192612267, 0.4471117644280508, 0.30036367454341706, 0.32225393200166597, 0.5300166281334366, 0.19377873681222713, 0.2226917386048468, 0.18532927273657096, 0.19610958104092957, 0.18720509574243194, 0.20221607714372725, 0.1970297207727144, 0.1970886765816463, 0.20066193409671573, 0.21456615012177893, 0.18897225706716558, 0.21233762312483773, 0.19144465671121103, 0.19626050114082016, 0.27715587916166673, 0.1932395329690858, 0.1840760293541055, 0.4113565692272232, 0.20115898022052547, 0.17001358082116425, 0.254703124627388, 0.6646530545188332, 0.19029371382469273, 0.14886927502712755, 0.17629566421443343, 0.19005030372706522, 0.8628212470883423, 0.7496217492721532, 0.20526577452428174, 0.796680478826322, 0.19386712133111372, 0.1981691851650187, 0.16573179227735746, 0.2047232510345144, 0.760491955913571, 0.8945551109770997, 0.18672574586773805, 0.17965527835884965, 0.17995149081537543, 0.18822153025398125, 0.19048790536427307, 0.1846891428677664, 0.18367109929624292, 0.1894012448581499, 0.16827720255066891, 0.07764811688226325, 0.07938583764107898, 0.07886560583209268, 0.0762006939959281, 0.08282881343598603, 0.08040276663321622, 0.07872540689227658, 0.07619988721633231, 0.08191714670013694]}, "mutation_prompt": null}
{"id": "01c5f2b4-4839-4717-bd3e-dc6e06fbfc15", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Parallel Island-Model Differential Evolution with Adaptive Exploration-Exploitation Balance and Dynamic Strategy Tuning for Robust Black-Box Optimization.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c5a9673e-2a37-4481-9eae-09fce4262245", "metadata": {"aucs": [0.7701071698121904, 0.7739622398414179, 0.8714863254814004, 0.7644806417267163, 0.774563337676615, 0.8685119973335337, 0.7652790004613379, 0.7814822833354831, 0.8546881901665065, 0.6302027081325128, 0.6175776207900061, 0.7703862189286983, 0.6134682417693413, 0.6522481094569965, 0.7890536898017617, 0.6206741110287015, 0.5822343818457505, 0.7869456776604898, 0.10605966319776183, 0.11101679445112134, 0.11003396155233114, 0.10769548354265335, 0.11482233401313768, 0.11289613556784661, 0.099844927001432, 0.12563814325001055, 0.11761188491814678, 0.09174195359018744, 0.08916492082012228, 0.1306006782443857, 0.0891303103454546, 0.096917437405592, 0.12937545515090876, 0.11183011950207689, 0.0985403120979288, 0.10834604135349857, 0.9680842512766984, 0.9597530626457279, 0.9774143756099978, 0.9107636650862225, 0.9660858701250786, 0.9019438444876235, 0.9790748141586113, 0.993277024665623, 0.8939944707163148, 0.5007467396621678, 0.42480374597410786, 0.6898191001886748, 0.4441662815484486, 0.45872775694294055, 0.6849709286870931, 0.4620857008039344, 0.5070446251602969, 0.6876766899224829, 0.7553030270633238, 0.8299118667818861, 0.8491664533603884, 0.806682645045464, 0.7815327251279295, 0.8724555458960916, 0.8072478801149642, 0.7834960553417012, 0.8554441738667322, 0.4912628710217254, 0.3883424050160095, 0.6548001629609108, 0.48273854152266604, 0.32487738069556427, 0.44792661852011517, 0.2290596160240287, 0.38142520451972883, 0.47019559126272703, 0.5097109739626867, 0.43428965107794115, 0.49176014115450895, 0.408876176309513, 0.26183965587550917, 0.38238718004071925, 0.350249999384173, 0.3673232719971957, 0.6277896794095454, 0.5371863005697226, 0.5566951132017592, 0.6988253387434802, 0.5424806097935073, 0.5238668397881219, 0.7249874158397731, 0.5564845310378335, 0.5109536089265343, 0.7193020747647232, 0.6545902721327256, 0.6021196711359166, 0.7688136036914077, 0.6189269386134515, 0.5943080328099177, 0.7904922941835997, 0.6211769499045658, 0.6357482065378157, 0.7641221186900573, 0.11480518271755813, 0.11414539968148552, 0.40093975758540557, 0.2907084258449413, 0.3042929987265688, 0.21780575781015432, 0.2176695441821349, 0.21489687181130102, 0.13094590349721802, 0.3841075355050473, 0.37922150809824573, 0.5966413297478814, 0.3790496435431765, 0.3835962355423743, 0.6022134905862802, 0.354603132268125, 0.3622470747075818, 0.5879385912921968, 0.683330709884076, 0.7213155056954439, 0.8412439289080881, 0.7435578651469985, 0.6945418592198886, 0.8396501927623691, 0.6950013823539862, 0.7135454289236298, 0.8376527022398077, 0.103244107663093, 0.10781988266048814, 0.09751045496095123, 0.08903040686699626, 0.10543508734032092, 0.12175857370142129, 0.11463487351992607, 0.10836745867418651, 0.12377608631529491, 0.13125618767516334, 0.17755804474298953, 0.1818818144030243, 0.1422768009754669, 0.16372656786233541, 0.21211802851844264, 0.1933011467050122, 0.15694534694120177, 0.10735396813153986, 0.41117216608031426, 0.40273361225194804, 0.5763011883103508, 0.4170108140086727, 0.38915853215018237, 0.6177715718916028, 0.4027728793864713, 0.39308993951233084, 0.561570098197945, 0.3113082101950042, 0.3323855392018682, 0.47191089735077496, 0.3505943169001037, 0.32475647192612267, 0.4471117644280508, 0.30036367454341706, 0.32225393200166597, 0.5300166281334366, 0.19377873681222713, 0.2226917386048468, 0.18532927273657096, 0.19610958104092957, 0.18720509574243194, 0.20221607714372725, 0.1970297207727144, 0.1970886765816463, 0.20066193409671573, 0.21456615012177893, 0.18897225706716558, 0.21233762312483773, 0.19144465671121103, 0.19626050114082016, 0.27715587916166673, 0.1932395329690858, 0.1840760293541055, 0.4113565692272232, 0.20115898022052547, 0.17001358082116425, 0.254703124627388, 0.6646530545188332, 0.19029371382469273, 0.14886927502712755, 0.17629566421443343, 0.19005030372706522, 0.8628212470883423, 0.7496217492721532, 0.20526577452428174, 0.796680478826322, 0.19386712133111372, 0.1981691851650187, 0.16573179227735746, 0.2047232510345144, 0.760491955913571, 0.8945551109770997, 0.18672574586773805, 0.17965527835884965, 0.17995149081537543, 0.18822153025398125, 0.19048790536427307, 0.1846891428677664, 0.18367109929624292, 0.1894012448581499, 0.16827720255066891, 0.07764811688226325, 0.07938583764107898, 0.07886560583209268, 0.0762006939959281, 0.08282881343598603, 0.08040276663321622, 0.07872540689227658, 0.07619988721633231, 0.08191714670013694]}, "mutation_prompt": null}
{"id": "a55faa30-2454-4d43-a98c-6231c5cef671", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Parallel Island-Model Differential Evolution with Adaptive Exploration-Exploitation Balance and Dynamic Strategy Tuning for Robust Black-Box Optimization.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c5a9673e-2a37-4481-9eae-09fce4262245", "metadata": {"aucs": [0.7701071698121904, 0.7739622398414179, 0.8714863254814004, 0.7644806417267163, 0.774563337676615, 0.8685119973335337, 0.7652790004613379, 0.7814822833354831, 0.8546881901665065, 0.6302027081325128, 0.6175776207900061, 0.7703862189286983, 0.6134682417693413, 0.6522481094569965, 0.7890536898017617, 0.6206741110287015, 0.5822343818457505, 0.7869456776604898, 0.10605966319776183, 0.11101679445112134, 0.11003396155233114, 0.10769548354265335, 0.11482233401313768, 0.11289613556784661, 0.099844927001432, 0.12563814325001055, 0.11761188491814678, 0.09174195359018744, 0.08916492082012228, 0.1306006782443857, 0.0891303103454546, 0.096917437405592, 0.12937545515090876, 0.11183011950207689, 0.0985403120979288, 0.10834604135349857, 0.9680842512766984, 0.9597530626457279, 0.9774143756099978, 0.9107636650862225, 0.9660858701250786, 0.9019438444876235, 0.9790748141586113, 0.993277024665623, 0.8939944707163148, 0.5007467396621678, 0.42480374597410786, 0.6898191001886748, 0.4441662815484486, 0.45872775694294055, 0.6849709286870931, 0.4620857008039344, 0.5070446251602969, 0.6876766899224829, 0.7553030270633238, 0.8299118667818861, 0.8491664533603884, 0.806682645045464, 0.7815327251279295, 0.8724555458960916, 0.8072478801149642, 0.7834960553417012, 0.8554441738667322, 0.4912628710217254, 0.3883424050160095, 0.6548001629609108, 0.48273854152266604, 0.32487738069556427, 0.44792661852011517, 0.2290596160240287, 0.38142520451972883, 0.47019559126272703, 0.5097109739626867, 0.43428965107794115, 0.49176014115450895, 0.408876176309513, 0.26183965587550917, 0.38238718004071925, 0.350249999384173, 0.3673232719971957, 0.6277896794095454, 0.5371863005697226, 0.5566951132017592, 0.6988253387434802, 0.5424806097935073, 0.5238668397881219, 0.7249874158397731, 0.5564845310378335, 0.5109536089265343, 0.7193020747647232, 0.6545902721327256, 0.6021196711359166, 0.7688136036914077, 0.6189269386134515, 0.5943080328099177, 0.7904922941835997, 0.6211769499045658, 0.6357482065378157, 0.7641221186900573, 0.11480518271755813, 0.11414539968148552, 0.40093975758540557, 0.2907084258449413, 0.3042929987265688, 0.21780575781015432, 0.2176695441821349, 0.21489687181130102, 0.13094590349721802, 0.3841075355050473, 0.37922150809824573, 0.5966413297478814, 0.3790496435431765, 0.3835962355423743, 0.6022134905862802, 0.354603132268125, 0.3622470747075818, 0.5879385912921968, 0.683330709884076, 0.7213155056954439, 0.8412439289080881, 0.7435578651469985, 0.6945418592198886, 0.8396501927623691, 0.6950013823539862, 0.7135454289236298, 0.8376527022398077, 0.103244107663093, 0.10781988266048814, 0.09751045496095123, 0.08903040686699626, 0.10543508734032092, 0.12175857370142129, 0.11463487351992607, 0.10836745867418651, 0.12377608631529491, 0.13125618767516334, 0.17755804474298953, 0.1818818144030243, 0.1422768009754669, 0.16372656786233541, 0.21211802851844264, 0.1933011467050122, 0.15694534694120177, 0.10735396813153986, 0.41117216608031426, 0.40273361225194804, 0.5763011883103508, 0.4170108140086727, 0.38915853215018237, 0.6177715718916028, 0.4027728793864713, 0.39308993951233084, 0.561570098197945, 0.3113082101950042, 0.3323855392018682, 0.47191089735077496, 0.3505943169001037, 0.32475647192612267, 0.4471117644280508, 0.30036367454341706, 0.32225393200166597, 0.5300166281334366, 0.19377873681222713, 0.2226917386048468, 0.18532927273657096, 0.19610958104092957, 0.18720509574243194, 0.20221607714372725, 0.1970297207727144, 0.1970886765816463, 0.20066193409671573, 0.21456615012177893, 0.18897225706716558, 0.21233762312483773, 0.19144465671121103, 0.19626050114082016, 0.27715587916166673, 0.1932395329690858, 0.1840760293541055, 0.4113565692272232, 0.20115898022052547, 0.17001358082116425, 0.254703124627388, 0.6646530545188332, 0.19029371382469273, 0.14886927502712755, 0.17629566421443343, 0.19005030372706522, 0.8628212470883423, 0.7496217492721532, 0.20526577452428174, 0.796680478826322, 0.19386712133111372, 0.1981691851650187, 0.16573179227735746, 0.2047232510345144, 0.760491955913571, 0.8945551109770997, 0.18672574586773805, 0.17965527835884965, 0.17995149081537543, 0.18822153025398125, 0.19048790536427307, 0.1846891428677664, 0.18367109929624292, 0.1894012448581499, 0.16827720255066891, 0.07764811688226325, 0.07938583764107898, 0.07886560583209268, 0.0762006939959281, 0.08282881343598603, 0.08040276663321622, 0.07872540689227658, 0.07619988721633231, 0.08191714670013694]}, "mutation_prompt": null}
{"id": "735b9809-7db9-4ddf-8ffc-064f5bdf8f14", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Parallel Island-Model Differential Evolution with Adaptive Exploration-Exploitation Balance and Dynamic Strategy Tuning for Robust Black-Box Optimization.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c5a9673e-2a37-4481-9eae-09fce4262245", "metadata": {"aucs": [0.7701071698121904, 0.7739622398414179, 0.8714863254814004, 0.7644806417267163, 0.774563337676615, 0.8685119973335337, 0.7652790004613379, 0.7814822833354831, 0.8546881901665065, 0.6302027081325128, 0.6175776207900061, 0.7703862189286983, 0.6134682417693413, 0.6522481094569965, 0.7890536898017617, 0.6206741110287015, 0.5822343818457505, 0.7869456776604898, 0.10605966319776183, 0.11101679445112134, 0.11003396155233114, 0.10769548354265335, 0.11482233401313768, 0.11289613556784661, 0.099844927001432, 0.12563814325001055, 0.11761188491814678, 0.09174195359018744, 0.08916492082012228, 0.1306006782443857, 0.0891303103454546, 0.096917437405592, 0.12937545515090876, 0.11183011950207689, 0.0985403120979288, 0.10834604135349857, 0.9680842512766984, 0.9597530626457279, 0.9774143756099978, 0.9107636650862225, 0.9660858701250786, 0.9019438444876235, 0.9790748141586113, 0.993277024665623, 0.8939944707163148, 0.5007467396621678, 0.42480374597410786, 0.6898191001886748, 0.4441662815484486, 0.45872775694294055, 0.6849709286870931, 0.4620857008039344, 0.5070446251602969, 0.6876766899224829, 0.7553030270633238, 0.8299118667818861, 0.8491664533603884, 0.806682645045464, 0.7815327251279295, 0.8724555458960916, 0.8072478801149642, 0.7834960553417012, 0.8554441738667322, 0.4912628710217254, 0.3883424050160095, 0.6548001629609108, 0.48273854152266604, 0.32487738069556427, 0.44792661852011517, 0.2290596160240287, 0.38142520451972883, 0.47019559126272703, 0.5097109739626867, 0.43428965107794115, 0.49176014115450895, 0.408876176309513, 0.26183965587550917, 0.38238718004071925, 0.350249999384173, 0.3673232719971957, 0.6277896794095454, 0.5371863005697226, 0.5566951132017592, 0.6988253387434802, 0.5424806097935073, 0.5238668397881219, 0.7249874158397731, 0.5564845310378335, 0.5109536089265343, 0.7193020747647232, 0.6545902721327256, 0.6021196711359166, 0.7688136036914077, 0.6189269386134515, 0.5943080328099177, 0.7904922941835997, 0.6211769499045658, 0.6357482065378157, 0.7641221186900573, 0.11480518271755813, 0.11414539968148552, 0.40093975758540557, 0.2907084258449413, 0.3042929987265688, 0.21780575781015432, 0.2176695441821349, 0.21489687181130102, 0.13094590349721802, 0.3841075355050473, 0.37922150809824573, 0.5966413297478814, 0.3790496435431765, 0.3835962355423743, 0.6022134905862802, 0.354603132268125, 0.3622470747075818, 0.5879385912921968, 0.683330709884076, 0.7213155056954439, 0.8412439289080881, 0.7435578651469985, 0.6945418592198886, 0.8396501927623691, 0.6950013823539862, 0.7135454289236298, 0.8376527022398077, 0.103244107663093, 0.10781988266048814, 0.09751045496095123, 0.08903040686699626, 0.10543508734032092, 0.12175857370142129, 0.11463487351992607, 0.10836745867418651, 0.12377608631529491, 0.13125618767516334, 0.17755804474298953, 0.1818818144030243, 0.1422768009754669, 0.16372656786233541, 0.21211802851844264, 0.1933011467050122, 0.15694534694120177, 0.10735396813153986, 0.41117216608031426, 0.40273361225194804, 0.5763011883103508, 0.4170108140086727, 0.38915853215018237, 0.6177715718916028, 0.4027728793864713, 0.39308993951233084, 0.561570098197945, 0.3113082101950042, 0.3323855392018682, 0.47191089735077496, 0.3505943169001037, 0.32475647192612267, 0.4471117644280508, 0.30036367454341706, 0.32225393200166597, 0.5300166281334366, 0.19377873681222713, 0.2226917386048468, 0.18532927273657096, 0.19610958104092957, 0.18720509574243194, 0.20221607714372725, 0.1970297207727144, 0.1970886765816463, 0.20066193409671573, 0.21456615012177893, 0.18897225706716558, 0.21233762312483773, 0.19144465671121103, 0.19626050114082016, 0.27715587916166673, 0.1932395329690858, 0.1840760293541055, 0.4113565692272232, 0.20115898022052547, 0.17001358082116425, 0.254703124627388, 0.6646530545188332, 0.19029371382469273, 0.14886927502712755, 0.17629566421443343, 0.19005030372706522, 0.8628212470883423, 0.7496217492721532, 0.20526577452428174, 0.796680478826322, 0.19386712133111372, 0.1981691851650187, 0.16573179227735746, 0.2047232510345144, 0.760491955913571, 0.8945551109770997, 0.18672574586773805, 0.17965527835884965, 0.17995149081537543, 0.18822153025398125, 0.19048790536427307, 0.1846891428677664, 0.18367109929624292, 0.1894012448581499, 0.16827720255066891, 0.07764811688226325, 0.07938583764107898, 0.07886560583209268, 0.0762006939959281, 0.08282881343598603, 0.08040276663321622, 0.07872540689227658, 0.07619988721633231, 0.08191714670013694]}, "mutation_prompt": null}
{"id": "111aed48-07fd-4ec9-b88f-15d60ebc4508", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.elite_archive_size = 5  # New elite archive size\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n                    self.update_elite_archive(self.population[i])  # Update elite archive\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        if len(self.archive) > 0:  # Use archive for migration\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                if self.success_rate > 0.5:\n                    self.population[island_a_start + swap_idx] = self.archive[np.random.randint(len(self.archive))]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def update_elite_archive(self, candidate):\n        if len(self.archive) < self.elite_archive_size:\n            self.archive.append(candidate)\n        else:\n            worst_idx = np.argmax([func(x) for x in self.archive])\n            if func(candidate) < func(self.archive[worst_idx]):\n                self.archive[worst_idx] = candidate\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                            self.update_elite_archive(trial)  # Update elite archive\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Dynamic Adaptive Differential Evolution with Multi-Island Learning and Elite Archive Strategy for Improved Black-Box Optimization Performance.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "c5a9673e-2a37-4481-9eae-09fce4262245", "metadata": {}, "mutation_prompt": null}
{"id": "63743242-ed2a-42ce-b91c-3641466a0628", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:\n                if np.random.rand() < 0.5: # Migration improvement\n                    self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                        self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7:\n            self.population_size = min(20 * self.dim, int(self.population_size * 1.1)) # Dynamic resizing\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def local_search(self, solution): # Local search integration\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n        return new_solution\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        local_sol = self.local_search(self.population[i])\n                        local_fitness = func(local_sol)\n                        evaluations += 1\n                        if local_fitness < self.fitness[i]:\n                            self.population[i] = local_sol\n                            self.fitness[i] = local_fitness\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Improved EnhancedADEOptimizer by introducing a dynamic island size strategy and integrating a local search heuristic for better convergence.", "configspace": "", "generation": 56, "fitness": 0.35180594822805583, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "c5a9673e-2a37-4481-9eae-09fce4262245", "metadata": {"aucs": [0.6856098067360019, 0.6770604070679076, 0.8037205151679929, 0.6531419468569002, 0.6911851819832839, 0.7853270493409001, 0.7069053473359772, 0.689426111556277, 0.8209197200712492, 0.42624561667096983, 0.3620578513974022, 0.6701434462834706, 0.4149921559120967, 0.3774110826959567, 0.6241688705976269, 0.41098241231177157, 0.4142145569442428, 0.6695651926706653, 0.12573801413360108, 0.10970116768756066, 0.11561133208182073, 0.12565566171678944, 0.11947553720230009, 0.13405641003615165, 0.1315811819866598, 0.13032995743272935, 0.1454690870338029, 0.12066108845408341, 0.10385298353599959, 0.12251370103466797, 0.10064007432111544, 0.09897222947803164, 0.1179482478925774, 0.09709870153836508, 0.09189186492376489, 0.11790326521133088, 0.9662149002199003, 0.9735294537047194, 0.9683092886925488, 0.9266881392029803, 0.8687378735841123, 0.9441742544307975, 0.9128806981114336, 0.9212994329002948, 0.8975501588730095, 0.31957964773080916, 0.3280684883246341, 0.5592622378100631, 0.2945017596653736, 0.30876631693558254, 0.488610626455514, 0.35209879845930225, 0.28182314721401325, 0.5349071383221413, 0.6368921723980909, 0.6026535114890148, 0.7713900408747263, 0.743175709312841, 0.6528819484993567, 0.8699124651331339, 0.6759817166353215, 0.6411060229611201, 0.7936781170233812, 0.16487316905992233, 0.23378567841057019, 0.4740693910103789, 0.32159104062045485, 0.20456719956338498, 0.32391490093808084, 0.18645903503800454, 0.2175521658945644, 0.34834480847940186, 0.3401500261566569, 0.18451725866070956, 0.23176727164358435, 0.2060650199213354, 0.38451728123947204, 0.4327489722131923, 0.23751747850059513, 0.18297066219114333, 0.43614244470097707, 0.2865227512485766, 0.28032845731495604, 0.544639324032612, 0.3227787352451208, 0.2803003714911828, 0.5386555500850289, 0.2598509308244613, 0.30289819190498923, 0.5815709828125116, 0.4616618482845355, 0.41658591411363055, 0.6604478522905932, 0.4023604261446023, 0.39053347846122166, 0.6174174397785075, 0.3980626098579355, 0.412228827932122, 0.6560660111652141, 0.08114154981297483, 0.08117963611410939, 0.2659613653101546, 0.11095197850295313, 0.12278173459820041, 0.23722449008809, 0.1317469317202905, 0.08380728412021088, 0.24569026789516213, 0.23160835514736744, 0.23008679439351476, 0.42007589102589227, 0.23766288708532002, 0.22597433024994718, 0.3884609939011079, 0.2461461997368143, 0.2492500817552078, 0.3918598929402579, 0.5734127750710231, 0.5491940793486425, 0.7435761710366489, 0.5949487273292564, 0.5960483567583588, 0.7226157177340939, 0.5548426460508671, 0.562202942778887, 0.7409817499108446, 0.10686948692828901, 0.10560612701953687, 0.1255390671948715, 0.10679326657191746, 0.1165733359787473, 0.13072848788809244, 0.1056393224294685, 0.11258376209640486, 0.12353346261279008, 0.18464038700453178, 0.21944735785920366, 0.2192140995100379, 0.27912333245090526, 0.19952747773561752, 0.21693999673866937, 0.20495627719321308, 0.18308603956672864, 0.18013580035602894, 0.3184120152325467, 0.29832918613668735, 0.39645255899534726, 0.3188289541382522, 0.2917736504732844, 0.3584655709997848, 0.3142939820734708, 0.2956635829996772, 0.3455880974472798, 0.2354722124179196, 0.22870838366084512, 0.28645821455946185, 0.24883815705054435, 0.23282784692016378, 0.32516148538454814, 0.23297138465579026, 0.2175413648380934, 0.2642694650913784, 0.19781519083222432, 0.1886177212998379, 0.20709915762081543, 0.1827757412546308, 0.22733037753413943, 0.18646533154914446, 0.19779483636951922, 0.18264036727983712, 0.21206814774314353, 0.19222266321642667, 0.20199671528842877, 0.21931771074541961, 0.19048229296150787, 0.19109375536334605, 0.20079455490744613, 0.20654985944993998, 0.18309647414258312, 0.18972925959870035, 0.1807617382553195, 0.5983809625981165, 0.6569812041220251, 0.6214714909345063, 0.1995801756776422, 0.1925971147398603, 0.6612134527775787, 0.5131603911126683, 0.18107306746275253, 0.6701821240126682, 0.5099216497618628, 0.7869167017622144, 0.6095630522370225, 0.39434249633749674, 0.1651651788659546, 0.16013236062052583, 0.20210581318464416, 0.813122168673979, 0.19402816321521055, 0.1873189220833259, 0.1839122264921591, 0.17832269475614615, 0.2059874201050378, 0.2028770477302657, 0.18218577296631022, 0.18673475906148151, 0.17991269615227679, 0.0717807882511925, 0.08919335388398208, 0.07981711814164849, 0.07007624213433317, 0.07871053396700933, 0.08408391668828319, 0.0755074726581979, 0.08850390424273469, 0.07482810431372622]}, "mutation_prompt": null}
{"id": "83a9763c-69ba-4d09-bde6-592d6b5074f7", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.archive = []\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self):\n        for i in range(self.num_islands - 1):\n            swap_idx = np.random.randint(0, self.sub_population_size)\n            island_a_start = i * self.sub_population_size\n            island_b_start = (i + 1) * self.sub_population_size\n            if self.success_rate > 0.5:\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                self.migrate()\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Parallel Island-Model Differential Evolution with Adaptive Exploration-Exploitation Balance and Dynamic Strategy Tuning for Robust Black-Box Optimization.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c5a9673e-2a37-4481-9eae-09fce4262245", "metadata": {"aucs": [0.7701071698121904, 0.7739622398414179, 0.8714863254814004, 0.7644806417267163, 0.774563337676615, 0.8685119973335337, 0.7652790004613379, 0.7814822833354831, 0.8546881901665065, 0.6302027081325128, 0.6175776207900061, 0.7703862189286983, 0.6134682417693413, 0.6522481094569965, 0.7890536898017617, 0.6206741110287015, 0.5822343818457505, 0.7869456776604898, 0.10605966319776183, 0.11101679445112134, 0.11003396155233114, 0.10769548354265335, 0.11482233401313768, 0.11289613556784661, 0.099844927001432, 0.12563814325001055, 0.11761188491814678, 0.09174195359018744, 0.08916492082012228, 0.1306006782443857, 0.0891303103454546, 0.096917437405592, 0.12937545515090876, 0.11183011950207689, 0.0985403120979288, 0.10834604135349857, 0.9680842512766984, 0.9597530626457279, 0.9774143756099978, 0.9107636650862225, 0.9660858701250786, 0.9019438444876235, 0.9790748141586113, 0.993277024665623, 0.8939944707163148, 0.5007467396621678, 0.42480374597410786, 0.6898191001886748, 0.4441662815484486, 0.45872775694294055, 0.6849709286870931, 0.4620857008039344, 0.5070446251602969, 0.6876766899224829, 0.7553030270633238, 0.8299118667818861, 0.8491664533603884, 0.806682645045464, 0.7815327251279295, 0.8724555458960916, 0.8072478801149642, 0.7834960553417012, 0.8554441738667322, 0.4912628710217254, 0.3883424050160095, 0.6548001629609108, 0.48273854152266604, 0.32487738069556427, 0.44792661852011517, 0.2290596160240287, 0.38142520451972883, 0.47019559126272703, 0.5097109739626867, 0.43428965107794115, 0.49176014115450895, 0.408876176309513, 0.26183965587550917, 0.38238718004071925, 0.350249999384173, 0.3673232719971957, 0.6277896794095454, 0.5371863005697226, 0.5566951132017592, 0.6988253387434802, 0.5424806097935073, 0.5238668397881219, 0.7249874158397731, 0.5564845310378335, 0.5109536089265343, 0.7193020747647232, 0.6545902721327256, 0.6021196711359166, 0.7688136036914077, 0.6189269386134515, 0.5943080328099177, 0.7904922941835997, 0.6211769499045658, 0.6357482065378157, 0.7641221186900573, 0.11480518271755813, 0.11414539968148552, 0.40093975758540557, 0.2907084258449413, 0.3042929987265688, 0.21780575781015432, 0.2176695441821349, 0.21489687181130102, 0.13094590349721802, 0.3841075355050473, 0.37922150809824573, 0.5966413297478814, 0.3790496435431765, 0.3835962355423743, 0.6022134905862802, 0.354603132268125, 0.3622470747075818, 0.5879385912921968, 0.683330709884076, 0.7213155056954439, 0.8412439289080881, 0.7435578651469985, 0.6945418592198886, 0.8396501927623691, 0.6950013823539862, 0.7135454289236298, 0.8376527022398077, 0.103244107663093, 0.10781988266048814, 0.09751045496095123, 0.08903040686699626, 0.10543508734032092, 0.12175857370142129, 0.11463487351992607, 0.10836745867418651, 0.12377608631529491, 0.13125618767516334, 0.17755804474298953, 0.1818818144030243, 0.1422768009754669, 0.16372656786233541, 0.21211802851844264, 0.1933011467050122, 0.15694534694120177, 0.10735396813153986, 0.41117216608031426, 0.40273361225194804, 0.5763011883103508, 0.4170108140086727, 0.38915853215018237, 0.6177715718916028, 0.4027728793864713, 0.39308993951233084, 0.561570098197945, 0.3113082101950042, 0.3323855392018682, 0.47191089735077496, 0.3505943169001037, 0.32475647192612267, 0.4471117644280508, 0.30036367454341706, 0.32225393200166597, 0.5300166281334366, 0.19377873681222713, 0.2226917386048468, 0.18532927273657096, 0.19610958104092957, 0.18720509574243194, 0.20221607714372725, 0.1970297207727144, 0.1970886765816463, 0.20066193409671573, 0.21456615012177893, 0.18897225706716558, 0.21233762312483773, 0.19144465671121103, 0.19626050114082016, 0.27715587916166673, 0.1932395329690858, 0.1840760293541055, 0.4113565692272232, 0.20115898022052547, 0.17001358082116425, 0.254703124627388, 0.6646530545188332, 0.19029371382469273, 0.14886927502712755, 0.17629566421443343, 0.19005030372706522, 0.8628212470883423, 0.7496217492721532, 0.20526577452428174, 0.796680478826322, 0.19386712133111372, 0.1981691851650187, 0.16573179227735746, 0.2047232510345144, 0.760491955913571, 0.8945551109770997, 0.18672574586773805, 0.17965527835884965, 0.17995149081537543, 0.18822153025398125, 0.19048790536427307, 0.1846891428677664, 0.18367109929624292, 0.1894012448581499, 0.16827720255066891, 0.07764811688226325, 0.07938583764107898, 0.07886560583209268, 0.0762006939959281, 0.08282881343598603, 0.08040276663321622, 0.07872540689227658, 0.07619988721633231, 0.08191714670013694]}, "mutation_prompt": null}
{"id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 58, "fitness": 0.42466355138972506, "feedback": "The algorithm RefinedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "c5a9673e-2a37-4481-9eae-09fce4262245", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "f7f0f310-7dd1-49ff-a0c5-9de7adab5082", "solution": "import numpy as np\n\nclass ImprovedDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted\n        self.sub_population_size = np.random.randint(5 * dim, 7 * dim)  # Adjusted\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.6  # Adjusted\n        self.crossover_rate = 0.85  # Adjusted\n        self.success_rate = 0.5  # Adjusted\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.1  # Adjusted\n        self.strategy_prob = [0.4, 0.6]  # Adjusted\n        self.global_learning_rate = 0.2  # Adjusted\n        self.local_learning_rate = 0.4  # Adjusted\n        self.migration_interval = 3  # Adjusted\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < self.strategy_prob[0]:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n                self.fitness[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.fitness[[island_b_start + swap_idx, island_a_start + swap_idx]]  # Ensure fitness swap\n\n    def resize_population(self):\n        if self.success_rate > 0.75 and self.population_size < 25 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.2, self.success_rate - self.dynamic_adjustment)  # Adjusted\n\n                    # Dynamic parameter adjustment\n                    self.mutation_factor = 0.4 + self.local_learning_rate * np.random.rand()  # Adjusted\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Adjusted\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "ImprovedDEOptimizer", "description": "Improved Differential Evolution with Dynamic Strategy Adaptation and Enhanced Island Collaboration for Better Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "27d9961f-0785-4d54-8bfd-a4d32f6b2588", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "f68938ed-9de4-49f5-a5a0-5313554596f1", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "19668ddf-206a-49af-975c-612a9f77e941", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5\n        self.archive = []\n        self.rank_threshold = 0.45  # New parameter for stochastic ranking\n        self.strategy_switch_interval = 10  # New parameter\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx, generation):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < self.strategy_prob[0]:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            scale = self.global_learning_rate if generation % 2 == 0 else self.local_learning_rate\n            return np.clip(a + self.mutation_factor * (b - c + scale * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def stochastic_ranking(self, trial, target, trial_fitness, target_fitness):\n        if np.random.rand() < self.rank_threshold:\n            return trial_fitness < target_fitness\n        else:\n            return np.linalg.norm(trial) < np.linalg.norm(target)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx, generation)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if self.stochastic_ranking(trial, self.population[i], trial_fitness, self.fitness[i]):\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1\n                self.migrate(generation)\n                if generation % self.strategy_switch_interval == 0:\n                    self.strategy_prob = [np.random.rand(), 1 - np.random.rand()]\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution integrating Stochastic Ranking and Dynamic Strategy Adaptation for improved exploration and exploitation balance in black-box optimization.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "5303c4e9-fe1b-45b5-80d7-f284a18db8d1", "solution": "import numpy as np\n\nclass EnhancedDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.sub_population_size = np.random.randint(3 * dim, 5 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.85\n        self.success_rate = 0.15\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.03\n        self.strategy_prob = [0.4, 0.6]\n        self.global_learning_rate = 0.15\n        self.local_learning_rate = 0.35\n        self.migration_interval = 4\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.6:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.6 and self.population_size < 15 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.6 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.75 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedDEOptimizer", "description": "Enhanced Differential Evolution with Adaptive Control Mechanism and Dynamic Learning Strategies for Improved Convergence in Black-Box Optimization.", "configspace": "", "generation": 63, "fitness": 0.41951226122336405, "feedback": "The algorithm EnhancedDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7345556295768538, 0.7436612793123649, 0.8641129931227515, 0.7349316846726283, 0.7632358928690062, 0.8654304548325602, 0.7610951939005232, 0.7689388681359643, 0.8674784691000546, 0.5553209925750646, 0.555538243927211, 0.7641581415239554, 0.5820080665709162, 0.5718971107649589, 0.7475787888650509, 0.5629307254388054, 0.5595478040958866, 0.7788236019482536, 0.08987137493937647, 0.0942502185445303, 0.27619288120480134, 0.09384930614881393, 0.0848928982591004, 0.10311680492909836, 0.1121246202794337, 0.11190707528964905, 0.126794481558404, 0.0811497217395416, 0.08475532889967485, 0.10491584889793326, 0.0930029433381665, 0.09704375661368736, 0.10341041425091335, 0.09577274773216382, 0.09172867008024732, 0.13305733229784256, 0.9553966912881935, 0.9774891387752126, 0.9809307093851388, 0.8844762255763963, 0.9483435970952276, 0.9564642477176389, 0.9156892065348006, 0.9330112105965316, 0.8746355162880622, 0.43154152322231576, 0.4036877182715384, 0.6588359489795088, 0.44121124911373644, 0.4380960856206384, 0.6894413162016155, 0.4419664904133689, 0.4220116357957512, 0.7132043862042622, 0.7468827217342051, 0.7466784147552671, 0.8542690250018606, 0.7715115107653621, 0.7604362490036526, 0.8704296651435564, 0.7617967385352601, 0.7734721021207123, 0.838924805006628, 0.41658436084934525, 0.46328593441867705, 0.7068257184254516, 0.5686187900130295, 0.45192370771306145, 0.5692517279728742, 0.518541808395697, 0.425831409220935, 0.7058236841977004, 0.48130330055230175, 0.41480267279649574, 0.697788166733593, 0.41337528218598696, 0.29641071173588185, 0.6797792912674333, 0.435257322592857, 0.27476747554229464, 0.7034143022392962, 0.48719285099754117, 0.527189582827019, 0.6921577872888494, 0.4682445869800129, 0.39580748034020885, 0.6824745046850591, 0.4991097455808414, 0.4665841127716761, 0.6902122516851201, 0.544326453556986, 0.5990601600094909, 0.7600116350199775, 0.5519241424175014, 0.6121460279269436, 0.737199189555227, 0.6395229711081865, 0.637082562093924, 0.7757622974013572, 0.17833143991428368, 0.24473031156657588, 0.35950049941088236, 0.3084417879592657, 0.2974834805040085, 0.5982006306582504, 0.2001957508412574, 0.24962300542675353, 0.22778458872075258, 0.35914924648263447, 0.3435055426318585, 0.610585012380716, 0.33705068812290995, 0.3387505710901899, 0.5777683310951337, 0.325983118182529, 0.3272720517381844, 0.5887302837007422, 0.6755098794790264, 0.6471150665626093, 0.81768731392625, 0.6799829172277215, 0.6859621386378896, 0.8295428941485213, 0.6427952562930286, 0.7104497990696237, 0.8224484436108137, 0.09894815569791315, 0.08212879117027772, 0.12483245968450996, 0.09546901396804774, 0.08894729479333074, 0.1131735057665263, 0.07807046709433274, 0.10011770570188017, 0.11420800974417611, 0.1435186803312175, 0.21758487772925694, 0.350594561008134, 0.14999721885049222, 0.1888159321213987, 0.31336348449141904, 0.2953650816745337, 0.1778374326950256, 0.20346865544658277, 0.34048784330263127, 0.3845909364310758, 0.5101517669663103, 0.3283752873584259, 0.34338981637522803, 0.49007085567866404, 0.3681376871257378, 0.36778181409009125, 0.5460914190554009, 0.2968379207697366, 0.2626968726697472, 0.43618411069012986, 0.29099285805665753, 0.2775106364722466, 0.48548411886924736, 0.29412578799788514, 0.29783613103384643, 0.46732373713833253, 0.1914587580527759, 0.18025599109367774, 0.19061342672854098, 0.18952969861184654, 0.191297931669549, 0.19971720220655553, 0.18476350399083064, 0.1880829789357793, 0.1965758463504802, 0.19174049166651486, 0.20049701199000758, 0.2287048150367922, 0.18469873006650672, 0.1878061474460846, 0.2296895795795031, 0.19315432589250836, 0.18686246138660123, 0.22474524105945715, 0.7890356195064485, 0.16810217070887634, 0.12427517462248838, 0.1608088673255157, 0.18466226001634922, 0.8302471177020353, 0.16889543389674821, 0.5986485552133278, 0.2010870149720112, 0.16656666650900775, 0.19223489747834166, 0.2110458494841131, 0.6514090466770912, 0.7523901572759468, 0.8700447250859873, 0.21250140167871456, 0.6962054430488609, 0.12805594727359115, 0.18846633775191957, 0.1755765413003042, 0.18667134925043616, 0.18322275188845194, 0.18489547204556067, 0.16624721792744745, 0.17611108531624964, 0.1879168357845158, 0.18846561165734332, 0.07566453901042769, 0.07012064277982533, 0.07301548436724292, 0.07591296462090846, 0.06979151279222773, 0.07324093868214054, 0.0802945676146728, 0.07849054833186331, 0.0855340509713216]}, "mutation_prompt": null}
{"id": "33a227f4-8f04-4b4c-82ea-e40504ad29e7", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "c417f8d6-65a3-4c84-bcf2-3d806ada03e9", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.sub_population_size = np.random.randint(5 * dim, 7 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.4  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.success_rate = 0.4     # Adjusted initial success rate\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.1  # Adjusted dynamic adjustment\n        self.strategy_prob = [0.4, 0.6]\n        self.global_learning_rate = 0.15  # Adjusted global learning rate\n        self.local_learning_rate = 0.25\n        self.migration_interval = 3  # Adjusted migration interval\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.local_learning_rate * np.random.rand() * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.75 and self.population_size < 25 * self.dim:\n            self.population_size += 2\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n            self.population = np.vstack([self.population, new_individuals])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.2, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.4 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.85 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Stochastic Population Control and Adaptive Mutation for Optimal Black-Box Performance.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "ea5f855b-f330-4f49-8e82-e86b5a54e0ed", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "baffe514-d8fd-4ff8-9e58-af2d63e0efb8", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "9c6eecfa-f555-4606-99d4-25e710c59240", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "4ffc1f87-d6c0-4f0e-9591-09f4afeebf9f", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "70ba1e2e-656c-4981-8cc8-609d7b22ad27", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for diversity\n        self.sub_population_size = np.random.randint(5 * dim, 7 * dim)  # Adjusted range\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.8  # Adjusted mutation factor for higher exploration\n        self.crossover_rate = 0.85\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.03  # Reduced adjustment for smoother adaptation\n        self.strategy_prob = [0.4, 0.6]  # Adjusted strategy probabilities\n        self.global_learning_rate = 0.15  # Adjusted global learning rate\n        self.local_learning_rate = 0.25\n        self.migration_interval = 3  # More frequent migration\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < self.strategy_prob[0]:  # Modified strategy selection\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            d = self.population[np.random.choice(indices)]\n            return np.clip(a + self.mutation_factor * (b - c + self.local_learning_rate * (d - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.65 and self.population_size < 22 * self.dim:\n            self.population_size += 2  # Increase increment\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))  # Add two new individuals\n            self.population = np.vstack([self.population, new_individuals])\n            self.fitness = np.append(self.fitness, [np.inf, np.inf])\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.6 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Island Organization and Novel Mutation Strategies for Superior Performance in Black-Box Optimization.", "configspace": "", "generation": 70, "fitness": 0.36103481127079085, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.6443339954949054, 0.680160956716233, 0.8058361268953756, 0.7226952007104697, 0.7024297839971714, 0.8523276353935584, 0.688323907909399, 0.7216956213315869, 0.8380565544788533, 0.4722571627318183, 0.4563811629773967, 0.6879388001370574, 0.44502290025711344, 0.4436377230718085, 0.7148103176254457, 0.4539434655232103, 0.48218252723445654, 0.7086222211223615, 0.09826296291180481, 0.09761050596374277, 0.09515265627238056, 0.09558431050626481, 0.0966255396973571, 0.10446062335479056, 0.09146502207885476, 0.1125693717744809, 0.12083315617578061, 0.0801795515782684, 0.08081464560406604, 0.09926671814057375, 0.08559894720150385, 0.08018388161542445, 0.08763709849230983, 0.11024779429524534, 0.08395397705552299, 0.09192475173500603, 0.8809795050368631, 0.9410578163986979, 0.9796206794633059, 0.8581170633254261, 0.9412154383536955, 0.8031855722677834, 0.7366150852040769, 0.8877590748974766, 0.9827791658388716, 0.3301593093779629, 0.3298993990762331, 0.5608029778212036, 0.3114291494885747, 0.33826250872360064, 0.5921629473289511, 0.3743728992060844, 0.3395973055355658, 0.6082948305681344, 0.6486146066439236, 0.656006588378347, 0.8156999021896615, 0.6832151473366201, 0.658591202464226, 0.8369884690744404, 0.698794873632746, 0.6149175973999974, 0.8364639678107703, 0.26539494396535357, 0.319743545584373, 0.5984824625225451, 0.29971722173729853, 0.2899011659069205, 0.39508271405959206, 0.2936723669465575, 0.31175934673657435, 0.6437521127898049, 0.25950341154532286, 0.3030105494471619, 0.4921351795578145, 0.2589140897658758, 0.23705700488669335, 0.6071285946758004, 0.27530862161404135, 0.31956240283659154, 0.5434418242021049, 0.2820611074036353, 0.2733763770651648, 0.6534556845027896, 0.32306627485567474, 0.32976377219122865, 0.6215516847434316, 0.32002510482220947, 0.34413785420311427, 0.6459352150068041, 0.4239258296919367, 0.4845320072353345, 0.6999076649986762, 0.46317931447362104, 0.40280116015009315, 0.7080257969174977, 0.4900280434490044, 0.45636647237245964, 0.7292756798463573, 0.08973652706454072, 0.11586834661812295, 0.29336070364547717, 0.18058658834686325, 0.1300896069411538, 0.19786546872067035, 0.11028281397239803, 0.14921709484681656, 0.30547068531635446, 0.2613714279591183, 0.2800126711972618, 0.5302270841577784, 0.2637637582057858, 0.24091273080475506, 0.5293298536111367, 0.2539081919084313, 0.2555827511598928, 0.5138833057977727, 0.5950332767361391, 0.5828263468605264, 0.7616041269840812, 0.5978875209608795, 0.6067671334498859, 0.7998156187893254, 0.6077472025872761, 0.584929564134063, 0.7721798259496947, 0.08165586994170515, 0.07971211484865293, 0.08839406080932966, 0.08981470597376173, 0.08488058735011439, 0.08840799716855219, 0.0850471190103812, 0.08437914810817915, 0.097484631992934, 0.15109198844324523, 0.16037145194009572, 0.16170354224354055, 0.12341154874648452, 0.18004566942752986, 0.15301857961414844, 0.15603189214266788, 0.129141008263418, 0.14109821795678856, 0.3189224820419444, 0.3197332016669817, 0.45767098289772123, 0.30075043205836294, 0.3153737803203064, 0.4294148387978064, 0.32205960059999006, 0.31989524146864545, 0.4734225446842011, 0.25047812811928827, 0.26425281990175264, 0.37948468299273996, 0.24978546656122347, 0.24544123452186306, 0.3733837238869745, 0.25017050171808997, 0.24591364149054806, 0.35287195274145455, 0.1996233238216164, 0.18856804064434451, 0.17891430340721837, 0.17843766785934168, 0.1942258943534626, 0.1868156177909942, 0.21585153116064826, 0.18772606849669515, 0.18276695984090352, 0.18453655580410355, 0.1749627723445536, 0.19184872707707334, 0.18003834111178463, 0.17238521511250693, 0.20700116602477003, 0.18057207859920477, 0.1791137367838772, 0.18864679719197108, 0.17554441237839236, 0.6933584025390298, 0.17075874263592328, 0.18515961562651484, 0.1748101363158897, 0.18438715505318992, 0.541097180549141, 0.6495209289395046, 0.7911727647841816, 0.1652152659175874, 0.5590104070116216, 0.6895163726050191, 0.23949993005098325, 0.17535004622749606, 0.2040738902466056, 0.20655089359001144, 0.21087353898392613, 0.80715140576758, 0.17939815639877266, 0.18428175824709836, 0.18409502706048342, 0.18336358923710672, 0.19935878138471907, 0.17645364309984557, 0.18009049298889768, 0.17202492196150576, 0.186386644369534, 0.06922578579817584, 0.07723931200492329, 0.08378583853463684, 0.07459378774731251, 0.07344559102949866, 0.08493594075520938, 0.07560183226471362, 0.07086420732282417, 0.07469915684597839]}, "mutation_prompt": null}
{"id": "e2d82264-3d49-4364-abda-5835a70ae094", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "3c574cc4-566c-4ea0-8897-96db0c9016e0", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "9a1741e3-2930-4c9f-9056-6fbb8375ea17", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "34cc9360-5040-40b9-9ff9-150deb51f0bc", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased base population size\n        self.sub_population_size = np.random.randint(4 * dim, 8 * dim)  # Adjusted range for sub-populations\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.success_rate = 0.3  # Initial success rate changed\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.1  # Increased dynamic adjustment\n        self.strategy_prob = [0.4, 0.6]  # Modified strategy probabilities\n        self.global_learning_rate = 0.2  # Increased global learning rate\n        self.local_learning_rate = 0.2  # Adjusted local learning rate\n        self.migration_interval = 4  # Reduced migration interval\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        d = self.best_solution\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c) + self.global_learning_rate * (d - a), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c) + np.random.rand() * (d - a), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 24 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.6 + self.local_learning_rate * np.random.rand()  # Adjusted mutation update\n                    self.crossover_rate = 0.85 + (1 - self.success_rate) * np.random.rand()  # Adjusted crossover update\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Island Collaboration and Hybrid Mutation Strategy for Robust Black-Box Optimization.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "31c9c1a6-5ede-41aa-94e8-c6baeb2c475a", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "b04f3d5c-cd0f-451c-b5cd-489ea64bdcbc", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5\n        self.archive = []\n        self.elitism_rate = 0.1  # New parameter for elitism\n        self.rank_weight = 0.8  # New parameter for stochastic ranking\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def stochastic_ranking(self):\n        ranks = np.argsort(self.fitness)\n        ranked_population = self.population[ranks]\n        self.population = self.rank_weight * ranked_population + (1 - self.rank_weight) * np.roll(ranked_population, 1, axis=0)\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1\n                self.migrate(generation)\n            self.stochastic_ranking()  # Apply stochastic ranking\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Island Collaboration, Stochastic Ranking, and Adaptive Parameter Control for Improved Black-Box Optimization Performance.", "configspace": "", "generation": 76, "fitness": 0.21514531379552992, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7247300696183888, 0.7994628621241859, 0.40904087015465806, 0.8123392311087333, 0.4805152943523139, 0.36465664068952686, 0.7859215579171795, 0.6743166982876869, 0.3622836792477686, 0.122540470982749, 0.0468275029191112, 9.999999999998899e-05, 0.21332709893888913, 0.32067242935054674, 9.999999999998899e-05, 0.10254978207373822, 0.05662544333394348, 9.999999999998899e-05, 0.11725592713041455, 0.1080054495325048, 0.057773949672968006, 0.15618600128096238, 0.1555216588611109, 0.09150205078880558, 0.11045668936131203, 0.15409002889864387, 0.06057295070605373, 0.057320008518350174, 0.05684805025867079, 0.05892547803130277, 0.07804956521004902, 0.07168228887453931, 0.016249325347840182, 0.06633072706231757, 0.09015716547605257, 0.03326746696344107, 0.8002542170637952, 0.9169815863022672, 0.9775880345414674, 0.830792763909368, 0.9801789000053068, 0.07384895489179777, 0.7478906367071005, 0.8951040005791729, 0.05376186433352892, 0.1835096715282878, 0.18877438136752545, 0.1677012429816066, 0.16912633154041068, 0.3325211195986387, 0.0918794029106933, 0.2015531555987542, 0.20985370508595658, 0.1633757959887151, 0.8721585679673055, 0.2369863917600904, 0.2608704116435929, 0.3309431937422368, 0.8832617146764182, 0.2535437741110619, 0.21261031468604785, 0.38284846426509334, 0.14635148307866186, 0.1780587896640271, 0.13244976290547872, 9.999999999998899e-05, 0.1301862936211211, 0.15774125490471047, 0.10490429067055174, 0.19672420456716844, 0.142661541019661, 0.2229508321755449, 0.17671534824077917, 0.15776220047407719, 0.13496526801047226, 0.14180069684817576, 0.1286693933590648, 0.21021794766467672, 0.12338484338050015, 0.15833411148674437, 0.13527955510825485, 0.0024574294965861165, 0.015354978290427979, 9.999999999998899e-05, 9.999999999998899e-05, 0.010483537127274345, 9.999999999998899e-05, 0.004026369568518207, 0.05937004639955901, 9.999999999998899e-05, 0.0955650091453375, 0.2027884956728203, 0.07917895366008598, 0.04273299273094766, 0.09143109352358658, 0.11713826000943395, 0.19329311531767213, 0.12463428928216957, 0.04887526252943386, 0.09493434997594652, 0.12192910585722405, 9.999999999998899e-05, 0.15393787810434112, 0.1235823609691733, 0.024898342445683896, 0.12587221455325392, 0.08849914208057819, 9.999999999998899e-05, 0.12550391428591212, 0.24799746962303137, 0.11298078480305107, 0.20272908425033587, 0.2381644071246497, 0.1332145674899442, 0.3544699218701387, 0.1673732278711032, 0.055839134487340014, 0.5567657847279865, 0.41508704955678954, 0.34820660468695064, 0.4116574581905714, 0.3848901389918651, 0.2337573211034526, 0.485339080700514, 0.5329076291721677, 0.3470736547903278, 0.06531837047649969, 0.12654357706688935, 0.025834105890842896, 0.07997059942453977, 0.0979527761750687, 0.06326352989145978, 0.08657534184326576, 0.08455686545230945, 0.04944076213370996, 0.13497789018014406, 0.16420578358593851, 0.13367374290282263, 0.08982620829263976, 0.13050302054400365, 0.19203855864060537, 0.1394067193043671, 0.14326074817567713, 0.15350963149319796, 0.29715720145200986, 0.21368135454527692, 0.2004287848222669, 0.5080282022587768, 0.30063551973405345, 0.21137908280952444, 0.2161431383646889, 0.264960305944027, 0.16982615703688553, 0.1630400102680566, 0.2955649491636758, 0.21016543675702937, 0.24125179142763586, 0.31983047505768114, 0.18123546196435103, 0.22962187114241694, 0.2291811321807975, 0.13026184982435485, 0.22220691316384267, 0.19984540563179487, 0.1897604493985745, 0.21050148556137815, 0.2198356675371984, 0.21666151194922312, 0.23835113180230183, 0.19406861131540076, 0.24748156365415763, 0.15485522316884492, 0.16955148803725406, 0.15974817314472434, 0.17062692329449725, 0.16165216833056983, 0.16578951267039044, 0.16964096148596275, 0.16541993689617052, 0.1639687582829441, 0.18586154435546454, 0.18686832273897747, 0.11645731325074904, 0.16306060552680102, 0.1708747667927919, 0.5558969136085024, 0.8965515542973937, 0.16751421059333282, 0.16059241928404533, 0.38509743462897505, 0.8467991974342949, 0.2319008432999664, 0.16472855258601216, 0.166695992499865, 0.07758872325937405, 0.21023865688245813, 0.12257354209178284, 0.30224885722215744, 0.17666239315727394, 0.15401907989795294, 0.1733456136138236, 0.16329972689034367, 0.19769949418841548, 0.18711525782501737, 0.18233914548612218, 0.2561751685573289, 0.18890541349424117, 0.07672088776574804, 0.07742631670281686, 0.05482257810663016, 0.07352965246134013, 0.07871493902306304, 0.09314559171030645, 0.08718368275411503, 0.08909071177453387, 0.09740454601287218]}, "mutation_prompt": null}
{"id": "7303219b-1d99-4786-874d-0ae6299e354e", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "a5f17ab2-32b9-4f1b-bdb5-cc536d8370b8", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.archive = np.empty((0, self.dim))  # Initialize archive\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_adaptive(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b = self.population[np.random.choice(indices, 2, replace=False)]\n        if len(self.archive) > 0:\n            c = self.archive[np.random.randint(len(self.archive))]  # Use archive\n        else:\n            c = self.population[np.random.choice(indices)]\n        return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    if np.random.rand() < self.strategy_prob[0]:\n                        mutant = self.mutate_adaptive(i, island_idx)\n                    else:\n                        mutant = self.mutate_hybrid(i, island_idx)\n\n                    trial = self.crossover(self.population[i], mutant)\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        if len(self.archive) < self.sub_population_size:\n                            self.archive = np.vstack([self.archive, self.population[i]])\n                        else:\n                            replace_idx = np.random.randint(len(self.archive))\n                            self.archive[replace_idx] = self.population[i]\n                            \n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Adaptive Strategy Selection and Dynamic Archive-Based Mutation for Superior Black-Box Optimization Performance.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedADEOptimizer' object has no attribute 'mutate_hybrid'\").", "error": "AttributeError(\"'EnhancedADEOptimizer' object has no attribute 'mutate_hybrid'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "bf6872a0-6857-45b9-9b28-5075f3ac731b", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "15cda1da-e716-4a13-844c-53511b7c3f65", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted size\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.15  # Increased learning rate\n        self.local_learning_rate = 0.35  # Adjusted local learning rate\n        self.migration_interval = 7  # Adjusted migration interval\n        self.archive = []  # Dynamic archive initialization\n        self.archive_size = 50  # New parameter for archive size\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 24 * self.dim:  # Increased upper limit\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def update_archive(self, individual, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((individual, fitness))\n        else:\n            max_idx = np.argmax([fit for _, fit in self.archive])\n            if fitness < self.archive[max_idx][1]:\n                self.archive[max_idx] = (individual, fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.update_archive(trial, trial_fitness)  # Update archive\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Island Collaboration, Improved Parameter Control, and Dynamic Archive Usage for Superior Convergence in Black-Box Optimization.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "8a8412e7-4b2a-4bdb-85cb-b804fe172b4a", "solution": "import numpy as np\n\nclass EnhancedPEOOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.2  # Adjusted parameter\n        self.local_learning_rate = 0.4  # Adjusted parameter\n        self.migration_interval = 5\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutation_strategy = np.random.rand()\n        if mutation_strategy < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 15 * self.dim:  # Adjusted max population size\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.7 + (1 - self.success_rate) * np.random.rand()  # Adjusted base crossover rate\n\n                generation += 1\n                self.migrate(generation)\n\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedPEOOptimizer", "description": "Enhanced Parallel Evolutionary Differential Optimization with Adaptive Mutation Rate and Inter-Island Communication for Superior Convergence on Black-Box Functions.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "e753f8ee-a5db-4f52-9752-4e2934a02b8d", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "b3e10332-d0d9-4fb7-a91f-afef729e63ce", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "f7e91c48-e602-48ff-a590-d032c67ed0c5", "solution": "import numpy as np\n\nclass HybridStrategyADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.mutation_memory = [0.5] * 5  # New memory for mutation factors\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mut_factor = np.random.choice(self.mutation_memory)  # Use a historical mutation factor\n        if np.random.rand() < 0.5:\n            return np.clip(a + mut_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + mut_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def update_mutation_memory(self, factor):\n        self.mutation_memory.pop(0)\n        self.mutation_memory.append(factor)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                        self.update_mutation_memory(self.mutation_factor)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "HybridStrategyADEOptimizer", "description": "Hybrid Strategy Adaptive Differential Evolution utilizing Adaptive Mutation Rates, Cooperative Islands, and Historical Memory for Improved Black-Box Optimization.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "00237de1-774c-4dcd-b374-89ef20ddb365", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "0fd6feb3-23e5-4e85-80c4-bf0a06de32ba", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted to enhance exploration\n        self.sub_population_size = np.random.randint(5 * dim, 8 * dim)  # Adjusted range for island\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.6  # Increased to enhance diversity\n        self.crossover_rate = 0.85  # Slightly adjusted\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.4, 0.6]  # Adjusted probabilities for strategies\n        self.global_learning_rate = 0.15  # Increased for more global influence\n        self.local_learning_rate = 0.4  # Increased for diversified search\n        self.migration_interval = 3  # Reduced for more frequent collaboration\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < self.strategy_prob[0]:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            # New mutation strategy\n            d = self.population[np.random.choice(indices)]\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - d)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 25 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.55 + self.local_learning_rate * np.random.rand()  # Modified factor adjustment\n                    self.crossover_rate = 0.75 + (1 - self.success_rate) * np.random.rand()  # Modified rate adjustment\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Multi-phase Mutation Strategy and Adaptive Island Collaboration for Improved Optimization Efficiency.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "e85abefb-6d87-4c67-9a92-a6fe1c83ebc9", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "8a3c5310-e9c6-437c-9f60-7854b5c8e58d", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "64315510-aad3-47c5-bd1a-c817e9decf1d", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "e481af40-c3fd-4e0a-87c2-e814fa285569", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "dd52d3d6-0d49-4823-bfd1-856d62fa6d81", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "40787c81-919e-4526-a83b-005fc64dcfdb", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "6095fb0b-36b1-49ec-8763-e70725275078", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5\n        self.archive = []\n        self.intensification_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < self.strategy_prob[0]:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def local_intensification(self, func, trial):\n        for _ in range(3):  # Local search with few steps\n            perturbation = np.random.normal(0, self.intensification_threshold, self.dim)\n            new_trial = np.clip(trial + perturbation, self.lower_bound, self.upper_bound)\n            new_fitness = func(new_trial)\n            if new_fitness < func(trial):\n                trial = new_trial\n        return trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial = self.local_intensification(func, trial)  # Apply local intensification\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1\n                self.migrate(generation)\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Differential Evolution with Adaptive Island Collaboration and Local Search Intensification for Improved Convergence in Black-Box Optimization.", "configspace": "", "generation": 93, "fitness": 0.15847020094696018, "feedback": "The algorithm EnhancedADEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.15.", "error": "", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.27393269882998594, 0.2791471973157821, 0.3935715406409701, 0.3275761949415188, 0.26845377319843267, 0.3755572929730451, 0.2732185840189928, 0.28896600249669846, 0.4280941153625031, 0.033877764408109745, 0.02457977995425986, 0.12619001175717492, 0.02679016167252979, 0.03136972038287844, 0.12951088465741611, 0.02495602579130285, 0.026835716026538337, 0.13160806879678455, 0.06334714421312149, 0.05766213131492548, 0.07455512334488035, 0.06820376075440215, 0.07668558490842137, 0.0756262500431456, 0.05368786593342578, 0.06935441493039529, 0.09065513748858689, 0.05742979065210074, 0.059619509028273066, 0.05691682181389679, 0.05100243741486321, 0.04151468225725863, 0.06621975844227801, 0.061744109147606085, 0.04148051060479141, 0.04800902460523482, 0.8828978476730709, 0.5714524377258748, 0.9611238108614792, 0.7536513890489985, 0.615507941623109, 0.7609915955740169, 0.5773067282870681, 0.6187063181168524, 0.7287667246826393, 0.12145887496351093, 0.10124473444603932, 0.19691023302551125, 0.08718220722965797, 0.1420679327085922, 0.14576350016670514, 0.08895948633069783, 0.12974332124134347, 0.18955475131223543, 0.17965958245809577, 0.16423351947815734, 0.21906298438985405, 0.1965513617112037, 0.1639793626476025, 0.34640127831188494, 0.21064496754317874, 0.23295057907511973, 0.3799710553482969, 0.08172511290011075, 0.08516634861601291, 0.11770225427813952, 0.05693276111213019, 0.07892727566958224, 0.11461249113727612, 0.07476189870303773, 0.08161188910459938, 0.1276600264250819, 0.06362673237119454, 0.048288474477745535, 0.14258331594802198, 0.06054393005785064, 0.05660927511795366, 0.12335691872004917, 0.05772788082807678, 0.07282922325722752, 0.09407468479073089, 0.017011998371786796, 0.023445824766811674, 0.09805948150016142, 0.014735929508972734, 0.0047202834035499075, 0.09755960355291626, 0.017916782716170587, 0.008653274697343671, 0.1054306712285501, 0.12405598458759415, 0.11999899729412755, 0.1748679482354044, 0.10387483233387451, 0.10715092919871205, 0.19312652454631274, 0.10394025102475957, 0.1387621581918247, 0.20965635127887872, 9.999999999998899e-05, 9.999999999998899e-05, 0.01254404991137037, 9.999999999998899e-05, 9.999999999998899e-05, 0.013901651721493491, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017803672926335334, 0.0482821678251073, 0.04024469807191822, 0.08632088709968122, 0.055212064515122616, 0.05132309253553935, 0.09535147704018676, 0.04667586414727953, 0.060473315005565964, 0.08070399939724815, 0.26797162811424335, 0.2844279147162402, 0.343583729593097, 0.2724242441408976, 0.25089943725694863, 0.3355763062699475, 0.29620446351540897, 0.2791645353583655, 0.3759188320054121, 0.0687171578536947, 0.06923888035148207, 0.07957772893549042, 0.07620478438042633, 0.06417696104983839, 0.0757290019429302, 0.06559566701472397, 0.0697253028336281, 0.08702558442018582, 0.13409536506095066, 0.13806829260117426, 0.13536143013597435, 0.15511511801639577, 0.12544889836432027, 0.1295302685484776, 0.14042075506427265, 0.1218193414723675, 0.15248491375214468, 0.1909246425986808, 0.18084750112663173, 0.22492323683587223, 0.19126157041347092, 0.18594506903614105, 0.22297032342155798, 0.19746883450189257, 0.19969014474012325, 0.2160975190072305, 0.13528307987364174, 0.1358705396446589, 0.1709880949256556, 0.14860496686626468, 0.13969516105233448, 0.1739410636608747, 0.13169743183234495, 0.13452285930933194, 0.13566962652462822, 0.15746580353361272, 0.16767867919772694, 0.1665879718644313, 0.18235388322802648, 0.17195337858945825, 0.17889056954228633, 0.16150142874818318, 0.17091285544118584, 0.16994163242770177, 0.1728280198560307, 0.13177565482724063, 0.15358237389524787, 0.14195695886275894, 0.1442367485088658, 0.16328948819424183, 0.14812650133700533, 0.15570945485871268, 0.17060221650973928, 0.1249471309518616, 0.18978719429533875, 0.2666627711425721, 0.14707044271887626, 0.22271149152761627, 0.173838185569531, 0.1511328543140038, 0.19546522937575173, 0.4701833872199912, 0.17723350131649296, 0.22662846743497567, 0.16634968570170117, 0.1972995069224538, 0.13775319682554377, 0.10781866995574507, 0.11206684969792491, 0.13882362288494665, 0.12160105516288455, 0.17189917173050928, 0.1768963792357806, 0.17226271806890614, 0.17587573767748832, 0.17936872758038003, 0.18811685958677138, 0.17176516697711774, 0.18298226054394207, 0.1683507108901935, 0.06222000851921439, 0.06178259697897537, 0.06117981317620125, 0.058925439354939435, 0.07541034378981926, 0.06649877977705165, 0.05242545912618046, 0.056578242306669524, 0.05953384802317685]}, "mutation_prompt": null}
{"id": "f84d97b5-b645-4573-8e8e-b460250e4a50", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "af703bc7-c333-4c39-a1e4-512376d1aef8", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "efa66fe6-da39-41a2-a8a7-794fad28d225", "solution": "import numpy as np\n\nclass EnhancedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        f_dynamic = self.mutation_factor * (1 + np.random.rand())  # Adjust mutation factor\n        if np.random.rand() < 0.5:\n            return np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + f_dynamic * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        adaptive_cr = self.crossover_rate + 0.1 * np.random.randn()  # Adapt crossover rate\n        adaptive_cr = np.clip(adaptive_cr, 0.1, 0.9)\n        crossover_mask = np.random.rand(self.dim) < adaptive_cr  # Use adaptive_cr\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                if np.random.rand() < 0.5:\n                    self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                        self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedADEOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Learning and Island Shuffle for Improved Exploration and Convergence.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "166aee31-7e24-4733-a831-dbeb3658caea", "solution": "import numpy as np\n\nclass RefinedADEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5  # New parameter\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:  # Check migration interval\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0  # New variable to track generations\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.5 + self.local_learning_rate * np.random.rand()\n                    self.crossover_rate = 0.8 + (1 - self.success_rate) * np.random.rand()\n\n                generation += 1  # Increment generation counter\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "RefinedADEOptimizer", "description": "Refined Adaptive Differential Evolution with Dynamic Island Collaboration and Improved Parameter Control for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.7590235938528742, 0.7420193940392875, 0.8639103601126582, 0.779560089190713, 0.7738308221965721, 0.8712035117830507, 0.7722680372972812, 0.7568070223262688, 0.8853757529560282, 0.5972410206187495, 0.6009943780864089, 0.7768807131825868, 0.6236430728696647, 0.6169228898218571, 0.7639167138601677, 0.60280340815302, 0.6131161462905143, 0.7551141586013892, 0.10993945340184275, 0.10671455866331891, 0.09943655226533643, 0.11148305518604995, 0.09992625952453527, 0.14759997822109105, 0.09622920250735933, 0.11138580769002071, 0.1639352485676132, 0.10122885568146267, 0.09845107775931883, 0.11553485460195301, 0.08430940309399992, 0.10151649293044707, 0.15721300166321306, 0.09979138068661941, 0.08752521118223267, 0.1212927576077587, 0.9318582468798218, 0.8725019788013053, 0.86434205987106, 0.8656867307847251, 0.8718069713091849, 0.9634527546906084, 0.933437471937628, 0.9690819546878087, 0.9296799298393341, 0.4551771105315292, 0.4648537176947003, 0.6532677547605494, 0.47755252315816155, 0.46714654687891344, 0.6991381810296651, 0.4425294454133335, 0.49421069788391603, 0.6548976949547688, 0.7917233104596783, 0.7616997470951029, 0.8396518838939266, 0.7854117552448834, 0.7849186553641841, 0.9162190260632334, 0.8241805164288138, 0.7837670827956824, 0.7564971164036399, 0.240179790944557, 0.4054494271314012, 0.513389902250523, 0.23490178037590181, 0.4198560340709371, 0.16700166064049826, 0.2802353614030261, 0.4863799023789659, 0.5121332733046509, 0.3996485526109277, 0.38059826009582165, 0.4826515205353805, 0.35618607492458554, 0.48680286764943326, 0.13066491095093202, 0.2233354491166133, 0.48280405461001497, 0.5834632207142818, 0.5565636934917746, 0.572240389248054, 0.6989568943142717, 0.5589892563307679, 0.5462682394652543, 0.7364285007260671, 0.5668593964325297, 0.5731659884150004, 0.7478777398397257, 0.6444883684861005, 0.6380740782702903, 0.7986812944975142, 0.6406812924074221, 0.6619177490155592, 0.8030440915928612, 0.6445733823013902, 0.6263311385954332, 0.788214037868781, 0.08242517080360046, 0.14233369532463314, 0.3814094085823836, 0.21226777879231684, 0.41403811664270884, 0.36022143531628903, 0.24162891956282906, 0.2081360718071601, 0.3866498612290937, 0.38155325779463367, 0.3981705854220947, 0.6476751373147296, 0.36321414903134974, 0.4055651880792708, 0.646298676794899, 0.3799002430727042, 0.4068153547585619, 0.6255105723381662, 0.7378810138965888, 0.737420472981988, 0.8364829865990129, 0.7106365720817164, 0.7166892528978215, 0.8635599968805341, 0.7391449019008727, 0.7214123273881616, 0.840075748700728, 0.0923998150512203, 0.1055194592343992, 0.07538257956909478, 0.1199783736770138, 0.09242816788212072, 0.11121391474901632, 0.09252926283538743, 0.10149202775846222, 0.12020537972621681, 0.11619047090778656, 0.1416394651071814, 0.22648350301487108, 0.14189687028117315, 0.1919477251367755, 0.19876326565764946, 0.15518989370842062, 0.20427789068079594, 0.23437045729372463, 0.3841943084771283, 0.3773426493214248, 0.6042082848172888, 0.3905778345525408, 0.38313483881229615, 0.5925893424521191, 0.40341835926259806, 0.42273046799016734, 0.5284765022161129, 0.2855843296856734, 0.33111177932566327, 0.5643297516687924, 0.3046299626910247, 0.3272782864882757, 0.5045444542938267, 0.33378215252111454, 0.3167086574953232, 0.4604310138425458, 0.1904653282304546, 0.21859569941244672, 0.21900355118030956, 0.20464361592306335, 0.1913245488133889, 0.19663930521837114, 0.1792293615966366, 0.20215560109074382, 0.22817644656995695, 0.1754760590294291, 0.2027996107517417, 0.2088823065542187, 0.18703826658507605, 0.18822920424067668, 0.19583662349833464, 0.25118350353673746, 0.18236675547953596, 0.1917103552077416, 0.18861830220047526, 0.1691671518581015, 0.1609363455323677, 0.653204273154457, 0.6905163133226705, 0.19186234325635432, 0.8140911419769585, 0.5012925758883429, 0.14574210457128134, 0.20031265173305768, 0.1641654218759815, 0.8467853905104196, 0.20530551240904893, 0.606485663832562, 0.8391811396757709, 0.6486577208566044, 0.2027392346471223, 0.8647786437835868, 0.18482539539407994, 0.18675830664376358, 0.19252529969433774, 0.1935893607167295, 0.1816738909880149, 0.18044767213691137, 0.19923153971170127, 0.18065258360806036, 0.17726121144161133, 0.08519786998577128, 0.07815340995235487, 0.07899167643734328, 0.07863251373289526, 0.0699355084571609, 0.0883792118528296, 0.07529020433240452, 0.07450277907409053, 0.07770952149978039]}, "mutation_prompt": null}
{"id": "f937287b-daa7-433c-90c6-444a1847d2f5", "solution": "import numpy as np\n\nclass EnhancedDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size\n        self.sub_population_size = np.random.randint(5 * dim, 7 * dim)  # Adjusted subpopulation size range\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.03  # Adjusted dynamic adjustment rate\n        self.strategy_prob = [0.4, 0.6]  # Updated strategy probabilities\n        self.global_learning_rate = 0.15  # Adjusted global learning rate\n        self.local_learning_rate = 0.35  # Adjusted local learning rate\n        self.migration_interval = 7  # Adjusted migration interval\n        self.archive = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.6:  # Adjusted probability\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.75 and self.population_size < 24 * self.dim:  # Adjusted population growth condition\n            self.population_size += 2  # Increase by 2 individuals instead of 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                    self.mutation_factor = 0.6 + self.local_learning_rate * np.random.rand()  # Adjusted mutation factor calculation\n                    self.crossover_rate = 0.85 + (1 - self.success_rate) * np.random.rand()  # Adjusted crossover rate calculation\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedDEOptimizer", "description": "Enhanced Differential Evolution with Dynamic Island Collaboration and Adaptive Parameter Tuning for Improved Convergence.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {}, "mutation_prompt": null}
{"id": "8b946afe-7d1f-467b-b2b4-783b8eb53b97", "solution": "import numpy as np\n\nclass EnhancedDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.sub_population_size = np.random.randint(4 * dim, 6 * dim)\n        self.num_islands = max(1, self.population_size // self.sub_population_size)\n        self.population = None\n        self.fitness = None\n        self.mutation_factor = 0.7  # Modified mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.success_rate = 0.2\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_adjustment = 0.05\n        self.strategy_prob = [0.5, 0.5]\n        self.global_learning_rate = 0.1\n        self.local_learning_rate = 0.3\n        self.migration_interval = 5\n        self.archive = []\n        self.diversity_factor = 0.2  # New parameter for diversity enhancement\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def mutate_hybrid(self, target_idx, island_idx):\n        start = island_idx * self.sub_population_size\n        end = start + self.sub_population_size\n        indices = np.arange(start, end)\n        indices = np.delete(indices, target_idx - start)\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        if np.random.rand() < 0.5:\n            return np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        else:\n            diversity_adjustment = self.diversity_factor * np.random.randn(self.dim)  # New diversity adjustment\n            return np.clip(a + self.mutation_factor * (b - c + self.global_learning_rate * (self.best_solution - a)) + diversity_adjustment, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        weights = np.random.rand(self.dim)\n        crossover_mask = weights < (self.crossover_rate * np.abs(mutant - target))  # Modified crossover strategy\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def migrate(self, generation):\n        if generation % self.migration_interval == 0:\n            for i in range(self.num_islands - 1):\n                swap_idx = np.random.randint(0, self.sub_population_size)\n                island_a_start = i * self.sub_population_size\n                island_b_start = (i + 1) * self.sub_population_size\n                self.population[[island_a_start + swap_idx, island_b_start + swap_idx]] = \\\n                    self.population[[island_b_start + swap_idx, island_a_start + swap_idx]]\n\n    def resize_population(self):\n        if self.success_rate > 0.7 and self.population_size < 20 * self.dim:\n            self.population_size += 1\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evaluations = 0\n        generation = 0\n\n        while evaluations < self.budget:\n            for island_idx in range(self.num_islands):\n                start = island_idx * self.sub_population_size\n                end = start + self.sub_population_size\n                for i in range(start, end):\n                    if evaluations >= self.budget:\n                        break\n\n                    mutant = self.mutate_hybrid(i, island_idx)\n                    trial = self.crossover(self.population[i], mutant)\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                        self.success_rate = min(1.0, self.success_rate + self.dynamic_adjustment)\n                    else:\n                        self.success_rate = max(0.1, self.success_rate - self.dynamic_adjustment)\n\n                generation += 1\n                self.migrate(generation)\n            self.resize_population()\n\n        return self.best_solution", "name": "EnhancedDEOptimizer", "description": "Enhanced Differential Evolution with Dynamic Island Collaboration and Multi-Criterion Recombination for Efficient Black-Box Optimization.", "configspace": "", "generation": 99, "fitness": 0.2359888067971998, "feedback": "The algorithm EnhancedDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "b8330fea-8a97-445c-9b9c-f4ddf150a816", "metadata": {"aucs": [0.5566501984388631, 0.5530423392357158, 0.7878943292861185, 0.5833344100021991, 0.5688316190823781, 0.789007626833864, 0.605465312940199, 0.5819352888728714, 0.804048656380212, 0.1633479590640804, 0.17584187498030956, 0.5510222108150888, 0.13821726083482322, 0.19726413280236277, 0.5641474332518478, 0.17266403269571307, 0.16390815730059016, 0.5527958140840155, 0.1519711736662388, 0.1343224115930327, 0.37565254771874723, 0.1223560395844503, 0.12114885743579218, 0.36403796284586765, 0.12577831430739406, 0.13572620571354332, 0.3029231802425576, 0.11218648308518875, 0.128899978145959, 0.30099266760749976, 0.12136967781269759, 0.11515060352235573, 0.3216061421978348, 0.11299270100133874, 0.11550904352046365, 0.25885282530472764, 0.9639325656590083, 0.980666831188607, 0.9919394937137739, 0.91603769546154, 0.9245340423380476, 0.9659783285444771, 0.946597575458484, 0.9297768954417948, 0.9582832175100358, 0.2406280184623586, 0.23823733011745873, 0.3073253598504673, 0.23505731343335168, 0.23907233498310987, 0.31356108069379685, 0.21811494355044114, 0.22417393194916735, 0.2636948820563262, 0.25551122792695546, 0.2806221912116923, 0.3006069424581247, 0.2908182194412392, 0.27473380920677337, 0.3120778310929182, 0.27401706925170477, 0.2876251019580929, 0.3407982846628632, 0.138232401732711, 0.14623457985223853, 0.15595555855793497, 0.1305267572376292, 0.15652102515503974, 0.15503287159491652, 0.15040103155559514, 0.15363041351730755, 0.15424811283444173, 0.12846186022966033, 0.15223557185020165, 0.11307632072596385, 0.15051620533454646, 0.1331729827140331, 0.1543660263197063, 0.14093649443008793, 0.14009800803930994, 0.14303775966119991, 0.012111620126460942, 0.008086989737751682, 0.043349265348653576, 0.032784720651643284, 0.06762022579741855, 0.10108467037770719, 0.05960011481484273, 0.044474209383182695, 0.10239018834553115, 0.15909394528820053, 0.16095802606967358, 0.18371081930703292, 0.15076931815688643, 0.1384968381824816, 0.16300586814704854, 0.17927398512419312, 0.16235885757743074, 0.17991033307287285, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004842759263311902, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08236721814603121, 0.09646501890848391, 0.11150721682803144, 0.09731997128343284, 0.08585504184105519, 0.14077668401557453, 0.08975211163092267, 0.09004118493361113, 0.10835842695415321, 0.39216308201380057, 0.40575574539571124, 0.48375505065050384, 0.39720820676192703, 0.40545800890010253, 0.4052240146448369, 0.3998595373048125, 0.38620225561613886, 0.476508673601476, 0.09392388336361457, 0.09892817050202352, 0.10317578952661133, 0.07959606398949637, 0.0891975472371016, 0.10426515483411913, 0.08021080563587457, 0.08557842574270746, 0.10750278839862881, 0.15414500584452961, 0.14014879257276713, 0.20667235237147497, 0.12609319707597733, 0.19830128777766654, 0.24880220127596353, 0.1571771144486933, 0.18120582250376038, 0.2126439865739338, 0.2661682097168103, 0.27448881287137605, 0.29994427829230286, 0.27224658932142665, 0.2578746120587494, 0.29183037750870555, 0.2662663411235401, 0.25977630054443235, 0.29773059273735725, 0.201418805802563, 0.20609350432048557, 0.2229082381670736, 0.19663135929995135, 0.19200683319510792, 0.21118330140584907, 0.20413942954412057, 0.19112034497579522, 0.22897135339456987, 0.18559077115584044, 0.20281540090619865, 0.1980408633040266, 0.19158457657492234, 0.20661056724169147, 0.19134001656933586, 0.1805342248193912, 0.20525057179025907, 0.20561136561943538, 0.18867142071019427, 0.1970507177050178, 0.19085585477311995, 0.18174592462551076, 0.1781601848071741, 0.20507554606135658, 0.18445175003438086, 0.1969119043367129, 0.22330629206746377, 0.17999446973434552, 0.17795553332713698, 0.1842548557535113, 0.18722323394018636, 0.3834232262854914, 0.16617719077104554, 0.17762009590179784, 0.18447476988132328, 0.1841670310276614, 0.16388098194381895, 0.20599222929303418, 0.1944051363476803, 0.2001088092823997, 0.20299467455527798, 0.2040474325878483, 0.20827482328036329, 0.3444886939232016, 0.12749571083710143, 0.1911733357632075, 0.17783168133947058, 0.18368428838131112, 0.1852300520671779, 0.1844125817539103, 0.17943267975745658, 0.1886588501366805, 0.18980871916850417, 0.19219301407980283, 0.07850124435140204, 0.07017493369528438, 0.07846851578089975, 0.07266646620200012, 0.07118299038853915, 0.07751217625887163, 0.08541143529468331, 0.07150342284605682, 0.08547917982448394]}, "mutation_prompt": null}
