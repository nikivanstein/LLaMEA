{"id": "a9aea0f7-d318-4295-8921-ab12c1bf37e3", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Mutation for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.2681358326403235, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.29.", "error": "", "parent_id": null, "metadata": {"aucs": [0.9590134176191978, 0.9580642915519602, 0.9642911720647322, 0.9612884084542213, 0.1909287201432981, 0.15734941630616428, 0.9577802470625714, 0.9616578551113312, 0.9529970370773185, 0.8650869880799875, 0.03962507951413341, 9.999999999998899e-05, 0.8949022790483989, 0.7221322039841636, 0.7253653098837516, 0.9059763876668931, 0.9085462854471693, 0.8834855326462703, 0.12479452330025853, 0.07871605320860564, 0.09463982900635437, 0.11278272703573966, 0.09833350879015157, 0.08441546148300116, 0.08342960588674975, 0.05360516322494535, 0.03978596590055383, 0.09866783064342088, 0.10302573089697031, 0.08036332764944598, 0.1284630420441748, 0.09051242551667238, 0.11336294716898032, 0.06998900307484657, 0.14862884615711425, 0.06467300175025925, 0.9943996401769465, 0.9891628346536363, 0.9945273976698803, 0.9934337934486798, 0.9876637703222744, 0.9861755835233657, 0.9912048200314344, 0.9931464219892409, 0.9859857445383513, 0.8952691834969527, 0.553793526073403, 0.4103504943338848, 0.6908143414640305, 0.176757460426045, 0.17645228830292403, 0.12873746966035016, 0.08945472228303275, 9.999999999998899e-05, 0.23237423121564338, 0.21372338307967997, 0.17229312224940663, 0.19593369731922727, 0.21517398094034457, 0.2835555100383297, 0.12712007559887173, 0.09346144381847021, 0.10541546161566862, 0.13238054014488465, 0.13558870971075598, 0.13277828312714135, 0.12587320626819987, 0.13683499990704584, 0.17340730659566184, 0.18096391214084395, 0.19140245854046878, 0.19152576791729414, 0.13014746574290037, 0.10750446862553287, 0.134985987964233, 0.23517314039395298, 0.1157719549348114, 0.14174210985620506, 0.19983052953445624, 9.999999999998899e-05, 0.13420269359482206, 9.999999999998899e-05, 9.999999999998899e-05, 0.014697270923172745, 0.0430237729780234, 0.19828655503846293, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1548751244310861, 0.023682887356889837, 0.09671382752960922, 0.0744541664063294, 0.020285607907660763, 0.02465657230285556, 0.08697408697155928, 0.051185271271166344, 0.122151115611147, 0.0549767463705122, 0.045126852797931494, 0.4388005474005414, 0.2373220137559543, 0.10383408824085416, 0.10614490906613938, 0.08040473830660555, 0.08218645992516682, 0.08089342878049555, 0.04525301003224391, 9.999999999998899e-05, 0.06946153192933857, 0.06640329511859633, 9.999999999998899e-05, 0.040236283660171956, 0.08634191898126797, 9.999999999998899e-05, 0.08643637699754747, 0.5623389963921326, 0.5874486940204369, 0.5138627047589006, 0.5868562070663957, 0.5525018684260957, 0.2098352525158106, 0.5884961809065596, 0.5965058630150777, 0.5406343328182424, 0.08772657110804138, 0.07310797806581082, 0.09853585932854114, 0.07593225949839832, 0.06275228381356157, 0.0988943659729683, 0.13627196842593858, 0.07342718735747367, 0.11385291304886092, 0.1604165793199097, 0.3020385238503591, 0.16985208893743564, 0.16929856859748382, 0.1813611247802437, 0.19052682369931717, 0.1951586220828594, 0.14849030349370151, 0.1734990824821825, 0.2589818186299664, 0.44739293240321276, 0.29766242137492793, 0.4549572857911678, 0.3512797268714748, 0.415541951760956, 0.23904779423115008, 0.1582918338874002, 0.20703468593075336, 0.11465352227333003, 0.30254393685527725, 0.1451395807912772, 0.24158410427611354, 0.32285503262348536, 0.2223688217437887, 0.20527491017458066, 0.1469202711115769, 0.07584720546894841, 0.22403537093301007, 0.20335269017816882, 0.20523959918917778, 0.2427455859866805, 0.22066326135947278, 0.27723037142938933, 0.20135788106921515, 0.2188547927171267, 0.19833570812062862, 0.21226312379269752, 0.19513990421520688, 0.17827903025594005, 0.20911439671646348, 0.19146188430882138, 0.18903548719656593, 0.1796355884120261, 0.1997865747238342, 0.21418646371557593, 0.26935946725364446, 0.967419754425342, 0.1548693793917011, 0.9614159626292184, 0.20228737928196083, 0.2019375427850546, 0.9653258290669937, 0.11414156742036141, 0.10398587973891515, 0.07927592107206238, 0.21274082089209068, 0.799519572094038, 0.2129523082574556, 0.1699044148479083, 0.2137606547587404, 0.10445398680413143, 0.1695266417617075, 0.3203315544201403, 0.1843014975222843, 0.21103597553818387, 0.19525096321904511, 0.1916154854549964, 0.21241011657698972, 0.22150953051100664, 0.19322668053255543, 0.2019262278108015, 0.244958801439223, 0.09190244655320534, 0.0709668509246647, 0.08698194787401392, 0.07144031568065856, 0.08454590154574693, 0.07415925435736759, 0.08609951078488665, 0.08707009375963992, 0.07782884126058631]}, "mutation_prompt": null}
{"id": "0e6f0049-066c-46ba-9bfa-aa97c3827c3f", "solution": "import numpy as np\n\nclass HybridPSO_ADM_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.9  # adaptive inertia weight (start value)\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Adaptive inertia weight\n            self.w = 0.4 + (0.5 * (self.budget - self.evaluations) / self.budget)\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                # Adaptive mutation rate\n                adaptive_mutation_rate = self.mutation_rate * (1 - (self.evaluations / self.budget))\n                if np.random.rand() < adaptive_mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_Enhanced", "description": "Enhanced HybridPSO_ADM with adaptive inertia weight and mutation rate for improved convergence speed and accuracy.", "configspace": "", "generation": 1, "fitness": 0.23016203907338706, "feedback": "The algorithm HybridPSO_ADM_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.24.", "error": "", "parent_id": "a9aea0f7-d318-4295-8921-ab12c1bf37e3", "metadata": {"aucs": [0.8276377298759923, 0.8260033912890488, 0.8330029862640236, 0.1901918592254762, 0.19005739434610414, 0.15729042405016846, 0.8229367093396818, 0.8382747716386054, 0.8305701442538591, 0.07053050154455176, 9.999999999998899e-05, 9.999999999998899e-05, 0.6783431550176543, 0.04196103601711565, 0.6562843069527824, 9.999999999998899e-05, 0.054786178151844944, 9.999999999998899e-05, 0.16492031251588402, 0.1167771217534298, 0.1471468220843981, 0.07655619653443557, 0.1755535954546551, 0.13439531385121517, 0.6337692913808015, 0.05503496559108678, 0.16678337217350303, 0.1430752133142682, 0.11421636100010346, 0.13723199032288558, 0.11239608596463335, 0.13192053386597435, 0.11274881260537872, 0.12260725808585071, 0.1301642128213769, 0.05343196535811201, 0.9958049788158918, 0.993220272026578, 0.995135396637186, 0.9933662834817543, 0.9931353813068842, 0.0749419009684128, 0.9918917701854586, 0.9945796709516209, 0.07475313006663331, 0.6259658473526288, 0.11306116654860343, 0.05911583382281027, 0.6343805005539234, 0.14947577096821385, 0.15368727853498054, 0.12619004671234924, 0.08955023458582945, 9.999999999998899e-05, 0.2182852727914968, 0.13351327505189858, 0.22743217624953682, 0.19510762376911794, 0.11707872906426708, 0.19272440026240234, 0.06814354048937332, 0.1275935152978096, 0.14791074114051295, 0.10280172020621703, 0.13095764979257396, 0.21882267575017855, 0.19701170822280023, 0.12383520349162647, 0.19176923158160464, 0.20790807392489563, 0.20292613709362672, 0.22116953848726784, 0.19142785338226453, 0.019884106291984782, 0.20694319331800515, 0.21545676588330642, 0.19727241291983488, 0.23955000348490119, 0.23715020695555145, 9.999999999998899e-05, 0.2292184043952561, 9.999999999998899e-05, 9.999999999998899e-05, 0.03548677693516511, 9.999999999998899e-05, 0.02691611486226353, 9.999999999998899e-05, 0.00794509554580014, 9.999999999998899e-05, 9.999999999998899e-05, 0.06989576851563906, 0.020664683460619226, 0.05815659646861915, 0.054898489042909615, 0.020145003078050117, 0.03908687735268945, 0.10242624645700649, 0.019444099997135145, 0.05239738995244736, 0.04377506785934748, 0.17058201850706578, 0.2895115651687762, 0.07463472528038106, 0.06897330308743332, 0.07833926734239371, 0.06730520853631383, 0.08936057306856349, 0.06194678869751591, 9.999999999998899e-05, 9.999999999998899e-05, 0.08093936397604262, 0.006078114761276399, 0.00570039251068577, 0.03760806380674697, 0.05503068708746228, 0.04894983661533403, 0.04906619280014635, 0.5321083122884297, 0.49753042503560563, 0.48955455061526, 0.5872671509162438, 0.4944457638676162, 0.20935236945562352, 0.5591211653102548, 0.5101687043991975, 0.5167362056567708, 0.07565716506575249, 0.07152974717586635, 0.1455518300583004, 0.10695530452227542, 0.13899741889558104, 0.15033421780787737, 0.0735980120780736, 0.08975514277784458, 0.12872412780113995, 0.22311390161812295, 0.22455698782730826, 0.2676326554285864, 0.24256938301736486, 0.5093114585649612, 0.17518248667216885, 0.18653782749620096, 0.20058794384492362, 0.24077388089146212, 0.3223472919915127, 0.3914692837791117, 0.5042406464436667, 0.3040318025562103, 0.44361332505456363, 0.38865494195760497, 0.5063307118080009, 0.25129638167820667, 0.15001518696810212, 0.17548076975719318, 0.33356465002157865, 0.13269450326915755, 0.21869020144349982, 0.229481748518505, 0.23786865714137917, 0.17026961671585628, 0.1341168080716998, 0.06478928104126846, 0.1987013527939594, 0.2457422126213863, 0.21239616707117193, 0.24915113877744766, 0.19389701094916134, 0.21194954649361952, 0.22527239667525323, 0.17628225590759117, 0.21477241045030493, 0.20545880204014033, 0.2392334661674821, 0.2405364346003993, 0.21622147028820615, 0.21450583079824004, 0.24173938460136102, 0.19847105773892004, 0.2191564279797661, 0.6836655956126404, 0.26689328433823134, 0.9076592732015781, 0.12471597512870591, 0.8520478445611771, 0.20001073467517294, 0.1999766877854875, 0.8303769133391585, 0.11390405255469582, 0.15288813269320034, 0.07909088415832843, 0.16684794361189847, 0.20578569408622838, 0.16887583672814566, 0.13981797179458189, 0.21212245547646913, 0.1051035998955333, 0.16628109989330808, 0.1673895392796585, 0.22306986292250464, 0.19446757440124451, 0.17496075169084357, 0.2165467895170209, 0.19104617471492247, 0.2049075532313721, 0.18275000900928384, 0.19428812614340663, 0.20365343513811007, 0.047617736986029224, 0.08042488154147398, 0.08791949483843686, 0.10845208222191272, 0.08561520373820986, 0.08855645513444665, 0.09198410541459578, 0.09152095369306712, 0.09025447120338359]}, "mutation_prompt": null}
{"id": "eda43dd2-ee4f-439b-8248-7102c9c4c357", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.w *= 0.99  # slightly decrease inertia weight for better convergence\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * (1 - self.evaluations / self.budget):\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Improved HybridPSO_ADM with dynamic mutation rate and velocity damping for enhanced adaptability and convergence.", "configspace": "", "generation": 2, "fitness": 0.15646000676123575, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": "a9aea0f7-d318-4295-8921-ab12c1bf37e3", "metadata": {"aucs": [0.38192181915371093, 0.4765916138865558, 0.37980261646923585, 0.3544737620997568, 0.18836852391573022, 0.15734554012559, 0.43290207941581016, 0.26633598502365075, 0.14392371032443774, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10499125350024263, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08482502387149904, 9.999999999998899e-05, 0.11901753819939842, 0.10102089884410925, 0.08123794253941541, 0.14160331094738943, 0.09903603964888519, 0.11243999397356796, 0.06539931683145062, 0.07185415219022506, 0.06929935323588743, 0.10166041298227135, 0.09866206833811686, 0.09462572643401368, 0.0805811784251198, 0.06504988962773628, 0.1032565645176674, 0.06429281045539392, 0.09119807283040537, 0.09761907823639726, 0.9931163283715616, 0.12476449644044407, 0.994460812626268, 0.9924895508633842, 0.15051573907998883, 0.1454959057487546, 0.985952611184556, 0.9911419392797176, 0.11217458212294751, 0.11950922150365895, 0.042837775147726465, 0.04383170764284805, 0.13760847103164775, 0.15289412284925674, 0.14304164105319617, 0.1241616418788859, 0.0471199424615657, 9.999999999998899e-05, 0.13224358014806203, 0.14155882295258893, 0.17210919778685363, 0.19518659688880213, 0.09652768858333871, 0.15708021282325335, 0.17745332108218625, 0.08460304299323596, 0.11275219673684256, 9.999999999998899e-05, 0.13343614826876837, 9.999999999998899e-05, 0.117771092624542, 0.0349041550018353, 0.13380285165392525, 0.1441940197948548, 0.1350066661395325, 0.14179958012408367, 0.2441504543456421, 0.07220980175438418, 0.13944405782761782, 9.999999999998899e-05, 9.999999999998899e-05, 0.10513130507752011, 0.1489627215117887, 9.999999999998899e-05, 0.13243043954505684, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09135958001594768, 0.028572820828101197, 0.06603343632931558, 0.06666442466206413, 0.0004726057529785832, 0.03321627175906283, 0.17794279191925033, 0.06411029697734083, 0.07076134533619138, 9.999999999998899e-05, 0.02813206186535211, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036277565009923296, 9.999999999998899e-05, 0.06225827523470451, 0.0318779978462328, 9.999999999998899e-05, 0.01943891941902387, 0.04822169731197534, 0.0002573800899932088, 0.026719997349337943, 0.3279079472058847, 0.40618284045257746, 0.4833471212837416, 0.42743196797506255, 0.37261231118666627, 0.20572690583943776, 0.37783341030112927, 0.28481075804672507, 0.32069729272143754, 0.07626872382206584, 0.08369028319509964, 0.10818968106221205, 0.0830985832298089, 0.04780044613037027, 0.08373108287890862, 0.06752199544246873, 0.03863497101129909, 0.07327083856908034, 0.1401761326883164, 0.27885060413415486, 0.2199326228466566, 0.1702894347920304, 0.1738449854287315, 0.14585473175174957, 0.15871342828786417, 0.16113965639124417, 0.21042065421161216, 0.2478173409887432, 0.2556679442876775, 0.17631403781858412, 0.31293262223189466, 0.2871111611386322, 0.22667611234606144, 0.17629448140073112, 0.162200626217627, 0.18393587117887422, 0.09017102185882608, 0.20893318763210034, 0.14634939888288445, 0.16221143279012962, 0.24410038765409714, 0.13390279493519697, 0.1835913455075875, 0.12390642308375377, 0.09858129612938538, 0.2234959608944197, 0.19957326453171076, 0.2389858588391649, 0.2655989523423523, 0.16219431998256062, 0.1692490646635515, 0.20808877378578094, 0.14973785089665326, 0.24016880285146214, 0.18857891762318812, 0.18566825863251302, 0.17823094357689118, 0.2563277387207439, 0.20413936946113387, 0.19081320249484734, 0.16696080709769812, 0.1690060718444658, 0.229847050886837, 0.3329775510609041, 0.16779679940936953, 0.15285072073654538, 0.5637629288118198, 0.20181800029181418, 0.20225557517663995, 0.5470692071741071, 0.11418050651369371, 0.14848909844381342, 0.08329413735141278, 0.17558121306815155, 0.32983082690580023, 0.10884929353915396, 0.16886566471695863, 0.21370792927197035, 0.10468194188149027, 0.1378609623635042, 0.16161383120245387, 0.18898935992444243, 0.19789560576824272, 0.20933182043154053, 0.19020458492963888, 0.19296107261019757, 0.21483763280769175, 0.18771292937896178, 0.22122997641295783, 0.24383379612519052, 0.0913509881597363, 0.08293280720692142, 0.07955261025337246, 0.08278359370702093, 0.09027618937905768, 0.09176276946292672, 0.06375142859241734, 0.07522467126822763, 0.06117314329208856]}, "mutation_prompt": null}
{"id": "8078a829-0f66-4546-b78e-eeceb0e89d24", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.9  # dynamic inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            self.w = 0.9 - 0.5 * (self.evaluations / self.budget)  # update inertia weight dynamically\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.7, 0.7, self.dim) * (self.global_best_position - self.positions[i])  # increase mutation range\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Hybrid Particle Swarm Optimization with Dynamic Inertia and Enhanced Differential Mutation for improved adaptability and solution quality.", "configspace": "", "generation": 3, "fitness": 0.24288133693692585, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.25.", "error": "", "parent_id": "a9aea0f7-d318-4295-8921-ab12c1bf37e3", "metadata": {"aucs": [0.8038838736400351, 0.831006653134472, 0.8237757105764303, 0.8379441733826649, 0.19091861445816083, 0.18947186030871932, 0.8106520984482836, 0.8316066095959033, 0.828979828910374, 0.6186090404033915, 9.999999999998899e-05, 0.5218789894428392, 0.661368847605102, 0.043841808091327206, 0.6608897742472728, 9.999999999998899e-05, 0.7064251028356713, 0.6515723025822537, 0.15218232379124363, 0.11567849123489782, 0.16095586767125292, 0.12071978734383737, 0.5197032429919788, 0.14661977914032454, 0.1526541015348879, 0.15626849522090192, 0.1710774709379923, 0.13856235718677523, 0.09088323918941699, 0.14372437613688793, 0.1429711082142594, 0.12617023165320074, 0.11332837803466478, 0.11350928077553257, 0.1427831767894182, 0.05192539911528915, 0.9958049445183355, 0.9932205654702001, 0.9951535054207622, 0.9933689572275824, 0.9931418260757475, 0.07494147578518828, 0.9919934131429886, 0.9945796666445776, 0.07466178758804964, 0.6522564962149902, 0.11182518953457588, 0.059545627683158964, 0.1510234043776001, 0.6574894844896197, 0.15371588548525383, 0.12683815957582922, 0.08961869721215265, 9.999999999998899e-05, 0.17129618827817905, 0.22999012247846917, 0.36740492798927527, 0.20357748627280858, 0.11712996148696553, 0.2724460317010423, 0.06824223760973436, 0.13099055169382523, 0.11647225451957655, 0.11781309076337987, 0.21432362214275658, 0.20890505784547853, 0.18860957233722841, 0.09488797642823266, 0.11696918498898468, 0.18453223000371355, 0.20363383336026242, 0.21589336174610763, 0.24178781880065803, 0.020430437831243986, 0.12936397923448095, 0.2164541860649355, 0.2212717479807238, 0.1993399393859312, 0.22669724095977128, 9.999999999998899e-05, 0.13059312849223792, 9.999999999998899e-05, 0.011661646247581703, 9.999999999998899e-05, 9.999999999998899e-05, 0.041146261176380206, 9.999999999998899e-05, 0.006690673070057662, 9.999999999998899e-05, 9.999999999998899e-05, 0.10928725895605529, 0.020412610673414378, 0.100089607222005, 0.0930401332377715, 0.016014424537147853, 0.02884007412648093, 0.04025884318077155, 0.019069168400908, 0.01749076069144906, 0.0421907254438616, 0.08839943751700485, 0.1107164067961327, 0.06851422103030813, 0.0705978757972151, 9.999999999998899e-05, 0.06779343651823033, 0.12989968405810415, 0.06711840515746059, 0.042350237322818285, 9.999999999998899e-05, 0.04043873263991449, 0.005986047941923922, 9.999999999998899e-05, 0.03650851959155765, 0.04904867017670744, 0.048071382638124494, 0.07952320116646716, 0.5153600595923764, 0.5832344236160691, 0.5718146906265389, 0.5450001228395768, 0.521023650003347, 0.20928868858917626, 0.5435935448206294, 0.5679907641909829, 0.5528883110490667, 0.10684306244489816, 0.06827636667656811, 0.13771248783122214, 0.12809249063374029, 0.130373713732571, 0.12260211136291876, 0.06941085146187431, 0.09275097500413865, 0.07862513264739279, 0.2375337110828949, 0.1810404043129218, 0.19431321511698607, 0.31103479622568586, 0.3950646932677835, 0.3208838909942757, 0.22141409460003092, 0.19304461019526853, 0.2498004549171433, 0.23143400936212777, 0.24947304004281745, 0.3315596292485211, 0.3301559460544021, 0.30347160418498265, 0.3057718883495063, 0.3279284828615786, 0.30496857109321296, 0.18847249542701727, 0.0988850028826388, 0.19705430978607352, 0.22599900345146018, 0.21112096998030805, 0.29988902529150674, 0.11815705084129746, 0.23547593638748254, 0.23415269889288115, 0.08111795531874233, 0.24069415980566078, 0.23167748807134803, 0.18795977464546587, 0.20056591164627102, 0.21226011422267133, 0.2145940248092807, 0.21278159579219869, 0.19946449629766472, 0.1907426290628873, 0.23513968996084056, 0.1878079036423399, 0.573945149648121, 0.23989428550348724, 0.21778960475378384, 0.19972420768268684, 0.19567338919572674, 0.2004288959207572, 0.22089003771927251, 0.8587540051499024, 0.19461160644386633, 0.1537592603468917, 0.8125483010931243, 0.2005527863497516, 0.1993661248207078, 0.8688362306739849, 0.11402248719137298, 0.15405640640525198, 0.07914953189277352, 0.16689401204678211, 0.1922547402514715, 0.16869412796086358, 0.194122999854213, 0.21244846150766872, 0.10490119369219641, 0.16269677559615126, 0.7168235430795586, 0.22291218445981453, 0.20258509771334965, 0.18730113206083554, 0.18960238249461836, 0.2265524706500952, 0.20272192480034512, 0.19548361531445335, 0.19941637570741177, 0.24198898060916785, 0.07957113282192985, 0.09743652483031584, 0.09843925881850046, 0.0843352041708808, 0.09064131155591926, 0.10628778942978756, 0.09233049229352819, 0.07522469035969426, 0.08567722347157125]}, "mutation_prompt": null}
{"id": "c2d66f6b-6376-4ec0-a42e-fcdf90d2d93e", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.initial_mutation_rate = 0.1\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            mutation_rate = self.initial_mutation_rate * (1 - self.evaluations / self.budget)  # Dynamic mutation rate\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Mutation and Dynamic Mutation Rate for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.2632578776091635, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.28.", "error": "", "parent_id": "a9aea0f7-d318-4295-8921-ab12c1bf37e3", "metadata": {"aucs": [0.9585057556002642, 0.9607090588999322, 0.9646451744819756, 0.9611530204723934, 0.19092869926860412, 0.1573494163665875, 0.9591077277822467, 0.9619374113531948, 0.9563666719054694, 0.6521084852381047, 0.03849999484999045, 9.999999999998899e-05, 0.8419245836401724, 0.7338128156102879, 0.8549512254377989, 0.8218443837307573, 0.9095067852644495, 0.9095176371034146, 0.09842374303083057, 0.0812849402495891, 0.09828351087978315, 0.1129453944535358, 0.09833992834040217, 0.09799228706090723, 0.06704872472990187, 0.037292883089817375, 0.03978548086560263, 0.09867045745374659, 0.10302628658690849, 0.07324467910506993, 0.12820063391077818, 0.0905191782265079, 0.1362826673627202, 0.11045196856530726, 0.1485312384756613, 0.06467609545141895, 0.9943996401769465, 0.9891628346536363, 0.9945273976698803, 0.9934337934486798, 0.9876637703222744, 0.9861755835233657, 0.9912048200314344, 0.9931464219892409, 0.9859857445383513, 0.6488712173639728, 0.31027372491269967, 0.7525290965465354, 0.37616860572778066, 0.15830902655670032, 0.1566676906604655, 0.12876084913333397, 0.08945206527702543, 9.999999999998899e-05, 0.23237423121564338, 0.21144695529045066, 0.17229312224940663, 0.19593369731922727, 0.21537263811998186, 0.2835555100383297, 0.12712007559887173, 0.0860379308586835, 0.10541546161566862, 0.13238070997047124, 0.1356517706786059, 0.13214387609496048, 0.1254268093602332, 0.13681750565544049, 0.17808777164296918, 0.1958835805400887, 0.16662248771948984, 0.17690403839485824, 0.13013724483996125, 0.10746127998115773, 0.13080590766437994, 0.23929269960916966, 0.11459725472235172, 0.13420172753961146, 0.229421114582549, 9.999999999998899e-05, 0.13365832992178717, 9.999999999998899e-05, 9.999999999998899e-05, 0.008888948425930354, 0.04454016181587628, 0.1117600861199255, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11478227411674247, 0.020531633887343692, 0.07692527506432034, 0.08125662276538936, 0.026883192138412282, 0.04204264483601727, 0.09057506152136918, 0.048847209564019445, 0.1152753488897863, 0.054795071974532594, 0.0444674481294407, 0.4456695489869801, 0.23102225687057576, 0.10394681081863677, 0.10627362773561944, 0.0805097219412717, 0.08207671147328366, 0.08096557777649105, 0.04525261188059704, 9.999999999998899e-05, 0.0687920177715523, 0.06619582370213428, 9.999999999998899e-05, 0.04023598211264412, 0.08633141184051163, 9.999999999998899e-05, 0.08644369048777678, 0.6126515467019821, 0.5423418153523119, 0.5196720390641993, 0.5703366749737853, 0.5748934154324721, 0.2098352522760739, 0.5759821460818182, 0.5587285225404831, 0.6085926162629985, 0.08766966407434484, 0.0731397482044438, 0.09843620587332758, 0.07622533736058323, 0.06276582233539396, 0.09894782200942187, 0.12024356408977421, 0.07342718730659303, 0.11383445237268208, 0.15981896398664264, 0.17805961082401067, 0.17000290331024315, 0.16565767335084092, 0.2074305794314243, 0.20084547627739746, 0.19611143512935925, 0.13588389462382788, 0.17954069607139955, 0.2540884033195453, 0.24406983727376608, 0.2963911577401145, 0.606103301681058, 0.38752981708801515, 0.4602228038694729, 0.24067393948780968, 0.15829183735190522, 0.20468742154357, 0.11547400475946035, 0.29575847484933326, 0.14431579547874918, 0.24265117465980013, 0.33465774059974174, 0.22468477031274092, 0.20081687248966174, 0.14606368555560234, 0.07584509015184593, 0.229885205710329, 0.2002861695493824, 0.19184153330640896, 0.2660409840316448, 0.22475588740172392, 0.29428920435682415, 0.180010576050754, 0.19018702108804475, 0.1951302791068903, 0.21226341414099215, 0.21173433186279855, 0.17827881421445202, 0.17463716747411273, 0.19219471593468185, 0.18981582960865884, 0.17963613424969316, 0.19972942290596707, 0.21420136158547765, 0.2693614358888957, 0.9632027740305621, 0.1548692071271578, 0.9604967866072267, 0.20228737254602847, 0.20193767638013027, 0.9610361551142667, 0.11414157132420477, 0.10398587278639082, 0.07927589593337636, 0.2130351374174695, 0.6437930509176295, 0.21304668942429428, 0.16990441152588265, 0.21375868121641717, 0.1044539798841344, 0.16950194408885821, 0.3467614729417895, 0.20381968365667835, 0.20952694831183982, 0.2027708401775159, 0.19244006950052306, 0.21093142513664231, 0.19341610030713619, 0.20459019092300124, 0.20705476884292562, 0.22295747259876186, 0.07325018658848714, 0.07090532768540103, 0.08789566118739223, 0.07717779961731264, 0.08926251896222037, 0.07394720016049683, 0.079776516128097, 0.0897552095323434, 0.07092255175098194]}, "mutation_prompt": null}
{"id": "a3405475-7b90-43ea-8e74-9be09605f36f", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.9  # inertia weight\n        self.w_min = 0.4\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n            # Dynamic inertia weight adjustment\n            self.w = self.w_min + (0.5 * (self.budget - self.evaluations) / self.budget)\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Mutation and Dynamic Inertia Weight for improved convergence in black-box optimization.", "configspace": "", "generation": 5, "fitness": 0.23371383508162266, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.24.", "error": "", "parent_id": "a9aea0f7-d318-4295-8921-ab12c1bf37e3", "metadata": {"aucs": [0.8043699582270902, 0.8252598119967156, 0.8126105433479989, 0.811663563689076, 0.190196364889754, 0.15728971345808318, 0.8244702043472485, 0.8317704551648278, 0.8502977404028529, 0.07113746425244083, 9.999999999998899e-05, 9.999999999998899e-05, 0.6702185178632819, 9.999999999998899e-05, 0.6587931885648579, 0.6464472625951811, 0.05443724870311073, 9.999999999998899e-05, 0.5994979125677751, 0.11941909369935222, 0.1416934307310701, 0.07563654258074837, 0.609018702466998, 0.09430585926355906, 0.16147731162973689, 0.0559077943150329, 0.1574711860734036, 0.12523688204592487, 0.14882743410583865, 0.10317569462715093, 0.11195260579556687, 0.13793552326006597, 0.145112986930936, 0.1673159962007459, 0.1207577816988824, 0.054106632136260435, 0.9958049920291417, 0.9932206213065989, 0.9951355053280547, 0.99336611776284, 0.9931353224173853, 0.0749419136229188, 0.9918918293936789, 0.9945799160771304, 0.07475314731803606, 0.6738968456742348, 0.11338655373922446, 0.0595637577031064, 0.14844218219159433, 0.14765439062818697, 0.15079385636844977, 0.1267233208811993, 0.08951570623881488, 9.999999999998899e-05, 0.22225286631094077, 0.13305756090508492, 0.7900459469298012, 0.19513030380535046, 0.11718657517690112, 0.19101839665412168, 0.06827283057774347, 0.12614213456607082, 0.11696691593159791, 0.10191737468469642, 0.20838873460758445, 0.20526938630045055, 0.12480817432876523, 0.09816909210589253, 0.12930372295531778, 0.19992249958683095, 0.20731220559031893, 0.20053888787915697, 0.220560796942336, 0.021514657373947754, 0.2257015680657628, 0.22021538240285787, 0.21689158079226, 0.24916195169844124, 0.23679329304726016, 9.999999999998899e-05, 0.2287345403899751, 9.999999999998899e-05, 9.999999999998899e-05, 0.03053794350174288, 0.00019874195304692144, 0.07276225117216562, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06884770188028633, 0.025355283950979524, 0.0506840942866138, 0.09198445688479429, 0.011060908788670387, 0.02901229630872515, 0.020786120476743553, 0.02798138502589831, 0.020440323911006475, 0.042913979576526984, 0.11973179989176586, 0.04760138917095735, 0.06595945093234079, 0.07030875774288692, 9.999999999998899e-05, 0.0643347332134705, 0.1805644018247754, 0.06172309924278796, 0.042545451785653166, 9.999999999998899e-05, 0.05803255138486785, 0.006047663669189185, 9.999999999998899e-05, 0.037651553632709556, 0.04669565944296716, 0.04882630380384689, 0.04913623656953914, 0.4867955494137268, 0.5880327694271721, 0.5042810415991263, 0.5265398254771474, 0.4927641232733676, 0.20937730001350985, 0.542243070237125, 0.5153591169580728, 0.5090964383695391, 0.07002538579667106, 0.07346724231726565, 0.13278781989913568, 0.12264785419967705, 0.1274070335845927, 0.17403725895875544, 0.0743524928805902, 0.10965679100624948, 0.09026852532636609, 0.18001220256455086, 0.1708839263561469, 0.2120756874567733, 0.18528713428407395, 0.3847526589110799, 0.1979012616527691, 0.20879010777294016, 0.20297785467024576, 0.2044358402415194, 0.17022839094121534, 0.4099309767672108, 0.25958321098581827, 0.2196289740891264, 0.3337218804275318, 0.22000655510117473, 0.3462326019558324, 0.398436578656986, 0.16262876872564813, 0.16382469293231772, 0.32446020309318524, 0.16422207167115288, 0.23000948214582706, 0.2992826944902326, 0.22669414649729247, 0.3093408181672094, 0.3367894339326837, 0.07650210293172732, 0.24898104257546627, 0.19627322422879323, 0.206559953317082, 0.20985991345615662, 0.17862976192837865, 0.19933656472965544, 0.24574554854906738, 0.2097973924783917, 0.21510968732695024, 0.530448873660472, 0.21214947697693454, 0.22149242035838113, 0.24175893716788888, 0.21121535322968643, 0.21798942443135627, 0.2005400992981511, 0.6299482274829793, 0.19327047245121198, 0.26724972397072344, 0.8863146031824544, 0.15272638038692077, 0.8510957186049005, 0.20088632948249463, 0.19971220206643725, 0.8314773070555793, 0.11464222615645703, 0.16077974420762475, 0.07908389129523308, 0.16685085400118804, 0.15811885350609955, 0.16893529316899947, 0.13919882514900928, 0.21201018373748592, 0.10422297952380488, 0.16263294793604088, 0.16740920430555595, 0.20158475517943975, 0.1834375147334456, 0.21143308529823113, 0.2026114421754427, 0.2058194093154626, 0.18663287043035237, 0.18865138266511305, 0.20068353574617004, 0.18404615301546523, 0.08263862458163918, 0.08413174848840954, 0.09138670302991536, 0.08716362607997985, 0.08447417171486937, 0.09511419870549431, 0.08867699446327715, 0.07269623766038402, 0.08765308085643597]}, "mutation_prompt": null}
{"id": "431146cf-6318-40e8-8f4e-940a60d3b95b", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Mutation for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a9aea0f7-d318-4295-8921-ab12c1bf37e3", "metadata": {"aucs": [0.9590134176191978, 0.9580642915519602, 0.9642911720647322, 0.9612884084542213, 0.1909287201432981, 0.15734941630616428, 0.9577802470625714, 0.9616578551113312, 0.9529970370773185, 0.8650869880799875, 0.03962507951413341, 9.999999999998899e-05, 0.8949022790483989, 0.7221322039841636, 0.7253653098837516, 0.9059763876668931, 0.9085462854471693, 0.8834855326462703, 0.12479452330025853, 0.07871605320860564, 0.09463982900635437, 0.11278272703573966, 0.09833350879015157, 0.08441546148300116, 0.08342960588674975, 0.05360516322494535, 0.03978596590055383, 0.09866783064342088, 0.10302573089697031, 0.08036332764944598, 0.1284630420441748, 0.09051242551667238, 0.11336294716898032, 0.06998900307484657, 0.14862884615711425, 0.06467300175025925, 0.9943996401769465, 0.9891628346536363, 0.9945273976698803, 0.9934337934486798, 0.9876637703222744, 0.9861755835233657, 0.9912048200314344, 0.9931464219892409, 0.9859857445383513, 0.8952691834969527, 0.553793526073403, 0.4103504943338848, 0.6908143414640305, 0.176757460426045, 0.17645228830292403, 0.12873746966035016, 0.08945472228303275, 9.999999999998899e-05, 0.23237423121564338, 0.21372338307967997, 0.17229312224940663, 0.19593369731922727, 0.21517398094034457, 0.2835555100383297, 0.12712007559887173, 0.09346144381847021, 0.10541546161566862, 0.13238054014488465, 0.13558870971075598, 0.13277828312714135, 0.12587320626819987, 0.13683499990704584, 0.17340730659566184, 0.18096391214084395, 0.19140245854046878, 0.19152576791729414, 0.13014746574290037, 0.10750446862553287, 0.134985987964233, 0.23517314039395298, 0.1157719549348114, 0.14174210985620506, 0.19983052953445624, 9.999999999998899e-05, 0.13420269359482206, 9.999999999998899e-05, 9.999999999998899e-05, 0.014697270923172745, 0.0430237729780234, 0.19828655503846293, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1548751244310861, 0.023682887356889837, 0.09671382752960922, 0.0744541664063294, 0.020285607907660763, 0.02465657230285556, 0.08697408697155928, 0.051185271271166344, 0.122151115611147, 0.0549767463705122, 0.045126852797931494, 0.4388005474005414, 0.2373220137559543, 0.10383408824085416, 0.10614490906613938, 0.08040473830660555, 0.08218645992516682, 0.08089342878049555, 0.04525301003224391, 9.999999999998899e-05, 0.06946153192933857, 0.06640329511859633, 9.999999999998899e-05, 0.040236283660171956, 0.08634191898126797, 9.999999999998899e-05, 0.08643637699754747, 0.5623389963921326, 0.5874486940204369, 0.5138627047589006, 0.5868562070663957, 0.5525018684260957, 0.2098352525158106, 0.5884961809065596, 0.5965058630150777, 0.5406343328182424, 0.08772657110804138, 0.07310797806581082, 0.09853585932854114, 0.07593225949839832, 0.06275228381356157, 0.0988943659729683, 0.13627196842593858, 0.07342718735747367, 0.11385291304886092, 0.1604165793199097, 0.3020385238503591, 0.16985208893743564, 0.16929856859748382, 0.1813611247802437, 0.19052682369931717, 0.1951586220828594, 0.14849030349370151, 0.1734990824821825, 0.2589818186299664, 0.44739293240321276, 0.29766242137492793, 0.4549572857911678, 0.3512797268714748, 0.415541951760956, 0.23904779423115008, 0.1582918338874002, 0.20703468593075336, 0.11465352227333003, 0.30254393685527725, 0.1451395807912772, 0.24158410427611354, 0.32285503262348536, 0.2223688217437887, 0.20527491017458066, 0.1469202711115769, 0.07584720546894841, 0.22403537093301007, 0.20335269017816882, 0.20523959918917778, 0.2427455859866805, 0.22066326135947278, 0.27723037142938933, 0.20135788106921515, 0.2188547927171267, 0.19833570812062862, 0.21226312379269752, 0.19513990421520688, 0.17827903025594005, 0.20911439671646348, 0.19146188430882138, 0.18903548719656593, 0.1796355884120261, 0.1997865747238342, 0.21418646371557593, 0.26935946725364446, 0.967419754425342, 0.1548693793917011, 0.9614159626292184, 0.20228737928196083, 0.2019375427850546, 0.9653258290669937, 0.11414156742036141, 0.10398587973891515, 0.07927592107206238, 0.21274082089209068, 0.799519572094038, 0.2129523082574556, 0.1699044148479083, 0.2137606547587404, 0.10445398680413143, 0.1695266417617075, 0.3203315544201403, 0.1843014975222843, 0.21103597553818387, 0.19525096321904511, 0.1916154854549964, 0.21241011657698972, 0.22150953051100664, 0.19322668053255543, 0.2019262278108015, 0.244958801439223, 0.09190244655320534, 0.0709668509246647, 0.08698194787401392, 0.07144031568065856, 0.08454590154574693, 0.07415925435736759, 0.08609951078488665, 0.08707009375963992, 0.07782884126058631]}, "mutation_prompt": null}
{"id": "790ed606-49d7-4f20-b969-87e910e62a28", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Mutation by introducing velocity clamping for better convergence control.", "configspace": "", "generation": 7, "fitness": 0.2963753321871, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.29.", "error": "", "parent_id": "a9aea0f7-d318-4295-8921-ab12c1bf37e3", "metadata": {"aucs": [0.9642362007481526, 0.9692985769295164, 0.9651244021699147, 0.9500545571000708, 0.19078514952967196, 0.9663864854746432, 0.9626616365991486, 0.9644481027067296, 0.9612504123072039, 0.9098065836120787, 0.9058681071633289, 0.8886353495687893, 0.8945602473680347, 0.49274617808777377, 0.9084433604418932, 0.824564024249377, 0.7225562447558976, 0.8117157756613115, 0.08191660142969193, 0.13748543159010274, 0.1337262774414565, 0.08778781651275713, 0.04782773907448423, 0.11994387479996527, 0.12086750243162858, 0.1494878100675815, 0.09416084866050767, 0.10764305534320961, 0.10786892368823997, 0.11956767772319654, 0.11318872578642691, 0.09093510380804559, 0.1121340131946077, 0.0715877746120479, 0.11997097479711138, 0.09819190020531532, 0.9822443933221173, 0.9843633342579475, 0.9884979941075419, 0.9843121708717256, 0.9861221049438237, 0.984122577287547, 0.9823873915212106, 0.9832407445588321, 0.9750206571090652, 0.9027048018815869, 0.06025808692656287, 0.3130825163332006, 0.44106657542835936, 0.2671629462639685, 0.4860751192049575, 0.12881076740350694, 0.9055545911675544, 0.21026591114556836, 0.18812717992822714, 0.21607372265029157, 0.14149948542225577, 0.9672356418441383, 0.2148052928759825, 0.9720203714492969, 0.15773384022387982, 0.14714930437193763, 0.24145116048968385, 0.2623914826487125, 0.24018287733164823, 0.146144812906293, 0.20228142952536143, 0.1373663996412835, 0.15999307129912121, 0.19944197287509302, 0.18174660572896817, 0.1666023749140384, 0.23170776811139504, 0.20445851685573369, 0.17582143600205002, 0.1759131647069615, 0.17247667456075266, 0.16436853634266535, 0.1707042821318704, 0.2185591338170152, 0.2170529663773133, 9.999999999998899e-05, 0.05837017371283726, 9.999999999998899e-05, 0.08691733466056117, 0.002342872316505762, 0.00724914842492963, 0.0488280145462997, 9.999999999998899e-05, 0.001757214409958907, 0.08739212155618992, 0.06397407743323424, 0.11102070394828878, 0.06369015625952268, 0.021384003437381005, 0.028610735643040064, 0.11476626205244012, 0.14477443962078218, 0.09257205859908135, 0.05476861949461176, 0.15926063633764242, 0.1237836921737604, 0.2053209361623276, 0.12029691633854056, 0.08667453844197548, 0.11242318556168152, 0.2300873506655562, 0.08154440668207752, 0.11500290784285683, 0.10880648873137777, 0.11561910903100503, 0.08480230675654143, 0.2956349580730121, 0.035433279950319085, 0.2768988656311101, 0.050797538845908985, 0.08644594802604244, 0.5478003357988981, 0.5483568411630921, 0.5497145776591821, 0.6177551244060429, 0.6083465842838813, 0.6212803186803499, 0.5986092321204206, 0.5656050525413963, 0.6021521402485164, 0.06696858277401829, 0.061246958864264345, 0.08395694333133741, 0.1062489142347306, 0.08121230740367302, 0.08432055633384494, 0.06127849604187108, 0.1031129355167888, 0.07166252616268176, 0.22268277579970241, 0.25224056200521705, 0.2505908386181256, 0.21245897237998346, 0.24938272831406405, 0.17281275398228957, 0.17329553264694753, 0.14985885790815479, 0.19552992220287724, 0.19127733683071302, 0.35129206497408305, 0.39050863770478017, 0.16320719947259654, 0.36356913938326585, 0.2048697242100992, 0.23817361936075154, 0.31544666186641956, 0.13068965001460742, 0.16017124843231378, 0.2141136985055817, 0.11259737439734674, 0.2893964357897556, 0.12978351518415965, 0.2287345809342437, 0.20525882969942844, 0.17930474062387114, 0.0900303240653384, 0.2289910485514699, 0.21159175963926968, 0.18511020562930203, 0.26182243164939434, 0.22181057513596347, 0.2633063846284591, 0.21810591702825588, 0.2626639118417613, 0.19910599697668152, 0.2131289372358136, 0.16972150381046525, 0.18024592793128558, 0.22111982698645183, 0.2299011940832617, 0.18823749026637815, 0.21249190372021087, 0.17881700942640744, 0.20007611878354226, 0.9668973148602267, 0.18946094474816122, 0.15479911330677676, 0.9648748833759968, 0.2023726709978353, 0.1707008471490139, 0.16919038965732358, 0.1687142360612255, 0.1546076264683326, 0.43993936873372863, 0.21470831499938392, 0.4988803946594592, 0.21387867258327464, 0.17025549267987095, 0.21421876416405128, 0.10447861192148811, 0.16938620836927343, 0.7977917267261905, 0.2019108794357921, 0.202205208477094, 0.21451981513212914, 0.21149798136115827, 0.18794952356922445, 0.22190202951009752, 0.23498437338179579, 0.24540014740890959, 0.21493258161677464, 0.09531367830238979, 0.09459607649955182, 0.08646832870207632, 0.05798495882125576, 0.10478164156590175, 0.0918154625902714, 0.08192243442071812, 0.09147678192316777, 0.06551333626323885]}, "mutation_prompt": null}
{"id": "82ac7f40-3c89-4258-97a5-abcb50f87980", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Mutation by introducing velocity clamping for better convergence control.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "790ed606-49d7-4f20-b969-87e910e62a28", "metadata": {"aucs": [0.9642362007481526, 0.9692985769295164, 0.9651244021699147, 0.9500545571000708, 0.19078514952967196, 0.9663864854746432, 0.9626616365991486, 0.9644481027067296, 0.9612504123072039, 0.9098065836120787, 0.9058681071633289, 0.8886353495687893, 0.8945602473680347, 0.49274617808777377, 0.9084433604418932, 0.824564024249377, 0.7225562447558976, 0.8117157756613115, 0.08191660142969193, 0.13748543159010274, 0.1337262774414565, 0.08778781651275713, 0.04782773907448423, 0.11994387479996527, 0.12086750243162858, 0.1494878100675815, 0.09416084866050767, 0.10764305534320961, 0.10786892368823997, 0.11956767772319654, 0.11318872578642691, 0.09093510380804559, 0.1121340131946077, 0.0715877746120479, 0.11997097479711138, 0.09819190020531532, 0.9822443933221173, 0.9843633342579475, 0.9884979941075419, 0.9843121708717256, 0.9861221049438237, 0.984122577287547, 0.9823873915212106, 0.9832407445588321, 0.9750206571090652, 0.9027048018815869, 0.06025808692656287, 0.3130825163332006, 0.44106657542835936, 0.2671629462639685, 0.4860751192049575, 0.12881076740350694, 0.9055545911675544, 0.21026591114556836, 0.18812717992822714, 0.21607372265029157, 0.14149948542225577, 0.9672356418441383, 0.2148052928759825, 0.9720203714492969, 0.15773384022387982, 0.14714930437193763, 0.24145116048968385, 0.2623914826487125, 0.24018287733164823, 0.146144812906293, 0.20228142952536143, 0.1373663996412835, 0.15999307129912121, 0.19944197287509302, 0.18174660572896817, 0.1666023749140384, 0.23170776811139504, 0.20445851685573369, 0.17582143600205002, 0.1759131647069615, 0.17247667456075266, 0.16436853634266535, 0.1707042821318704, 0.2185591338170152, 0.2170529663773133, 9.999999999998899e-05, 0.05837017371283726, 9.999999999998899e-05, 0.08691733466056117, 0.002342872316505762, 0.00724914842492963, 0.0488280145462997, 9.999999999998899e-05, 0.001757214409958907, 0.08739212155618992, 0.06397407743323424, 0.11102070394828878, 0.06369015625952268, 0.021384003437381005, 0.028610735643040064, 0.11476626205244012, 0.14477443962078218, 0.09257205859908135, 0.05476861949461176, 0.15926063633764242, 0.1237836921737604, 0.2053209361623276, 0.12029691633854056, 0.08667453844197548, 0.11242318556168152, 0.2300873506655562, 0.08154440668207752, 0.11500290784285683, 0.10880648873137777, 0.11561910903100503, 0.08480230675654143, 0.2956349580730121, 0.035433279950319085, 0.2768988656311101, 0.050797538845908985, 0.08644594802604244, 0.5478003357988981, 0.5483568411630921, 0.5497145776591821, 0.6177551244060429, 0.6083465842838813, 0.6212803186803499, 0.5986092321204206, 0.5656050525413963, 0.6021521402485164, 0.06696858277401829, 0.061246958864264345, 0.08395694333133741, 0.1062489142347306, 0.08121230740367302, 0.08432055633384494, 0.06127849604187108, 0.1031129355167888, 0.07166252616268176, 0.22268277579970241, 0.25224056200521705, 0.2505908386181256, 0.21245897237998346, 0.24938272831406405, 0.17281275398228957, 0.17329553264694753, 0.14985885790815479, 0.19552992220287724, 0.19127733683071302, 0.35129206497408305, 0.39050863770478017, 0.16320719947259654, 0.36356913938326585, 0.2048697242100992, 0.23817361936075154, 0.31544666186641956, 0.13068965001460742, 0.16017124843231378, 0.2141136985055817, 0.11259737439734674, 0.2893964357897556, 0.12978351518415965, 0.2287345809342437, 0.20525882969942844, 0.17930474062387114, 0.0900303240653384, 0.2289910485514699, 0.21159175963926968, 0.18511020562930203, 0.26182243164939434, 0.22181057513596347, 0.2633063846284591, 0.21810591702825588, 0.2626639118417613, 0.19910599697668152, 0.2131289372358136, 0.16972150381046525, 0.18024592793128558, 0.22111982698645183, 0.2299011940832617, 0.18823749026637815, 0.21249190372021087, 0.17881700942640744, 0.20007611878354226, 0.9668973148602267, 0.18946094474816122, 0.15479911330677676, 0.9648748833759968, 0.2023726709978353, 0.1707008471490139, 0.16919038965732358, 0.1687142360612255, 0.1546076264683326, 0.43993936873372863, 0.21470831499938392, 0.4988803946594592, 0.21387867258327464, 0.17025549267987095, 0.21421876416405128, 0.10447861192148811, 0.16938620836927343, 0.7977917267261905, 0.2019108794357921, 0.202205208477094, 0.21451981513212914, 0.21149798136115827, 0.18794952356922445, 0.22190202951009752, 0.23498437338179579, 0.24540014740890959, 0.21493258161677464, 0.09531367830238979, 0.09459607649955182, 0.08646832870207632, 0.05798495882125576, 0.10478164156590175, 0.0918154625902714, 0.08192243442071812, 0.09147678192316777, 0.06551333626323885]}, "mutation_prompt": null}
{"id": "7f30b055-0fbe-477e-9c6a-8958bcb6dd4e", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Mutation by introducing velocity clamping for better convergence control.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "790ed606-49d7-4f20-b969-87e910e62a28", "metadata": {"aucs": [0.9642362007481526, 0.9692985769295164, 0.9651244021699147, 0.9500545571000708, 0.19078514952967196, 0.9663864854746432, 0.9626616365991486, 0.9644481027067296, 0.9612504123072039, 0.9098065836120787, 0.9058681071633289, 0.8886353495687893, 0.8945602473680347, 0.49274617808777377, 0.9084433604418932, 0.824564024249377, 0.7225562447558976, 0.8117157756613115, 0.08191660142969193, 0.13748543159010274, 0.1337262774414565, 0.08778781651275713, 0.04782773907448423, 0.11994387479996527, 0.12086750243162858, 0.1494878100675815, 0.09416084866050767, 0.10764305534320961, 0.10786892368823997, 0.11956767772319654, 0.11318872578642691, 0.09093510380804559, 0.1121340131946077, 0.0715877746120479, 0.11997097479711138, 0.09819190020531532, 0.9822443933221173, 0.9843633342579475, 0.9884979941075419, 0.9843121708717256, 0.9861221049438237, 0.984122577287547, 0.9823873915212106, 0.9832407445588321, 0.9750206571090652, 0.9027048018815869, 0.06025808692656287, 0.3130825163332006, 0.44106657542835936, 0.2671629462639685, 0.4860751192049575, 0.12881076740350694, 0.9055545911675544, 0.21026591114556836, 0.18812717992822714, 0.21607372265029157, 0.14149948542225577, 0.9672356418441383, 0.2148052928759825, 0.9720203714492969, 0.15773384022387982, 0.14714930437193763, 0.24145116048968385, 0.2623914826487125, 0.24018287733164823, 0.146144812906293, 0.20228142952536143, 0.1373663996412835, 0.15999307129912121, 0.19944197287509302, 0.18174660572896817, 0.1666023749140384, 0.23170776811139504, 0.20445851685573369, 0.17582143600205002, 0.1759131647069615, 0.17247667456075266, 0.16436853634266535, 0.1707042821318704, 0.2185591338170152, 0.2170529663773133, 9.999999999998899e-05, 0.05837017371283726, 9.999999999998899e-05, 0.08691733466056117, 0.002342872316505762, 0.00724914842492963, 0.0488280145462997, 9.999999999998899e-05, 0.001757214409958907, 0.08739212155618992, 0.06397407743323424, 0.11102070394828878, 0.06369015625952268, 0.021384003437381005, 0.028610735643040064, 0.11476626205244012, 0.14477443962078218, 0.09257205859908135, 0.05476861949461176, 0.15926063633764242, 0.1237836921737604, 0.2053209361623276, 0.12029691633854056, 0.08667453844197548, 0.11242318556168152, 0.2300873506655562, 0.08154440668207752, 0.11500290784285683, 0.10880648873137777, 0.11561910903100503, 0.08480230675654143, 0.2956349580730121, 0.035433279950319085, 0.2768988656311101, 0.050797538845908985, 0.08644594802604244, 0.5478003357988981, 0.5483568411630921, 0.5497145776591821, 0.6177551244060429, 0.6083465842838813, 0.6212803186803499, 0.5986092321204206, 0.5656050525413963, 0.6021521402485164, 0.06696858277401829, 0.061246958864264345, 0.08395694333133741, 0.1062489142347306, 0.08121230740367302, 0.08432055633384494, 0.06127849604187108, 0.1031129355167888, 0.07166252616268176, 0.22268277579970241, 0.25224056200521705, 0.2505908386181256, 0.21245897237998346, 0.24938272831406405, 0.17281275398228957, 0.17329553264694753, 0.14985885790815479, 0.19552992220287724, 0.19127733683071302, 0.35129206497408305, 0.39050863770478017, 0.16320719947259654, 0.36356913938326585, 0.2048697242100992, 0.23817361936075154, 0.31544666186641956, 0.13068965001460742, 0.16017124843231378, 0.2141136985055817, 0.11259737439734674, 0.2893964357897556, 0.12978351518415965, 0.2287345809342437, 0.20525882969942844, 0.17930474062387114, 0.0900303240653384, 0.2289910485514699, 0.21159175963926968, 0.18511020562930203, 0.26182243164939434, 0.22181057513596347, 0.2633063846284591, 0.21810591702825588, 0.2626639118417613, 0.19910599697668152, 0.2131289372358136, 0.16972150381046525, 0.18024592793128558, 0.22111982698645183, 0.2299011940832617, 0.18823749026637815, 0.21249190372021087, 0.17881700942640744, 0.20007611878354226, 0.9668973148602267, 0.18946094474816122, 0.15479911330677676, 0.9648748833759968, 0.2023726709978353, 0.1707008471490139, 0.16919038965732358, 0.1687142360612255, 0.1546076264683326, 0.43993936873372863, 0.21470831499938392, 0.4988803946594592, 0.21387867258327464, 0.17025549267987095, 0.21421876416405128, 0.10447861192148811, 0.16938620836927343, 0.7977917267261905, 0.2019108794357921, 0.202205208477094, 0.21451981513212914, 0.21149798136115827, 0.18794952356922445, 0.22190202951009752, 0.23498437338179579, 0.24540014740890959, 0.21493258161677464, 0.09531367830238979, 0.09459607649955182, 0.08646832870207632, 0.05798495882125576, 0.10478164156590175, 0.0918154625902714, 0.08192243442071812, 0.09147678192316777, 0.06551333626323885]}, "mutation_prompt": null}
{"id": "85a316f2-0bd2-4491-931d-00ab0271d31a", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_max - ((self.w_max - self.w_min) * self.evaluations / self.budget)  # dynamic inertia weight\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Adaptive Differential Mutation using dynamic inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.29868073691565006, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "790ed606-49d7-4f20-b969-87e910e62a28", "metadata": {"aucs": [0.8306560348820103, 0.8277559663705308, 0.8454523319546279, 0.19022545810885771, 0.8385643129893314, 0.8361550843446495, 0.8358838773803539, 0.8475103760834453, 0.8274921493800866, 0.6755595193373087, 0.6418480109996145, 0.5695467625653844, 0.6611429377678928, 0.7155711723949274, 0.6784005726382977, 0.6881968443378437, 0.6936543537440929, 0.6772860094382247, 0.14621222132103817, 0.13914144169013254, 0.1399696054519367, 0.1407731091021669, 0.16386575512279944, 0.1706827857909975, 0.11027918312928886, 0.16210356497897138, 0.17091213969815122, 0.14873865323572777, 0.1332416977330435, 0.11557719865662952, 0.17230499348944306, 0.13079674839290434, 0.13236682148580892, 0.14798084747347207, 0.11726589822444389, 0.17347292813802284, 0.9918643445694864, 0.9879350525915919, 0.9918615214461521, 0.9888245530369426, 0.9914593771714622, 0.9871599501288869, 0.9859102591627077, 0.9879769136220942, 0.07475779009558359, 0.6913126817650168, 0.06015470256808364, 0.6769509857472957, 0.6774368911538, 0.1532944751508678, 0.6911800663811256, 0.6849226606977741, 0.08935770127497422, 9.999999999998899e-05, 0.28066245260413003, 0.35787050432958456, 0.37394458930694263, 0.37339015494351724, 0.19381524283757723, 0.278756932233328, 0.23108191894924568, 0.23242331008175776, 0.8535857048740356, 0.15731673042243688, 0.2151606791219992, 0.2181567131504868, 0.13115430065374312, 0.21167814073834623, 0.19687428510023142, 0.234295480040691, 0.20303331644046874, 0.21205704159657635, 0.13294993337320282, 9.999999999998899e-05, 0.23075965557338873, 0.20306981291260684, 0.1324164973677926, 0.2574575972193729, 0.2400500578329572, 0.11316356626977231, 0.2596378965266025, 0.08045466985854277, 0.03274269819709774, 0.07621278969825385, 9.999999999998899e-05, 0.03979256361547412, 0.05649198485525375, 0.014175207104209941, 9.999999999998899e-05, 0.00378427447228713, 0.13251448793108755, 0.04443191619897591, 0.09967314459561205, 0.08211139495989173, 0.023502167383757322, 0.024103319816236257, 0.12079476657090982, 0.14965947887091136, 0.07949179984861421, 9.999999999998899e-05, 9.999999999998899e-05, 0.13625479204610602, 0.07065377402859652, 0.07078529017739787, 0.12620695403126392, 0.15771980658128015, 0.11852245351951374, 0.06500054990086979, 0.0996448873837309, 0.18974414373162185, 0.07095181548975182, 0.09254595870886062, 0.006145872394088703, 9.999999999998899e-05, 0.08096632686992178, 0.11160171121294116, 0.07804466837551005, 0.5531926606959159, 0.5287025151166935, 0.5194870562272966, 0.5403208566782141, 0.5398125411015283, 0.550071126363149, 0.5452720074469666, 0.5657960723444185, 0.5542092132892744, 0.09669869029621492, 0.17542580437070776, 0.1590573001223622, 0.13298772994329755, 0.08313335250094045, 0.1418558234415117, 0.09730036472558479, 0.14130938504379176, 0.12022983733847303, 0.19854202878117944, 0.21161593560251268, 0.30824485561085324, 0.2024719275312673, 0.3308801997888742, 0.3929751470889834, 0.25450569934005174, 0.25781438925745903, 0.24861933963338556, 0.41564904962390214, 0.2580722498479243, 0.3271120252654378, 0.36143317390449725, 0.3880008706235767, 0.38715446351490423, 0.24587650809952177, 0.5330712749717783, 0.2558600434059911, 0.11607250221130838, 0.27590655609230175, 0.2923584162381351, 0.27565954564021544, 0.2592715395353369, 0.3246308151990154, 0.20495698206031998, 0.2915143282362095, 0.27120979268171463, 0.23603014759088425, 0.2366132601914771, 0.21060646012354134, 0.25172313629712895, 0.23621728151838328, 0.24964096472608233, 0.24781973285385683, 0.22421994996217165, 0.23770669687508428, 0.20625304465082295, 0.21065963125837373, 0.6241208664009401, 0.6390070117815332, 0.23054147322642837, 0.20471726054245432, 0.24603988353410722, 0.19721095598530902, 0.20215317299877356, 0.8690113668628527, 0.18846796945706146, 0.15475558604396034, 0.8860579922991201, 0.20161828211127464, 0.19978198996677132, 0.16747407233448097, 0.16842964949708927, 0.15422602890348536, 0.6654868664396169, 0.21294633876746316, 0.7245964443285273, 0.6832472963937313, 0.16759274381160705, 0.2120406048423229, 0.10519989747959335, 0.16852829115509427, 0.7714132596314227, 0.20636519953983556, 0.1880011813099831, 0.20634775242756764, 0.22223683757744783, 0.18008072858023794, 0.22643319018448738, 0.22692934453962244, 0.18318587876093573, 0.20182111451684026, 0.0934851947099945, 0.10814978281569843, 0.09345248415937513, 0.10106447880096348, 0.09111164321750131, 0.10162892487428576, 0.09851330123497826, 0.10101788615547536, 0.0895811653736851]}, "mutation_prompt": null}
{"id": "1acbb951-3f45-4625-ac96-1faab7dd6b98", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_max - ((self.w_max - self.w_min) * self.evaluations / self.budget)  # dynamic inertia weight\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Adaptive Differential Mutation using dynamic inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85a316f2-0bd2-4491-931d-00ab0271d31a", "metadata": {"aucs": [0.8306560348820103, 0.8277559663705308, 0.8454523319546279, 0.19022545810885771, 0.8385643129893314, 0.8361550843446495, 0.8358838773803539, 0.8475103760834453, 0.8274921493800866, 0.6755595193373087, 0.6418480109996145, 0.5695467625653844, 0.6611429377678928, 0.7155711723949274, 0.6784005726382977, 0.6881968443378437, 0.6936543537440929, 0.6772860094382247, 0.14621222132103817, 0.13914144169013254, 0.1399696054519367, 0.1407731091021669, 0.16386575512279944, 0.1706827857909975, 0.11027918312928886, 0.16210356497897138, 0.17091213969815122, 0.14873865323572777, 0.1332416977330435, 0.11557719865662952, 0.17230499348944306, 0.13079674839290434, 0.13236682148580892, 0.14798084747347207, 0.11726589822444389, 0.17347292813802284, 0.9918643445694864, 0.9879350525915919, 0.9918615214461521, 0.9888245530369426, 0.9914593771714622, 0.9871599501288869, 0.9859102591627077, 0.9879769136220942, 0.07475779009558359, 0.6913126817650168, 0.06015470256808364, 0.6769509857472957, 0.6774368911538, 0.1532944751508678, 0.6911800663811256, 0.6849226606977741, 0.08935770127497422, 9.999999999998899e-05, 0.28066245260413003, 0.35787050432958456, 0.37394458930694263, 0.37339015494351724, 0.19381524283757723, 0.278756932233328, 0.23108191894924568, 0.23242331008175776, 0.8535857048740356, 0.15731673042243688, 0.2151606791219992, 0.2181567131504868, 0.13115430065374312, 0.21167814073834623, 0.19687428510023142, 0.234295480040691, 0.20303331644046874, 0.21205704159657635, 0.13294993337320282, 9.999999999998899e-05, 0.23075965557338873, 0.20306981291260684, 0.1324164973677926, 0.2574575972193729, 0.2400500578329572, 0.11316356626977231, 0.2596378965266025, 0.08045466985854277, 0.03274269819709774, 0.07621278969825385, 9.999999999998899e-05, 0.03979256361547412, 0.05649198485525375, 0.014175207104209941, 9.999999999998899e-05, 0.00378427447228713, 0.13251448793108755, 0.04443191619897591, 0.09967314459561205, 0.08211139495989173, 0.023502167383757322, 0.024103319816236257, 0.12079476657090982, 0.14965947887091136, 0.07949179984861421, 9.999999999998899e-05, 9.999999999998899e-05, 0.13625479204610602, 0.07065377402859652, 0.07078529017739787, 0.12620695403126392, 0.15771980658128015, 0.11852245351951374, 0.06500054990086979, 0.0996448873837309, 0.18974414373162185, 0.07095181548975182, 0.09254595870886062, 0.006145872394088703, 9.999999999998899e-05, 0.08096632686992178, 0.11160171121294116, 0.07804466837551005, 0.5531926606959159, 0.5287025151166935, 0.5194870562272966, 0.5403208566782141, 0.5398125411015283, 0.550071126363149, 0.5452720074469666, 0.5657960723444185, 0.5542092132892744, 0.09669869029621492, 0.17542580437070776, 0.1590573001223622, 0.13298772994329755, 0.08313335250094045, 0.1418558234415117, 0.09730036472558479, 0.14130938504379176, 0.12022983733847303, 0.19854202878117944, 0.21161593560251268, 0.30824485561085324, 0.2024719275312673, 0.3308801997888742, 0.3929751470889834, 0.25450569934005174, 0.25781438925745903, 0.24861933963338556, 0.41564904962390214, 0.2580722498479243, 0.3271120252654378, 0.36143317390449725, 0.3880008706235767, 0.38715446351490423, 0.24587650809952177, 0.5330712749717783, 0.2558600434059911, 0.11607250221130838, 0.27590655609230175, 0.2923584162381351, 0.27565954564021544, 0.2592715395353369, 0.3246308151990154, 0.20495698206031998, 0.2915143282362095, 0.27120979268171463, 0.23603014759088425, 0.2366132601914771, 0.21060646012354134, 0.25172313629712895, 0.23621728151838328, 0.24964096472608233, 0.24781973285385683, 0.22421994996217165, 0.23770669687508428, 0.20625304465082295, 0.21065963125837373, 0.6241208664009401, 0.6390070117815332, 0.23054147322642837, 0.20471726054245432, 0.24603988353410722, 0.19721095598530902, 0.20215317299877356, 0.8690113668628527, 0.18846796945706146, 0.15475558604396034, 0.8860579922991201, 0.20161828211127464, 0.19978198996677132, 0.16747407233448097, 0.16842964949708927, 0.15422602890348536, 0.6654868664396169, 0.21294633876746316, 0.7245964443285273, 0.6832472963937313, 0.16759274381160705, 0.2120406048423229, 0.10519989747959335, 0.16852829115509427, 0.7714132596314227, 0.20636519953983556, 0.1880011813099831, 0.20634775242756764, 0.22223683757744783, 0.18008072858023794, 0.22643319018448738, 0.22692934453962244, 0.18318587876093573, 0.20182111451684026, 0.0934851947099945, 0.10814978281569843, 0.09345248415937513, 0.10106447880096348, 0.09111164321750131, 0.10162892487428576, 0.09851330123497826, 0.10101788615547536, 0.0895811653736851]}, "mutation_prompt": null}
{"id": "57a759f7-4c96-42d6-9fc2-08ee87218300", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n        self.chaotic_factor = lambda t: np.sin(np.pi * t)  # introducing chaotic map\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_max - ((self.w_max - self.w_min) * self.evaluations / self.budget)  # dynamic inertia weight\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    chaotic_value = self.chaotic_factor(np.random.rand())\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (\n                        self.global_best_position - self.positions[i]) * chaotic_value\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Adaptive Differential Mutation using dynamic inertia weight and chaotic map for improved exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.29583461775113834, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "85a316f2-0bd2-4491-931d-00ab0271d31a", "metadata": {"aucs": [0.8229126483745131, 0.8356308765569548, 0.8284725594145063, 0.1830809064863922, 0.8520308737301713, 0.8358735726736153, 0.8307244771840587, 0.8265749017853368, 0.8316024926455223, 0.06666179007386186, 0.6252958648603615, 0.6610643388871167, 0.679671365782299, 0.6866480347937474, 0.686061161423539, 0.6715937758821446, 0.6721744910321602, 0.051798811266842715, 0.16867832860514864, 0.17400983557092153, 0.16798732171853503, 0.14407521357442543, 0.17125715792626395, 0.14915164816579873, 0.1518579115767178, 0.17171289847517224, 0.09802222102659364, 0.16762588678784485, 0.13629044662808576, 0.1422315954010892, 0.14725044892810624, 0.11776116409645643, 0.16515595459333376, 0.1572336638896863, 0.14999019623262633, 0.13382670993328816, 0.9902606747408101, 0.9877079779335927, 0.9928090849257364, 0.9875152425978747, 0.9877070078149944, 0.9880949255217559, 0.9868519711336892, 0.9875994959741236, 0.09948407464423725, 0.7022267424674693, 0.6916722328951259, 0.7020934011564988, 0.6649913309366913, 0.6574002117294467, 0.6891102940969651, 0.1278151086438818, 0.08816058948998362, 0.08900375358899659, 0.23059545596603226, 0.33242275200200344, 0.22229704496781177, 0.27890349630693767, 0.27003534140292473, 0.20570940626335088, 0.23735586083574212, 0.23403912316980235, 0.2334141702030743, 0.20082081012173536, 0.20277882832853877, 0.20264347616749823, 0.20993389726678569, 0.2049925826122152, 0.21359504068459767, 0.20889419070063509, 0.21274812524037867, 0.46412936171385677, 0.2244285857781274, 0.15548600347272967, 0.21795730354337706, 0.25268920326456423, 0.19441974411191643, 0.2142131134589167, 0.21710961484876534, 0.1343227411247533, 0.24384208976281574, 0.0026558446661228974, 0.010127030008982962, 0.01026515294032726, 0.005999122063287898, 0.010845365842566235, 9.999999999998899e-05, 0.051230582838416416, 9.999999999998899e-05, 0.004120828211648386, 0.0572347173740021, 0.020779719518871698, 0.07505120560313427, 0.07317996761662582, 0.0005086603522999056, 0.03548982752032881, 0.12480609623060934, 0.13428939512497073, 0.0568931846131, 0.11869766271632964, 0.1013760888360219, 0.1795514314800617, 0.21391503550264224, 0.07052913571986208, 0.07596522295152441, 0.09334171379676959, 0.06809172975876865, 0.06986270083181445, 0.07693050055403472, 0.2904051597646351, 0.05662288498858614, 0.038535317957600235, 0.03330043710213504, 0.14009024748953924, 0.05042414915629656, 0.04770936779561086, 0.07973548956361287, 0.5137411957264454, 0.4890618715030468, 0.503743107111895, 0.5399006180926347, 0.5597716540603277, 0.5282784317009652, 0.5876830587034158, 0.5571343946867098, 0.5445410195609764, 0.11190945436352973, 0.13419301769367054, 0.1362483726436824, 0.18187916575162677, 0.1196955243871336, 0.12196116723707395, 0.1729021511694092, 0.1357003646108338, 0.10478330920976475, 0.2763738207367529, 0.24963768545169607, 0.3951947692073082, 0.24612336632490917, 0.32303734812672547, 0.1694557728963375, 0.24155447439188849, 0.22158200955925456, 0.3364954744402524, 0.3264318669011167, 0.38033702512147616, 0.4478529832064603, 0.3742031661419465, 0.3955292470005408, 0.45804807672140124, 0.29941199870653523, 0.19561231420606295, 0.33449050775570144, 0.22359656048238197, 0.26040604442822324, 0.25518067493113994, 0.2404947230475427, 0.21395760640472528, 0.3038503496755971, 0.23172087303639188, 0.20958463779041914, 0.24304242980953328, 0.2804170212973438, 0.23965863649462893, 0.20980516176723074, 0.2428059453196414, 0.18990045645442477, 0.250428773851205, 0.2139973000341272, 0.22408137163284725, 0.1979452884137377, 0.24304658896188003, 0.24491833001388108, 0.23990013095438945, 0.2370839786297514, 0.20537387508978378, 0.24556575872147246, 0.20150729907611453, 0.7413208197818104, 0.6309885128199894, 0.8755330629684188, 0.8767458182680063, 0.1247623167079217, 0.8919618815150044, 0.20036415256359308, 0.20123117042520577, 0.163502652050181, 0.1668866786581117, 0.16297802363676905, 0.7118258082256426, 0.16680306286485025, 0.6655166613912901, 0.21281294071013335, 0.1558902704230113, 0.2124234750020607, 0.10417813543743537, 0.1679332384775234, 0.7350869461278816, 0.18341541684985851, 0.22566723996024862, 0.1999066307359253, 0.20606567756698946, 0.23541090883903792, 0.2080257990741573, 0.21149232878439783, 0.2216512170517605, 0.1788059888621778, 0.07282842882601781, 0.09992679610833799, 0.09186544133639052, 0.10315099259540184, 0.0895134767443384, 0.07474837859273498, 0.0990079888784452, 0.09593012564397962, 0.09031536222678149]}, "mutation_prompt": null}
{"id": "ffc63901-47ae-4c20-b39e-e0d49f9a7479", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_max - ((self.w_max - self.w_min) * self.evaluations / self.budget)  # dynamic inertia weight\n            self.mutation_rate = 0.1 + 0.5 * (self.evaluations / self.budget)  # adaptive mutation rate\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Adaptive Differential Mutation using dynamic inertia weight and adaptive mutation rate for improved exploration-exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.30001771274081945, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "85a316f2-0bd2-4491-931d-00ab0271d31a", "metadata": {"aucs": [0.8292643811529989, 0.8382566035658161, 0.841583311603926, 0.1901035945597831, 0.83268840719234, 0.8463972967370526, 0.8442824550934465, 0.8309264242008374, 0.853671073486837, 0.6638813522583387, 0.6455946391827216, 9.999999999998899e-05, 0.6741591248056202, 0.5966648436872259, 0.6853010819873181, 0.671773193905442, 0.6978715412986021, 0.6368596898981136, 0.15122086737526375, 0.14821893926811058, 0.09117197401883348, 0.1593911231836853, 0.60678895232598, 0.1354734998912791, 0.1820580789718086, 0.17678862400612694, 0.6020099584485457, 0.1425625593005152, 0.11652508345472212, 0.12547217827479729, 0.11223728155057122, 0.14531482452288003, 0.14354561613132644, 0.10501581028975504, 0.11234612347620165, 0.1590367710977183, 0.9918643445694864, 0.9879350525915919, 0.9918615214461521, 0.9888245530369426, 0.9914593771714622, 0.9869528495897768, 0.9859102591627077, 0.9879769136220942, 0.07475817195858914, 0.6829575672481332, 0.06012505443675531, 0.6856258661642438, 0.6401183020523369, 0.6543967304444125, 0.6800907543921308, 0.6834137358715868, 0.08938618622302963, 9.999999999998899e-05, 0.22735613027082857, 0.16603639846769658, 0.2272299951078065, 0.8315014997248535, 0.19411678506789276, 0.27747889335623943, 0.23595674564086666, 0.233621164019444, 0.33813585565705084, 0.12368203218367801, 0.21323732349286906, 0.20217024046751053, 0.12807840415031058, 0.21204816093389567, 0.12693491935672196, 0.13368519757880204, 0.19968966997522164, 0.20428905696581467, 0.18732976780046862, 9.999999999998899e-05, 0.21376166804509578, 0.22271575123600318, 0.21619661351551944, 0.21660459067441096, 0.24694720241357615, 0.2617403732549589, 0.25738800392101924, 0.003570219781179551, 9.999999999998899e-05, 0.06154649383716515, 9.999999999998899e-05, 0.010163688452029196, 9.999999999998899e-05, 0.009053744053038604, 9.999999999998899e-05, 0.0008208936818615564, 0.09632847804942557, 0.05775518593250839, 0.11179970214985246, 0.08350098436253517, 0.018294592659025555, 0.04184646728026342, 0.10343598626061379, 0.09118480871597856, 0.06503136543479526, 9.999999999998899e-05, 9.999999999998899e-05, 0.17972390324744414, 0.06782675971506957, 0.06773216144496252, 0.07135648706511344, 0.10985456086900847, 0.17480268129530618, 0.06509705970409962, 0.10163873456449224, 0.09260555086964761, 0.09060157010991332, 0.12307654290617465, 0.11570532186096882, 9.999999999998899e-05, 0.08246602388942714, 0.05567580539665962, 0.08009252518247867, 0.5555993524997762, 0.5029556189134152, 0.5066772885773527, 0.5994437587179084, 0.5210175550200407, 0.5501983855905355, 0.5288909314241768, 0.5665743320419601, 0.5410960284430659, 0.15154247233107077, 0.11853414638956872, 0.11567997814082187, 0.10544776643915299, 0.14564101220102044, 0.13886763443178174, 0.13071973254792701, 0.12688368849562737, 0.10689125975834757, 0.1763266294231729, 0.345378592126225, 0.18649115721901965, 0.41150852110948855, 0.21618117417469718, 0.19868544666973853, 0.23612468885836102, 0.33006948340366504, 0.22587348872248225, 0.2996298458972739, 0.2841511127200025, 0.2922039555888699, 0.3605044476143904, 0.41519886532261385, 0.4372290118950045, 0.3492275737518141, 0.3211272923307612, 0.2439543714542367, 0.2367909193970681, 0.2816914174351358, 0.33408652150700147, 0.3280914085630916, 0.2715342964755755, 0.2567128283354445, 0.2188527981677275, 0.28659119159539703, 0.2839389120769298, 0.23037821432259575, 0.24027141927280637, 0.19942807575812083, 0.22307707655229037, 0.22091381982631064, 0.23479112845858152, 0.21228865906126482, 0.22260012450152422, 0.23781457286334406, 0.7076679110518587, 0.23984194521208224, 0.19804245334736492, 0.5471831237028427, 0.20509709237509777, 0.22441052813268336, 0.7233838820677259, 0.2385669605242784, 0.22031362475080096, 0.923833293046325, 0.18771209769872932, 0.1544847688405111, 0.8844084801379343, 0.2018863368441267, 0.20040582990838884, 0.16736642917922018, 0.16828165335387224, 0.15367194723608701, 0.756931547896401, 0.21210321338285776, 0.7118357459364562, 0.7699587801621182, 0.1539801301438587, 0.21217632751050064, 0.10416957929225423, 0.1688475188359576, 0.7372473007177964, 0.20645783127006057, 0.19412925600722986, 0.2075877203599904, 0.19121719692584116, 0.20412040052137048, 0.1981290083633277, 0.2068105441767354, 0.21708938060743954, 0.21741161386747843, 0.09070959242375232, 0.09763421770308245, 0.09876848097889401, 0.09997314423832182, 0.08140236260620681, 0.10371743785564236, 0.08919260106917859, 0.0804504802341669, 0.09320093486901992]}, "mutation_prompt": null}
{"id": "293e60b2-c8af-4ebb-941f-0f94ebbd9d08", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n        self.chaotic_sequence = np.random.rand(self.budget)  # Added chaotic sequence initialization\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_max - ((self.w_max - self.w_min) * self.evaluations / self.budget)  # dynamic inertia weight\n            self.mutation_rate = 0.1 + 0.5 * (self.evaluations / self.budget)  # adaptive mutation rate\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n                \n                chaotically_adjusted_position = self.positions[i] + self.chaotic_sequence[self.evaluations % self.budget]  # Chaotic adjustment\n                self.positions[i] = np.clip(chaotically_adjusted_position, self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Improved Hybrid PSO with Adaptive Differential Mutation using a novel chaotic map for enhanced exploration and convergence speed.", "configspace": "", "generation": 14, "fitness": 0.04814746213978361, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "ffc63901-47ae-4c20-b39e-e0d49f9a7479", "metadata": {"aucs": [0.07181397830146763, 0.06824748366122768, 0.0871088509499004, 0.029109804109675674, 0.062138895920524906, 0.07829132429447894, 0.07795415841203734, 0.07431300570909605, 0.06711154613058024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007086528911496082, 0.022565297992430677, 0.00945578034786465, 0.015492356987582334, 0.013811251678157666, 0.011695786512004425, 0.018248263482334326, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.005863558338695785, 9.999999999998899e-05, 9.999999999998899e-05, 0.007965721269983073, 9.999999999998899e-05, 0.04637413834054771, 0.04400132953506086, 0.0449729553733238, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03978865280479771, 0.048986754550083944, 0.02584969810736515, 0.03599317581506789, 0.002933616193071087, 9.999999999998899e-05, 9.999999999998899e-05, 0.009901909271951781, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.07424893485192374, 0.10085065986248443, 0.044395845695404335, 0.036981206135514144, 0.0051080168671051585, 0.09036651009400198, 0.04083009438212326, 0.1306117982623224, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03328946580571224, 0.0006684371717837756, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016844005770504378, 0.00387083402598587, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17230621269755086, 0.1220062550946357, 0.19019532350810087, 0.09912502916740029, 0.11755659487534975, 0.11288018124099364, 0.13019886294344574, 0.10722734925064781, 0.14542422670910582, 0.023814401276680885, 0.011717091499633514, 0.0038003446958629894, 0.006101769545772684, 9.999999999998899e-05, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.11547068353804646, 0.09615728115550648, 0.10467403342819148, 0.13499270183181578, 0.10910612010350429, 0.08202824777959528, 0.1096448444298962, 0.11670586843065989, 0.09334235569579419, 0.1400196661764076, 0.12166690775581479, 0.15300088137710788, 0.14450346400775615, 0.11579681441457546, 0.12012414902955171, 0.12904533064560364, 0.14502446181892847, 0.11203165688568117, 0.07176241576458542, 0.07695359434580218, 0.09022893668926846, 0.09291494368123765, 0.05992760848292489, 0.055953234173656496, 0.07348857510320417, 0.08523614621060138, 0.058946028363649594, 0.0916346253723066, 0.09522133159133395, 0.13345086981233123, 0.10289055837941885, 0.11238756916183024, 0.11661364913617511, 0.13109061548708745, 0.09823121030468773, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08368562661974499, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13261765307784046, 0.08864471067576163, 0.1107037750844001, 0.08405594052026388, 0.1526551127824558, 0.07978800686179444, 0.08728446265553125, 0.07137185757391618, 0.11488050119808091, 0.08390271269734006, 0.1008721505478477, 0.07437819681881919, 0.07281947813697975, 0.07298321931366214, 0.06912533889424743, 0.06956245021793561, 0.07145636212328677, 0.07960442504643228, 0.1702851619827116, 0.15469275673287175, 0.15569427611834274, 0.18750252847369586, 0.1651713229824432, 0.15680147389132193, 0.1693302022577271, 0.18023647662652043, 0.16361692442734332, 0.010177010246020468, 0.03824665693398255, 0.031393493129599714, 0.01764089320434925, 0.034250362467319606, 0.02523183729457612, 0.017549719768346073, 0.03177596454829745, 0.04068246029935452]}, "mutation_prompt": null}
{"id": "340d17ef-3001-4aad-85e6-7458e1e745a8", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_max - ((self.w_max - self.w_min) * self.evaluations / self.budget)  # dynamic inertia weight\n            self.mutation_rate = 0.1 + 0.5 * (self.evaluations / self.budget)  # adaptive mutation rate\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                # Introduce slight random perturbation to improve diversity\n                random_perturbation = np.random.normal(0, 0.01, self.velocities[i].shape)\n                self.velocities[i] += random_perturbation\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Adaptive Differential Mutation using dynamic inertia weight and adaptive mutation rate for improved exploration-exploitation balance and slightly modified velocity update strategy for diversity.", "configspace": "", "generation": 15, "fitness": 0.2659049587460728, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "ffc63901-47ae-4c20-b39e-e0d49f9a7479", "metadata": {"aucs": [0.563420017984778, 0.5886196973334211, 0.5784686468333791, 0.5832737697766954, 0.5794350447809413, 0.5747451627330474, 0.5784908835748886, 0.56431820252628, 0.575835189885793, 0.18024740263478867, 0.03920205971500945, 0.15482454257719347, 0.13294882974637567, 0.04960663091667539, 0.14561823158092502, 0.056309886440043866, 0.05088556503427877, 0.14550538347954112, 0.14402949153383182, 0.1342086762299346, 0.2548131890800228, 0.13895225831843094, 0.14309797167836236, 0.13324980056557656, 0.1366335562950851, 0.15208121674709707, 0.14526389799741934, 0.15192257954724742, 0.1132021845986777, 0.10484818834487764, 0.11350019088139451, 0.12004837611335839, 0.1149184731484798, 0.1085026981378, 0.13607086389626732, 0.13264087533337843, 0.98699095682612, 0.9891555604065907, 0.9927813639240669, 0.9901009149625466, 0.9915613489466433, 0.9812166116711434, 0.9903163037463376, 0.9897026431073389, 0.9835251068005161, 0.4062109075295941, 0.39720187733002876, 0.42321153032555014, 0.4093384078432306, 0.40699988803374354, 0.3955433953851226, 0.401100391203156, 0.3828785880546195, 0.4108698788843249, 0.3518167663001305, 0.3389959520493364, 0.3602451648224686, 0.37230135150074306, 0.2125931663372519, 0.2791393433408288, 0.36608600394296187, 0.17542351471361195, 0.2353118856312919, 0.18764064195317331, 0.19904282790280436, 0.19037063448598812, 0.19187191601630815, 0.18827865349094963, 0.198242860093641, 0.19306694371081767, 0.19306651850234857, 0.19041430271884596, 0.20379146543062976, 0.2087740310261753, 0.20007151954873115, 0.20276376038535104, 0.1817590440757193, 0.19902257262036516, 0.20887257917276691, 0.20400585584545983, 0.21365105436488185, 0.0044009940778494405, 9.999999999998899e-05, 0.07534714967233336, 0.00020280121352300728, 0.08043454712275089, 0.03941308524138254, 0.04490810714838356, 9.999999999998899e-05, 9.999999999998899e-05, 0.1674828545439061, 0.07149186857965473, 0.09297646595504572, 0.07570327859697168, 0.051349519385829656, 0.04828035065764891, 0.08703248388948359, 0.08430234955576288, 0.08888376646397467, 0.029903052236082805, 0.04366469930324024, 0.03857288258171887, 0.04284698571076029, 0.03469086495310314, 0.031257556235510076, 0.043840788190711466, 0.047131641435386507, 0.03383788722329395, 0.04022810271189314, 0.1290368948723264, 0.1356303304971228, 0.05170985336093237, 0.02537805808305782, 0.12652493282587673, 0.08184131842898257, 0.05665342077937641, 0.08117317912537036, 0.4903251337886755, 0.48366491930270716, 0.48822790252375503, 0.4825914563620991, 0.5023657074042089, 0.5034119923002661, 0.49542453882510273, 0.5024152580749438, 0.4996049355401073, 0.13637411886909556, 0.102520431607659, 0.07853730642108259, 0.16253406294854122, 0.12915822032954605, 0.13265532318668394, 0.09421181831312131, 0.13772560269220324, 0.1093626292725628, 0.2426334591990189, 0.38354666454665864, 0.2883205765440936, 0.2497784588798263, 0.2817759631200425, 0.2492955041023538, 0.2534340632058899, 0.28725774889002964, 0.2770501894890556, 0.3436434774754036, 0.3536282581443918, 0.3620157251604029, 0.35429844793957777, 0.36266323963229763, 0.3580501676780681, 0.356831162721999, 0.26213384757038316, 0.3456569012903048, 0.2894795814554819, 0.2326232811184552, 0.20977706381046335, 0.2834241108601496, 0.23395424209507154, 0.283294914037612, 0.2732219381387403, 0.2604273926356432, 0.2413931073012816, 0.22925983164056163, 0.21764446198775955, 0.23413750154920743, 0.21080877675343146, 0.23910720958305443, 0.20155005206760446, 0.2136423822694533, 0.21813373624714427, 0.2049889048084591, 0.42605427711551624, 0.24071515034295243, 0.3935831680005466, 0.24854207304109743, 0.23027014012115765, 0.22021685025483784, 0.21767826244556565, 0.22265430584927848, 0.19685046838340692, 0.18816742769624395, 0.8438963399477076, 0.15473486509873657, 0.8721110733570195, 0.20035767205829702, 0.20108678640012734, 0.15343907235024912, 0.1670720463019426, 0.16366462253717895, 0.6223579478296739, 0.212149161479659, 0.8058177658054346, 0.2104400468897465, 0.533093962152948, 0.8187890674631066, 0.5998091352660515, 0.16936282289849036, 0.6162463069304354, 0.2286012184642343, 0.19049174090562881, 0.18050826272597587, 0.19908773425472615, 0.2041570263318787, 0.2032530426408612, 0.18060679236688848, 0.19170034232694744, 0.1894155809373509, 0.08763237039618166, 0.10119443808016582, 0.08617904496298812, 0.09274167579209736, 0.09905456030666904, 0.09800847407171187, 0.08022051274639164, 0.0886420908076434, 0.10332394967944092]}, "mutation_prompt": null}
{"id": "ca2f1892-abe0-4871-a41f-3e907de38312", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # refine inertia weight update strategy\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget) \n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)  # refined mutation rate range\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Adaptive Differential Mutation using a refined inertia weight and mutation update strategy for improved convergence.", "configspace": "", "generation": 16, "fitness": 0.3001099552245042, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "ffc63901-47ae-4c20-b39e-e0d49f9a7479", "metadata": {"aucs": [0.8455057049804624, 0.8492250613913298, 0.8279844375717117, 0.19009776608876072, 0.8430020994472779, 0.8670533724421221, 0.8480657918407694, 0.8378078794669371, 0.8529940532318077, 0.6473281845972989, 0.6432784609762143, 9.999999999998899e-05, 0.6509669587941418, 0.04414010491828868, 0.6721966985022714, 0.6661770085171943, 0.703083144691944, 0.6766116692915481, 0.14868170825214544, 0.16563823272659794, 0.09844424618619507, 0.1335824286470968, 0.1365728474444926, 0.46477351783991605, 0.1450753412491127, 0.615421586295686, 0.17771220320359293, 0.1418453150610387, 0.5846232412637431, 0.12682338680392113, 0.11113118438326508, 0.14537736856921202, 0.15398555008175574, 0.10656385634911802, 0.14739623036502858, 0.10953839232612317, 0.9918643445694864, 0.9879350525915919, 0.9918615214461521, 0.9888245530369426, 0.9914593771714622, 0.9869528495897768, 0.9859102591627077, 0.9879769136220942, 0.07475817195858914, 0.694970302194331, 0.06011602456413767, 0.6793938049262848, 0.6808745276373376, 0.7023446541276804, 0.7021794726886206, 0.6631885631331141, 0.08939647364782255, 9.999999999998899e-05, 0.6886245229035763, 0.20472142647497404, 0.22896804328920584, 0.3662679762425588, 0.1942841550283958, 0.22020297609116324, 0.23082479844916026, 0.23324554216416837, 0.2383030773097511, 0.1850368495552378, 0.20131359146969863, 0.20643921754510186, 0.20092308340667608, 0.211731737986795, 0.20666223344972912, 0.22057330235944794, 0.2140946265535506, 0.210810051810168, 0.21714899697557977, 9.999999999998899e-05, 0.2187014092483318, 0.21813321355787962, 0.34495998449275367, 0.2099132144497512, 0.24626156889827067, 0.11554083748586186, 0.25113659538074606, 0.11246798538958558, 9.999999999998899e-05, 0.05626824691402399, 9.999999999998899e-05, 0.1593544171070551, 9.999999999998899e-05, 0.00041769971598026867, 9.999999999998899e-05, 0.001726143003296765, 0.09690327969209245, 0.04686660378928753, 0.15898168921325573, 0.10333294756333122, 0.015257959019215228, 0.04341121515959945, 0.09327724838033213, 0.11397061956602828, 0.10309600821611964, 9.999999999998899e-05, 0.025870664622053674, 0.21905515643817164, 0.07839461645408885, 0.06979331187402527, 0.07253428943475615, 0.09647470652850365, 0.2182890913075315, 0.06561771156752261, 0.1063721865871401, 0.1038442676682867, 0.09903738124448813, 0.1475330342031166, 0.049383778479962004, 9.999999999998899e-05, 0.0859938873833993, 0.05912779357556808, 0.08117181854403477, 0.5076034367169417, 0.4997639127883483, 0.5043393131624667, 0.5595157907768293, 0.6023229679713771, 0.5570391248328915, 0.520682456451854, 0.5748042940820384, 0.5454901990085286, 0.1310852759055906, 0.14976735728596047, 0.13714446671346214, 0.10905912534368312, 0.12387705605781829, 0.1366196688362814, 0.0863274756026714, 0.1638763303809868, 0.09813482749958291, 0.19248756192277316, 0.2817172236076073, 0.2450415394529245, 0.2384499882164859, 0.25620327455864766, 0.17328220360853197, 0.25574359391471924, 0.31588863971816317, 0.36499989632795926, 0.2923239328608994, 0.39259970940233513, 0.33133468841574043, 0.4945038993860057, 0.3026837422810238, 0.45134946656748054, 0.23462098897710482, 0.37393523967724773, 0.24250540164548606, 0.20390565924683335, 0.33018675464737846, 0.30570777277509675, 0.3630201676366086, 0.2838505580732802, 0.19809412104637325, 0.2230831038084029, 0.29570340310171284, 0.2476236173359544, 0.20073329253057814, 0.23846555888100407, 0.20209407913663124, 0.22976861445116314, 0.2448777902489726, 0.24832325678107192, 0.2227801501467528, 0.2141548298466669, 0.2506485660459252, 0.2386542244549532, 0.23909408950784672, 0.22094026318006577, 0.19720723909740734, 0.2215851741678051, 0.21399410560037002, 0.5603077907462989, 0.2134939355034402, 0.24464971495558552, 0.8581339784850792, 0.18803861151581103, 0.15447187841274623, 0.8428853888721575, 0.8223421990870808, 0.20038235766522428, 0.1671849005786653, 0.16827897054400653, 0.1540390000445121, 0.5466978555932257, 0.21237859252140567, 0.6835097420913848, 0.8472792938045228, 0.15435475333523097, 0.21218505887780958, 0.10419076529452209, 0.16884965265903806, 0.7827167655813227, 0.21774990790750193, 0.20181160359011296, 0.20728469384731407, 0.18696434851713173, 0.19525324226512453, 0.18816851181020533, 0.20232269953742188, 0.19310351435420803, 0.18876565398437528, 0.10661615584072681, 0.09661775868677192, 0.09081608480259618, 0.09056515467891235, 0.10206747353224532, 0.10096220262243316, 0.10164761566122493, 0.0812528558231137, 0.09552849206846425]}, "mutation_prompt": null}
{"id": "554c60a7-5529-4d5c-848a-e555d724baf9", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # refine inertia weight update strategy\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget) \n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)  # refined mutation rate range\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)  # velocity clamping\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Adaptive Differential Mutation using a refined inertia weight and mutation update strategy for improved convergence.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca2f1892-abe0-4871-a41f-3e907de38312", "metadata": {"aucs": [0.8455057049804624, 0.8492250613913298, 0.8279844375717117, 0.19009776608876072, 0.8430020994472779, 0.8670533724421221, 0.8480657918407694, 0.8378078794669371, 0.8529940532318077, 0.6473281845972989, 0.6432784609762143, 9.999999999998899e-05, 0.6509669587941418, 0.04414010491828868, 0.6721966985022714, 0.6661770085171943, 0.703083144691944, 0.6766116692915481, 0.14868170825214544, 0.16563823272659794, 0.09844424618619507, 0.1335824286470968, 0.1365728474444926, 0.46477351783991605, 0.1450753412491127, 0.615421586295686, 0.17771220320359293, 0.1418453150610387, 0.5846232412637431, 0.12682338680392113, 0.11113118438326508, 0.14537736856921202, 0.15398555008175574, 0.10656385634911802, 0.14739623036502858, 0.10953839232612317, 0.9918643445694864, 0.9879350525915919, 0.9918615214461521, 0.9888245530369426, 0.9914593771714622, 0.9869528495897768, 0.9859102591627077, 0.9879769136220942, 0.07475817195858914, 0.694970302194331, 0.06011602456413767, 0.6793938049262848, 0.6808745276373376, 0.7023446541276804, 0.7021794726886206, 0.6631885631331141, 0.08939647364782255, 9.999999999998899e-05, 0.6886245229035763, 0.20472142647497404, 0.22896804328920584, 0.3662679762425588, 0.1942841550283958, 0.22020297609116324, 0.23082479844916026, 0.23324554216416837, 0.2383030773097511, 0.1850368495552378, 0.20131359146969863, 0.20643921754510186, 0.20092308340667608, 0.211731737986795, 0.20666223344972912, 0.22057330235944794, 0.2140946265535506, 0.210810051810168, 0.21714899697557977, 9.999999999998899e-05, 0.2187014092483318, 0.21813321355787962, 0.34495998449275367, 0.2099132144497512, 0.24626156889827067, 0.11554083748586186, 0.25113659538074606, 0.11246798538958558, 9.999999999998899e-05, 0.05626824691402399, 9.999999999998899e-05, 0.1593544171070551, 9.999999999998899e-05, 0.00041769971598026867, 9.999999999998899e-05, 0.001726143003296765, 0.09690327969209245, 0.04686660378928753, 0.15898168921325573, 0.10333294756333122, 0.015257959019215228, 0.04341121515959945, 0.09327724838033213, 0.11397061956602828, 0.10309600821611964, 9.999999999998899e-05, 0.025870664622053674, 0.21905515643817164, 0.07839461645408885, 0.06979331187402527, 0.07253428943475615, 0.09647470652850365, 0.2182890913075315, 0.06561771156752261, 0.1063721865871401, 0.1038442676682867, 0.09903738124448813, 0.1475330342031166, 0.049383778479962004, 9.999999999998899e-05, 0.0859938873833993, 0.05912779357556808, 0.08117181854403477, 0.5076034367169417, 0.4997639127883483, 0.5043393131624667, 0.5595157907768293, 0.6023229679713771, 0.5570391248328915, 0.520682456451854, 0.5748042940820384, 0.5454901990085286, 0.1310852759055906, 0.14976735728596047, 0.13714446671346214, 0.10905912534368312, 0.12387705605781829, 0.1366196688362814, 0.0863274756026714, 0.1638763303809868, 0.09813482749958291, 0.19248756192277316, 0.2817172236076073, 0.2450415394529245, 0.2384499882164859, 0.25620327455864766, 0.17328220360853197, 0.25574359391471924, 0.31588863971816317, 0.36499989632795926, 0.2923239328608994, 0.39259970940233513, 0.33133468841574043, 0.4945038993860057, 0.3026837422810238, 0.45134946656748054, 0.23462098897710482, 0.37393523967724773, 0.24250540164548606, 0.20390565924683335, 0.33018675464737846, 0.30570777277509675, 0.3630201676366086, 0.2838505580732802, 0.19809412104637325, 0.2230831038084029, 0.29570340310171284, 0.2476236173359544, 0.20073329253057814, 0.23846555888100407, 0.20209407913663124, 0.22976861445116314, 0.2448777902489726, 0.24832325678107192, 0.2227801501467528, 0.2141548298466669, 0.2506485660459252, 0.2386542244549532, 0.23909408950784672, 0.22094026318006577, 0.19720723909740734, 0.2215851741678051, 0.21399410560037002, 0.5603077907462989, 0.2134939355034402, 0.24464971495558552, 0.8581339784850792, 0.18803861151581103, 0.15447187841274623, 0.8428853888721575, 0.8223421990870808, 0.20038235766522428, 0.1671849005786653, 0.16827897054400653, 0.1540390000445121, 0.5466978555932257, 0.21237859252140567, 0.6835097420913848, 0.8472792938045228, 0.15435475333523097, 0.21218505887780958, 0.10419076529452209, 0.16884965265903806, 0.7827167655813227, 0.21774990790750193, 0.20181160359011296, 0.20728469384731407, 0.18696434851713173, 0.19525324226512453, 0.18816851181020533, 0.20232269953742188, 0.19310351435420803, 0.18876565398437528, 0.10661615584072681, 0.09661775868677192, 0.09081608480259618, 0.09056515467891235, 0.10206747353224532, 0.10096220262243316, 0.10164761566122493, 0.0812528558231137, 0.09552849206846425]}, "mutation_prompt": null}
{"id": "dff99aac-8880-4201-9b08-ae7d6eb722fe", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Improved Hybrid PSO with Dynamic Mutation and Local Search for enhanced exploration and convergence precision.", "configspace": "", "generation": 18, "fitness": 0.30370748928348024, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "ca2f1892-abe0-4871-a41f-3e907de38312", "metadata": {"aucs": [0.8236189689909085, 0.8230025088660167, 0.8273976181788105, 0.869110632952363, 0.8027686324136352, 0.8472519945754532, 0.8173252633077646, 0.8088003064767355, 0.8292876427387792, 0.6671615095626375, 0.03869444757771945, 0.6654501578042804, 0.6502802680533988, 0.6574448240921507, 0.6434605770366368, 0.5983316015358335, 0.6600525136285289, 0.6540576852127362, 0.6146224436997803, 0.16294480241843867, 0.1328237926707616, 0.14106562486998808, 0.1585876418650174, 0.16473160728265468, 0.6042477525968186, 0.580604550057966, 0.17472344916417037, 0.11606595170632295, 0.16305738547092263, 0.11696118823660762, 0.139153328058775, 0.13840694783807028, 0.14340660343548128, 0.12092172980289073, 0.14426491158869814, 0.1176534936491136, 0.9891418515843697, 0.9884176934769946, 0.9914112337721335, 0.9885217764466042, 0.9894696652342735, 0.9500266417723754, 0.9863420950511119, 0.9891613840482351, 0.9843265272482351, 0.6027515007994408, 0.6610434018258458, 0.5914899376226502, 0.5608764888434805, 0.6514874611873225, 0.567007348211706, 0.5927448433205276, 0.6016382361611718, 0.6459725107000239, 0.695946277029863, 0.22169463396646116, 0.22842503943744719, 0.2540167696517891, 0.21215777505910394, 0.21475408031293042, 0.3488438428248877, 0.17813666578307652, 0.6395918525437557, 0.2055976237736432, 0.2137274901554208, 0.20150058373356283, 0.20467825539592643, 0.1821839173585802, 0.11797429056289765, 0.2018013897664347, 0.20733670025456385, 0.2159971912504668, 0.1292993802315756, 0.19603233934116293, 0.21149057077725397, 0.14474916090176826, 0.22202374416641957, 0.21164212926715287, 0.1321197454887033, 0.3086096692625868, 0.13170819408418533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003736892027048855, 9.999999999998899e-05, 0.004252534364621141, 9.999999999998899e-05, 0.00019255313996580092, 0.11885271526147356, 0.050316241714994825, 0.055478189904928366, 0.0863335855788846, 0.07246225179709054, 0.00015522310597892996, 0.21172665375921884, 0.17119568700154397, 0.0691991790623595, 0.3037295511218796, 0.08005292884433313, 0.166319458415368, 0.12807047603832167, 0.07063230563322997, 0.08679611656846298, 0.07171076867745596, 0.105605151968582, 0.06946841254778646, 0.042152944467933606, 0.06911835438170033, 0.15569939085561413, 0.18747556027068035, 0.02138240189251006, 0.03928586108749388, 0.23190769298592684, 0.05687276899017035, 0.08388773890209178, 0.5516784376722438, 0.4876106195557499, 0.501617290206291, 0.5622742576053437, 0.5249971401148261, 0.49241581847388494, 0.5164108524949547, 0.5160835801939314, 0.5281691283669785, 0.12144747466829808, 0.09813673788446398, 0.10295718942543952, 0.12176865499483358, 0.102172399830744, 0.1105229221415569, 0.07354523843019178, 0.12787114148785128, 0.10980629471746162, 0.25325457281406305, 0.2182007456846886, 0.23456189206679456, 0.21928069147965124, 0.33430244100218864, 0.2921937524204271, 0.3368054011283217, 0.18867776834673788, 0.29035176367082527, 0.23896474075259633, 0.23773744810759023, 0.4356938882040158, 0.3924062019365776, 0.3852120601524799, 0.32586552879564357, 0.2936546029023356, 0.24300834127572657, 0.3505101627628845, 0.25387472904347574, 0.20959417721827434, 0.15659209140799935, 0.3378606508029577, 0.3020478378045123, 0.3334630225717512, 0.20951532153734032, 0.22007093686506318, 0.22355076770358961, 0.17990160094645236, 0.2269572071950816, 0.2201875515501125, 0.22445973800210617, 0.1906022920270276, 0.2136152093569209, 0.2432328617882905, 0.22227622725674268, 0.23023058138162455, 0.233361254815886, 0.21988457930849403, 0.2870079601229577, 0.24743259711251897, 0.22743217013706485, 0.21919519324543357, 0.22561601415431176, 0.2411945142576457, 0.21707735406805462, 0.8539422423757331, 0.18838496139154082, 0.1540902892110071, 0.847663938914699, 0.20096547109317775, 0.2012570051557092, 0.168125552454078, 0.16796941029646073, 0.15417473462024467, 0.12782772480272997, 0.21312773790823336, 0.6596937511793967, 0.21208857403986026, 0.15564790227580338, 0.21205278297065788, 0.10545750088208772, 0.167576629064911, 0.7634949660346013, 0.21080546659742438, 0.20006388001587438, 0.1766170822898494, 0.19525091103157832, 0.18210750110522544, 0.21559705884709957, 0.21983645346052416, 0.18891926529973302, 0.19697731776510752, 0.10493103675578008, 0.08896434422500588, 0.08662225791683975, 0.10387437851119286, 0.0713392712156452, 0.10474203747345001, 0.0890795243588216, 0.09060219894260813, 0.08826504382611933]}, "mutation_prompt": null}
{"id": "3da9c78a-091d-47b4-9418-63e6599e675a", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.15 + 0.5 * (self.evaluations / self.budget)  # Increased mutation rate\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.05, 0.05, self.dim)  # Enhanced local search precision\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Refined Hybrid PSO increasing dynamic mutation intensity and enhancing local search precision.", "configspace": "", "generation": 19, "fitness": 0.30020790514840584, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "dff99aac-8880-4201-9b08-ae7d6eb722fe", "metadata": {"aucs": [0.8130219140369119, 0.8102607407755393, 0.8022169560281879, 0.7928922379648059, 0.7822133532073489, 0.8274887483170417, 0.8153724136809456, 0.7796540259574188, 0.8191621867686643, 0.6214359720712361, 0.036934633206409107, 0.6079494670283183, 0.5981168085972818, 0.5850814744626204, 0.6026142058438706, 0.5854190177586243, 0.6032290326706855, 0.6361976479051186, 0.10592853060596896, 0.12973720809238187, 0.17106437238589645, 0.17361714882623525, 0.11875003297173026, 0.17159869340506362, 0.15876428997748915, 0.5843862951830243, 0.11703031589802049, 0.1419161379259467, 0.14437443903640346, 0.14328673161215866, 0.13109669704069016, 0.15348089675639953, 0.13254662313314125, 0.12453537503278445, 0.14624417100529097, 0.10719118022896568, 0.9890215271047565, 0.9881656951317194, 0.9920951177650601, 0.9865559618442356, 0.9894695202704844, 0.9873799531467402, 0.9819841852713187, 0.9891638537842817, 0.9434182932053206, 0.6195920836679272, 0.6660865656376154, 0.6134603191808394, 0.5199277328488519, 0.6859608227695184, 0.5700074569600114, 0.6013732040564925, 0.6207231421105301, 0.6038640712648062, 0.3075536659660716, 0.22497857295941814, 0.22450365998449184, 0.3490209670817743, 0.7051439222668392, 0.3636745864223663, 0.31896373065618466, 0.6519697968551963, 0.23079401190187432, 0.19652893708281327, 0.21619223203145588, 0.12744416252602497, 0.12676433220485173, 0.12989373320391895, 0.19187705371413766, 0.21136902194199614, 0.21260796606715404, 0.20007989698975248, 0.20477529981837184, 0.1270314147686913, 0.21127875338812863, 0.22642718570185694, 0.2089737361004419, 0.24326832453328007, 0.23960802956596894, 0.2073439327131693, 0.23755190317569863, 0.006606808047029178, 0.050584736134035246, 0.044026850787459826, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04384439634011705, 0.004216794604641638, 0.007068783209738694, 0.07702969416504024, 0.042478455483999866, 0.04422234173416151, 0.09152794903527484, 0.058644565355905565, 0.002916589463141994, 0.16444997460696797, 0.07385811000947762, 0.05386674505815958, 0.04605278126335366, 0.21263943795643014, 0.14378532651270903, 0.07112307870689105, 0.06545864782270383, 0.20497855290705025, 0.06233185146321152, 0.11912799725794154, 0.06369485469316227, 0.0574772410171126, 0.09096426870694962, 0.04152548925822208, 0.1562852539852041, 0.011920326989139363, 0.06357117336284734, 0.14823210079245586, 0.05665902613799245, 0.08004255053879628, 0.5052763620981036, 0.5372633561303888, 0.5155257205275114, 0.527994165882272, 0.5378149222926565, 0.5650984737985277, 0.5545105052106001, 0.522054718517756, 0.5434906097735998, 0.08175749059335335, 0.09370031466131279, 0.1323932203163628, 0.10833295731545245, 0.1504643548875736, 0.12662409350230297, 0.08392416524086199, 0.1281341785366612, 0.1257056193563132, 0.27278934159493295, 0.25347643472066916, 0.37196261906716555, 0.25379063740123886, 0.1951299216432707, 0.2189991839497597, 0.2600534126699461, 0.1533918520632529, 0.1969820516609928, 0.2547741572969239, 0.2570519742138857, 0.25043258378166655, 0.31700161743237054, 0.390028296343055, 0.3473702591909359, 0.46835033203156906, 0.45707317370405454, 0.20753317477524824, 0.19502606636966024, 0.17145427614431918, 0.19657770961518273, 0.24811630240256222, 0.2681639031556582, 0.3279803590374075, 0.13982266021343837, 0.2954214675578499, 0.18899810394673844, 0.24285867952452178, 0.22200724733264665, 0.21169603622537136, 0.24609088476381902, 0.20938541260208887, 0.2030429560526793, 0.20744843523515433, 0.20155931680757266, 0.2264399807850873, 0.24896899329142474, 0.6854956980537258, 0.18427608027408604, 0.19861973351289675, 0.24197558785508833, 0.22842324215483245, 0.2161838135493066, 0.24538421590920823, 0.21029505018193295, 0.8934872614054917, 0.1885590295026942, 0.1477032274860206, 0.8957310051953068, 0.20056749230174709, 0.20077365032867278, 0.16747122064191988, 0.1681240020752608, 0.1527553230523867, 0.08303994423605543, 0.21320275255907417, 0.6015853051440841, 0.21040217495630908, 0.1555950696923175, 0.7926813548493437, 0.10530684103372301, 0.16508709485257878, 0.6675993754090661, 0.19391557113034086, 0.1991639735334263, 0.180242364965293, 0.1822800016454461, 0.19824187341165866, 0.2053196476921808, 0.1852403246729174, 0.2007754644908769, 0.18789494757828118, 0.088561243078492, 0.08771164751501748, 0.10872841223848095, 0.12683116634367675, 0.10336017088513161, 0.10164839137153725, 0.0895113946336713, 0.08313013102586897, 0.10451913193611817]}, "mutation_prompt": null}
{"id": "bb10aebd-a0f5-4c8d-b95d-376970f169c1", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 2.0  # cognitive component (increased from 1.5)\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Focused Exploration and Increased Cognitive Influence for adaptive search dynamics.", "configspace": "", "generation": 20, "fitness": 0.29366401767018463, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "dff99aac-8880-4201-9b08-ae7d6eb722fe", "metadata": {"aucs": [0.7771576188598426, 0.7702760407414454, 0.7601141432927294, 0.757012848076102, 0.7480923651930673, 0.7636036723234434, 0.7395530645628849, 0.781393048523352, 0.7715337311794744, 0.595226564491029, 0.03628398933447696, 0.5946646553547669, 0.5759499607805664, 0.5830853454122418, 0.5801379903727057, 0.046861591474109954, 0.6041389839903788, 0.5803519074042249, 0.14021371518938974, 0.16118990624415896, 0.38639140003842554, 0.15055535543113097, 0.17267106734143434, 0.14606532643797632, 0.46588341016052603, 0.16520950161470682, 0.3961941798943437, 0.1183611511339675, 0.10861557694067725, 0.1412405350887782, 0.14815469053289632, 0.11944937908984887, 0.16330076563935014, 0.11765552005680224, 0.13348705457135968, 0.10930004951845296, 0.9891472161479723, 0.9884183750226727, 0.9914112337721335, 0.9885214585688322, 0.9894697626665654, 0.9477327896814597, 0.9863431049347742, 0.9891625366204099, 0.9843361085433331, 0.5383350960729764, 0.4946442649743906, 0.5557795664112744, 0.4361636037027683, 0.535775047128612, 0.5139108875647177, 0.5027997634407656, 0.4576380436690839, 0.5054734327458175, 0.2380846943688829, 0.20844542508180874, 0.2283625299602532, 0.3592355728175891, 0.265794702011389, 0.28363749894338863, 0.5407757148334302, 0.3311507240137965, 0.682875577041441, 0.38039552888846107, 0.19363783667637513, 0.18651786278003424, 0.17580719441087944, 0.2141829551083867, 0.1439832693218872, 0.17597402748769198, 0.18269779662320118, 0.18216605596432045, 0.19721722283719278, 0.1449146396505877, 0.1296131200680375, 0.16603198496708682, 0.1765294246225756, 0.1913209895129242, 0.12730965200653732, 0.17820000874344133, 0.21051393182030642, 9.999999999998899e-05, 0.08025672655609928, 0.08028126630811927, 9.999999999998899e-05, 0.08670081175304589, 9.999999999998899e-05, 0.026930722382777827, 9.999999999998899e-05, 0.010247754407771037, 0.08821747226850307, 0.06519102631433671, 0.17600566526940697, 0.10889804688039517, 0.009881921882063716, 0.01083857397324517, 0.12774017632414492, 0.11343474265614972, 0.0992111856386555, 0.029916980906470214, 0.08813835614413523, 0.13478339006943807, 0.059345237707756904, 0.0629549814622089, 0.060608674548179975, 0.059994571230422844, 0.14549426714191904, 0.06294749298956959, 0.09305019281104632, 0.11487515987721031, 0.07245263198044138, 0.19488825497245565, 0.021657563741419694, 0.14193446156261946, 0.08931004999250036, 0.055406814571452245, 0.07830149315667079, 0.5028594380278653, 0.541397611170814, 0.48307106888219065, 0.5176501187559541, 0.5337011896597342, 0.5145815757672993, 0.48105934987712773, 0.5071546723870914, 0.523280174833843, 0.09805842906225481, 0.11395916496281278, 0.11146483974421828, 0.1287326740711895, 0.10971328947355419, 0.09910965994897325, 0.11016316515881441, 0.1127217579925266, 0.12984474011707825, 0.22745067378157835, 0.21600998650998704, 0.183696549560192, 0.369574687339979, 0.3213574283794657, 0.15848351687861395, 0.25012784028479174, 0.17924132401389592, 0.19027095887802248, 0.2502177435266295, 0.35799900541119045, 0.34428874610539584, 0.3627436602701226, 0.3867184440665189, 0.2729529059480943, 0.40466809132437487, 0.4079271485065209, 0.4712383891434402, 0.29730536236318217, 0.16314999818319298, 0.25118684460691243, 0.22057160795575737, 0.32879041659918906, 0.2945391663631741, 0.3950324404579555, 0.25110950784673636, 0.21361700577156428, 0.22246179065517457, 0.22409341032901597, 0.2438132791493266, 0.20812298700577425, 0.21965467214241363, 0.20786439938716772, 0.24272561612946197, 0.27764122295704696, 0.23787880146434837, 0.23253363846897124, 0.4660766518312044, 0.21434260704437202, 0.23153640103028583, 0.6153252537673215, 0.20250564857674225, 0.22807198923314997, 0.24218172609088662, 0.2417079195990458, 0.8054489033046494, 0.1880480593180387, 0.15359131694535821, 0.8368719392987776, 0.1995087150181616, 0.72164200545433, 0.16738213279479042, 0.1682946059234971, 0.1519896251848799, 0.1279458280583451, 0.21299545465712777, 0.4886898982325363, 0.21205735190885167, 0.15555531630972796, 0.21297746283494612, 0.10530813231420943, 0.16649419018962086, 0.5895218435879122, 0.2022396353955851, 0.19948183698547528, 0.20556083183216056, 0.19230037640386122, 0.2055160964521533, 0.2226418278700385, 0.1975943126444204, 0.1951380220334229, 0.19429907338840957, 0.08943919586242333, 0.0974350377215567, 0.09593371802632578, 0.11168142692225902, 0.08742522447203771, 0.09175746337162127, 0.09859193940843525, 0.0896072008401465, 0.09302042496010055]}, "mutation_prompt": null}
{"id": "3bcf66ad-e25e-4d35-a7ed-72a0dd54ae2a", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                adaptive_probability = 0.2 + 0.6 * (self.global_best_score / (self.personal_best_scores[i] + 1e-9))\n                if np.random.rand() < adaptive_probability:  # Adaptive learning probability\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Adaptive Learning Probability to balance exploitation and exploration.", "configspace": "", "generation": 21, "fitness": 0.29015222093199033, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "dff99aac-8880-4201-9b08-ae7d6eb722fe", "metadata": {"aucs": [0.7662519145672692, 0.7566019862885258, 0.7529314466763884, 0.78445428167952, 0.7980577911939628, 0.7743542068205398, 0.786869593658918, 0.7976787382852891, 0.7985411797266232, 0.558538792745246, 0.5288117317984096, 0.5432683219582705, 0.6030798174265695, 0.04307582584581682, 0.5764866866215864, 0.6008535518848125, 0.5555510542340738, 0.563164522265498, 0.10786832616160669, 0.16542320704316027, 0.11025624050947136, 0.14256326591932122, 0.15998798442864426, 0.14533675543323676, 0.14508955899635745, 0.15082576710092943, 0.16385797114439138, 0.13726403240157925, 0.10478109795686996, 0.11488939943079546, 0.15299002838454523, 0.12255729298561857, 0.12798680661596917, 0.14664930393718645, 0.09007562978730044, 0.12649186403153168, 0.9897165897077614, 0.9849075001296115, 0.9900969751373192, 0.9597744335202535, 0.9680593502206918, 0.9825174087328187, 0.9333991973130153, 0.9828744543748128, 0.9788872789135226, 0.5908274690940651, 0.5166375141993513, 0.5970449245622109, 0.5778739765083947, 0.5646502407959932, 0.528792066432745, 0.5947829648609381, 0.5428418735778956, 0.5844916795477173, 0.22664188104689664, 0.22458158532744088, 0.6168842831101125, 0.27185833454732866, 0.11685907105229199, 0.20833897714420102, 0.2145643802334266, 0.2347902427076406, 0.23037942286386637, 0.187227121467608, 0.19087322498522918, 0.1962222443353837, 0.1831730731421789, 0.1253800814939806, 0.16076605939507116, 0.19703662217414464, 0.19213742477787832, 0.18029812923020605, 0.19899461544060637, 0.1145365625720256, 0.20150065329978584, 0.20911095857118844, 0.13264145811997818, 0.12969659048511017, 0.13575233414730703, 0.19876848133878477, 0.22919454554015406, 9.999999999998899e-05, 0.019181694722577025, 9.999999999998899e-05, 9.999999999998899e-05, 0.0499050953882324, 0.005730370814423402, 0.004156195237402294, 9.999999999998899e-05, 0.005938836697298555, 0.0971798342373903, 0.035176362214800805, 0.1100680664919026, 0.10016870014840684, 0.008995383717660621, 0.005769689299316649, 0.10334634580452928, 0.09602448380333972, 0.08713173747918734, 0.044071264332217974, 0.08524669239469607, 0.036403768903799594, 0.066727321769121, 0.06708934516222775, 0.07141243397469421, 0.06233641567199921, 0.06379452866185698, 0.06726004389268214, 0.11056007198556839, 0.06620487647631834, 0.3944904406202008, 0.24691403520297894, 0.14471636150939682, 0.17901132623272553, 0.09618688436661582, 0.06003944089756774, 0.08163303794350163, 0.5069043987371187, 0.46176400418044705, 0.5019593344437868, 0.489131638277409, 0.5068542369664886, 0.5114319823567788, 0.551685712800799, 0.5262375463432951, 0.5086371085232844, 0.11410276611891146, 0.11098507989462891, 0.07739360279169982, 0.10384833457459974, 0.08363899923114781, 0.12823773723488452, 0.38683134103384376, 0.13810354264207003, 0.1174280868793669, 0.31657220143077547, 0.3646074335501053, 0.2230290358641005, 0.23869351565582542, 0.3986543336829901, 0.35343756155685047, 0.22818159164740737, 0.17855232264239473, 0.19508909888638426, 0.3799595325757399, 0.3381427675332308, 0.4324721183662318, 0.3968222145991117, 0.34531634651295373, 0.319208209301471, 0.4086259924541934, 0.35994502869169254, 0.43377494455769583, 0.23807771066356676, 0.22514847764950108, 0.18551102700310063, 0.20962257220121105, 0.213157337440106, 0.3299182174347358, 0.18098310061956446, 0.2809078274283384, 0.10040594979617368, 0.2199127204110457, 0.2352949529096282, 0.21480210071780126, 0.21905181323105416, 0.24751561011578327, 0.23353271970595957, 0.21858112557011578, 0.21614573974180262, 0.24733580523437992, 0.19166735986290673, 0.23116757737686744, 0.2170821141633904, 0.2344549956804054, 0.19174781150049935, 0.2306506808622958, 0.20317138506289056, 0.19305058027478494, 0.21694607675005417, 0.8305630732003979, 0.8040984137248123, 0.15383545218666217, 0.8709423721243602, 0.1999951265929686, 0.20099227821951604, 0.1517772001749701, 0.1666832965332583, 0.17652386602364145, 0.7195065935218741, 0.20972469842003238, 0.4847834095646828, 0.21062652889702882, 0.2077051490021371, 0.20972423112991678, 0.10505287489772797, 0.09451494809034433, 0.5606757689559296, 0.1817710980029973, 0.2051918607882841, 0.19814834515937185, 0.18692094333798004, 0.19537838495903326, 0.19144557897843173, 0.1874912614893507, 0.18861302523741375, 0.17931555515794262, 0.10351129352387667, 0.11145837869386754, 0.09437976327592312, 0.1009860287766049, 0.09555191904996374, 0.10103369874946433, 0.09134687875214731, 0.09445090147452861, 0.09293511451537284]}, "mutation_prompt": null}
{"id": "eb9a0f4b-6f5d-4e4e-a5e2-77dc417290c5", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Improved Hybrid PSO with Dynamic Mutation and Local Search for enhanced exploration and convergence precision.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dff99aac-8880-4201-9b08-ae7d6eb722fe", "metadata": {"aucs": [0.8236189689909085, 0.8230025088660167, 0.8273976181788105, 0.869110632952363, 0.8027686324136352, 0.8472519945754532, 0.8173252633077646, 0.8088003064767355, 0.8292876427387792, 0.6671615095626375, 0.03869444757771945, 0.6654501578042804, 0.6502802680533988, 0.6574448240921507, 0.6434605770366368, 0.5983316015358335, 0.6600525136285289, 0.6540576852127362, 0.6146224436997803, 0.16294480241843867, 0.1328237926707616, 0.14106562486998808, 0.1585876418650174, 0.16473160728265468, 0.6042477525968186, 0.580604550057966, 0.17472344916417037, 0.11606595170632295, 0.16305738547092263, 0.11696118823660762, 0.139153328058775, 0.13840694783807028, 0.14340660343548128, 0.12092172980289073, 0.14426491158869814, 0.1176534936491136, 0.9891418515843697, 0.9884176934769946, 0.9914112337721335, 0.9885217764466042, 0.9894696652342735, 0.9500266417723754, 0.9863420950511119, 0.9891613840482351, 0.9843265272482351, 0.6027515007994408, 0.6610434018258458, 0.5914899376226502, 0.5608764888434805, 0.6514874611873225, 0.567007348211706, 0.5927448433205276, 0.6016382361611718, 0.6459725107000239, 0.695946277029863, 0.22169463396646116, 0.22842503943744719, 0.2540167696517891, 0.21215777505910394, 0.21475408031293042, 0.3488438428248877, 0.17813666578307652, 0.6395918525437557, 0.2055976237736432, 0.2137274901554208, 0.20150058373356283, 0.20467825539592643, 0.1821839173585802, 0.11797429056289765, 0.2018013897664347, 0.20733670025456385, 0.2159971912504668, 0.1292993802315756, 0.19603233934116293, 0.21149057077725397, 0.14474916090176826, 0.22202374416641957, 0.21164212926715287, 0.1321197454887033, 0.3086096692625868, 0.13170819408418533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003736892027048855, 9.999999999998899e-05, 0.004252534364621141, 9.999999999998899e-05, 0.00019255313996580092, 0.11885271526147356, 0.050316241714994825, 0.055478189904928366, 0.0863335855788846, 0.07246225179709054, 0.00015522310597892996, 0.21172665375921884, 0.17119568700154397, 0.0691991790623595, 0.3037295511218796, 0.08005292884433313, 0.166319458415368, 0.12807047603832167, 0.07063230563322997, 0.08679611656846298, 0.07171076867745596, 0.105605151968582, 0.06946841254778646, 0.042152944467933606, 0.06911835438170033, 0.15569939085561413, 0.18747556027068035, 0.02138240189251006, 0.03928586108749388, 0.23190769298592684, 0.05687276899017035, 0.08388773890209178, 0.5516784376722438, 0.4876106195557499, 0.501617290206291, 0.5622742576053437, 0.5249971401148261, 0.49241581847388494, 0.5164108524949547, 0.5160835801939314, 0.5281691283669785, 0.12144747466829808, 0.09813673788446398, 0.10295718942543952, 0.12176865499483358, 0.102172399830744, 0.1105229221415569, 0.07354523843019178, 0.12787114148785128, 0.10980629471746162, 0.25325457281406305, 0.2182007456846886, 0.23456189206679456, 0.21928069147965124, 0.33430244100218864, 0.2921937524204271, 0.3368054011283217, 0.18867776834673788, 0.29035176367082527, 0.23896474075259633, 0.23773744810759023, 0.4356938882040158, 0.3924062019365776, 0.3852120601524799, 0.32586552879564357, 0.2936546029023356, 0.24300834127572657, 0.3505101627628845, 0.25387472904347574, 0.20959417721827434, 0.15659209140799935, 0.3378606508029577, 0.3020478378045123, 0.3334630225717512, 0.20951532153734032, 0.22007093686506318, 0.22355076770358961, 0.17990160094645236, 0.2269572071950816, 0.2201875515501125, 0.22445973800210617, 0.1906022920270276, 0.2136152093569209, 0.2432328617882905, 0.22227622725674268, 0.23023058138162455, 0.233361254815886, 0.21988457930849403, 0.2870079601229577, 0.24743259711251897, 0.22743217013706485, 0.21919519324543357, 0.22561601415431176, 0.2411945142576457, 0.21707735406805462, 0.8539422423757331, 0.18838496139154082, 0.1540902892110071, 0.847663938914699, 0.20096547109317775, 0.2012570051557092, 0.168125552454078, 0.16796941029646073, 0.15417473462024467, 0.12782772480272997, 0.21312773790823336, 0.6596937511793967, 0.21208857403986026, 0.15564790227580338, 0.21205278297065788, 0.10545750088208772, 0.167576629064911, 0.7634949660346013, 0.21080546659742438, 0.20006388001587438, 0.1766170822898494, 0.19525091103157832, 0.18210750110522544, 0.21559705884709957, 0.21983645346052416, 0.18891926529973302, 0.19697731776510752, 0.10493103675578008, 0.08896434422500588, 0.08662225791683975, 0.10387437851119286, 0.0713392712156452, 0.10474203747345001, 0.0890795243588216, 0.09060219894260813, 0.08826504382611933]}, "mutation_prompt": null}
{"id": "84b5541e-5dfa-435a-8a1f-e487a3cbbfdf", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max = 0.2 * (self.ub - self.lb)  # max velocity\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM", "description": "Improved Hybrid PSO with Dynamic Mutation and Local Search for enhanced exploration and convergence precision.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dff99aac-8880-4201-9b08-ae7d6eb722fe", "metadata": {"aucs": [0.8236189689909085, 0.8230025088660167, 0.8273976181788105, 0.869110632952363, 0.8027686324136352, 0.8472519945754532, 0.8173252633077646, 0.8088003064767355, 0.8292876427387792, 0.6671615095626375, 0.03869444757771945, 0.6654501578042804, 0.6502802680533988, 0.6574448240921507, 0.6434605770366368, 0.5983316015358335, 0.6600525136285289, 0.6540576852127362, 0.6146224436997803, 0.16294480241843867, 0.1328237926707616, 0.14106562486998808, 0.1585876418650174, 0.16473160728265468, 0.6042477525968186, 0.580604550057966, 0.17472344916417037, 0.11606595170632295, 0.16305738547092263, 0.11696118823660762, 0.139153328058775, 0.13840694783807028, 0.14340660343548128, 0.12092172980289073, 0.14426491158869814, 0.1176534936491136, 0.9891418515843697, 0.9884176934769946, 0.9914112337721335, 0.9885217764466042, 0.9894696652342735, 0.9500266417723754, 0.9863420950511119, 0.9891613840482351, 0.9843265272482351, 0.6027515007994408, 0.6610434018258458, 0.5914899376226502, 0.5608764888434805, 0.6514874611873225, 0.567007348211706, 0.5927448433205276, 0.6016382361611718, 0.6459725107000239, 0.695946277029863, 0.22169463396646116, 0.22842503943744719, 0.2540167696517891, 0.21215777505910394, 0.21475408031293042, 0.3488438428248877, 0.17813666578307652, 0.6395918525437557, 0.2055976237736432, 0.2137274901554208, 0.20150058373356283, 0.20467825539592643, 0.1821839173585802, 0.11797429056289765, 0.2018013897664347, 0.20733670025456385, 0.2159971912504668, 0.1292993802315756, 0.19603233934116293, 0.21149057077725397, 0.14474916090176826, 0.22202374416641957, 0.21164212926715287, 0.1321197454887033, 0.3086096692625868, 0.13170819408418533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003736892027048855, 9.999999999998899e-05, 0.004252534364621141, 9.999999999998899e-05, 0.00019255313996580092, 0.11885271526147356, 0.050316241714994825, 0.055478189904928366, 0.0863335855788846, 0.07246225179709054, 0.00015522310597892996, 0.21172665375921884, 0.17119568700154397, 0.0691991790623595, 0.3037295511218796, 0.08005292884433313, 0.166319458415368, 0.12807047603832167, 0.07063230563322997, 0.08679611656846298, 0.07171076867745596, 0.105605151968582, 0.06946841254778646, 0.042152944467933606, 0.06911835438170033, 0.15569939085561413, 0.18747556027068035, 0.02138240189251006, 0.03928586108749388, 0.23190769298592684, 0.05687276899017035, 0.08388773890209178, 0.5516784376722438, 0.4876106195557499, 0.501617290206291, 0.5622742576053437, 0.5249971401148261, 0.49241581847388494, 0.5164108524949547, 0.5160835801939314, 0.5281691283669785, 0.12144747466829808, 0.09813673788446398, 0.10295718942543952, 0.12176865499483358, 0.102172399830744, 0.1105229221415569, 0.07354523843019178, 0.12787114148785128, 0.10980629471746162, 0.25325457281406305, 0.2182007456846886, 0.23456189206679456, 0.21928069147965124, 0.33430244100218864, 0.2921937524204271, 0.3368054011283217, 0.18867776834673788, 0.29035176367082527, 0.23896474075259633, 0.23773744810759023, 0.4356938882040158, 0.3924062019365776, 0.3852120601524799, 0.32586552879564357, 0.2936546029023356, 0.24300834127572657, 0.3505101627628845, 0.25387472904347574, 0.20959417721827434, 0.15659209140799935, 0.3378606508029577, 0.3020478378045123, 0.3334630225717512, 0.20951532153734032, 0.22007093686506318, 0.22355076770358961, 0.17990160094645236, 0.2269572071950816, 0.2201875515501125, 0.22445973800210617, 0.1906022920270276, 0.2136152093569209, 0.2432328617882905, 0.22227622725674268, 0.23023058138162455, 0.233361254815886, 0.21988457930849403, 0.2870079601229577, 0.24743259711251897, 0.22743217013706485, 0.21919519324543357, 0.22561601415431176, 0.2411945142576457, 0.21707735406805462, 0.8539422423757331, 0.18838496139154082, 0.1540902892110071, 0.847663938914699, 0.20096547109317775, 0.2012570051557092, 0.168125552454078, 0.16796941029646073, 0.15417473462024467, 0.12782772480272997, 0.21312773790823336, 0.6596937511793967, 0.21208857403986026, 0.15564790227580338, 0.21205278297065788, 0.10545750088208772, 0.167576629064911, 0.7634949660346013, 0.21080546659742438, 0.20006388001587438, 0.1766170822898494, 0.19525091103157832, 0.18210750110522544, 0.21559705884709957, 0.21983645346052416, 0.18891926529973302, 0.19697731776510752, 0.10493103675578008, 0.08896434422500588, 0.08662225791683975, 0.10387437851119286, 0.0713392712156452, 0.10474203747345001, 0.0890795243588216, 0.09060219894260813, 0.08826504382611933]}, "mutation_prompt": null}
{"id": "43c71461-86ed-407e-b247-405b3e322932", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Hybrid PSO_ADM with Adaptive Velocity Boundaries for enhanced exploration and convergence.", "configspace": "", "generation": 24, "fitness": 0.3079528984489802, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "dff99aac-8880-4201-9b08-ae7d6eb722fe", "metadata": {"aucs": [0.823207071414036, 0.821716821752364, 0.8248713742034423, 0.8309748064312388, 0.8335725544351338, 0.8330748059589208, 0.8069348197842918, 0.8079377790933957, 0.826044283630877, 0.6752923779058689, 0.03812323041069454, 0.6813087689349668, 0.6672604519136033, 0.638116873269897, 0.6158371018941899, 0.6073321936076166, 0.6899538069884705, 0.6439202006862966, 0.13789501880971633, 0.13681311690645015, 0.16711474660349956, 0.11351633598452593, 0.07433046718138614, 0.6362982485488764, 0.13737164139696612, 0.13115592811145038, 0.14649195932565562, 0.12958020372464418, 0.13614581939439996, 0.14049328479849077, 0.15106443730578267, 0.13484213154305547, 0.1160816840458021, 0.16533437312796817, 0.1478849108210174, 0.16559028802117448, 0.9891378255431723, 0.9883977933234528, 0.9913998604903255, 0.9885165931402168, 0.9894644594035412, 0.9499687500995295, 0.9863372823383861, 0.9891576066960835, 0.9843244620453987, 0.6715031541148622, 0.6758972868379024, 0.6428775856630471, 0.5701431786648932, 0.6905286244802564, 0.690194053544104, 0.6706984518893466, 0.6240611496660607, 0.6669605478254823, 0.23070025705079844, 0.22323307002566262, 0.22657650266518592, 0.3576220021316704, 0.21177060554819938, 0.21457646783940865, 0.3539875793610715, 0.7691816722171467, 0.7480334448255496, 0.19787258389420703, 0.2319855416926121, 0.19513028395289744, 0.20942919467696375, 0.18508997424162366, 0.11325904993798008, 0.21046825783829715, 0.21396986024650477, 0.2269159527064497, 0.2039521548257358, 0.17715874918601782, 0.2338189228154589, 0.1330068777068414, 0.23128976699704618, 0.2224561109303228, 0.22249961882794655, 0.30117725490764147, 0.22623403148693233, 0.03582428100535817, 0.02251344864069782, 0.0014420919480678807, 9.999999999998899e-05, 0.07784902904031754, 9.999999999998899e-05, 0.03681698404284539, 9.999999999998899e-05, 0.011328068422426396, 0.0586910883929993, 0.03794626187530015, 0.0675357115279438, 0.10715747717989421, 0.06983198348418973, 0.01315594064770298, 0.07815843773610232, 0.1611660225026431, 0.11369548978704314, 0.15325012652983205, 0.0843495617492317, 0.22801010147733503, 0.14832979522711687, 0.06700510183631392, 0.0851115269124666, 0.06385756429146516, 0.12499621843170039, 0.06250955148151938, 0.046692207390568674, 0.1260071467572852, 0.11000517493338591, 0.1380409159333229, 0.01130338841518419, 0.039152908749280124, 0.2253879147227067, 0.05557180740757761, 0.08162831360713951, 0.5242892156237576, 0.5290746249808245, 0.5656079300561827, 0.5514406777873475, 0.5160926707266701, 0.5010300972739243, 0.5153632060616983, 0.5588796267072047, 0.5250234428727532, 0.12053925971742518, 0.07796283249766855, 0.12051842888315589, 0.11591707925183004, 0.1425240529651981, 0.10020308658893395, 0.0872006258744632, 0.11367329788742486, 0.09555319467058165, 0.2633896606328241, 0.16626185415597772, 0.38969605409122765, 0.34620782683822615, 0.27848471638799543, 0.2614306414701405, 0.3452550967338176, 0.1548073348298038, 0.26954416902895884, 0.32476361600138814, 0.365845083651853, 0.41222416044801324, 0.37007422883002283, 0.4465512717012673, 0.39544197080828025, 0.4374498292128275, 0.3460003851465707, 0.40309947959242376, 0.30104698471472013, 0.16429459836968685, 0.14045257885656592, 0.21087474247062743, 0.3584878538715808, 0.3160389544246964, 0.1934780928669967, 0.3005934484349998, 0.2552285353051059, 0.24332475421829936, 0.22034195811146373, 0.2170651031632339, 0.21112190559819488, 0.21214509967881368, 0.22958504223904563, 0.2210163594537794, 0.2092464225296934, 0.21974728903170138, 0.24244361346824383, 0.21121376803865088, 0.2370840737173191, 0.2391578507735147, 0.23661375572376153, 0.22095818356601227, 0.21570375304418987, 0.24871227277069163, 0.20422757763596333, 0.8820202323222393, 0.18820733523482047, 0.1541367579567472, 0.8690504372004658, 0.20050610145742398, 0.20114275100781753, 0.16843583101866788, 0.16796237309366424, 0.1531813344596279, 0.12810529791360237, 0.213205774963662, 0.6736463670074004, 0.21000091609838145, 0.1560181698530747, 0.2105237136005832, 0.10545566744199764, 0.16903016614951916, 0.7887477286841157, 0.19386349319176543, 0.21586702293059135, 0.19939275384339128, 0.1960409194924615, 0.21348372953964645, 0.1865696494661334, 0.18704533800603007, 0.2073535830325306, 0.18781215977469734, 0.0930292559471676, 0.09803219691946852, 0.09904975926216708, 0.12166548427662205, 0.09276902244849838, 0.08402314240644049, 0.08693952144620176, 0.08820134037259741, 0.10061542073793261]}, "mutation_prompt": null}
{"id": "0715ca81-e629-45e5-b0f3-3aacda507b14", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Hybrid PSO_ADM with Adaptive Velocity Boundaries for enhanced exploration and convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "43c71461-86ed-407e-b247-405b3e322932", "metadata": {"aucs": [0.823207071414036, 0.821716821752364, 0.8248713742034423, 0.8309748064312388, 0.8335725544351338, 0.8330748059589208, 0.8069348197842918, 0.8079377790933957, 0.826044283630877, 0.6752923779058689, 0.03812323041069454, 0.6813087689349668, 0.6672604519136033, 0.638116873269897, 0.6158371018941899, 0.6073321936076166, 0.6899538069884705, 0.6439202006862966, 0.13789501880971633, 0.13681311690645015, 0.16711474660349956, 0.11351633598452593, 0.07433046718138614, 0.6362982485488764, 0.13737164139696612, 0.13115592811145038, 0.14649195932565562, 0.12958020372464418, 0.13614581939439996, 0.14049328479849077, 0.15106443730578267, 0.13484213154305547, 0.1160816840458021, 0.16533437312796817, 0.1478849108210174, 0.16559028802117448, 0.9891378255431723, 0.9883977933234528, 0.9913998604903255, 0.9885165931402168, 0.9894644594035412, 0.9499687500995295, 0.9863372823383861, 0.9891576066960835, 0.9843244620453987, 0.6715031541148622, 0.6758972868379024, 0.6428775856630471, 0.5701431786648932, 0.6905286244802564, 0.690194053544104, 0.6706984518893466, 0.6240611496660607, 0.6669605478254823, 0.23070025705079844, 0.22323307002566262, 0.22657650266518592, 0.3576220021316704, 0.21177060554819938, 0.21457646783940865, 0.3539875793610715, 0.7691816722171467, 0.7480334448255496, 0.19787258389420703, 0.2319855416926121, 0.19513028395289744, 0.20942919467696375, 0.18508997424162366, 0.11325904993798008, 0.21046825783829715, 0.21396986024650477, 0.2269159527064497, 0.2039521548257358, 0.17715874918601782, 0.2338189228154589, 0.1330068777068414, 0.23128976699704618, 0.2224561109303228, 0.22249961882794655, 0.30117725490764147, 0.22623403148693233, 0.03582428100535817, 0.02251344864069782, 0.0014420919480678807, 9.999999999998899e-05, 0.07784902904031754, 9.999999999998899e-05, 0.03681698404284539, 9.999999999998899e-05, 0.011328068422426396, 0.0586910883929993, 0.03794626187530015, 0.0675357115279438, 0.10715747717989421, 0.06983198348418973, 0.01315594064770298, 0.07815843773610232, 0.1611660225026431, 0.11369548978704314, 0.15325012652983205, 0.0843495617492317, 0.22801010147733503, 0.14832979522711687, 0.06700510183631392, 0.0851115269124666, 0.06385756429146516, 0.12499621843170039, 0.06250955148151938, 0.046692207390568674, 0.1260071467572852, 0.11000517493338591, 0.1380409159333229, 0.01130338841518419, 0.039152908749280124, 0.2253879147227067, 0.05557180740757761, 0.08162831360713951, 0.5242892156237576, 0.5290746249808245, 0.5656079300561827, 0.5514406777873475, 0.5160926707266701, 0.5010300972739243, 0.5153632060616983, 0.5588796267072047, 0.5250234428727532, 0.12053925971742518, 0.07796283249766855, 0.12051842888315589, 0.11591707925183004, 0.1425240529651981, 0.10020308658893395, 0.0872006258744632, 0.11367329788742486, 0.09555319467058165, 0.2633896606328241, 0.16626185415597772, 0.38969605409122765, 0.34620782683822615, 0.27848471638799543, 0.2614306414701405, 0.3452550967338176, 0.1548073348298038, 0.26954416902895884, 0.32476361600138814, 0.365845083651853, 0.41222416044801324, 0.37007422883002283, 0.4465512717012673, 0.39544197080828025, 0.4374498292128275, 0.3460003851465707, 0.40309947959242376, 0.30104698471472013, 0.16429459836968685, 0.14045257885656592, 0.21087474247062743, 0.3584878538715808, 0.3160389544246964, 0.1934780928669967, 0.3005934484349998, 0.2552285353051059, 0.24332475421829936, 0.22034195811146373, 0.2170651031632339, 0.21112190559819488, 0.21214509967881368, 0.22958504223904563, 0.2210163594537794, 0.2092464225296934, 0.21974728903170138, 0.24244361346824383, 0.21121376803865088, 0.2370840737173191, 0.2391578507735147, 0.23661375572376153, 0.22095818356601227, 0.21570375304418987, 0.24871227277069163, 0.20422757763596333, 0.8820202323222393, 0.18820733523482047, 0.1541367579567472, 0.8690504372004658, 0.20050610145742398, 0.20114275100781753, 0.16843583101866788, 0.16796237309366424, 0.1531813344596279, 0.12810529791360237, 0.213205774963662, 0.6736463670074004, 0.21000091609838145, 0.1560181698530747, 0.2105237136005832, 0.10545566744199764, 0.16903016614951916, 0.7887477286841157, 0.19386349319176543, 0.21586702293059135, 0.19939275384339128, 0.1960409194924615, 0.21348372953964645, 0.1865696494661334, 0.18704533800603007, 0.2073535830325306, 0.18781215977469734, 0.0930292559471676, 0.09803219691946852, 0.09904975926216708, 0.12166548427662205, 0.09276902244849838, 0.08402314240644049, 0.08693952144620176, 0.08820134037259741, 0.10061542073793261]}, "mutation_prompt": null}
{"id": "ebda751f-5204-45aa-9337-cd251a430528", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                # Added orthogonal exploration step for diversity boost\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced Hybrid PSO_ADM with Adaptive Velocity introduces a diversity boost using orthogonalization for improved global exploration.", "configspace": "", "generation": 26, "fitness": 0.31758045660798484, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "43c71461-86ed-407e-b247-405b3e322932", "metadata": {"aucs": [0.8168625399390765, 0.8195374139436268, 0.8292895180882969, 0.8095265162230999, 0.8440749888967282, 0.8468961228290273, 0.8050424631178935, 0.8273874689195342, 0.8197841907640062, 0.6346755862290463, 0.6711714321187134, 0.640314577665458, 0.5152675105767155, 0.6211690328114661, 0.6447793930626619, 0.6162939028959116, 0.052925539330130555, 0.6706827204139956, 0.6898023611273381, 0.10974394592159298, 0.7079518227153496, 0.1595782424786183, 0.533059660981851, 0.14824444721724395, 0.09371978470906528, 0.6820187520296035, 0.09789379235490037, 0.11356751150257427, 0.13410886107623177, 0.1079963525287776, 0.17304449463164218, 0.1542060173859292, 0.11279950172224418, 0.11441856728633992, 0.1203868098938663, 0.1240415658196733, 0.9861881409217763, 0.9866104310127167, 0.991457132486632, 0.9882341154866149, 0.9879885599281912, 0.9834263824171693, 0.9852303309573341, 0.98717335515184, 0.9832286237207276, 0.6508106516499155, 0.6468768986167324, 0.697280122396897, 0.6479001744897402, 0.5326907905677576, 0.7014101168414961, 0.5747480731007052, 0.641970663450701, 0.6060897463486947, 0.6026519231353513, 0.6309188977781794, 0.37707417161938417, 0.9018712403331633, 0.19014847203285046, 0.3738496945046579, 0.32718750077217584, 0.223512965650438, 0.22397716764925335, 0.19999154633835137, 0.25183019358296344, 0.21900686032201655, 0.12801988623038962, 0.2078609256990117, 0.18597420689428712, 0.20451454075420894, 0.20423549536246077, 0.182317160635041, 0.12809880365325188, 0.20087648908104094, 0.21652252080680523, 0.22413689139463056, 0.21846266526310187, 0.20229034402523172, 0.22759022169723397, 0.241971245569213, 0.23111913428901343, 0.037826865080246685, 0.013625594195197488, 9.999999999998899e-05, 9.999999999998899e-05, 0.08208392226373451, 0.015914803648346743, 0.002829456672250652, 9.999999999998899e-05, 9.999999999998899e-05, 0.07559182669221931, 0.08300684687559201, 0.1043439555870389, 0.10239067039085914, 0.005924803528990941, 0.0347450665114688, 0.09319335996360967, 0.12193138360966294, 0.046876584127691245, 0.07515307747340993, 0.2402365053336757, 0.12393628276376889, 0.066887323673818, 0.06924476926836887, 0.10207099988489732, 0.26830833820927014, 0.1777716549224595, 0.06765280147056241, 0.0412425117635421, 0.04555064355299032, 0.09975813888728557, 0.01216161943145111, 0.012214111354452495, 0.14065034406510368, 0.07947966476377477, 0.05473473413403085, 0.18372552541432186, 0.49659275160766714, 0.49082937082357836, 0.5169520409662192, 0.5749926296544878, 0.5774832807759698, 0.5952769692451707, 0.5170418538177697, 0.579296762242318, 0.5173313383805005, 0.09808627738822906, 0.16532059117061304, 0.06874016715790399, 0.14168139416758274, 0.09888261591873837, 0.11566800344280348, 0.180688542715708, 0.15376120192429987, 0.08837463905763776, 0.19904793131706844, 0.2795195614828474, 0.3145488064229294, 0.21605256541629603, 0.3181977119020224, 0.25524162912487924, 0.2801758311100001, 0.22171618185674546, 0.42026727413273623, 0.3738225302565906, 0.2372364728480112, 0.3303631738727849, 0.4764894931953454, 0.48060843127504227, 0.39548067038786017, 0.36585782568653114, 0.4071552041597071, 0.49910055114220087, 0.24876498812053793, 0.32920568100991743, 0.20036692670568823, 0.2315468059967194, 0.1940131138747836, 0.2924069803189969, 0.19683110778258361, 0.2887336737248023, 0.28707185994013285, 0.2342011648063318, 0.22902027872977793, 0.21073090989896026, 0.2267894314031188, 0.2203405462224597, 0.20817301367492413, 0.2471841509728554, 0.20217891899836027, 0.2294106266277377, 0.20593259646410378, 0.19614560228868894, 0.6863815495090451, 0.20116100641608892, 0.2516075324096697, 0.20160342461168124, 0.21024001701105022, 0.2207123914245661, 0.2054224157219936, 0.8791053482783924, 0.16886270942735426, 0.1527078083382779, 0.8666280796543079, 0.20099184763233457, 0.20124985728122335, 0.16345044620491933, 0.11502297242142945, 0.162025411021412, 0.08288753504763025, 0.20779762855354367, 0.7254950205768769, 0.211267622878635, 0.15551366226972363, 0.15571135420722748, 0.10524263378760823, 0.09442098391876885, 0.8289813501911361, 0.19805133773043648, 0.21001936844584534, 0.18885629803029547, 0.21133025035536002, 0.2266325566525611, 0.21056643957894605, 0.19688290043714662, 0.19497671677763073, 0.2153311988802673, 0.10691918669329514, 0.11203363966467461, 0.08042021293802393, 0.1116187289907501, 0.09045343805023454, 0.12953155959204377, 0.089314127051212, 0.09349390532724922, 0.10047243038390352]}, "mutation_prompt": null}
{"id": "c95524d6-87fc-4caa-94bb-ddef73512bf4", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                # Enhanced orthogonal exploration step for diversity boost\n                if self.evaluations < self.budget and np.random.rand() < 0.1:  # Adjusted frequency\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.15  # Adjusted step size\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refinement of Adaptive Velocity Control and Enhanced Orthogonal Exploration for Improved Convergence.", "configspace": "", "generation": 27, "fitness": 0.30126089107737497, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "ebda751f-5204-45aa-9337-cd251a430528", "metadata": {"aucs": [0.8184944070151069, 0.8229490070079233, 0.8373832011139235, 0.8066543250076984, 0.8123527577562641, 0.8151809494940734, 0.8130148202412861, 0.8001104630549702, 0.8270960379693374, 0.615201614701921, 0.650768627624889, 0.6553959361580133, 0.6508680658322781, 0.041874550203381156, 0.6258344424302764, 0.041785710723115654, 0.6377090745373409, 0.6173673015743235, 0.1520375392830814, 0.10800819649753268, 0.6102922200584975, 0.15573469758904612, 0.14219285564283524, 0.11627905691035134, 0.13749944737873643, 0.1655099403622997, 0.1547545192141222, 0.13270834771527174, 0.12169292184720726, 0.11792252222682842, 0.15868977883085789, 0.14841609243677323, 0.11790731452090253, 0.1279538555552011, 0.1487761668459423, 0.13695877644377474, 0.9843516895345756, 0.9856448090105304, 0.9920246024703452, 0.9898050443426852, 0.9865994311950756, 0.9863019689337614, 0.9849761356843864, 0.9841900512791776, 0.983638209963874, 0.6271228230277401, 0.6530217841063719, 0.6630278557465482, 0.6706113901829442, 0.5933253942812957, 0.6517351838830499, 0.618937447493062, 0.6252518984424867, 0.6267045948613877, 0.22926570961005932, 0.21288792164216408, 0.22591142007834664, 0.2748122347089317, 0.21411902335891952, 0.2773552832588314, 0.34707533070818786, 0.21339536136238801, 0.3658551739972178, 0.18957377543123188, 0.1947395236156072, 0.2125645323316564, 0.13317593360273372, 0.20425702306525595, 0.19392060998994354, 0.21484047424179076, 0.2585781116432039, 0.20056368544188075, 0.13190415683826973, 0.21806903406644773, 0.13229193198654698, 0.2194863250755107, 0.23475060517832136, 0.2199184943984469, 0.22672121519448973, 0.21565881340579995, 0.23503853823862464, 0.04260462036936219, 9.999999999998899e-05, 0.05490697920728671, 9.999999999998899e-05, 0.00708333212551282, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007630452572892077, 0.0658232683312977, 0.07144691650018409, 0.10302605504705187, 0.07905964040811508, 0.050535781989501816, 9.999999999998899e-05, 0.014401813190770607, 0.10520570198768842, 0.09222901412742324, 0.12813855395212614, 0.04326104825031052, 0.0649788516494133, 0.3182106140950913, 0.06757041197052549, 0.07102252884291249, 0.06863644617504161, 0.17357802417189339, 0.11789522304308775, 0.06131153712240689, 0.09168158876752763, 0.05171509448382117, 0.04495073562398588, 0.12341437763591456, 0.07455278736754667, 0.11992070581450587, 0.09239741729683937, 0.05493034326293322, 0.08091636612473563, 0.5096865410137065, 0.49776156209657785, 0.6308898036418978, 0.5213284897319328, 0.520307006171907, 0.5146832924312903, 0.5122097946872906, 0.5487129798738655, 0.5572265094413255, 0.09259280499476663, 0.12710022015805011, 0.101460471228761, 0.13634263956207937, 0.11152255987068782, 0.10456801101917335, 0.0957783066065847, 0.1416843981445549, 0.14058285706881402, 0.22657822114188764, 0.2128438312148111, 0.2984599778064415, 0.2966592513059344, 0.26454048660546947, 0.32321763421867844, 0.3872132568205088, 0.16996943098525408, 0.2044612431913817, 0.34328829642084513, 0.37461410725298794, 0.3710537446098149, 0.35057701478256864, 0.2589410332766984, 0.3359029987495824, 0.34817736768390406, 0.556921940493188, 0.36206160713221647, 0.23475244349958457, 0.21055583513843923, 0.29402241634588466, 0.25642595351811914, 0.24460580944178034, 0.23390867351531874, 0.19912649300430374, 0.28635294880318574, 0.2770662873042976, 0.20498390833399305, 0.24847169788642254, 0.21819270929433077, 0.1938509091374815, 0.19703215724220657, 0.21468706881571453, 0.2280063887181767, 0.22824420652023503, 0.2147741447086965, 0.692246906208108, 0.19503883486177898, 0.2163369901337805, 0.5899407177080935, 0.2044894165978881, 0.18939513341419056, 0.24065239379278214, 0.21749041601941976, 0.21122231850025042, 0.8627403408661024, 0.11382144221725343, 0.1545505436103506, 0.8898772298665613, 0.20030468424065162, 0.20158566331651828, 0.1535343190554891, 0.11502434731109812, 0.1664249037594998, 0.08286759408657562, 0.21084001379485218, 0.6513507815039157, 0.2087196587646749, 0.1693276146766457, 0.21045544600535582, 0.10529641462813799, 0.7027638383117109, 0.7364816527404248, 0.20123886508231414, 0.1880852033539433, 0.1968207452765781, 0.21049541408768824, 0.2134411024221029, 0.18061965841896, 0.19038778895902997, 0.22142609949468584, 0.19868007039845892, 0.09943683757185295, 0.0858788031037413, 0.09689007556036888, 0.1205101672537876, 0.09159257871620374, 0.07610769175443133, 0.09851737524315107, 0.09395511135825496, 0.0964646030941203]}, "mutation_prompt": null}
{"id": "505390ae-da39-42a0-b31e-bc06c3fb49ac", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget) * 0.8  # Enhanced adaptive max velocity\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.05, 0.05, self.dim)  # Enhanced local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced velocity adaptation and refined mutation strategy in Hybrid PSO_ADM to improve convergence rate.", "configspace": "", "generation": 28, "fitness": 0.31581935515748527, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "ebda751f-5204-45aa-9337-cd251a430528", "metadata": {"aucs": [0.8355585273943743, 0.8334394900232434, 0.8368991109763673, 0.8410722017466554, 0.8242912578893018, 0.8352364762686791, 0.8376554365296482, 0.8296150056220749, 0.8184485352121392, 0.620672160641161, 0.6920749113177838, 0.6273259996569314, 0.6422865068394834, 0.5584180151602742, 0.636553182997956, 0.6230013325978179, 0.6584031747154151, 0.6259595503466746, 0.1071207534772417, 0.14985271203446993, 0.5642040250692533, 0.16509712485422712, 0.12626784313302086, 0.12295652450378636, 0.10832052055467523, 0.5058732352051849, 0.15401790348683675, 0.08825155079413927, 0.12299189066088889, 0.10985273825532915, 0.11735829936841469, 0.11749066375684902, 0.09615328355822184, 0.16030054371229652, 0.49130337535567115, 0.11198701956971058, 0.986562425841764, 0.98509387899576, 0.9896249577899389, 0.9806267989768389, 0.9818624748123679, 0.9824354360571892, 0.9820411709193815, 0.9847465552519774, 0.9797897140737182, 0.68202145611832, 0.657454064512607, 0.6767684791505792, 0.663624420446213, 0.43927773164777495, 0.6416567443927707, 0.6231685359233294, 0.6323849393837646, 0.6626213541665968, 0.37551943443531055, 0.21980300919331852, 0.21745738693755112, 0.37512993751981716, 0.277878868299847, 0.19266734210372893, 0.23518956409375447, 0.21087801586820465, 0.31947482498659274, 0.21120836261593745, 0.206686201860954, 0.20521871980789652, 0.19886856298526467, 0.13405550843974867, 0.1949163220540593, 0.21056217391764487, 0.20661580976325034, 0.19510276192067477, 0.20758373908461136, 0.2152633962382947, 0.21533909728910972, 0.224649005559159, 0.20278244658883415, 0.23079107455857906, 0.13283464878133078, 0.2403201250350605, 0.23105542639373944, 9.999999999998899e-05, 0.009851887248445435, 0.003186569672700146, 9.999999999998899e-05, 0.006754475005263716, 0.020580274830040768, 0.02855582493080533, 0.003189748726888708, 0.008941830523181538, 0.06791140434792631, 0.04434295903404495, 0.0981566471587999, 0.04165754502430863, 0.019202809089267747, 0.078358983578518, 0.11758750895616699, 0.05808147224267468, 0.033259669866909314, 0.1249194474298736, 0.22357462318192123, 0.03389243628774308, 0.06835082589030894, 0.0717393270422324, 0.07202544204728623, 0.15051027347125057, 0.16348032323635286, 0.06618611190875145, 0.22541952380703256, 0.043476895284773165, 0.16632126141179193, 0.1487029229482929, 0.014451639988428355, 0.1466942590320709, 0.08058865159732254, 0.07394412865550926, 0.0821350347476848, 0.5099924939184799, 0.516406390904, 0.512370379328046, 0.547776448862608, 0.5091496493660672, 0.5342915699095891, 0.527922483232919, 0.5459664229476187, 0.538687813316588, 0.1220433764929959, 0.1710205088168234, 0.1349312336266355, 0.15426630628550442, 0.09337249586225571, 0.09982076241178728, 0.15625892820334975, 0.13633265162795216, 0.09975452845322397, 0.1903452689255002, 0.3822163238607338, 0.36167681245560146, 0.38235834888288767, 0.21795991692312544, 0.29281626948047723, 0.16642549340612, 0.21525151680757104, 0.26613979462647064, 0.28913345947128355, 0.3332474951015486, 0.30140968081869646, 0.447708680760208, 0.4071504181561397, 0.4105687956626969, 0.40317277053030987, 0.5259592464854473, 0.4619289200013682, 0.19395409909707906, 0.22842309824924178, 0.2125192035298601, 0.26893254285869084, 0.20358174616152958, 0.1274935677045168, 0.24172606964217647, 0.25785663321362473, 0.0973078484592006, 0.21170184855765561, 0.2707971952472258, 0.22086155493472948, 0.21654669464755483, 0.22103419439754202, 0.27001043215828, 0.21963994131726827, 0.24330629490084332, 0.22126433833014103, 0.23135391271940686, 0.2213423767591336, 0.20446680515281346, 0.24113702220206756, 0.6664731147296383, 0.2428519308534165, 0.21071094457688855, 0.19848781555562933, 0.22301165184554084, 0.8788484809479579, 0.9006992692449186, 0.15418165172945542, 0.8744476625515666, 0.20106610625673693, 0.20117006328548692, 0.16283876508401096, 0.1266850255224281, 0.16694691152481356, 0.6758745976947054, 0.20777053724704697, 0.6039587309990722, 0.21061694295314326, 0.15503783341463895, 0.21300923038295272, 0.10522894420115336, 0.6894556473600928, 0.7468203865017669, 0.19959752094583405, 0.2085759970479084, 0.1998436587049216, 0.18783965121138813, 0.2123063218426483, 0.2314534884346614, 0.20719515021973056, 0.22730154235954037, 0.2110169684688512, 0.09306375836576242, 0.1062278217643099, 0.09695227276928797, 0.1159130367173129, 0.10078426599510604, 0.10806454794674814, 0.09493849268287269, 0.08889174188116555, 0.10757462974855192]}, "mutation_prompt": null}
{"id": "ff179ac5-48f1-462e-ad16-917399529e18", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:  # Adjusted dynamic mutation rate\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Local search step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                # Added orthogonal exploration step for diversity boost\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced Hybrid PSO_ADM with Adaptive Velocity introduces a diversity boost using orthogonalization for improved global exploration.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ebda751f-5204-45aa-9337-cd251a430528", "metadata": {"aucs": [0.8168625399390765, 0.8195374139436268, 0.8292895180882969, 0.8095265162230999, 0.8440749888967282, 0.8468961228290273, 0.8050424631178935, 0.8273874689195342, 0.8197841907640062, 0.6346755862290463, 0.6711714321187134, 0.640314577665458, 0.5152675105767155, 0.6211690328114661, 0.6447793930626619, 0.6162939028959116, 0.052925539330130555, 0.6706827204139956, 0.6898023611273381, 0.10974394592159298, 0.7079518227153496, 0.1595782424786183, 0.533059660981851, 0.14824444721724395, 0.09371978470906528, 0.6820187520296035, 0.09789379235490037, 0.11356751150257427, 0.13410886107623177, 0.1079963525287776, 0.17304449463164218, 0.1542060173859292, 0.11279950172224418, 0.11441856728633992, 0.1203868098938663, 0.1240415658196733, 0.9861881409217763, 0.9866104310127167, 0.991457132486632, 0.9882341154866149, 0.9879885599281912, 0.9834263824171693, 0.9852303309573341, 0.98717335515184, 0.9832286237207276, 0.6508106516499155, 0.6468768986167324, 0.697280122396897, 0.6479001744897402, 0.5326907905677576, 0.7014101168414961, 0.5747480731007052, 0.641970663450701, 0.6060897463486947, 0.6026519231353513, 0.6309188977781794, 0.37707417161938417, 0.9018712403331633, 0.19014847203285046, 0.3738496945046579, 0.32718750077217584, 0.223512965650438, 0.22397716764925335, 0.19999154633835137, 0.25183019358296344, 0.21900686032201655, 0.12801988623038962, 0.2078609256990117, 0.18597420689428712, 0.20451454075420894, 0.20423549536246077, 0.182317160635041, 0.12809880365325188, 0.20087648908104094, 0.21652252080680523, 0.22413689139463056, 0.21846266526310187, 0.20229034402523172, 0.22759022169723397, 0.241971245569213, 0.23111913428901343, 0.037826865080246685, 0.013625594195197488, 9.999999999998899e-05, 9.999999999998899e-05, 0.08208392226373451, 0.015914803648346743, 0.002829456672250652, 9.999999999998899e-05, 9.999999999998899e-05, 0.07559182669221931, 0.08300684687559201, 0.1043439555870389, 0.10239067039085914, 0.005924803528990941, 0.0347450665114688, 0.09319335996360967, 0.12193138360966294, 0.046876584127691245, 0.07515307747340993, 0.2402365053336757, 0.12393628276376889, 0.066887323673818, 0.06924476926836887, 0.10207099988489732, 0.26830833820927014, 0.1777716549224595, 0.06765280147056241, 0.0412425117635421, 0.04555064355299032, 0.09975813888728557, 0.01216161943145111, 0.012214111354452495, 0.14065034406510368, 0.07947966476377477, 0.05473473413403085, 0.18372552541432186, 0.49659275160766714, 0.49082937082357836, 0.5169520409662192, 0.5749926296544878, 0.5774832807759698, 0.5952769692451707, 0.5170418538177697, 0.579296762242318, 0.5173313383805005, 0.09808627738822906, 0.16532059117061304, 0.06874016715790399, 0.14168139416758274, 0.09888261591873837, 0.11566800344280348, 0.180688542715708, 0.15376120192429987, 0.08837463905763776, 0.19904793131706844, 0.2795195614828474, 0.3145488064229294, 0.21605256541629603, 0.3181977119020224, 0.25524162912487924, 0.2801758311100001, 0.22171618185674546, 0.42026727413273623, 0.3738225302565906, 0.2372364728480112, 0.3303631738727849, 0.4764894931953454, 0.48060843127504227, 0.39548067038786017, 0.36585782568653114, 0.4071552041597071, 0.49910055114220087, 0.24876498812053793, 0.32920568100991743, 0.20036692670568823, 0.2315468059967194, 0.1940131138747836, 0.2924069803189969, 0.19683110778258361, 0.2887336737248023, 0.28707185994013285, 0.2342011648063318, 0.22902027872977793, 0.21073090989896026, 0.2267894314031188, 0.2203405462224597, 0.20817301367492413, 0.2471841509728554, 0.20217891899836027, 0.2294106266277377, 0.20593259646410378, 0.19614560228868894, 0.6863815495090451, 0.20116100641608892, 0.2516075324096697, 0.20160342461168124, 0.21024001701105022, 0.2207123914245661, 0.2054224157219936, 0.8791053482783924, 0.16886270942735426, 0.1527078083382779, 0.8666280796543079, 0.20099184763233457, 0.20124985728122335, 0.16345044620491933, 0.11502297242142945, 0.162025411021412, 0.08288753504763025, 0.20779762855354367, 0.7254950205768769, 0.211267622878635, 0.15551366226972363, 0.15571135420722748, 0.10524263378760823, 0.09442098391876885, 0.8289813501911361, 0.19805133773043648, 0.21001936844584534, 0.18885629803029547, 0.21133025035536002, 0.2266325566525611, 0.21056643957894605, 0.19688290043714662, 0.19497671677763073, 0.2153311988802673, 0.10691918669329514, 0.11203363966467461, 0.08042021293802393, 0.1116187289907501, 0.09045343805023454, 0.12953155959204377, 0.089314127051212, 0.09349390532724922, 0.10047243038390352]}, "mutation_prompt": null}
{"id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 30, "fitness": 0.32795585264286226, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "ebda751f-5204-45aa-9337-cd251a430528", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "6a8e0c3b-cfea-4543-aa8e-71d9a2841abf", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "98c9831d-88cd-4463-842a-9b70350a3f92", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_max = 2.0  # max cognitive component\n        self.c1_min = 1.0  # min cognitive component\n        self.c2_max = 2.0  # max social component\n        self.c2_min = 1.0  # min social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)\n\n            self.c1 = self.c1_max - (self.c1_max - self.c1_min) * (self.evaluations / self.budget)\n            self.c2 = self.c2_min + (self.c2_max - self.c2_min) * (self.evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced Hybrid PSO_ADM with Dynamic Component Adjustment by introducing time-dependent social and cognitive coefficients for improved exploration-exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.31756730002481215, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.863291665898182, 0.8560228697988993, 0.8771310009012165, 0.8553022629036526, 0.8723062615655736, 0.8758588715631234, 0.8504046868518509, 0.8706887166483948, 0.87137983663674, 0.7324888113530967, 0.6197577397778156, 0.7126796974047194, 0.7273274863266135, 0.7157016704908338, 0.7429076758682518, 0.7327072677619502, 0.7144160815054312, 0.730921999397401, 0.12481422274553955, 0.1411156720708947, 0.15245682380062298, 0.158076703971889, 0.15946742362015864, 0.1529815997509204, 0.12024825478930745, 0.1630432149112161, 0.18090414082680095, 0.15061186499688806, 0.1487543824783799, 0.17201259077402842, 0.14713120243905287, 0.15303485882080803, 0.15216590742639258, 0.1502709842677672, 0.11172906469016342, 0.15185783391127683, 0.9892790010833952, 0.9865762452716633, 0.9915411530674817, 0.987654947606994, 0.986289031108783, 0.9788634260229233, 0.985894490603015, 0.9864802156306585, 0.9523212903019354, 0.6780925776070712, 0.6602707251294555, 0.6718938371112255, 0.6696996985840471, 0.7178420213386865, 0.7431119509026651, 0.7209503272391588, 0.7168347505905956, 0.7378848647540557, 0.22949968276450072, 0.22115070227431255, 0.18041519864916755, 0.1923070676761166, 0.2776755158829305, 0.2142539289152463, 0.21996506296800267, 0.11689239096351323, 0.40924378301945674, 0.3221635859556585, 0.2073175292468189, 0.2074082205197244, 0.13368001244054561, 0.20380142351771524, 0.1978384995574155, 0.1322283433325514, 0.23526799557185252, 0.22520529537697087, 0.3525424831767039, 0.0996174741055389, 0.23059713971590912, 0.2528052325806287, 0.22193697425694514, 0.2125638257371274, 0.2364161419107893, 0.10104005045870212, 0.2364408619096653, 0.034814340360185825, 0.002101633431466521, 9.999999999998899e-05, 0.018452415226801855, 0.0631230582234833, 9.999999999998899e-05, 0.03905063680904264, 0.005238759726155173, 0.007087370580746599, 0.11338448793997336, 0.05061422844266139, 0.11119250326743846, 0.07638399415546904, 0.02389561277095087, 0.04226039812941129, 0.10054197677007048, 0.08043154456657087, 0.06349833517232328, 0.047302814509128654, 0.14568016017466234, 0.10857228859546053, 0.0744571032644783, 0.07313334515478587, 0.07723313699367007, 0.12419808521396314, 0.07477821314734878, 0.0719930040861122, 0.07911198232808492, 0.04342265142030355, 0.08252344431008529, 0.18621246385322587, 0.14552146127572674, 0.26269951219498944, 0.08250790258898999, 0.281017812266788, 0.08238010712708743, 0.4994720938729831, 0.546318660265469, 0.5207716209875357, 0.5082041902577894, 0.5569512000471122, 0.5482673712794914, 0.5206481540596537, 0.5920931062673734, 0.5799730172166058, 0.13826190200787802, 0.11194463821837342, 0.10300753499645965, 0.09806430521471188, 0.6093290793343333, 0.10907424761903695, 0.1072257986616576, 0.10069079807713899, 0.12337526645413222, 0.25276922525561973, 0.23425848502115143, 0.24288931842824746, 0.2608643729339667, 0.19092098993634665, 0.3138650200524806, 0.17660368394631565, 0.25442771962265365, 0.2259240032808717, 0.4257756643968734, 0.3645398728204764, 0.34965492807953225, 0.34810133512015595, 0.41573469910763716, 0.3671138832322546, 0.29383909933879293, 0.41062896374137914, 0.1737471864168849, 0.35537077564748665, 0.30603086319304973, 0.18473550864348298, 0.20862720156805548, 0.3793153954517131, 0.35559328980645966, 0.2247839243874541, 0.20419900695423643, 0.20418072660010045, 0.21824700057394697, 0.19303893743865908, 0.22727003526004497, 0.22424328026325313, 0.23191958792420275, 0.2064632870943488, 0.27877651599619735, 0.20984342473353013, 0.21091513007856166, 0.20570979854256588, 0.24534853199694573, 0.24066428944922735, 0.2474113078067065, 0.2055729927191553, 0.22754445119337452, 0.21131138541073347, 0.218823740902515, 0.19538542266201597, 0.8945611537344182, 0.9047589262483248, 0.1549160363462001, 0.9085868190391789, 0.20051210789743046, 0.20111912383657404, 0.15372652511014961, 0.12341021299899946, 0.16736915440081324, 0.15465352249607167, 0.21290137529594078, 0.6375871934569377, 0.210181468770413, 0.15612715839741353, 0.20735701319836175, 0.7685721995238848, 0.09476187339557052, 0.8644049439604475, 0.2022043414142407, 0.2082654827653051, 0.215432994474955, 0.20972450101043838, 0.2055622028737646, 0.20453541014979348, 0.17628891114905654, 0.1988828874580073, 0.18500211898363705, 0.09307050820718377, 0.08092628878658892, 0.09021672928572921, 0.13717377868478597, 0.08504718062568628, 0.09920062717478972, 0.08999821813036302, 0.08690932264374729, 0.09518813610501198]}, "mutation_prompt": null}
{"id": "086e0edd-48cb-410e-92e7-46a985bb0d40", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "0c3b47ce-a9fb-406f-8feb-ca2a7c70f23f", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            adaptive_factor = (self.global_best_score / (np.mean(self.personal_best_scores) + 1e-10))**0.5\n            self.mutation_rate = 0.1 + 0.4 * (1 - adaptive_factor)  # Modified mutation rate strategy\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introducing a dynamic adaptive mutation strategy that adjusts rates more effectively based on convergence speed for improved exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.31621633082455036, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8657433945393198, 0.8773163219110965, 0.8756435039356031, 0.8616662447779803, 0.8832952937848628, 0.8803787241300418, 0.8635534481243481, 0.8756205545420621, 0.8668324858199228, 0.719362758567619, 0.7315160112104313, 0.7141241201882114, 0.7354644134151367, 0.0422137117144713, 0.7492118837375501, 0.7156407637891955, 0.732082753757987, 0.7577148682460667, 0.11335744088164423, 0.15244734115619651, 0.1348885047006887, 0.15559391959042346, 0.14211506697054943, 0.11179819079275022, 0.15652740771474072, 0.13167800724232215, 0.13591540502143706, 0.15635773019286048, 0.13787711938467617, 0.1282273224942201, 0.10358154414527543, 0.15581410787768624, 0.10631365061141718, 0.11401231140792334, 0.1098563651589497, 0.13938019776575017, 0.9884158691699793, 0.9837377559686952, 0.9914282564899298, 0.9872713115442511, 0.9872809518653065, 0.9834246840428735, 0.9867929718238573, 0.9893335015389967, 0.9824543691038339, 0.760484275547034, 0.6080423559188195, 0.5932545109026395, 0.7460034375096609, 0.7098395922455274, 0.748005570508038, 0.7393220187630145, 0.7492054433310325, 0.7624053029929555, 0.23032931130430823, 0.221831675928715, 0.22729301464207352, 0.21355161169217385, 0.3383523184363951, 0.21296336787647974, 0.21754867766025932, 0.3879112548747853, 0.8559286961641942, 0.20977035548759615, 0.20551618913742664, 0.2009126761555058, 0.21012648507370846, 0.2112913250530294, 0.13235804354614977, 0.19162412605185586, 0.20710179397874895, 0.21261328584707928, 0.20907969030784113, 0.17309589491738175, 0.12891596428232444, 0.23492251550644472, 0.24718077318721188, 0.1311427125131024, 0.2277157546370252, 0.26093996588299606, 0.2379584140889629, 0.015605713496019247, 0.13394293265066715, 0.00989822493906034, 0.02712377739594818, 0.054395098848527446, 9.999999999998899e-05, 0.11456945058003398, 9.999999999998899e-05, 9.999999999998899e-05, 0.06030231869862801, 0.09087296797856415, 0.12342068820173513, 0.07281732196974422, 0.08121661602645402, 0.048188433075788684, 0.1118572456908834, 0.09582171944985207, 0.09021534231142925, 0.09332469212992545, 0.21452367115057747, 0.045649805100142604, 0.11158553670072957, 0.07419833981436674, 0.09166920233297482, 0.06548172124745866, 0.09274179939418503, 0.06729934944016513, 0.06234764450139463, 0.04497123193122621, 0.19817009340030534, 0.09298674158002274, 0.018858080275012123, 0.22361571173010186, 0.052403049636335686, 0.0576165246941267, 0.0882032847625851, 0.5767484236811641, 0.5274819328002112, 0.5208833543518885, 0.5482729312819715, 0.5436409258405779, 0.5551180640810224, 0.5720637573615948, 0.5419597235779046, 0.5390720134458371, 0.16677976267392058, 0.0628241815901952, 0.11420050490624922, 0.124489528216154, 0.10534590534883814, 0.10072972996317386, 0.153271139424643, 0.11739796531949398, 0.11347201584794242, 0.2561862433055627, 0.2963045383182411, 0.17625885562967214, 0.2889290122683471, 0.4053685596634026, 0.2593831591120608, 0.43600147674119494, 0.19442811951022987, 0.2729787494172107, 0.3951857983612157, 0.41438979571000356, 0.42292885323426443, 0.33745834582543643, 0.49894072911406984, 0.37379048650809277, 0.4000358202871044, 0.34580142607151054, 0.21916863745180803, 0.27513317525724335, 0.17418690387975277, 0.24342664538511116, 0.3949650071202715, 0.2727705647751203, 0.378039337466355, 0.3704330211436784, 0.24886813305763722, 0.29029468245048007, 0.22043518579217924, 0.24095244492244705, 0.2220581750454388, 0.22394971180638068, 0.22148272115422118, 0.2049522025442636, 0.2690064698995669, 0.2315564121286895, 0.199896079450265, 0.2074892892068373, 0.24667940174680414, 0.22145148611450838, 0.7259353174403187, 0.22676609037156992, 0.22165559159914006, 0.22044970451516588, 0.22359847872251615, 0.22346134641756998, 0.8836982286507634, 0.18719960315664663, 0.15453388534066292, 0.9115350517500187, 0.2009527394955437, 0.20079812361716887, 0.16776466851906446, 0.16718690715560913, 0.167873420610255, 0.08280175115506061, 0.21288293328899266, 0.5330006742831908, 0.21071456383208464, 0.21068817935495843, 0.1548614546528192, 0.10519001167919739, 0.16948953232053987, 0.8161950624971557, 0.20062665971511584, 0.2152577443641397, 0.19354539668978, 0.2342900729119337, 0.20348360504758856, 0.22141983506514584, 0.20532716372458382, 0.1954320720497773, 0.23060421138777076, 0.08507916175552999, 0.10762838731354574, 0.11181880610736972, 0.10596336002230744, 0.09787133198997167, 0.1471034786770139, 0.074123675199259, 0.08215763575654322, 0.08244872937343029]}, "mutation_prompt": null}
{"id": "465b0663-213f-4cae-bec0-6ee69ae8b743", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "85b905c8-29fe-468f-aae9-090c69778912", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "5634d2f5-9884-4556-87c9-730d97d8f506", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "c2a03f4c-2da5-4541-a9cc-a7609484fe5f", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    if self.evaluations < self.budget and np.random.rand() < 0.1:  # Increased local search frequency\n                        local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                        local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                        self.evaluations += 1\n\n                        if local_search_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = local_search_score\n                            self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Adaptive velocity refinement with multi-phase local search integration for enhanced exploration and exploitation.", "configspace": "", "generation": 38, "fitness": 0.3276080864571397, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8829789730333727, 0.8647660036883037, 0.8656978553294383, 0.8653015436679284, 0.8672194147297778, 0.8752946914817314, 0.8710925102996658, 0.8740989690834194, 0.8790910081575806, 0.7325292827491592, 0.7220262778918933, 0.7366999191489468, 0.7488059949968096, 0.7352586320125466, 0.7375646990236941, 0.05452648796253656, 0.766847115812888, 0.18433352933713976, 0.09058660792020479, 0.12132368004281979, 0.153038911886186, 0.15288037217375772, 0.11936065360095616, 0.1770247735942605, 0.13936566402931816, 0.17469638773201368, 0.17745739648836356, 0.12511146222052938, 0.11987055170383809, 0.11588852235260527, 0.13925399842628483, 0.1076042659372457, 0.11371591115404012, 0.15108427395818746, 0.12959082413821088, 0.11178533755609965, 0.9914764069902937, 0.9869570818824629, 0.9929937869579548, 0.9907960758459946, 0.9911198352665338, 0.9871396007020193, 0.9897655676055596, 0.9880179677751881, 0.9137271794504374, 0.7274289330424564, 0.7374810596115815, 0.7458024303018257, 0.7748253046861169, 0.6547079078712832, 0.7408395996345639, 0.7359384679934321, 0.7475493342217769, 0.7334759007863821, 0.8721966875734967, 0.20930814649318474, 0.3761664249162846, 0.2725089301179209, 0.1338701954578866, 0.1927428016104754, 0.23167157314533426, 0.4342264208319261, 0.38174664780903345, 0.22784578825360569, 0.21910257290087853, 0.22343385929232873, 0.10759482918582453, 0.2317335243125912, 0.12255489113253892, 0.22333720957824976, 0.21748745444903383, 0.2194403403675247, 0.13350672815467057, 0.3016914258782084, 0.4773951184738384, 0.2214070890780978, 0.13344665237823194, 0.13245284645684618, 0.12941331825352098, 0.3304013552807453, 0.25730288999924567, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11169102095849337, 9.999999999998899e-05, 0.01721796618058269, 9.999999999998899e-05, 9.999999999998899e-05, 0.1465635560902132, 0.08882366359538718, 0.07294836922432713, 0.1927898166876395, 0.07966263463555556, 0.0004287595990998261, 0.06819474296645622, 0.14524932152952297, 0.27050322922214165, 0.1083133377500981, 0.11297689048479165, 0.09865654951349367, 0.36989600119789934, 0.07814203557309174, 0.1085806804098367, 0.15304171026358704, 0.0691973997314912, 0.12335732327633142, 0.14021621115227523, 0.04241709365414559, 0.08771313009899695, 0.15068754855311794, 0.21240087328637758, 0.02250989630614897, 0.14460759754685004, 0.229997519120531, 0.05574078942435812, 0.08150018237975454, 0.5133783446369931, 0.5406906743660614, 0.5426332568351366, 0.5401285838168137, 0.5397601754482624, 0.5465388764560959, 0.5547140631057872, 0.5544479244560616, 0.5558036333255466, 0.08724454552857064, 0.11002452500924575, 0.13100317653673066, 0.14398479167689515, 0.14239862318619867, 0.15402887956323774, 0.14920675999222655, 0.15505938198167046, 0.1075912975331339, 0.22197904779595778, 0.22771242480015386, 0.17430402348007878, 0.2586148362776691, 0.33350686009427843, 0.24245160324234794, 0.3110211281865167, 0.3392774219979746, 0.4127551404706351, 0.33152522977207366, 0.3798335886064751, 0.396814577675104, 0.3544612165478511, 0.3705832973524389, 0.3500372689924438, 0.2502097172302088, 0.4187021727755572, 0.21850227232471486, 0.21346306810800308, 0.27073149320706924, 0.18813851201453713, 0.29760590288330646, 0.21334371846775835, 0.22783438886838914, 0.3758258763136473, 0.29410928429759264, 0.28396465806246907, 0.2513464976351478, 0.18811736517916033, 0.22778833244326802, 0.27571500591578046, 0.23800850616777847, 0.20274019586433045, 0.2363530261229263, 0.219047815545643, 0.2699475463630425, 0.7907294690011479, 0.25136328613932146, 0.24828725064324075, 0.7196746266577847, 0.20968053607638226, 0.2510336532059392, 0.20012020476087633, 0.7926638078655182, 0.2038137303734251, 0.9223437143853457, 0.8975022663851491, 0.15474019063050015, 0.9094112439993884, 0.15363291402752444, 0.20143568441467385, 0.1540729850927648, 0.12661721714654373, 0.1675948374854721, 0.08293605133596105, 0.2116663264905566, 0.8520968172776061, 0.21296261434994712, 0.16973370409459443, 0.21143507201828515, 0.10537144381100028, 0.16938748415914706, 0.7929908393439471, 0.19475091266090827, 0.19888430868067375, 0.21550397485631556, 0.19856857356197533, 0.215596175248418, 0.20537494146079038, 0.21383536347755383, 0.19947317036722612, 0.19794193609716082, 0.0974534935909902, 0.09856607310292798, 0.09757316050281606, 0.18392793620218384, 0.09301824392993441, 0.10181688112005782, 0.07033157402098444, 0.07975442242644548, 0.09024051198402216]}, "mutation_prompt": null}
{"id": "aec9603c-a21d-4f44-a2e2-7393298bd9e0", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            diversity = np.mean(np.std(self.positions, axis=0))  # Calculate diversity\n            self.mutation_rate = 0.1 + 0.4 * (1 - diversity / (self.ub - self.lb))  # Adjusted mutation rate\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced a diversity maintenance component by adjusting the mutation rate based on particle diversity to enhance exploration.", "configspace": "", "generation": 39, "fitness": 0.31418886559761355, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8328801271474964, 0.847285012042123, 0.8336524093481891, 0.8317897784284627, 0.845549313174252, 0.8343103535053682, 0.8399196502394758, 0.8429167141410236, 0.8240162510422796, 0.6441357201032194, 0.6636560648979994, 0.6249316415566188, 0.6737508301040512, 0.04320014362065017, 0.6605245075510532, 0.6810094310985214, 0.6883061689668691, 0.6704784114288032, 0.14820501998389335, 0.536997088479807, 0.1348289980537256, 0.15088802039731275, 0.13353395321128625, 0.5744692058988354, 0.14546215060273537, 0.17722415908194833, 0.14610690956091443, 0.14589257867601158, 0.10798539837405119, 0.1377168834364484, 0.15242989196827672, 0.1366066562424184, 0.14242981433765345, 0.14535409853455916, 0.1463165900598533, 0.14386388194578736, 0.9882593784906837, 0.9800450504537138, 0.9859708970263305, 0.987835348057407, 0.9826056564205666, 0.9769522357771946, 0.9365995857194425, 0.9833111610654942, 0.9784745440956427, 0.603319416592818, 0.6896402289817918, 0.6913607130157351, 0.6657130274275005, 0.6551581840865418, 0.6286251054003149, 0.6968964468682944, 0.6463782406311569, 0.7074641839305381, 0.22510562121908273, 0.22555492999676297, 0.7982003080192166, 0.6859377371245363, 0.19356703193918945, 0.8497822636662167, 0.221895594831912, 0.3618611899498132, 0.7943251290437943, 0.11039812093247925, 0.20373017627799306, 0.21439386350731793, 0.150853755853794, 0.21612567796585413, 0.1937186648492487, 0.1995393760585008, 0.19380191840768735, 0.20857627586485583, 0.214201807408407, 0.11751298795168164, 0.20436699175224016, 0.22310073976201106, 0.23020719772441645, 0.1256637526988339, 0.2552350921049745, 0.23132779957327, 0.2559203416428786, 0.012060599822326878, 9.999999999998899e-05, 0.005743330394778812, 0.003406070989498411, 0.000789769283408126, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013354619471301343, 0.13215553644908817, 0.047817852682536244, 0.10568182697794548, 0.06975646774219113, 0.001646927789842656, 0.03131449536606046, 0.15083953651655047, 0.13898643887981488, 0.0649160750778417, 0.24950875780115156, 0.1784339413195739, 0.1310363781785029, 0.0748360384041753, 0.06781289282669767, 0.17367347070867656, 0.08897573089814104, 0.10894254580852758, 0.0666159962401014, 0.084484303617682, 0.14366441409236008, 0.05110580808611864, 0.0409481778775731, 0.01337490349488002, 0.13437201861648318, 0.08995430643348701, 0.0647298873316462, 0.08103211506502028, 0.5443591647013253, 0.4856154891892467, 0.53469241563885, 0.503004500876558, 0.5087716319544078, 0.5384065407664216, 0.5334382147292291, 0.5041288421352907, 0.5395610507969949, 0.10888740220999027, 0.07948868186142377, 0.0868532264783044, 0.1489715841792033, 0.08354555981728096, 0.09231997924140178, 0.11062194909640044, 0.13645440020276023, 0.13898111347462816, 0.20819253956045236, 0.20206261521492308, 0.2771995290752137, 0.2792933643321186, 0.24375776472297517, 0.41420074408129137, 0.2160490170311311, 0.20531179704992797, 0.2851602363898935, 0.32914076521024904, 0.40725078785196944, 0.2922835393291856, 0.270238451713786, 0.42459741485225944, 0.3396925179013057, 0.33683644898585996, 0.3189925013153263, 0.39802234132090963, 0.2897515023391187, 0.2446818872922627, 0.22488838396119937, 0.312571466643345, 0.23516172409987757, 0.24717861457742685, 0.21045505744281123, 0.200051634865396, 0.206776167310478, 0.26675194272107716, 0.21214508654897468, 0.23552308445865056, 0.19880530815983677, 0.2990913109744828, 0.20365403548271432, 0.2411534388138673, 0.2393974737392618, 0.24788665331558923, 0.21763695450467457, 0.19029968604234027, 0.20529179965508126, 0.225753355580537, 0.22321290365574964, 0.21945217604207645, 0.24133970011408423, 0.2189644900718537, 0.2085575960625876, 0.1770722035979002, 0.08092408424635, 0.15362256890898351, 0.8241805824995332, 0.2004923925118003, 0.14821158558297742, 0.15333097562891507, 0.12592762936800594, 0.15904816529396337, 0.7010745588861936, 0.21029405833266346, 0.7203493937921602, 0.21303161679187155, 0.16824906084373392, 0.7391625777885062, 0.10499435049483896, 0.6817771416665828, 0.7053000327095515, 0.2020794705462975, 0.19943334165042892, 0.18816323668061097, 0.17276049613986688, 0.20090855465119772, 0.2252196707197871, 0.21580239287570446, 0.19332748742466288, 0.19985766243082304, 0.0833625895355331, 0.09524036665116198, 0.08902433983638547, 0.0927543117164712, 0.0909689703989528, 0.09649083226792265, 0.10098569150417791, 0.0798313402432852, 0.0782148654487912]}, "mutation_prompt": null}
{"id": "966b95d4-5342-4fb9-8f2a-f549c90200fc", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    # Gradient-based local search\n                    gradient_direction = np.random.randn(self.dim) * 0.01 \n                    local_search = self.positions[i] + gradient_direction\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced Hybrid PSO_ADM with Gradient-Based Local Search for improved exploitation phase and rapid convergence.", "configspace": "", "generation": 40, "fitness": 0.3120216770941455, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8689416214639815, 0.8684176978502999, 0.8679320083765532, 0.8720610073558593, 0.8590926392118616, 0.8637348644762695, 0.870261485002567, 0.872138567708953, 0.8541475668967963, 0.7252697071308232, 0.7041472127844992, 0.771396906148712, 0.7461728788808584, 0.04607111477687431, 0.7624894522301968, 0.7570747840927574, 0.7255823201701019, 0.7143018701703878, 0.15571322921891684, 0.1376929070868137, 0.14170326868851768, 0.1363362661324623, 0.10557486863224108, 0.16976945857162207, 0.17596519429366886, 0.1494231985004224, 0.09599607247255904, 0.1564263276778607, 0.09453772474359556, 0.13776441006948703, 0.1471525122764621, 0.11262617045060141, 0.15542246656606895, 0.1518469310420716, 0.11277182523965346, 0.17779744297871403, 0.9896724391144076, 0.9856655041656525, 0.9923300492026182, 0.9844046870131854, 0.9894723060874052, 0.9876357213825823, 0.982243070936139, 0.9860666426375371, 0.9791805876033643, 0.6239565038277048, 0.7464221108707504, 0.7452262307638647, 0.659512916196277, 0.6715871992520717, 0.7452608289674585, 0.7603584910292184, 0.7110018175101034, 0.7375455312899757, 0.21780661997287087, 0.22582772714143917, 0.2260092052639644, 0.2804205660477974, 0.15499483427177363, 0.19299171319567843, 0.22348931431500063, 0.2180796958111033, 0.23487403566756615, 0.21583102206469595, 0.2266989457926465, 0.20718953397639406, 0.21778663884411553, 0.27014710579428625, 0.20073615172387715, 0.2115884067269681, 0.1356177605694051, 0.22697309593547366, 0.2201060583928467, 0.1189793466785346, 0.22664766879647447, 0.2449896232637806, 0.24351568778402755, 0.2565500691976933, 0.25225462772645324, 0.09820877219847135, 0.24867474681972623, 0.008405652900547511, 9.999999999998899e-05, 0.003036828532320346, 0.008560315493634008, 9.999999999998899e-05, 0.01696205864653344, 0.05170016149885581, 9.999999999998899e-05, 0.00010090878319934937, 0.04919149047100124, 0.10108705959732667, 0.06355273776628745, 0.09446639391959688, 0.04192720238400838, 0.06341727109081763, 0.12896551240018417, 0.15303810620593672, 0.03978507830274158, 0.31533385808410186, 0.09936570838770764, 0.13200169446421717, 0.2877652140540653, 0.07349308320778836, 0.07885771267781749, 0.15993689463279515, 0.08370553700847727, 0.0692320050344375, 0.09443387981224893, 0.1117065712299613, 0.21654688459415106, 0.13606056174436776, 0.009176778870865432, 0.17755167058204702, 0.08168699348705011, 0.10674201039863851, 0.08204143999848035, 0.5393806790319493, 0.5564793896144116, 0.5313309135661906, 0.5336911299902918, 0.5271720226698524, 0.5463709049635816, 0.5667779649459186, 0.552353118101474, 0.5221654723894109, 0.08404142305045503, 0.0866127072288777, 0.08041972544037634, 0.12900336201163187, 0.11745364709202277, 0.11058592135207923, 0.12170876477763126, 0.10012982794382319, 0.1081202016163354, 0.24715959923855824, 0.26290441011542376, 0.2800703825837817, 0.16880674323316147, 0.22845078665857865, 0.22309587107090423, 0.2590561971893971, 0.208523657190116, 0.28815052668034935, 0.2609736298845935, 0.2478016837110083, 0.3577064498400875, 0.3536833064797874, 0.35308680340744025, 0.31009380598321745, 0.5087565145251746, 0.591611100673895, 0.17006545646443394, 0.2396899864587565, 0.22291147014341883, 0.188877204318745, 0.20122631034158278, 0.32772307993929994, 0.2597282062705685, 0.2993147036808109, 0.2097820280592665, 0.2593281148097195, 0.22503198177751782, 0.18814549306682926, 0.2169511510788501, 0.2520868977276004, 0.2333233860245364, 0.21684207409391942, 0.20245288377151005, 0.232374799115879, 0.2736436127201758, 0.2111117655952014, 0.20878320327904876, 0.24207266649767867, 0.2069808177282606, 0.22315874334844354, 0.22302691921692064, 0.2226108855629132, 0.20354307998923604, 0.5446645973990822, 0.9157699607848766, 0.18887174557711894, 0.15449063351854642, 0.8993497176143068, 0.20102372144936154, 0.2018799388395517, 0.15352470182378242, 0.1667225487243631, 0.15356085417962262, 0.08312217135464472, 0.210215199753792, 0.7042872522466195, 0.21131389335364792, 0.1690638696768798, 0.195761496193398, 0.74428389729732, 0.16950478473274433, 0.8407931843319719, 0.21022108374093873, 0.21303797202922337, 0.2458190690803913, 0.20408524916710924, 0.18848711049687294, 0.19489026170035162, 0.2643478734796003, 0.2056142286202437, 0.2180624985575711, 0.11067761199160886, 0.09801428405247259, 0.09722218679333106, 0.14114396600701962, 0.09653604434101148, 0.09175333303531441, 0.0969912767712644, 0.1056077052465948, 0.10302989558430331]}, "mutation_prompt": null}
{"id": "dcf14a5f-a371-465c-835e-0a98350d6613", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim) * (1 - self.evaluations / self.budget)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced Hybrid PSO_ADM with a refined local search strategy using adaptive mutation scaling for improved exploration.", "configspace": "", "generation": 41, "fitness": 0.3170645989293406, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8588225615382628, 0.8820508151075068, 0.8728805505450195, 0.8606565510797358, 0.8665448338176582, 0.8643886446820431, 0.8602818867571169, 0.8525733494689044, 0.8817189469983859, 0.7248082112848426, 0.7223281271630777, 0.7521024702424438, 0.7196621363291469, 0.711665088459112, 0.0452338874995748, 0.7080393802578973, 0.7251055085462568, 0.051757547572133134, 0.148586687328215, 0.13609385574508392, 0.24608228538043042, 0.1522989776635495, 0.14787162489634176, 0.16152619898269605, 0.1274497242084397, 0.1415745843188111, 0.1507641715477528, 0.15043430784603185, 0.15624358796649063, 0.15422972450481864, 0.13679329168171572, 0.14968535227486612, 0.15330208658254973, 0.12687059981098903, 0.15180190947093375, 0.10453709369051833, 0.9861826351708123, 0.9866030350549047, 0.9914541778451826, 0.9882263546705806, 0.9879863989526199, 0.9834246835676913, 0.9852246868770163, 0.9871722977663693, 0.9832245930413647, 0.5375869048183903, 0.794233020406578, 0.6730367344477479, 0.5754657665217366, 0.718283019662169, 0.7681016094294792, 0.661957838626885, 0.7157630904165373, 0.7384784110511664, 0.7882012823382958, 0.169542987055326, 0.3826963290631634, 0.37719734767246205, 0.20702783386268697, 0.27553481650897704, 0.38886602661860525, 0.16705125121934894, 0.394676578330846, 0.2150103619448428, 0.22877508039356131, 0.20637563580157436, 0.13305407093539434, 0.22957392069579763, 0.2047120895444695, 0.21085821945244188, 0.21192866763223406, 0.2518160882231909, 0.22973424552531374, 0.22511021228288863, 0.1300489384113689, 0.25928253967910564, 0.2576911216463834, 0.22748534047145186, 0.2543559345504901, 0.23441474299357745, 0.2427909300689527, 0.0039392596835843285, 0.005721643237956431, 9.999999999998899e-05, 9.999999999998899e-05, 0.10943824886318343, 0.01644724204611736, 0.005444749248760261, 0.0019175878847965677, 0.009289636482785357, 0.11661216169077193, 0.07615479976960682, 0.10365981051461293, 0.07855554246854224, 0.002369795592022772, 0.02725791041142933, 0.0984716406225491, 0.20387473400987477, 0.0542924791549132, 0.0765916373655613, 0.20332956117684542, 0.14588016530871994, 0.07308908122268198, 0.07656824483433577, 0.14584552953060959, 0.15499698524889227, 0.12634834218975344, 0.07031013253169227, 0.0480076124266241, 0.05190456524257514, 0.23058527344458957, 0.02784201031019895, 0.00882771641450486, 0.14066510181814318, 0.08118434107117478, 0.06081704790470033, 0.1665435701280097, 0.5241231313967447, 0.5286461284822092, 0.5083419929066808, 0.5458345045578799, 0.5479120992152908, 0.5225251158224735, 0.589846851230936, 0.5336467791180118, 0.5882168163519479, 0.09216115499496713, 0.1108353683839226, 0.08094483591521207, 0.12411281299168508, 0.7382956718616237, 0.15738073685501108, 0.11412240282009412, 0.1825903120376322, 0.1290260711027751, 0.21393487354293372, 0.3846018470091105, 0.2936676020713789, 0.43702199040530276, 0.500099761722782, 0.19749662340650853, 0.3277655067311629, 0.19691980685968602, 0.22489979372979763, 0.44187970607369365, 0.28218672978138604, 0.28401502428690173, 0.3932974238620963, 0.31154949904711315, 0.4546138161115496, 0.3953512629336703, 0.2113478774858687, 0.21739922937736467, 0.2021577244708853, 0.26637247758361604, 0.4159769093028204, 0.22897574534492227, 0.35599220445083024, 0.3208904949941769, 0.2030890601028742, 0.19972641304278693, 0.44115560015964006, 0.25647323609205464, 0.22657219745789303, 0.21249711210069422, 0.20433451500141575, 0.22512365604160822, 0.2370058570208453, 0.23900095531303855, 0.2059014595451396, 0.21078355258265224, 0.20170816772769495, 0.24734974784089658, 0.2518308950203163, 0.21997548114926735, 0.1937165325904986, 0.22033594603858042, 0.7576008292221073, 0.20608376823132002, 0.22262827042916256, 0.8945745802074765, 0.16885825625459205, 0.153001244455238, 0.8746271513149203, 0.2005691273165875, 0.20125957391307325, 0.1635700734344846, 0.11504157543901705, 0.1535396462960491, 0.08308675326132364, 0.21098124929702788, 0.8275933810880508, 0.21219697422229333, 0.15618499905496086, 0.15487962329820149, 0.10520411756275605, 0.09470139172449454, 0.7532357304370456, 0.20245908868645401, 0.2469896164242431, 0.2081798553805092, 0.2152682580473635, 0.1943604879601568, 0.1874995822531701, 0.20491255178051837, 0.22310106216294245, 0.1914975864473245, 0.10271164774459318, 0.11763135017895399, 0.09087623713388726, 0.13004943334808028, 0.08712445772756039, 0.1143758861561397, 0.09126492179778689, 0.08671509056716664, 0.08199226467153808]}, "mutation_prompt": null}
{"id": "62650e97-4d43-4765-b5ac-70ed1ae6443b", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "bedd6962-4db2-41f0-8065-0ae207a6f968", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        velocity_memory = np.zeros((self.num_particles, self.dim))\n        \n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                anticipated_velocity = 0.1 * velocity_memory[i]  # Incorporate previous velocity adjustment\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity + anticipated_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n                velocity_memory[i] = self.velocities[i]  # Update velocity memory\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced Hybrid PSO_ADM incorporates anticipated learning to improve convergence by leveraging previous step adjustments in velocity calculations.", "configspace": "", "generation": 43, "fitness": 0.3003729152821889, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.775880196529692, 0.8003206208430953, 0.8065708601531277, 0.7733531458601729, 0.7877829200509424, 0.8077833497954434, 0.7822105059196623, 0.7796119421220128, 0.7862332353522435, 0.5539224865205472, 0.6194191593598903, 0.6418982671728415, 0.5403399986454618, 0.040669432235833525, 0.647682800032437, 0.6068083744985755, 0.6115122079735688, 0.5901187358762876, 0.1339427264606009, 0.5161544773476598, 0.15410605997447657, 0.1654085698867922, 0.10725920793587351, 0.12944786258562668, 0.16364400589214778, 0.1378123490316464, 0.14263350696236798, 0.12833585727579755, 0.14007437849851756, 0.12940327005287888, 0.10605337663111547, 0.11859526033880663, 0.10194215095033154, 0.10117050638593006, 0.10300526082210704, 0.13235952717092425, 0.9862166264672837, 0.987929321584618, 0.992113205453647, 0.9881994869699251, 0.9883908739952575, 0.9868537919382341, 0.9849324795836842, 0.9881889525183916, 0.9834133644504693, 0.6268970212350782, 0.6102059546589059, 0.6638353881475665, 0.6210543892770124, 0.5780352446875257, 0.6216242636030037, 0.6171076641556046, 0.6393634341211629, 0.6335206498487951, 0.6663254461091934, 0.21661830857043696, 0.6397411413184582, 0.2639387387057014, 0.2091972489688554, 0.19216403739119314, 0.721637593451927, 0.225175799706954, 0.23409505483606619, 0.19368337143199998, 0.22165549017723474, 0.19244519995404175, 0.18594476566931895, 0.21725622113375465, 0.19232109633525374, 0.19063169951308023, 0.20315480111322826, 0.1838865885579345, 0.20272605277079714, 0.19735759671060127, 0.20643834205872935, 0.2318903875673044, 0.12762742107218528, 0.19406227015516375, 0.21822865778738254, 0.2396037376709026, 0.22400705332351012, 0.0608783332258116, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010084552965505811, 9.999999999998899e-05, 9.999999999998899e-05, 0.00033283352348356665, 9.999999999998899e-05, 0.06748884627873686, 0.10242202011951596, 0.09383986925769983, 0.09873368623601675, 0.09350063913845674, 0.045244060889575666, 0.05470916128487646, 0.20533910503969077, 0.11127393659759377, 0.04522587632219022, 0.04106989853581999, 0.0919809498883376, 0.06047844799949975, 0.06350747499964604, 0.06613587411942767, 0.17886682393874886, 0.08045109958126251, 0.059995075883245264, 0.061659922384725396, 0.04019085099303121, 0.057329674135331854, 0.17287373419618102, 0.0948801504576553, 0.012143375244196286, 0.13086755917269421, 0.07701358376746303, 0.050808051961442335, 0.10458206992505348, 0.49860982041333846, 0.5091607819260917, 0.5057425779747955, 0.5365285329726394, 0.5469915458295671, 0.4795408239013377, 0.506708057799508, 0.5306311235549681, 0.5228502943404839, 0.10067199488429324, 0.07828322158428869, 0.13629033683534908, 0.1387374040143592, 0.09734330836114191, 0.11699806093276655, 0.10741015369436557, 0.5741821150375294, 0.07629202280848058, 0.17057985088071836, 0.390979840318014, 0.22696429284890596, 0.30146021668083045, 0.35763190902661357, 0.2527585952363457, 0.16391384682175225, 0.21543217924069213, 0.25625496739384457, 0.30402636154959883, 0.28069666396343484, 0.24129227329355363, 0.2940409306331798, 0.39299906987618294, 0.31617674974072296, 0.40924469368448246, 0.45489580023311915, 0.4484019732510637, 0.3457225999466885, 0.2777306007843091, 0.17475917929059215, 0.26956191600929846, 0.2703041137536446, 0.2836997858129795, 0.20483223420049712, 0.2344493512387288, 0.19501975333692634, 0.21804718324952232, 0.21778649704316444, 0.20147184524927453, 0.23791288651620635, 0.20918146309148622, 0.22802308032473406, 0.20632834967584546, 0.17952061567414168, 0.23782011607291464, 0.2113685180324143, 0.20160195705281758, 0.20666146800909913, 0.19449097181500685, 0.23639393783941165, 0.177481068832396, 0.21382631529710483, 0.21670171886023548, 0.23825682632791811, 0.8574630392808252, 0.1686017411731442, 0.1503184363268001, 0.8040206327282042, 0.19924750971616045, 0.20025105693030343, 0.16118563636830696, 0.14372467619295315, 0.16359469453361164, 0.08255391060487094, 0.21023447633009895, 0.7824539457042192, 0.20801083155738653, 0.1553002515077696, 0.2093870882591884, 0.10527945297138974, 0.6595477601792583, 0.7282056912540438, 0.19087642028042806, 0.1944117611559305, 0.19264196050247806, 0.20743129438723484, 0.20200618772948586, 0.20638429077568643, 0.19835462667019998, 0.21580056029457695, 0.2040769650230826, 0.07737678236031442, 0.10478496301859797, 0.09655635193451584, 0.11750889505899009, 0.08340476389198193, 0.12995167848154576, 0.1014756128713663, 0.07475200608162791, 0.08611034541062801]}, "mutation_prompt": null}
{"id": "850e4199-b029-4897-b6c5-8925afd6d1ae", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "37668046-1e7d-46c8-8cc6-f8ba8fe6c4b0", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "f3f708d3-cd1f-4b68-b01e-d487a03aa2b6", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n        self.last_best_score = float('inf')  # Track last best score for mutation scaling\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n                    \n            improvement_rate = (self.last_best_score - self.global_best_score) / self.last_best_score\n            mutation_scale = max(0.1, improvement_rate)  # Adaptive mutation scaling\n            self.last_best_score = self.global_best_score\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + mutation_scale * np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced an adaptive mutation scaling based on fitness improvement rate to enhance exploration.", "configspace": "", "generation": 46, "fitness": 0.3151041202154463, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8582715231549458, 0.8676521643396201, 0.8797891014417376, 0.858175223155539, 0.8878801741398844, 0.8681011906182098, 0.856187605250283, 0.8711477381892351, 0.8669552067775115, 0.7010535842335204, 0.7261825585048906, 0.7535993021472277, 0.7161382839883754, 0.7080014314028028, 0.750514257812478, 0.7114774018801028, 0.7545732042290442, 0.7057911194496596, 0.6713291920192785, 0.17597956684471627, 0.18063759733090579, 0.14376645758147533, 0.1491882264302763, 0.14801170772019978, 0.0934446705418337, 0.17727822023387108, 0.09383256891172986, 0.12533565907737487, 0.14259943358193616, 0.1807469073179836, 0.0967455330288467, 0.13781113524966226, 0.10901523975836658, 0.10585731840727619, 0.10764848951905037, 0.1443727787023974, 0.9861813328554293, 0.9866309526318783, 0.9914543201526743, 0.9870313398261267, 0.988002250113675, 0.9841863644449907, 0.9852157068504405, 0.9867530085250557, 0.9813739136244859, 0.6390736807637862, 0.7644733457783889, 0.6823142341682961, 0.77000984991832, 0.5389048314951452, 0.6514726675686839, 0.725858529387244, 0.6040336561738554, 0.6843571163372358, 0.6301331700253026, 0.17115320267086098, 0.22515089727468907, 0.27794394477018247, 0.25956509816990436, 0.2117442170994882, 0.18031840980397706, 0.1161940729997456, 0.23661866926012332, 0.22042336098632742, 0.249131187000192, 0.2063551485957521, 0.13154117744009586, 0.2196945994781312, 0.20502494329305188, 0.2043073586064751, 0.2554175811485556, 0.2253546149256508, 0.23019185066987724, 0.15118678977945188, 0.2218164418089329, 0.2550511350984147, 0.28231112677904124, 0.22940256109855794, 0.24922928258002397, 0.09721250533504044, 0.23548444892567755, 0.038757268607041984, 0.12209602034387368, 0.09728216499258091, 0.000782924389883366, 0.08526289340369841, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2016703524221004, 0.07028494525827178, 0.06196243968325821, 0.0859456798065581, 0.08936780704932212, 0.03175919549858808, 0.021837005498772877, 0.15297783635588003, 0.08347750839397083, 0.039040559900651584, 0.046562506417005545, 0.14438409067540758, 0.22004102650877988, 0.07410216057926533, 0.07841100331811923, 0.07663504709605773, 0.16174081791814698, 0.1312887372861593, 0.07077570499019459, 0.04175773988512699, 0.17735330598953947, 0.13820997381320832, 0.13930436520869882, 0.014368666827420551, 0.12108337857106544, 0.09098614101556557, 0.09418605804892899, 0.1388931287155034, 0.5103525118039997, 0.5346475540686321, 0.5531989129344019, 0.5318260429310333, 0.5847498883975801, 0.5092819949798123, 0.5644190839967069, 0.5849445661698593, 0.5463389104830709, 0.09125485524328703, 0.06859232866584875, 0.07840723663819427, 0.1105652218928348, 0.10862719887555394, 0.1470749162923739, 0.09632977630091377, 0.08136872648147842, 0.1356668953243665, 0.25509049416906215, 0.3312157510335041, 0.21606328385105011, 0.34375555862450835, 0.30696689628389784, 0.3238844379173492, 0.18738999604354423, 0.21561231233055833, 0.21198701381153695, 0.3497728594834639, 0.30472858454348684, 0.3961043854032509, 0.3227091419928957, 0.32197922585300043, 0.2882994161559126, 0.24231563061223338, 0.4496453089983804, 0.17401632583414062, 0.28968508544552574, 0.26510375721127133, 0.2839356440429369, 0.2356157908846842, 0.34258863878293233, 0.2517467167475521, 0.17696635686989537, 0.24633851684978447, 0.2613533677528379, 0.22443525185517077, 0.20274511179935506, 0.1964713124437476, 0.1931177942963206, 0.21062219226552148, 0.19965557031120285, 0.26381942675841685, 0.23296911739480497, 0.22299283947547321, 0.21355267426815694, 0.19280002795368456, 0.24538217407704976, 0.2202953310805278, 0.8092799422690907, 0.18802516523298007, 0.2075961564937563, 0.6356111390216949, 0.2258849701244976, 0.855994776250968, 0.18819957028138157, 0.1520176905215852, 0.17324297300348135, 0.20058665374640883, 0.20127387363481852, 0.1624337873513001, 0.16737905645773976, 0.15317887961576215, 0.08314902461212859, 0.20844383406368228, 0.6558971581290919, 0.2127398460605484, 0.15637254453132787, 0.21219389465697736, 0.10534813353040606, 0.7558251178815045, 0.8022217652181307, 0.19457391411093827, 0.20596397129583743, 0.1810943503828737, 0.2034285435596127, 0.21435464424746775, 0.2005200466147824, 0.19933008753209147, 0.18837464802174086, 0.18504432482986855, 0.09707257220796583, 0.13171940849008135, 0.10116867070543667, 0.11372410191879812, 0.09483443689558246, 0.14441797660811806, 0.08889265247912914, 0.08635938841044877, 0.08407920886766151]}, "mutation_prompt": null}
{"id": "8af746a4-98b9-48c3-85b8-87145bf52d60", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "43c41910-dfb3-4d27-8ac7-bb35132ddee5", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            # Adapt learning factors dynamically\n            self.c1 = 2.0 - 1.0 * (self.evaluations / self.budget)\n            self.c2 = 1.0 + 1.0 * (self.evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced Hybrid PSO_ADM with Adaptive Velocity now incorporates gradual learning factor adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.31756730002481215, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.863291665898182, 0.8560228697988993, 0.8771310009012165, 0.8553022629036526, 0.8723062615655736, 0.8758588715631234, 0.8504046868518509, 0.8706887166483948, 0.87137983663674, 0.7324888113530967, 0.6197577397778156, 0.7126796974047194, 0.7273274863266135, 0.7157016704908338, 0.7429076758682518, 0.7327072677619502, 0.7144160815054312, 0.730921999397401, 0.12481422274553955, 0.1411156720708947, 0.15245682380062298, 0.158076703971889, 0.15946742362015864, 0.1529815997509204, 0.12024825478930745, 0.1630432149112161, 0.18090414082680095, 0.15061186499688806, 0.1487543824783799, 0.17201259077402842, 0.14713120243905287, 0.15303485882080803, 0.15216590742639258, 0.1502709842677672, 0.11172906469016342, 0.15185783391127683, 0.9892790010833952, 0.9865762452716633, 0.9915411530674817, 0.987654947606994, 0.986289031108783, 0.9788634260229233, 0.985894490603015, 0.9864802156306585, 0.9523212903019354, 0.6780925776070712, 0.6602707251294555, 0.6718938371112255, 0.6696996985840471, 0.7178420213386865, 0.7431119509026651, 0.7209503272391588, 0.7168347505905956, 0.7378848647540557, 0.22949968276450072, 0.22115070227431255, 0.18041519864916755, 0.1923070676761166, 0.2776755158829305, 0.2142539289152463, 0.21996506296800267, 0.11689239096351323, 0.40924378301945674, 0.3221635859556585, 0.2073175292468189, 0.2074082205197244, 0.13368001244054561, 0.20380142351771524, 0.1978384995574155, 0.1322283433325514, 0.23526799557185252, 0.22520529537697087, 0.3525424831767039, 0.0996174741055389, 0.23059713971590912, 0.2528052325806287, 0.22193697425694514, 0.2125638257371274, 0.2364161419107893, 0.10104005045870212, 0.2364408619096653, 0.034814340360185825, 0.002101633431466521, 9.999999999998899e-05, 0.018452415226801855, 0.0631230582234833, 9.999999999998899e-05, 0.03905063680904264, 0.005238759726155173, 0.007087370580746599, 0.11338448793997336, 0.05061422844266139, 0.11119250326743846, 0.07638399415546904, 0.02389561277095087, 0.04226039812941129, 0.10054197677007048, 0.08043154456657087, 0.06349833517232328, 0.047302814509128654, 0.14568016017466234, 0.10857228859546053, 0.0744571032644783, 0.07313334515478587, 0.07723313699367007, 0.12419808521396314, 0.07477821314734878, 0.0719930040861122, 0.07911198232808492, 0.04342265142030355, 0.08252344431008529, 0.18621246385322587, 0.14552146127572674, 0.26269951219498944, 0.08250790258898999, 0.281017812266788, 0.08238010712708743, 0.4994720938729831, 0.546318660265469, 0.5207716209875357, 0.5082041902577894, 0.5569512000471122, 0.5482673712794914, 0.5206481540596537, 0.5920931062673734, 0.5799730172166058, 0.13826190200787802, 0.11194463821837342, 0.10300753499645965, 0.09806430521471188, 0.6093290793343333, 0.10907424761903695, 0.1072257986616576, 0.10069079807713899, 0.12337526645413222, 0.25276922525561973, 0.23425848502115143, 0.24288931842824746, 0.2608643729339667, 0.19092098993634665, 0.3138650200524806, 0.17660368394631565, 0.25442771962265365, 0.2259240032808717, 0.4257756643968734, 0.3645398728204764, 0.34965492807953225, 0.34810133512015595, 0.41573469910763716, 0.3671138832322546, 0.29383909933879293, 0.41062896374137914, 0.1737471864168849, 0.35537077564748665, 0.30603086319304973, 0.18473550864348298, 0.20862720156805548, 0.3793153954517131, 0.35559328980645966, 0.2247839243874541, 0.20419900695423643, 0.20418072660010045, 0.21824700057394697, 0.19303893743865908, 0.22727003526004497, 0.22424328026325313, 0.23191958792420275, 0.2064632870943488, 0.27877651599619735, 0.20984342473353013, 0.21091513007856166, 0.20570979854256588, 0.24534853199694573, 0.24066428944922735, 0.2474113078067065, 0.2055729927191553, 0.22754445119337452, 0.21131138541073347, 0.218823740902515, 0.19538542266201597, 0.8945611537344182, 0.9047589262483248, 0.1549160363462001, 0.9085868190391789, 0.20051210789743046, 0.20111912383657404, 0.15372652511014961, 0.12341021299899946, 0.16736915440081324, 0.15465352249607167, 0.21290137529594078, 0.6375871934569377, 0.210181468770413, 0.15612715839741353, 0.20735701319836175, 0.7685721995238848, 0.09476187339557052, 0.8644049439604475, 0.2022043414142407, 0.2082654827653051, 0.215432994474955, 0.20972450101043838, 0.2055622028737646, 0.20453541014979348, 0.17628891114905654, 0.1988828874580073, 0.18500211898363705, 0.09307050820718377, 0.08092628878658892, 0.09021672928572921, 0.13717377868478597, 0.08504718062568628, 0.09920062717478972, 0.08999821813036302, 0.08690932264374729, 0.09518813610501198]}, "mutation_prompt": null}
{"id": "a945280a-c69c-4bd4-b348-be7548e16540", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined Hybrid PSO_ADM with Adaptive Velocity now includes dynamic inertia adjustment for enhanced convergence speed in the final optimization stages.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.8501905804813665, 0.8683737550367563, 0.8744875498843454, 0.8834629207921398, 0.8728645440418142, 0.87225819390631, 0.8671719643452289, 0.8581364688376161, 0.8764618476962789, 0.7408796909580302, 0.7588315851323341, 0.7313177982743723, 0.7174408988408533, 0.7089820518721699, 0.750246640052003, 0.6597634610280472, 0.7204823726508716, 0.638559115336016, 0.16879850683694653, 0.10602338609366124, 0.7627903352268958, 0.15078716795464464, 0.13459943183985867, 0.17733693733223643, 0.1113576618696539, 0.119492524809659, 0.17857708830720187, 0.15243726693494297, 0.15640948548677747, 0.11542088438109055, 0.15162584459258832, 0.14908917150323608, 0.15333958073688192, 0.11020220988100171, 0.15272513215911698, 0.11733411982914455, 0.9861826378129317, 0.9866030350921644, 0.9914541778451826, 0.9882263459616626, 0.9879863981187001, 0.9834246840428735, 0.9852246721515783, 0.9871722965694751, 0.9832245946167021, 0.7429878026222869, 0.5550058557884938, 0.5871376307096976, 0.7259940453848339, 0.7260671153194325, 0.7345296635324607, 0.733704586920474, 0.7038357112587916, 0.7350286469730867, 0.5883806928713566, 0.169542987055326, 0.8311640143802619, 0.8177190507919306, 0.20699878039987785, 0.2753899155501184, 0.5762311082790263, 0.18017476019249257, 0.5648452673326338, 0.21691387173178045, 0.21497494233073489, 0.20409123236225402, 0.133281113297402, 0.21175767879019147, 0.1981342370163437, 0.22254937450660417, 0.20409010304132014, 0.7159646661847014, 0.23056724587342592, 0.21720731230396473, 0.22450704608956007, 0.2523303828866048, 0.25299210974666064, 0.225954740278822, 0.24769500138769962, 0.22755452072611482, 0.24199506150093242, 0.015213938416708706, 0.0033726667069650107, 9.999999999998899e-05, 9.999999999998899e-05, 0.09434064115404017, 9.999999999998899e-05, 0.0062086699274715995, 0.0023073201495003026, 0.006690327263696005, 0.10887679991701626, 0.09972216108756571, 0.08760670278460858, 0.08614688561270833, 0.008607515320033787, 0.026055080449589152, 0.07986221299446039, 0.1879499773802098, 0.04580420095403659, 0.07481815476411025, 0.2361929293924292, 0.1540119166445938, 0.07300208987559509, 0.07558147931633807, 0.14942031070626272, 0.15576167410131625, 0.12070254084959542, 0.07092090963810538, 0.04283137682317806, 0.05198856876700231, 0.2014349669821015, 0.020875838328607954, 0.01284508318669264, 0.3167815552996761, 0.08103447597936664, 0.05949349641680024, 0.16431693692723315, 0.5182674156267035, 0.5432283210755746, 0.5618294433790011, 0.49385888212454687, 0.5516300244858588, 0.5667722271032747, 0.5360493745090837, 0.57605355049332, 0.5485049900821746, 0.09215893306678424, 0.11981226948706247, 0.08094397975422074, 0.13574067900521714, 0.13362392747189478, 0.15703121086726146, 0.11368634576296666, 0.18230063544800823, 0.12886510596347378, 0.21833516480031145, 0.3179675673101028, 0.2813419232138997, 0.30576550726004803, 0.34853693306313294, 0.21157967903565988, 0.2599649372989511, 0.21967583865529428, 0.22574905041141868, 0.3524508381472048, 0.26049860664783575, 0.2544790505374571, 0.5388412367712228, 0.4700366049227851, 0.44702822204568216, 0.2830513519260973, 0.2088811795266402, 0.20784004862683514, 0.20865471610155428, 0.2597964542654687, 0.28192219066198665, 0.23856158646613268, 0.2646866278531572, 0.425791363490035, 0.21118571902526762, 0.19475427885933805, 0.2614376347982179, 0.24149742364706994, 0.2525708313246313, 0.21061798194190529, 0.2294216137764592, 0.2468313482383485, 0.22707430179803045, 0.2820955772917315, 0.20624928392293773, 0.23933342556343518, 0.20892577000581702, 0.24743671556339686, 0.25188566503526333, 0.22004564089564183, 0.19812584130114896, 0.1976693902139235, 0.7688376585332338, 0.19841714003807465, 0.22257944817493658, 0.8895813038183661, 0.16885868247481717, 0.15300127518811535, 0.8708928027081488, 0.20057173860279043, 0.20126592181396008, 0.1635464964712786, 0.11504427991902644, 0.1535399381452588, 0.08308639747060365, 0.21098933845743084, 0.7724611925001883, 0.2123230495226871, 0.1562238982326437, 0.15478726033489854, 0.10522874413072392, 0.09470112699195254, 0.7718468442025008, 0.2005824323440315, 0.2544218096472528, 0.20320877696107464, 0.18355340655548413, 0.19855475314489335, 0.19938730109132385, 0.19379407172387864, 0.20986491184499378, 0.22339665217106686, 0.10178999056595184, 0.14090551359496117, 0.089943248100681, 0.11038490708190474, 0.09311064932661284, 0.12159793215881853, 0.10102235034815732, 0.08505128845769927, 0.08502250337124662]}, "mutation_prompt": null}
{"id": "87b57011-2a4d-45eb-878b-d531c5c81c42", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            adaptive_c1 = self.c1 + 0.5 * (self.evaluations / self.budget)  # Adaptive cognitive component\n            \n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = adaptive_c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced an adaptive personal-best weight factor to enhance exploration-exploitation balance incrementally throughout the optimization process.", "configspace": "", "generation": 50, "fitness": 0.31788544468925356, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.860635516682585, 0.8593223731786488, 0.8611941759785748, 0.8658328716181709, 0.8709234314432683, 0.872133938765433, 0.8592508941148765, 0.8558534620062231, 0.8734404324615521, 0.7160524361639519, 0.7386621505555926, 0.7332272292685861, 0.6973519385383051, 0.7139896771234887, 0.7402716794090463, 0.6895476354668919, 0.6690408705601785, 0.6272513424727655, 0.6380340386652699, 0.14021618397614077, 0.7326422414413392, 0.14786926613343931, 0.14127597363395472, 0.17628279192201113, 0.14674365494867603, 0.14786189842816988, 0.157085223298721, 0.12915908929835673, 0.14444647880377903, 0.13938413804453287, 0.13774916964861494, 0.12190121974825674, 0.150089503167658, 0.11112284996276245, 0.10578973062393926, 0.12749690986072204, 0.9861827628545904, 0.9866030351095523, 0.9914541779970136, 0.9882263362180281, 0.9879863978358574, 0.9834246846358978, 0.9852249514875926, 0.9871722891082105, 0.9832245824521298, 0.6986872507324347, 0.7283756527244754, 0.686654101292254, 0.6780143897973054, 0.7550252901233157, 0.7459007157946421, 0.7104892168064068, 0.7320903995030057, 0.6709108678034541, 0.6768030596847581, 0.22344577769313034, 0.31699068456522284, 0.27878990841810414, 0.21126715094958226, 0.25657024766782943, 0.23451484191618233, 0.1617860985766847, 0.23353831233953448, 0.21464645377923453, 0.22366448790264926, 0.1973551596387999, 0.1318982882662716, 0.2066971028216572, 0.20204942292639394, 0.2099072398386983, 0.2054340411019876, 0.2855022369089093, 0.2266557166886083, 0.13177045605787074, 0.13049588589853134, 0.24165887537831543, 0.2401564939536246, 0.2263402143756632, 0.24453129814832364, 0.24936766477873906, 0.250727114127824, 0.051130714548817235, 0.05440805542020766, 9.999999999998899e-05, 9.999999999998899e-05, 0.0672832087896591, 0.0032425822652605296, 9.999999999998899e-05, 9.999999999998899e-05, 0.06258666916827482, 0.09123874619172745, 0.08152072813344635, 0.08222571135160961, 0.07947051107760816, 0.020909457038919887, 0.017564610699545624, 0.11235594953749029, 0.12206610428668119, 0.03889602948252813, 0.08228582135003804, 0.21121758922903433, 0.14046112725362436, 0.07355081200244662, 0.07352944237088455, 0.1393382584466939, 0.1788792295166577, 0.19909746049928667, 0.06992316979623026, 0.047449801290965876, 0.062016616277125514, 0.15655328173437355, 0.015583372599618617, 0.015820025774224478, 0.16448168602157653, 0.08237784922954128, 0.05615206267304562, 0.2137284603190336, 0.570344371333946, 0.5733814106395558, 0.5270188313552795, 0.582580682097706, 0.5558624259948133, 0.5750401198603263, 0.5503085292555472, 0.5506139411839357, 0.56158068802174, 0.09258144357694886, 0.13588574594182667, 0.07001301503463309, 0.1377652225263457, 0.12330704464263054, 0.15193318064444028, 0.12835260615876265, 0.14408886107662078, 0.1468361236765544, 0.21931299944738625, 0.2617412146566218, 0.20611389599599983, 0.2301342565390353, 0.3677118581199974, 0.19920057929290447, 0.24272255027119827, 0.21654480141656784, 0.35138789290844363, 0.40547579785182064, 0.2372956811799729, 0.3574896485859763, 0.3081965920457155, 0.4353431000385798, 0.38192400429557416, 0.34290626186424866, 0.2125497010537114, 0.21264571755493145, 0.22184768671227284, 0.2979258685587499, 0.24471056193773466, 0.2497283634007983, 0.244726473259802, 0.25745506466585644, 0.20144905215928977, 0.21839612921524199, 0.28541462586308464, 0.2325874841509561, 0.23205707595674108, 0.23131873766908762, 0.23790216698104338, 0.2214832140930032, 0.19789110455201697, 0.21485138374472357, 0.20084876872292456, 0.2150911477117119, 0.20099058998849773, 0.20666557432056065, 0.25425028648786263, 0.2132447519145496, 0.23132141810812779, 0.19652512083681828, 0.7200589824372416, 0.2004388733652661, 0.2422148674010396, 0.8770788369606035, 0.16884746666759542, 0.15284304985649522, 0.8424037092059498, 0.20129909180581806, 0.20131812125909687, 0.16359941476237816, 0.11503094363788136, 0.16093471753713529, 0.08309740732196902, 0.21220091742948233, 0.833239633911859, 0.21228652154632388, 0.15534126114256774, 0.15596793999228797, 0.10528716728030485, 0.09467657234550475, 0.7883808385159727, 0.20623163643773323, 0.1949948041917322, 0.19036410231091272, 0.18209241911482332, 0.21190376610939943, 0.1879599989337607, 0.20182049156301152, 0.26278729355608843, 0.20390747800436304, 0.10696685458367139, 0.16149154002068822, 0.0885140119811938, 0.12589527635345454, 0.0956895636446694, 0.13961208401047365, 0.09273837909524396, 0.08633858319991417, 0.09743908976314253]}, "mutation_prompt": null}
{"id": "7acef844-ffe0-4d4c-9ca7-d984c2df94be", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced adaptive mutation strategy with diversity preservation to improve exploration and exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.33248459759158205, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "dba235eb-6ed7-4c1e-b18e-e72f1d07d5f6", "metadata": {"aucs": [0.877859191826563, 0.8571949117751944, 0.8627207020540385, 0.8775800695287668, 0.8627520523437784, 0.8537877386747789, 0.8723745653013819, 0.860133586482589, 0.8514529022900915, 0.7224902619329048, 0.7388402802785542, 0.7334762738930101, 0.7383479628864302, 0.6815610675760888, 0.7245855336580191, 0.7290156140544203, 0.7325423216344972, 0.7341674553237181, 0.14910458819805683, 0.12224851020301408, 0.17902095051492417, 0.7080098248795741, 0.15067560225164434, 0.1388069413172338, 0.40616402828056664, 0.13552495493415573, 0.14322925081178295, 0.12133507828427414, 0.1084221894517775, 0.12860293324184002, 0.11534807703877958, 0.12417416032979434, 0.11845024090507628, 0.13440112128353776, 0.12142819560315488, 0.12904149328475467, 0.9895193142751418, 0.9867099890000182, 0.9917254829632046, 0.986941600794503, 0.9866046973802836, 0.9839989017213426, 0.9832374306840196, 0.9828298190959421, 0.9548833625828179, 0.7013090204445895, 0.7674160684060898, 0.7204326521095048, 0.7185460118263312, 0.7236860786513774, 0.7374523569456446, 0.7429786202897549, 0.6939044401043126, 0.7175762268783147, 0.8557667982246894, 0.16665921878531553, 0.22618739139791477, 0.41419737444313365, 0.21183136364041588, 0.37577365845756383, 0.18128168977091375, 0.23533576409443435, 0.6836951899927941, 0.18752171702183873, 0.20941994463791758, 0.21250223309356553, 0.20990651342371325, 0.2187276958515164, 0.22365303932216518, 0.22602394230602418, 0.21861911749939522, 0.22141374943987946, 0.2340244638886868, 0.20889913280110883, 0.2981420421273615, 0.30562824734390914, 0.2302524865358676, 0.2262081242771733, 0.2390787658135307, 0.13749602184028187, 0.24403636121402494, 0.0401382292720609, 0.00401859335250887, 0.03635878150993577, 0.05647653049842849, 9.999999999998899e-05, 9.999999999998899e-05, 0.05074107391061333, 9.999999999998899e-05, 9.999999999998899e-05, 0.05781038139801098, 0.03659185578023738, 0.07376333862457707, 0.1105395812805362, 9.999999999998899e-05, 0.07092681423599279, 0.19306384753385142, 0.150395606748841, 0.06753525103620617, 0.047987054575864385, 0.24040038027817534, 0.26446452697749623, 0.0761325945045741, 0.07418430077033578, 0.10227117381002737, 0.07074737531538844, 0.1679052664099412, 0.07196218596259696, 0.053039012321372314, 0.6449173096083284, 0.21177900232436775, 0.03808749469816852, 0.014687084704314124, 0.21370193850349584, 0.08167511243635783, 0.13194893520136397, 0.08179800693583106, 0.5257635583948542, 0.5373814493312954, 0.512905280434322, 0.542194442910668, 0.5513953290828502, 0.5637508940277086, 0.5540686948136424, 0.5513257357527492, 0.5501620157442475, 0.102581183197891, 0.10319252949865843, 0.16676437043253955, 0.1412652802931591, 0.10798942120204447, 0.13585993955873288, 0.1272361855042634, 0.13737484431404368, 0.1371017396089126, 0.2583708402909075, 0.20067656749582174, 0.3339315623310557, 0.2973548957840215, 0.2755805858593531, 0.21626723754148602, 0.21562795405106994, 0.271973995494166, 0.40973611902970575, 0.4653815414825071, 0.49677747324129706, 0.40312880574061605, 0.3982996561241169, 0.30118427715735585, 0.37295110531515163, 0.23153427630588685, 0.32130330511410543, 0.23931790350048787, 0.2543687318100679, 0.3496093893118949, 0.1753348320737037, 0.3104096730625955, 0.3347796500939674, 0.2915803934273199, 0.244254276783213, 0.3108880703926177, 0.24625841438363505, 0.24622339653861336, 0.2495452510484657, 0.21981735339485942, 0.2604518247083447, 0.2450749226096277, 0.21426299565001128, 0.2524305659086744, 0.1989847579719447, 0.20904946164878546, 0.19874736065372012, 0.24127186782989463, 0.20921897671588807, 0.22565613029461074, 0.23652242987255812, 0.2452801524144842, 0.2216709949865201, 0.2225552032578333, 0.2021910601424849, 0.8927490362859856, 0.8911779889834746, 0.15450729431114574, 0.8951462279973851, 0.20193570445242348, 0.20157337281851473, 0.15291935465106432, 0.16853337284901504, 0.16789233455336194, 0.7289656225795822, 0.2123082616383415, 0.5992447050074057, 0.21073558506828338, 0.15510024957773472, 0.21081993664181187, 0.10559242549996017, 0.16967936026049135, 0.7515083117432388, 0.20069565429532743, 0.21050674977579864, 0.19498811081804168, 0.20422917553540343, 0.2006440279558075, 0.24067942608162607, 0.23063576452682433, 0.20715037470528008, 0.20339472170096973, 0.08544185834966778, 0.11775063865502466, 0.08958590118590204, 0.08669481150355418, 0.10372401349080085, 0.09311458831988062, 0.09026244135960881, 0.054522350710861645, 0.10466079869720413]}, "mutation_prompt": null}
{"id": "802b524a-6091-419d-bb2a-987370295d3c", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                distance_to_global_best = np.linalg.norm(self.positions[i] - self.global_best_position)\n                perturbation = np.tanh(distance_to_global_best) * np.random.randn(self.dim) * 0.1\n                self.velocities[i] += perturbation\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced perturbation of velocities based on the current distance to the global best to enhance exploration.", "configspace": "", "generation": 52, "fitness": 0.3027120419121092, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "7acef844-ffe0-4d4c-9ca7-d984c2df94be", "metadata": {"aucs": [0.8437948528915019, 0.8331602054148562, 0.8281276269445634, 0.8168389713063191, 0.8387052721108591, 0.8273456972054505, 0.8351847404059535, 0.8249064494924239, 0.8375950865005168, 0.057663386630034785, 0.008181282805986512, 0.11556356966071579, 0.07509796725716056, 0.039916710110242226, 0.07651900575653581, 0.029626002053396938, 0.024050180328228143, 0.045939986678156464, 0.09554095224547332, 0.14570286166200475, 0.13178365851749219, 0.06525012572788269, 0.11330046708073838, 0.11678801331139477, 0.13484192630972902, 0.16136526073200252, 0.09393992790775008, 0.11920201363214733, 0.10820614071414836, 0.11762530253613424, 0.13755847492122797, 0.116463250443124, 0.1375545811672959, 0.12799396635492888, 0.11327159329530334, 0.10410452012952742, 0.9890289321535548, 0.9860541840561196, 0.9895194579823952, 0.9913217761407384, 0.9896726863075911, 0.9826642795755619, 0.9867244717263146, 0.9895581701241812, 0.975966611909878, 0.7216164455950012, 0.715434568684632, 0.7047919754476026, 0.7164642064520382, 0.6763794838590962, 0.7165230495169235, 0.6938994545787041, 0.6886181706716008, 0.6859480549025141, 0.8081628643445047, 0.2281659424666006, 0.21431383959030859, 0.21212957962631573, 0.21318674180445574, 0.7807678694532271, 0.9110850588314167, 0.5216546985662827, 0.401473183679544, 0.17282950218938753, 0.20491886294017014, 0.19528179536557067, 0.20438847878124156, 0.20677431316062167, 0.12139590205995754, 0.2051169149465576, 0.20624707034270295, 0.19940086873735663, 0.19960933731315977, 0.13130784740259238, 0.21075384118817309, 0.18222139144104943, 0.13262688263718614, 0.20606991427668309, 0.13045484981800126, 0.04284950776170593, 0.2227953094803793, 9.999999999998899e-05, 0.02831901983710272, 0.011971473892065432, 0.14406667886212077, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007495640649607727, 0.08540653106053564, 0.08428205437608649, 0.04783750753490856, 0.052486630279058644, 0.0050197599641371715, 0.04728342159743515, 0.20410369345069845, 0.15200414506098314, 0.058434510907159676, 0.11268458407498927, 0.15493335381299678, 0.1385784326304289, 0.2005231465948053, 0.07182863256505312, 0.14542723583048411, 0.21319779280742746, 0.12099197797755201, 0.06505205082537724, 0.09480835815031585, 0.14873965298264902, 0.21543350348619794, 0.05500860660795237, 0.04463301611380943, 0.11340445970707203, 0.10815426889014124, 0.05638002332016767, 0.08190284845299378, 0.49878833198023775, 0.49412640145158937, 0.5209980672449842, 0.5403948289555374, 0.5559156302707313, 0.5737836334840998, 0.5406430881753181, 0.5313443004440925, 0.5224068194987894, 0.12502844902862797, 0.12775229948477518, 0.07195392054102645, 0.1501612525110686, 0.11371442908367857, 0.10649829013544787, 0.13498146008540024, 0.09440340333146446, 0.13460515611957524, 0.36055956136081513, 0.32817355354523947, 0.24037610770299445, 0.29565572244508964, 0.31753579978209523, 0.19714634861508995, 0.22128119346398423, 0.18644721971231948, 0.27503086833252977, 0.30615220028842716, 0.41958096753251395, 0.48518546603832535, 0.41852504329100315, 0.4424055018110684, 0.35305903540020767, 0.4473659414107779, 0.5305539597487503, 0.24501975002045107, 0.2985430438386828, 0.21381190429733576, 0.26808221606153826, 0.2591328654364883, 0.24221550737063668, 0.24961989283161223, 0.18581963529088474, 0.26491083912573254, 0.22187048876328674, 0.19621868828913047, 0.22174373774493839, 0.23906671238908683, 0.21262383779554173, 0.27136457281535775, 0.22561229627004842, 0.24229093251277067, 0.24468525942318708, 0.22853793498275377, 0.6752031460192751, 0.22344239477996897, 0.20273812760136212, 0.19787101690332343, 0.19827690155602806, 0.2381393535151496, 0.19646831418098787, 0.7251150708312419, 0.21456250214727401, 0.8665552693617462, 0.8947615418060235, 0.1543822879880019, 0.8707450787159589, 0.2017200285111409, 0.2021649819396215, 0.16692913146186839, 0.1684649558402017, 0.16760343757397644, 0.7963346523725885, 0.21292736126556655, 0.8147103513445739, 0.21135925596820127, 0.16862265622125416, 0.21188216697394524, 0.6718466005640966, 0.1692870693211418, 0.704590805386804, 0.2628159664153884, 0.19610111711624245, 0.1997579539145179, 0.21008953372602968, 0.21253987433636612, 0.1862672950519514, 0.20589500871574207, 0.21346024509228512, 0.2102997195323908, 0.09015020594794765, 0.07912084127084651, 0.13848273425151147, 0.1215872542313553, 0.09898425571077951, 0.10293554304721853, 0.10378152630391191, 0.10434376343588014, 0.09300799676364202]}, "mutation_prompt": null}
{"id": "af12a333-ead9-4cd4-afd5-8bf0f046c9cb", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                if self.evaluations > self.budget * 0.8:  # Velocity dampening\n                    self.velocities[i] *= 0.8\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced velocity dampening for convergence enhancement in late-stage optimization.", "configspace": "", "generation": 53, "fitness": 0.3324148401001882, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "7acef844-ffe0-4d4c-9ca7-d984c2df94be", "metadata": {"aucs": [0.877859191826563, 0.8571949117751944, 0.8627207020540385, 0.8775800695287668, 0.8627520523437784, 0.8537877386747789, 0.8723745653013819, 0.860133586482589, 0.8514529022900915, 0.7224902619329048, 0.7388402802785542, 0.7334762738930101, 0.7383479628864302, 0.6815610675760888, 0.7245855336580191, 0.7290156140544203, 0.7325423216344972, 0.7341674553237181, 0.14910458819805683, 0.12224851020301408, 0.17902095051492417, 0.7080098248795741, 0.15067560225164434, 0.1388069413172338, 0.40616402828056664, 0.13552495493415573, 0.14322925081178295, 0.12133507828427414, 0.1084221894517775, 0.12860293324184002, 0.11534807703877958, 0.12417416032979434, 0.11845024090507628, 0.13440112128353776, 0.12142819560315488, 0.12904149328475467, 0.9895193142751418, 0.9867099890000182, 0.9917254829632046, 0.986941600794503, 0.9866046973802836, 0.9839989017213426, 0.9832374306840196, 0.9828298190959421, 0.9548833625828179, 0.7013090204445895, 0.7674160684060898, 0.7204326521095048, 0.7185460118263312, 0.7236860786513774, 0.7374523569456446, 0.7429786202897549, 0.6939044401043126, 0.7175762268783147, 0.8557667982246894, 0.16665921878531553, 0.22618739139791477, 0.41419737444313365, 0.21183136364041588, 0.37577365845756383, 0.18128168977091375, 0.23533576409443435, 0.6836951899927941, 0.18732761389005936, 0.20899834166970443, 0.21240492245135878, 0.20946279296344406, 0.21762669491841147, 0.22297602979412157, 0.2260226124900837, 0.2183265852120323, 0.22108846533931503, 0.23355203518852308, 0.20868857666798324, 0.29813188725331985, 0.30529739467095873, 0.230177511863907, 0.22514542523248005, 0.2392684822720138, 0.13749602184028187, 0.24321211443438595, 0.04013390576457898, 0.0040169963852053625, 0.03597996445712781, 0.05645540533965554, 9.999999999998899e-05, 9.999999999998899e-05, 0.05070872076014088, 9.999999999998899e-05, 9.999999999998899e-05, 0.05770708280499748, 0.0365941491428885, 0.07367838955664496, 0.11035607537197045, 9.999999999998899e-05, 0.07078531545956812, 0.19296288149024576, 0.150395606748841, 0.06541976366267666, 0.047987054575864385, 0.24039990350546203, 0.2644636420235811, 0.0761325945045741, 0.07418430077033578, 0.10227123270530936, 0.07074737531538844, 0.1679051967530244, 0.0719618759316436, 0.053039012321372314, 0.6449173096083284, 0.21177900232436775, 0.03808749469816852, 0.01474194335161172, 0.21370193850349584, 0.08167511243635783, 0.13194893520136397, 0.08179800693583106, 0.5254507529407031, 0.5372878903363523, 0.5128618967014813, 0.54187678672517, 0.5510591737736192, 0.5637615800864704, 0.553791217121711, 0.5511472633913792, 0.549629454182326, 0.102581183197891, 0.10319252949865843, 0.16676437043253955, 0.1412652802931591, 0.10798942120204447, 0.13585993955873288, 0.1272361855042634, 0.13737484431404368, 0.1371017396089126, 0.258370785959146, 0.20067630923134083, 0.3339315621056963, 0.29776510743657825, 0.2727021020717535, 0.2162672175875463, 0.21562795405106994, 0.2719737506665204, 0.40973611902872986, 0.46538154201936666, 0.49677747324129706, 0.40312881656199306, 0.39829965679577106, 0.30118427715735585, 0.37295110537662846, 0.23153427621658285, 0.3213033061751991, 0.23931790350048787, 0.2543687318100679, 0.349609389260798, 0.17533483215105805, 0.3104096667122618, 0.33478016746721295, 0.29158039372334543, 0.244254276783213, 0.3108880706579986, 0.2462587207967647, 0.24622157872705286, 0.24871907757838885, 0.22249535256132946, 0.26045067691243806, 0.24511487705321933, 0.21426371070787986, 0.2524267797924731, 0.1988123659105393, 0.20911649650146835, 0.19874736065372012, 0.24127186782989463, 0.20921897671588807, 0.22565613029461074, 0.23652242987255812, 0.2452801524144842, 0.2216709949865201, 0.2225552032578333, 0.2021910601424849, 0.8927490362859856, 0.8911779889834746, 0.15450729431114574, 0.8951462279973851, 0.20193570445242348, 0.20157337281851473, 0.15291935465106432, 0.16853337284901504, 0.16789233455336194, 0.7270862921630497, 0.2123082616383415, 0.5981192903654906, 0.21073558506828338, 0.15510024957773472, 0.21081993664181187, 0.10559242549996017, 0.16967936026049135, 0.7515083117432388, 0.2008259804448509, 0.2109726156525984, 0.19499241034332904, 0.20414533835686177, 0.20056890662555127, 0.24160841233677577, 0.23071230572235246, 0.20771218667945957, 0.20189615246572168, 0.08544185834966778, 0.1177519248953266, 0.08959359204435846, 0.08651644893537835, 0.10361486868488645, 0.09313349338627996, 0.09025501719365603, 0.0545551476372762, 0.10455343484538371]}, "mutation_prompt": null}
{"id": "6681c1b6-fafc-459c-ac4a-0e653b766298", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * ((self.budget - self.evaluations) / self.budget)**2\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                # Change: Introduce dynamic adjustment of velocity bound based on progress\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * (0.1 + 0.05 * (self.evaluations / self.budget))\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introducing a dynamic velocity bound adjustment strategy for refined exploration-exploitation balance in particle swarm optimization.", "configspace": "", "generation": 54, "fitness": 0.3300276737795159, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "7acef844-ffe0-4d4c-9ca7-d984c2df94be", "metadata": {"aucs": [0.8785014210652562, 0.8561572933718425, 0.8625233009100491, 0.8726785775584656, 0.8479177835110432, 0.8521453475477555, 0.8602012562735508, 0.8609190198294663, 0.8494199140318452, 0.7223964262207396, 0.725855072226064, 0.7154927422876843, 0.7251000594020902, 0.7075952863182361, 0.7161260217987644, 0.7235864064870816, 0.7180544923153861, 0.7132356488993746, 0.1362706840432174, 0.12169059649638225, 0.16955615377221234, 0.1744320726413835, 0.4343228371547794, 0.11441563310077274, 0.4196177586438473, 0.14607310458127198, 0.15190450236594866, 0.1393710342149943, 0.1256262214286411, 0.10855712384739324, 0.16549727113669377, 0.1392942210823167, 0.1103466107446871, 0.11124143766386174, 0.15941647176102725, 0.1260619817150973, 0.9895193142751418, 0.9867099859493952, 0.9917254829632046, 0.9869416045839051, 0.9866048590117215, 0.9839988251231186, 0.983237456150272, 0.982829816631466, 0.9549032176002951, 0.7215676419741024, 0.7492055257484318, 0.7430572759202856, 0.731555785814282, 0.721212733939878, 0.582175635364163, 0.6852990374751982, 0.6971792297534252, 0.7133500697945574, 0.8557667982246894, 0.16665921878531553, 0.22618739139791477, 0.8623490503380971, 0.19318756981610985, 0.27635878940282055, 0.16166212450680084, 0.23533576409443435, 0.6109718978201764, 0.2221695595614679, 0.2253154467706998, 0.2043280871689933, 0.20131020563616675, 0.22925313856584828, 0.2731659073012531, 0.1976934103052207, 0.21861911749939522, 0.21218860954190544, 0.23294099198419094, 0.20428543885700834, 0.21724163972063726, 0.312420860833033, 0.23322766176046317, 0.2262081242771733, 0.24703042598944525, 0.13749590541640955, 0.249186097347861, 0.007873042275685083, 0.044023287917572596, 9.999999999998899e-05, 0.05659535289874784, 9.999999999998899e-05, 9.999999999998899e-05, 0.05680174400479732, 0.0006674258855701165, 9.999999999998899e-05, 0.05051175219423876, 0.03667704920563741, 0.06364927715733304, 0.12373641301086558, 9.999999999998899e-05, 0.06260072349141532, 0.10872604827627441, 0.1968354252848139, 0.10034478645130163, 0.04855415583860978, 0.2394599486123027, 0.35306667124509294, 0.07639454741630491, 0.07417145583595064, 0.10040655614545702, 0.06992568696821144, 0.2051588836922138, 0.0687110270066863, 0.048273755578288724, 0.17743766648082293, 0.20609274425176283, 0.038076157105227715, 0.01342294401859967, 0.21370193850349584, 0.08167511214602796, 0.1319911804296544, 0.0819134891342359, 0.5077437949783294, 0.4988817422403311, 0.512905280434322, 0.5633594006315745, 0.5266341609537225, 0.5434266148076732, 0.5648806083845572, 0.5496007651256405, 0.5501620157442475, 0.12064478229599795, 0.10319252949865843, 0.08867712718126008, 0.14135105260242786, 0.13826655480717587, 0.10336586125102332, 0.12723620580923123, 0.13905771228299746, 0.18169900266292394, 0.2637770284422186, 0.21208985681116654, 0.4084652837262611, 0.34712351851067047, 0.3219652099947222, 0.24923225948336336, 0.21678705335418713, 0.31040337722332334, 0.3461070912961912, 0.3689285731077242, 0.552464738974183, 0.4250863172882938, 0.38820674107681474, 0.3021961726030865, 0.34448553694643247, 0.22883372508994615, 0.35694069280886276, 0.23616800016465045, 0.2543687318100679, 0.3419431045800718, 0.1769402007298142, 0.2671205050748219, 0.3171410597620794, 0.33927090269708937, 0.244254276783213, 0.3236782956431513, 0.25743069469726965, 0.21452044192134112, 0.22270772525023907, 0.22373629694993247, 0.21506102685516493, 0.24487492082878948, 0.2263343118892449, 0.23554076708819083, 0.2040490407861728, 0.2473391447027643, 0.19874594909609644, 0.21984457916171873, 0.20911077790084331, 0.22419959501898368, 0.2456932039267795, 0.24615064387161534, 0.2216709949865201, 0.24285948736146734, 0.20219218149447082, 0.8898382470934494, 0.8913208065831, 0.15447346548292495, 0.8912492167899888, 0.20193717440122794, 0.20157604157233855, 0.15291935465106432, 0.16853337224194254, 0.16789288301030159, 0.7289656225795822, 0.21230822570509467, 0.6310673209017399, 0.21073558493241384, 0.15512870221327868, 0.21090781394919966, 0.10559183416396134, 0.16967936026049135, 0.8050286151324489, 0.19218394748329903, 0.21468917682750932, 0.20249835685110762, 0.20336626484232723, 0.1963427600966141, 0.2027228344990849, 0.22008920173388313, 0.2071910877492824, 0.21222687278987518, 0.1015944424528945, 0.11253926342696974, 0.1018927088235374, 0.10017643276367072, 0.09179497634168332, 0.09306932323190686, 0.09955674820666194, 0.05241451785238316, 0.10213896336729233]}, "mutation_prompt": null}
{"id": "94c866d4-a8b4-4ee0-a5b6-edfe821b2d90", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced a non-uniform mutation strategy and dynamic inertia weight adaptation to enhance convergence speed and robustness.", "configspace": "", "generation": 55, "fitness": 0.33578222918273243, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "7acef844-ffe0-4d4c-9ca7-d984c2df94be", "metadata": {"aucs": [0.9302728214527703, 0.9236123762453473, 0.9319509961703698, 0.9243112617939776, 0.9299319367033911, 0.9267284994705035, 0.9221540059636273, 0.9230408205887115, 0.9291953711504672, 0.8432969355961442, 0.8359474222495559, 0.8520609374874782, 0.8519849329450147, 0.6929075875428152, 0.7798814245306898, 0.8071402568277404, 0.8273737071896412, 0.7776263611330356, 0.12475650203282762, 0.16029957729462618, 0.1867832355880339, 0.1450375911771209, 0.12490595816220706, 0.07753080843313032, 0.18823513562929606, 0.1444818076169937, 0.12541052874596748, 0.11222487513775925, 0.1432602667509194, 0.11088043834557426, 0.1554705973978927, 0.14596429471759587, 0.1111525124614624, 0.12259605889113623, 0.11128818416283759, 0.11022288517789236, 0.9870410213910752, 0.9897897881525658, 0.9898804146327198, 0.9909736882414246, 0.9876216462797311, 0.9858843377160666, 0.9845734988110567, 0.985613442578674, 0.9826272993442372, 0.6485943106653931, 0.8494359760497743, 0.5632335977846663, 0.42874319889651, 0.652229927864302, 0.687933749751447, 0.8284028943764135, 0.8368756619711838, 0.5287147217165535, 0.3574211892295549, 0.22905218863483845, 0.39616050003040904, 0.2817008660237741, 0.9058787552103067, 0.21308854419674517, 0.2457916310000584, 0.7887875275148064, 0.212161229829964, 0.20053625854157064, 0.12027069199621254, 0.17289411622992445, 0.1917596446305011, 0.13437743377955025, 0.16558509345906058, 0.2023941316506126, 0.2022838177405879, 0.20296548252032343, 0.2201317850190745, 0.15925796310534424, 0.16311405227268716, 0.21333887786605688, 0.13508724685295403, 0.1302294358003413, 0.20643462598888906, 0.10309188837595851, 0.2500110335295219, 0.193048615165043, 0.016893753238715892, 0.09745079253621936, 0.06218872960365984, 0.08705504988407009, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04512219010942298, 0.12491421024355787, 0.02279070980367892, 0.09165449438050133, 0.05254387727095877, 0.0008775276028396561, 0.001967992487479586, 0.1852130737333859, 0.13363709206619057, 0.040789837838077214, 0.05145150034575885, 0.0518063613361317, 0.2428766081493865, 0.3262522780280652, 0.08777456400106953, 0.08127221651652294, 0.3323107720724675, 0.39309721718291424, 0.10803807966556067, 0.05128054900331824, 0.13499810521501676, 0.13118277028229042, 0.06209313330674726, 0.11011749783000868, 0.07621481526940355, 0.08546354443788629, 0.059659738624605385, 0.08397076077178933, 0.519540580379784, 0.5471288657027427, 0.5278908343970203, 0.5231947130463921, 0.5335756143862405, 0.6178424288493238, 0.582607896177068, 0.5788381264096107, 0.6166398579435652, 0.08053050072403889, 0.11739160898222312, 0.08271801771521337, 0.07773536102316758, 0.14046537760889788, 0.10314491141484528, 0.09256581526479546, 0.08659860219439375, 0.19146201827710485, 0.2833372692754913, 0.2923422066539433, 0.3532289224512256, 0.5447030344559003, 0.484477722542198, 0.22530714758304393, 0.2759845444914174, 0.2558770661772415, 0.2263954247750396, 0.23928054715736558, 0.22279960895222561, 0.2615306942504487, 0.564141980466258, 0.3542259883229325, 0.3690469803659594, 0.26207773871785556, 0.4386969090225379, 0.25053893050655673, 0.18402524803487663, 0.21818247223999387, 0.2193744996655288, 0.3038702529396684, 0.3737318967919575, 0.2897843374986864, 0.2177887638019782, 0.2235762942031897, 0.22394478052912303, 0.2748693552585888, 0.194929712837282, 0.24648242541197574, 0.24033210307982167, 0.2793589203873015, 0.20180981392271546, 0.2770068179457652, 0.2145930641970596, 0.2358675604036654, 0.20947260495921305, 0.2114697846675615, 0.20201495889693355, 0.19887388047521481, 0.2131480653137583, 0.18486764076226392, 0.1958559360663784, 0.19371537519213866, 0.18927704035302495, 0.9375469275799584, 0.9502352792842423, 0.15389917291898947, 0.9363617895341334, 0.20134931530139621, 0.20186005055063883, 0.16282706396491553, 0.8494408723899964, 0.16342373266545385, 0.8346661960968611, 0.2128640947081013, 0.7776420389578069, 0.16972455934211028, 0.1564848142407118, 0.15608329643116703, 0.10523472116189547, 0.1677610244139479, 0.8277948500686769, 0.2097733026131967, 0.2204404032857893, 0.2037468496930367, 0.23710673179899355, 0.20251819657351045, 0.2030151763076279, 0.20004423446599984, 0.2534290561444301, 0.2750188374993656, 0.11340898284974332, 0.16445930958923416, 0.08729858359290832, 0.1299113257598794, 0.11593705319705006, 0.11907796082464706, 0.08402359602590026, 0.15074469598753548, 0.10351739712990438]}, "mutation_prompt": null}
{"id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 56, "fitness": 0.3497337747124914, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "94c866d4-a8b4-4ee0-a5b6-edfe821b2d90", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "86a609f6-b136-459b-83c7-6bc101884540", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (0.5 - 0.4 * (self.evaluations / self.budget))  # Enhanced adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.7, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced diversity through adaptive velocity scaling and modified mutation to improve exploration further.", "configspace": "", "generation": 57, "fitness": 0.3322871863005872, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9248986376101511, 0.9142984361792195, 0.9193501708383818, 0.920206940424306, 0.9220660811329371, 0.923410633585993, 0.9235416355900514, 0.9236789553291975, 0.9150846369860368, 0.8464862723837598, 0.7938069660108413, 0.816701441767663, 0.8407500125812656, 0.7742891950919534, 0.8266639446766019, 0.8155224092046852, 0.8376839024923018, 0.801369394889646, 0.15417068197541395, 0.15556759688929722, 0.08917186368509533, 0.1187015363742352, 0.12642706424324046, 0.11562156969496429, 0.15528093951002686, 0.1409488740778142, 0.1180534515338797, 0.11502475567792858, 0.11488537385266573, 0.1569288186278156, 0.11854776350764873, 0.1062272985295003, 0.10073992350733496, 0.11776371587099965, 0.09647332596818903, 0.10095329900537997, 0.9766942447352426, 0.9740134709979096, 0.9880698826486777, 0.9719344953002974, 0.980264527809962, 0.9760539677989077, 0.9703864868045246, 0.9801181024022382, 0.9743526988387085, 0.8312358884523658, 0.8533054476718582, 0.8240267557265859, 0.72742466258176, 0.7831624138813293, 0.8177205241479858, 0.7831838134733266, 0.8076940368056513, 0.8256922883637683, 0.7156453108319253, 0.21687716132952006, 0.23007686007202632, 0.2774372089429561, 0.19338087233385937, 0.36957630363467875, 0.2220413698041066, 0.19282703162009918, 0.7045547518690533, 0.22677925155215195, 0.21887412258751637, 0.18394657735613906, 0.2385893064986805, 0.23577302636047526, 0.19515410073231187, 0.2182020615162097, 0.2347959992381521, 0.2178897609067435, 0.2281251275065307, 0.20593715282523262, 0.13724574170152137, 0.2396647205013953, 0.13011244512395737, 0.23064926243218875, 0.26210251668147166, 0.16126535402275044, 0.25263870963390855, 0.01055195479303861, 0.032131934183617705, 0.14174340739987967, 0.04250431321143955, 9.999999999998899e-05, 0.02002717465977344, 0.010114234117593712, 9.999999999998899e-05, 0.012726858185706402, 0.07553771342497273, 0.07259943814577074, 0.057598519322712094, 0.056738785366578504, 0.02614085723039805, 0.03834975188160583, 0.08299723871169173, 0.04748853690480226, 0.06101668887883993, 0.052056725388354264, 0.055597074076731534, 0.1348458169826665, 0.08088814658687793, 0.0895792559265235, 0.08408047674834229, 0.11821713691187119, 0.21906557867634768, 0.07635405260351058, 0.14724921639547228, 0.18830520715339882, 0.13619320788944245, 0.20140282923934782, 0.1668553220022977, 0.15590239356913804, 0.15064844827655122, 0.19497288267895585, 0.0848311582493998, 0.5348674402961118, 0.5609731545701009, 0.5321412237064638, 0.5698357714145617, 0.587133824827851, 0.5590952429605878, 0.5825192014551054, 0.6086877584518153, 0.5674152336512838, 0.158708672402622, 0.09690370602665621, 0.14744158956920406, 0.1926734978331015, 0.11921056466899715, 0.10995410894142332, 0.07967604074035317, 0.0940983598364784, 0.12100377788761763, 0.33134631745257137, 0.29473368859337423, 0.2021217548709746, 0.30883047263259, 0.2532663643372842, 0.40735757085801017, 0.33697935015636626, 0.2105914712525898, 0.19649158420999302, 0.2694525194369214, 0.453307074472004, 0.16910736732145393, 0.3817849754291379, 0.36909574579893023, 0.4263715802517919, 0.25068838269908533, 0.28588525613270177, 0.21937860353957372, 0.25603690610159524, 0.23471439641744185, 0.19107843026550098, 0.28433763788890987, 0.3708737926508149, 0.2722379368822171, 0.22508585119913926, 0.27160071096448535, 0.3518259262213087, 0.2708928003054658, 0.2147113331263174, 0.22947688448695236, 0.21737504031985166, 0.27737358921588284, 0.2654371246262295, 0.2393873601471488, 0.23836514702303935, 0.25254766988822863, 0.2271956905735869, 0.18711623224197005, 0.2009739851789235, 0.19585958153915572, 0.25724886246849843, 0.19292767037858272, 0.1955546082492332, 0.19928423685648533, 0.2117882013338258, 0.9502730194491662, 0.18896662644416706, 0.15459535531785096, 0.940227833385199, 0.20208976830841163, 0.20199930750673223, 0.16751166821866226, 0.16816065011201498, 0.16718508231026263, 0.7672163571887127, 0.2132362240569151, 0.7434423735478535, 0.2130909066260187, 0.15660352064424554, 0.780658987626265, 0.10526257867897004, 0.059119244279537075, 0.6983167236748142, 0.2167081826455861, 0.24517627813372056, 0.2229316442437258, 0.19137997936061413, 0.23280885171927868, 0.19459315084388262, 0.22240988446354926, 0.20718759684521282, 0.2397179989691559, 0.09003669344662213, 0.08160703087732368, 0.07261865703162707, 0.1103220612956769, 0.09560687013960234, 0.11447654248822914, 0.10140613593282377, 0.10097010322690636, 0.08337582551428002]}, "mutation_prompt": null}
{"id": "1c483116-2288-4595-a9e2-070a4f99afeb", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * (1 - adapt_coeff**2)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.6 * adapt_coeff  # More adaptive cognitive component\n            self.c2 = self.c2_base + 0.4 * (1 - adapt_coeff)  # Less adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refined inertia weight decay and adaptive components for enhanced convergence precision.", "configspace": "", "generation": 58, "fitness": 0.33171416707160356, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.958467360282295, 0.9547417291048512, 0.961947967119765, 0.9567751566905706, 0.9611732977401634, 0.9603297590019875, 0.9643708823384239, 0.9569975649848219, 0.958273180307878, 0.8635334867268283, 0.9104574070584315, 0.9052582426403321, 0.9088844257253751, 0.8837335476651141, 0.8748956119379456, 0.9134109598153246, 0.8446199270955633, 0.8666900657698656, 0.09096919166234751, 0.15935631746359957, 0.16307512981211625, 0.16533246505917287, 0.11422850854298305, 0.1365058484826539, 0.10133300531228162, 0.14652156411487394, 0.11906556740138474, 0.1660299620120088, 0.08429946003874322, 0.09396083210151429, 0.11168673005777707, 0.10608838311561486, 0.06972485842950538, 0.16339364338940754, 0.07582002663296683, 0.06647038425658336, 0.9798543519382852, 0.9763466358025014, 0.9876861909289413, 0.9807625112406673, 0.9829187653807884, 0.9768652353746095, 0.9819852751990203, 0.9816000439858918, 0.9779189184872148, 0.8644697527540304, 0.6536630112200279, 0.8392333296907056, 0.6781899794232824, 0.7520240278236845, 0.8793743243781855, 0.7561637926092529, 0.7812015751762563, 0.7896977822872147, 0.23072372727235713, 0.23057142392270258, 0.22337940961443414, 0.28198244934137595, 0.20966877101070636, 0.6740250375008177, 0.17849256884400966, 0.24700263208457718, 0.24109447143794516, 0.1377094355002909, 0.13460793134579963, 0.18802973748491558, 0.2214024266046215, 0.20240551117902883, 0.17531801555741167, 0.20422461547768866, 0.21546111285524205, 0.20197992153795363, 0.22872072091179418, 0.20307752402332768, 0.1346163929537959, 0.25150279648195006, 0.1368814654257121, 0.13558660605215977, 0.23275574014820988, 9.999999999998899e-05, 0.2584579067460161, 0.011571713446232978, 0.0674877367754303, 0.23123509846764612, 0.06044105786628984, 0.05302074374367549, 0.05621525013494233, 0.006946385437468394, 9.999999999998899e-05, 0.09483643165779032, 0.1308854076590794, 0.0428420660897767, 0.13434735280137977, 0.09877498337856383, 0.017971759878872895, 0.03586503495117377, 0.25093027071469076, 0.07136628344901419, 0.06915539071132282, 0.2956453654210405, 0.03931669255934289, 0.23710837848915867, 0.14199011187540722, 0.08630503538484968, 0.20651273621221466, 0.15596184332656082, 0.08417798910461893, 0.10105760416982923, 0.21893189929447043, 0.09104707237416665, 0.24699649191501305, 0.20197908685950672, 0.00696664474734221, 0.13117088149942358, 0.08657647859087725, 0.16514277307114478, 0.08693332056316272, 0.5340092945401538, 0.5574717191175151, 0.5303756620078759, 0.5537702413998713, 0.551735440651925, 0.5385922479003422, 0.5786785552368041, 0.592527171031508, 0.5616521521854689, 0.05969204079284485, 0.12995804451683468, 0.055040578189380684, 0.11402607953674049, 0.1421207108177559, 0.10695027265344126, 0.09478720560379295, 0.1179392103040896, 0.08713006686996538, 0.19394328708026953, 0.2559965936886648, 0.1982737285136481, 0.2194737447304067, 0.3578711901995666, 0.2396425148326884, 0.24034136143188012, 0.22056554137056994, 0.32627100276712395, 0.19922456673565658, 0.3084966511868087, 0.14930281921404054, 0.20770729641709396, 0.2967807232411728, 0.4513407536673195, 0.20584889848634835, 0.533413919586294, 0.2357123331008707, 0.11657967775620215, 0.38079460033688806, 0.19759925728405348, 0.23459263648188233, 0.21162789530318438, 0.18550266688227135, 0.20559515628347647, 0.41022690057626576, 0.11544791654650877, 0.2986875939000839, 0.279487609091028, 0.20372817919040376, 0.23240344229321463, 0.2920888614481607, 0.2858111481920168, 0.290070338393846, 0.21831421626359127, 0.24276064985329238, 0.1975106371267238, 0.1903090714914908, 0.22463698605431415, 0.1819739967522418, 0.19742143974500148, 0.1855645680410436, 0.2129463646628016, 0.3330946175450652, 0.18034836993979642, 0.9694530094899734, 0.953046133958028, 0.154845099029015, 0.9712853586114295, 0.2026257954848394, 0.20212104472728665, 0.15495800879923793, 0.1686119390062184, 0.16781175205994692, 0.822084617583446, 0.211670227829158, 0.9217691514512578, 0.21371983834470898, 0.16967789748666162, 0.21092263772916553, 0.1055948231212851, 0.1687677215742206, 0.8447672218750255, 0.2158231508634899, 0.18071330979463618, 0.19888744863973906, 0.19807372627885633, 0.2043546778876878, 0.1892564887562177, 0.20853928639025543, 0.19749741869947146, 0.1863916656337261, 0.11690333179613988, 0.09600475178227841, 0.1004245703380211, 0.10660767685211592, 0.09905333275551587, 0.10113621569677123, 0.06514466406222941, 0.0920197944847847, 0.07193820402399487]}, "mutation_prompt": null}
{"id": "2c7d9b25-4d68-44ce-a718-9aa832e5f195", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * (1 - adapt_coeff)  # Dynamic inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.normal(0, 0.1, self.dim) # Enhanced local search with Gaussian perturbation\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced a dynamic inertia weight and enhanced local search using Gaussian perturbation.", "configspace": "", "generation": 59, "fitness": 0.3333427813501948, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9581791826472443, 0.9636707846060542, 0.9624902118951455, 0.952503165283333, 0.9591061088602062, 0.9631428309439309, 0.9515366952676251, 0.9609356864352159, 0.9538771264662607, 0.8919621763914864, 0.8371413694956038, 0.8819532185259303, 0.8666623138378873, 0.8952479237189662, 0.891961631156631, 0.8924347280135615, 0.9142649968481954, 0.9050158057490816, 0.8709569524948332, 0.14854728684389962, 0.14684234588316725, 0.09021223015157864, 0.15848015636567092, 0.12071550842225642, 0.17612088868697306, 0.1487270187672175, 0.10179450830469616, 0.12795198750994385, 0.09424673063955691, 0.13572177174401345, 0.10478928290984146, 0.06488421121683752, 0.09440867569917977, 0.14634173994996236, 0.13540472616158516, 0.09811607173270809, 0.9802778183128761, 0.9742090864872687, 0.9835199436460796, 0.9623237656170911, 0.9736617900624569, 0.9802771549401138, 0.9747415286871011, 0.9298782855566511, 0.9558686468906189, 0.8042208899810875, 0.593496049853971, 0.8447525876509401, 0.7914630878331922, 0.5321694250477014, 0.7972528801053327, 0.8599608634048259, 0.8240197287928113, 0.8471805636094274, 0.3220881479298797, 0.1405600823804789, 0.22768876573968366, 0.36912176906075034, 0.28452874839364106, 0.19127410274362067, 0.2343441419575979, 0.18753888318864198, 0.21606072927889852, 0.2065414703381725, 0.13388065657222104, 0.23319369640999954, 0.2884010407441284, 0.21087022756288976, 0.17146969778805154, 0.2198733492436239, 0.13863051906924484, 0.13700669561453593, 0.2213578788496553, 0.017452727746720353, 0.13861395887153338, 0.21008795206496833, 0.22537444015098074, 0.2911397528604729, 0.2470811706274827, 0.23778263778097986, 0.13472176293765115, 0.03744627683763624, 0.0341776122160824, 0.16116907258762203, 0.001657652020049638, 0.019551195858072634, 0.014449524082523757, 9.999999999998899e-05, 0.0319347284068866, 0.0033345086193113938, 0.07637101610028274, 0.05555758446041925, 0.1669757123957919, 0.08070490553502407, 0.039785295158733636, 0.021853535274807268, 0.1493530371106142, 0.1413185307650252, 0.07875701737813201, 0.10772972026284078, 0.1801424679025384, 0.26891460350868124, 0.08679788085461226, 0.10932934176755038, 0.1521727581880532, 0.09761884688320388, 0.3203532628237893, 0.08009331791869923, 0.13284712775936058, 0.07567082091117949, 0.2555735987753678, 0.22892383788941828, 0.075282505207525, 0.14532478103198332, 0.08632697488085128, 0.20786851368120185, 0.08647645643694635, 0.6116202177559003, 0.6805961798657439, 0.5499063654214449, 0.5730572720610334, 0.5392760667227825, 0.5507661126228705, 0.5965305085189346, 0.5675807747978951, 0.5923560006175802, 0.06402435488682479, 0.08737202739835559, 0.07411579763374443, 0.08670073346036589, 0.12024150625299446, 0.12558066194773732, 0.11297860851943842, 0.07655599067080932, 0.11883560449282271, 0.18319055169172205, 0.2433813488980361, 0.19316280256088691, 0.31892132231606696, 0.2630269997045357, 0.20478781058351292, 0.17763522316943237, 0.26766182462307575, 0.1626703580888701, 0.31365527156353057, 0.3357537778058468, 0.160660165709976, 0.24028185125045365, 0.30352608250060065, 0.333065129277058, 0.20705354269263765, 0.20549429188044221, 0.25114289126815315, 0.12586140863425355, 0.23151252890602958, 0.18160576544991347, 0.25125804591287626, 0.2447021702804617, 0.2163308705207272, 0.1416778176432052, 0.26454809001642365, 0.12039416376127154, 0.24031800128219638, 0.2528349805688128, 0.20016154698799182, 0.24407767430224314, 0.3195679298888644, 0.2938820869675798, 0.20433951487910973, 0.261985391522101, 0.2158331652603651, 0.22961652515976005, 0.20817346823552574, 0.20293180230196228, 0.6601257284540174, 0.1943117782110897, 0.18286765053757426, 0.25848558870607174, 0.25856743772563684, 0.21142903030990423, 0.9535685194573211, 0.9171395497601538, 0.15488056319351873, 0.9770123164268516, 0.20204385528064217, 0.2021692169948336, 0.1687928491654519, 0.1678019238661047, 0.1688004040004507, 0.08335614703760752, 0.21294189832306698, 0.6074042902260943, 0.2139078307080131, 0.15712687756837007, 0.7864498640899293, 0.7132364386499819, 0.169875889008682, 0.8193383704353285, 0.22647895064256796, 0.1792495962254561, 0.19118470935683185, 0.2040227653230945, 0.18175979188252245, 0.23511084715938224, 0.223182406160644, 0.2122644702415335, 0.23440149342383243, 0.09006518996151369, 0.14478453119693113, 0.08333782644337295, 0.10424567153953901, 0.10123056672473318, 0.12311951400211474, 0.09451337614045774, 0.09203643845544884, 0.07038845740845867]}, "mutation_prompt": null}
{"id": "c5c7599a-0994-4d51-9791-999b6ab76b01", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                dynamic_sigma = 0.5 * (1 - self.evaluations / self.budget)  # Added dynamic sigma for Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, dynamic_sigma, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation with dynamic sigma\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced local mutation strategy by introducing Gaussian perturbations based on dynamic sigma for improved local exploration.", "configspace": "", "generation": 60, "fitness": 0.34757022423369177, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.923451034817114, 0.909914339648461, 0.9146763950049702, 0.9172646871911633, 0.9142059247167114, 0.9143243535906217, 0.9157899419384136, 0.9076568840408633, 0.9095789378278424, 0.8415651819795504, 0.832084370162206, 0.7795532712962794, 0.8271344457399976, 0.8283527752286095, 0.8371275737542943, 0.8159736894488507, 0.8229743154863888, 0.8138941968638904, 0.15897824004763883, 0.7050670288216128, 0.12337746892817247, 0.15983603545651803, 0.12539903350644932, 0.1859837977628358, 0.18887540403337388, 0.18844333461685592, 0.09523525929425813, 0.14326463261342526, 0.10585743619050847, 0.159115474766805, 0.12456411985881755, 0.11642339954903125, 0.08902185202132129, 0.110902377526099, 0.14068338507952527, 0.13923895726620883, 0.9870365393514539, 0.9897862431270376, 0.9898606943699797, 0.9910024496963807, 0.9876223217773356, 0.9858885824948428, 0.9845789117722453, 0.9859781876409878, 0.9830014570605632, 0.7722113717395788, 0.807361108889217, 0.8159049645412766, 0.8412755026524749, 0.8315661108842475, 0.5358958424078459, 0.7701335881290552, 0.810185427560189, 0.7726939629475554, 0.8547216295603683, 0.2257159306977542, 0.48904813713601303, 0.2791959464574757, 0.19642287972522665, 0.19322716440523213, 0.23077014533466622, 0.23500429679056067, 0.20064376406130835, 0.12174967400985226, 0.4184045758140923, 0.2083187070297342, 0.2439064613989822, 0.13593073480313034, 0.2030348307068287, 0.21685089081291198, 0.21902469589536055, 0.2456915798509769, 0.2356811940356177, 0.13423670308017732, 0.23025374530756249, 0.21952498791004538, 0.22511484875438992, 0.18280846064629708, 0.24993659349562225, 0.14302915966090513, 0.1334268706875149, 9.999999999998899e-05, 9.999999999998899e-05, 0.1467842502876796, 9.999999999998899e-05, 9.999999999998899e-05, 0.09215514304169481, 0.0007728967192615066, 9.999999999998899e-05, 9.999999999998899e-05, 0.1293830455174082, 0.054422346290364465, 0.10504090213397865, 0.07148904642280018, 0.04192818890266259, 0.032801307560903714, 0.13849095112813992, 0.07948732710816508, 0.10436308205795286, 0.05138564783314359, 0.05138359320895014, 0.06123155573476069, 0.14664687246425767, 0.09961857628995019, 0.08058752157744709, 0.14082883067559104, 0.12380534527411324, 0.18178731755069943, 0.10761739826064498, 0.2212177318019093, 0.38995268922760284, 0.08156068042650078, 0.19838280456735313, 0.039767441479364285, 0.08417928259791718, 0.15132520667892857, 0.0834729979495662, 0.5496773896944698, 0.5216482967362173, 0.533267229082675, 0.5480791388124772, 0.5270529820383818, 0.5831909102139148, 0.6026587885927837, 0.546761409101641, 0.5704219210773213, 0.15661342048572546, 0.08865402457321647, 0.11131978075960236, 0.10074000902922475, 0.10751443196098975, 0.09832966502238982, 0.12232855789508523, 0.13055928271602169, 0.10519292923577106, 0.2576058564609771, 0.2549430450561364, 0.3374440442761527, 0.3683823593620814, 0.20364575033860977, 0.19734144548298316, 0.27061271957051247, 0.1788739928601708, 0.18350183798958153, 0.4536836550637261, 0.4135114663051228, 0.5336717466933522, 0.4066284687403252, 0.3682192834072908, 0.5476317138956213, 0.2615471291133711, 0.6179707907729097, 0.22215752414766388, 0.35587465891005654, 0.25596050009295257, 0.3162725960392049, 0.22771498975977988, 0.2203908538630006, 0.3180371256101012, 0.1802285665458323, 0.21766931138964696, 0.42035602639014, 0.2642124890100759, 0.27224490473621377, 0.214749797619197, 0.21615665059013978, 0.24815816755140518, 0.20653658888884718, 0.23074490677260806, 0.2360396039588556, 0.22554840343704408, 0.228440123278277, 0.2273649611113565, 0.21709954911916374, 0.19337825195750435, 0.8781136294630257, 0.22886111463202163, 0.8299519121992724, 0.22948226144345296, 0.19868168284069876, 0.9327982226102514, 0.9393675662571433, 0.1538618206738922, 0.9270261983425968, 0.20178634492404268, 0.20183756206187475, 0.15357785929793843, 0.1685787317671006, 0.1778016326300207, 0.6232522706709055, 0.21225350258463127, 0.8396158585037428, 0.876335011263697, 0.15596972408370424, 0.1550353853307126, 0.10512083076665679, 0.16639020052248232, 0.7823232998040612, 0.20030673658686482, 0.213733692402564, 0.23183557172035862, 0.2009178012004369, 0.20111336839283034, 0.21046534554618068, 0.1871281218115649, 0.1978400410754756, 0.2766821234106813, 0.10564703217317839, 0.11445030770320641, 0.08400240664611591, 0.10897148825097158, 0.09187567200486624, 0.1402932715586025, 0.09304481873324699, 0.1385417845103304, 0.07381679292385179]}, "mutation_prompt": null}
{"id": "3b45870a-c658-4d3d-9dbb-b4a5facf00bd", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    mutant = self.positions[i] + np.random.normal(0, 0.3, self.dim) * (self.global_best_position - self.positions[i])  # Enhanced mutation strategy\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.05, 0.05, self.dim)  # Improved local search precision\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced mutation strategy and exploitation to improve local search precision and convergence speed.", "configspace": "", "generation": 61, "fitness": 0.3323896019381498, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9150646156338952, 0.9108373611216762, 0.9146871015612221, 0.9058693781751239, 0.9201109193059062, 0.9206774448036688, 0.9122657994915654, 0.9168408924130138, 0.9129491039703164, 0.8530923238650738, 0.8374112805303803, 0.8272776074020862, 0.8435634444167208, 0.04819264705911486, 0.8292046534067785, 0.8230327255241945, 0.8364605794932362, 0.827490511840854, 0.15988426721912474, 0.1581653508303732, 0.16098078883280886, 0.15446858705708033, 0.15751645618967647, 0.1316027204730924, 0.1265465960142903, 0.18259027315176724, 0.09040174107673793, 0.11596425999288873, 0.18260180458135467, 0.12758598718849956, 0.11060157556152239, 0.09708974709615137, 0.1306087701777502, 0.131597611225579, 0.14494529014527635, 0.11084237024508325, 0.9896978290693481, 0.9896818898276043, 0.9920022794137259, 0.9837974464989878, 0.989730498644248, 0.9879426144264443, 0.983625069131055, 0.9884434957116613, 0.9841332201759254, 0.7769746588664727, 0.7808864811117595, 0.7788348958855011, 0.8145313428333104, 0.7458688377699922, 0.7546048066735171, 0.8055421583522805, 0.7771443027269991, 0.8001066997806947, 0.35878135028017466, 0.37690483527534036, 0.2253590121160015, 0.2790330115838773, 0.8921806828036088, 0.19374608259920867, 0.24364038776085495, 0.6640478396349001, 0.2372450736778975, 0.13293850619440495, 0.20801970134326853, 0.2125128953851083, 0.21194535021002925, 0.22512762169025258, 0.19522208266618613, 0.22267429454180887, 0.20613253650957508, 0.20502873309336345, 0.22160441159090238, 0.10610358766486683, 0.2645193742707982, 0.24640767433063004, 0.23009921715474957, 0.24211626559653776, 0.2656561605342508, 0.10212052094904889, 0.24885227766583018, 9.999999999998899e-05, 9.999999999998899e-05, 0.06215883831799851, 0.06015426834776605, 0.039537584780330315, 0.008390827293373482, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010797352093065982, 0.1204331282249077, 0.06286666831077914, 0.08637424709813168, 0.0821458848894615, 0.007002968581957814, 0.02537329159305468, 0.11369654043732458, 0.10284629748494645, 0.09671738752899961, 0.05267082848437421, 0.1772016556948811, 0.12286000598691493, 0.09113506952881889, 0.08166528433087494, 0.08034646674139645, 0.1570531568173812, 0.0761058455616026, 0.09148553545358351, 0.09454277578050496, 0.11755020723518594, 0.1477264162479789, 0.06184049714455775, 0.025670818588151678, 0.17382025170763282, 0.09028391048512818, 0.05778378738653733, 0.08392696029049929, 0.5937365715727261, 0.5551368018223068, 0.604908304345189, 0.5312842468353149, 0.5336780620733539, 0.5328271104738604, 0.5871742835717348, 0.5610144235177674, 0.5694223104182976, 0.15730528942959954, 0.11277778701406027, 0.08400335024541783, 0.1888574469225891, 0.1418366013980754, 0.12411495022896302, 0.10582945506179453, 0.12012280210158499, 0.0941096817122401, 0.2610808665240193, 0.18672073932884758, 0.2653468403863156, 0.22748126338569663, 0.2254418268063073, 0.2323893867210609, 0.253291569226089, 0.18363699958062696, 0.3075637907232419, 0.34274885882252804, 0.37777221901851976, 0.33534189168849515, 0.3480450440142524, 0.3205575699565807, 0.33159647533353864, 0.24129156590129797, 0.5092317813205419, 0.23861733848991484, 0.2891812050632978, 0.37120687139072583, 0.18251019743280572, 0.2516035410403792, 0.20126177410576407, 0.2538227708888007, 0.18182596277107144, 0.22475682755414306, 0.10309837873177585, 0.23411237091888748, 0.22248804579213688, 0.21345296935482816, 0.2341015196056061, 0.20476738864823696, 0.2694789406224365, 0.24455683787564697, 0.25385867975966947, 0.22322490874774725, 0.2557977596565464, 0.21124556418657225, 0.2125165677883729, 0.20366960775899723, 0.2295959268359895, 0.2171153442029482, 0.2245540957527793, 0.8201332599105885, 0.18651176689019866, 0.9275291540631401, 0.9237090693367171, 0.15448887571216274, 0.17344194768535492, 0.20110094737033402, 0.2017499415057047, 0.168306774821118, 0.16719442800996953, 0.1682004544824789, 0.7729867712822813, 0.21250147994861468, 0.5931122765371333, 0.900874114062615, 0.16939690683694186, 0.21011252953192316, 0.7865294249528567, 0.16928524338374862, 0.7982699495119773, 0.20307708927559442, 0.2054561465922914, 0.19469890192235262, 0.20410774954079502, 0.2087813953935722, 0.18801085221543956, 0.18910430429455105, 0.18952286913159977, 0.2489322854808379, 0.09631416437143381, 0.1327005456649487, 0.10552296745490075, 0.1356416537997578, 0.08562543953584068, 0.08525462109262139, 0.08178219563989664, 0.10251486006643684, 0.11013335621148723]}, "mutation_prompt": null}
{"id": "c00e27d3-0f82-4a53-ba34-459bf6d18119", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    if self.evaluations < self.budget and np.random.rand() < 0.15:  # Adjusted local search probability\n                        local_search = self.positions[i] + np.random.uniform(-0.2, 0.2, self.dim)  # Adjusted local search step size\n                        local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                        self.evaluations += 1\n\n                        if local_search_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = local_search_score\n                            self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced exploration by introducing dynamic diversity injection and randomized local search adjustments.", "configspace": "", "generation": 62, "fitness": 0.332537482765122, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9175147739529556, 0.9182280198256527, 0.923066510533808, 0.9120547596529462, 0.9203415113727492, 0.9202901205884203, 0.9186002241869045, 0.9191805772465633, 0.9160784462350079, 0.849465180508072, 0.8203914820916969, 0.8376132944617518, 0.8453332227844433, 0.8434406777333574, 0.8379514739016573, 0.8294712894139598, 0.8456485120812145, 0.8432765043059909, 0.08909281480124942, 0.18432148451631192, 0.18772349496407326, 0.15963101406602653, 0.17958573937911626, 0.17893094675741827, 0.16163598124122658, 0.16694816840368354, 0.09442305794332129, 0.14211207253325464, 0.15786012044948516, 0.13940981666722763, 0.12262076494941154, 0.10407027817596648, 0.15473164685073793, 0.1149593224000337, 0.10465856108443439, 0.1175536771247283, 0.9879459829084536, 0.9876158946466839, 0.9920996933773703, 0.9838549229795298, 0.9879939414731421, 0.9853133849948047, 0.9836368749611273, 0.9880983520365743, 0.9727167251048332, 0.8447496009924131, 0.8183772110136096, 0.8296316089807481, 0.8183409429735221, 0.8058589143788477, 0.42926959412962273, 0.8270510466692447, 0.7987288517924498, 0.7988755289619456, 0.37859289162783505, 0.23136267730350202, 0.22713022684821638, 0.37360059044501315, 0.17096408857071277, 0.2795877068826723, 0.39702358745346555, 0.24309090452315107, 0.35725744758711875, 0.2091164534434361, 0.21292060079701736, 0.22184903588902372, 0.21209632816366286, 0.13118512331929089, 0.22016357027614797, 0.2109365808763236, 0.2119915376217404, 0.2185740590550529, 0.24356401264105965, 0.23636224205088496, 0.24163505263970075, 0.2531284982393076, 0.23269260499569533, 0.2521703257435425, 0.2558629525542332, 0.16704020230762584, 0.20813213210443648, 9.999999999998899e-05, 0.041894426780079486, 0.0753686017065831, 0.027745375513617332, 9.999999999998899e-05, 0.0351519944616312, 9.999999999998899e-05, 9.999999999998899e-05, 0.1425846616701263, 0.10084891952154862, 0.03452448555199916, 0.10808720306948438, 0.06548620659584792, 0.022687359756989323, 0.027527570039522442, 0.13015624484944277, 0.06334956288969551, 0.10660503931572562, 0.05173472804357482, 0.08252668333426405, 0.3865901846112073, 0.08674645036465223, 0.0804797605153722, 0.21038463265627916, 0.14998515946586954, 0.22172492385671339, 0.0756942935993602, 0.08563231871695731, 0.08365403335752053, 0.14226054662521115, 0.1708595898307047, 0.03583709241605704, 0.06903711304586013, 0.08415511561699385, 0.05700125032776482, 0.11822053485579087, 0.5482294607742764, 0.5453086369041165, 0.5365288899196721, 0.5352989877309119, 0.5402416857036341, 0.6141195030996758, 0.571275629220549, 0.5970118391507293, 0.5822052879057789, 0.1063044660785043, 0.11697453945891079, 0.0759713214634592, 0.1611050981134613, 0.11189039910754928, 0.10190480358718612, 0.10635864543321583, 0.11309500784585813, 0.1260755144896213, 0.22485422602064087, 0.2053719527284601, 0.2713987292192842, 0.16702016966173072, 0.4262390102160233, 0.17977233418032423, 0.25814364394696343, 0.3393268839409157, 0.20556838433816804, 0.2388555638591534, 0.31200776257697693, 0.238170340951539, 0.3399642547181798, 0.40621237058320314, 0.3429949683196507, 0.4559389739638504, 0.5571258871002259, 0.298058276413919, 0.30941836733272887, 0.20374755627115215, 0.1810542625818382, 0.25257513379359176, 0.32046355367671864, 0.3006267808884767, 0.2137833587988055, 0.18854940736217995, 0.09513000662728643, 0.2599767552504537, 0.21182680616422178, 0.23995658670298659, 0.2431992048173799, 0.27007003458091683, 0.2301387001957439, 0.25102459788568876, 0.20728860672780247, 0.2553790344254139, 0.20044368201245488, 0.2520785058485049, 0.18996952423195157, 0.2536491165355984, 0.6853399979454934, 0.25265926251043636, 0.2309284889959755, 0.22596621424011587, 0.22657982882019045, 0.9469708807333005, 0.20010347680044838, 0.15419115880039058, 0.9402963169447883, 0.20188477955313544, 0.2017615240225068, 0.15436199098237846, 0.16815965283727785, 0.16680918275175205, 0.8298315337948335, 0.2121178282211016, 0.9249740266834106, 0.1687992699062275, 0.17006318278924537, 0.15467241166722656, 0.10523587058612649, 0.17026039933612314, 0.8058414330702144, 0.22404222474947744, 0.20626510319174973, 0.19571255106308616, 0.1954122534247179, 0.19963116907394218, 0.21656261629171036, 0.21471952347753542, 0.24481302521190695, 0.21761939581197265, 0.10275496296494002, 0.13320390090709278, 0.09348981282975177, 0.112940447787519, 0.09721696239248445, 0.10888705536108667, 0.09757757672308576, 0.0976794534358667, 0.09313838665542296]}, "mutation_prompt": null}
{"id": "2e1198c4-fba1-4f4d-9127-e0f0342c2d5a", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "e13c4901-b0ac-4201-9fb9-5083978a24e0", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "08540137-ef26-4548-9a00-03b14d90d8c9", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "e78a0688-fd3a-429b-bbfc-2bf28e9d40a2", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "79369c6e-5af1-462b-83dd-74bc6c7ceb87", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "78ea1b7c-8208-4b90-873d-bc4e154d19d2", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + 0.7 * np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])  # Bias towards best\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced a biased mutation towards the best-known position to enhance convergence speed.", "configspace": "", "generation": 68, "fitness": 0.34457897421900613, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9173572316069158, 0.9103768484295913, 0.9106043798199658, 0.9246118060641357, 0.9208598501439236, 0.9185239417074929, 0.9071996794306749, 0.9125147139274921, 0.9176111299044287, 0.8252330510675623, 0.8165932103459823, 0.8330104816646046, 0.8407388573075506, 0.048307430872137624, 0.8036197154961864, 0.8247021406107717, 0.8228676563750636, 0.8218207280253674, 0.7284019548481326, 0.13022467705956842, 0.15725245820212364, 0.696211885025289, 0.12546784102623187, 0.15277212009073138, 0.18188572149632198, 0.15770604222964268, 0.09859252705978816, 0.15599312778415297, 0.12719544097559088, 0.1437921261087145, 0.11607705591945217, 0.12413165727188713, 0.10868800703241199, 0.13114094747204585, 0.14282042176356247, 0.14283108743616435, 0.9870410653346012, 0.989786699031756, 0.9898546706246687, 0.9910574409601434, 0.987621663702349, 0.9858886208617071, 0.9845993857558567, 0.9856186813284838, 0.9830013064966866, 0.8383716720716586, 0.8152414128606987, 0.8283276362071292, 0.7055000938212492, 0.5445461053319909, 0.5939764851533493, 0.7428997800984773, 0.7880680742339663, 0.8198099315496581, 0.26329955982777853, 0.22653920009863382, 0.8971911835937715, 0.21128583262349432, 0.20806604997630262, 0.21319224105545598, 0.23474430807970648, 0.24283510766746064, 0.24726141892537035, 0.12985284127424823, 0.2895523459320244, 0.21612566474291373, 0.20596372944423413, 0.13433703365113048, 0.21315967858202212, 0.21649215065034522, 0.214491535791284, 0.22593110635419733, 0.2282486676828548, 0.244929927043684, 0.26055658093417855, 0.22432890026687624, 0.22541095846221393, 0.19753164688162306, 0.25689626427647494, 0.10599091121646687, 0.16330029858828143, 0.0075040043654096555, 9.999999999998899e-05, 0.18127287752475751, 9.999999999998899e-05, 0.10273752031442218, 0.054680647265767046, 0.00010012575109719091, 9.999999999998899e-05, 9.999999999998899e-05, 0.12484469264801423, 0.03016260913956814, 0.10092879611564298, 0.057135193945678675, 0.02872131109154219, 0.035212193171398565, 0.14885952592777252, 0.07618000283798898, 0.10478536052344789, 0.05307616391873182, 0.0507243146231503, 0.06126382473792169, 0.22985800329256467, 0.2197747223465204, 0.08150905869656566, 0.13151487881586021, 0.10299928211577447, 0.4839199006814432, 0.1267030187072754, 0.29426693030250917, 0.12075917032327432, 0.07918217588966014, 0.1774314941461662, 0.04352964974762219, 0.08453012047452213, 0.15143171263092758, 0.08396955724415966, 0.537885350292115, 0.6000061152296403, 0.5211550879468796, 0.5399944708095986, 0.5722628460785679, 0.5522782816957341, 0.5818456673810777, 0.5940502115188208, 0.5655686316589452, 0.13834582844057985, 0.13069752202926233, 0.110357919064899, 0.10916896235014484, 0.09416838051015952, 0.808048277212712, 0.09211987670348831, 0.13813690680786372, 0.11777223473845155, 0.27531709175894126, 0.28961692850735854, 0.41454948942112013, 0.13959145477757406, 0.2931709749390453, 0.1998458800199734, 0.2526140824361983, 0.19749373831697037, 0.21542547235848242, 0.35421243454629425, 0.4138919776808925, 0.37311675498964836, 0.37758672369978374, 0.44879994929714595, 0.3939894025755406, 0.23479779951984692, 0.23677666709423206, 0.23085027511969114, 0.25155934225326204, 0.3459345767666313, 0.18994096372871205, 0.21402222426099649, 0.2280284110144476, 0.29836132877599564, 0.21047909123333974, 0.20539574122812398, 0.29408160379159376, 0.23629095616707085, 0.22156194272117502, 0.24110943724079292, 0.258661077346085, 0.26855721777335306, 0.23665213066307733, 0.23066319942854818, 0.1984986374760045, 0.19484209916262052, 0.8618541922551143, 0.2084444825491374, 0.21204501790333108, 0.22217096512282364, 0.22954181538024743, 0.2174506986511453, 0.25378172002552235, 0.8493097255370504, 0.20299765085985977, 0.9392031845942276, 0.9427276497983016, 0.15359215322913955, 0.9420184060329676, 0.20180546955706524, 0.20183697014004331, 0.15433168397683095, 0.16846276047814823, 0.17724854296978632, 0.6507225803714713, 0.21272803762967607, 0.7758740442154297, 0.7472807903693399, 0.15622105885383641, 0.2091856140877194, 0.10512795434354616, 0.16596353752502524, 0.7769133277051274, 0.20971000888831626, 0.19769071358636325, 0.24563234925846966, 0.19111760314555826, 0.19495345919350926, 0.19867462354682053, 0.21796448039209315, 0.21170043702526742, 0.2271589549223485, 0.10386341598842841, 0.10956957574733694, 0.09376395626412592, 0.13186193792310075, 0.10474144458176193, 0.130486531270942, 0.0890014045094284, 0.09966621205597315, 0.07607898031777549]}, "mutation_prompt": null}
{"id": "a634a2a0-420d-46ed-bf55-784a568e6ea8", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n        self.stagnation_counter = 0  # New counter for stagnation\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n\n            # Introduced velocity scaling based on stagnation\n            if self.stagnation_counter > 10:\n                self.v_max = self.v_max_base * (0.5 - self.evaluations / self.budget)\n            else:\n                self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n                    self.stagnation_counter = 0  # Reset stagnation count on improvement\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n                    self.stagnation_counter = 0  # Reset stagnation count on improvement\n                else:\n                    self.stagnation_counter += 1  # Increase stagnation if no improvement\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive velocity scaling based on stagnation detection to enhance local search efficacy.", "configspace": "", "generation": 69, "fitness": 0.3143975517228065, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.29.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9128229433570315, 0.9085682684429384, 0.9195637110953562, 0.9224831693200417, 0.9127339273524163, 0.9185166784792151, 0.9193344395500527, 0.9172696960626727, 0.9119158891948291, 0.8323920998850334, 0.8218580896152596, 0.04221212075077585, 0.8210198251646181, 0.04700494351928519, 0.8299098955478103, 0.05267255140907001, 0.8257169279407618, 0.058133739178870214, 0.11765929047839074, 0.1873215259456562, 0.15850861728360288, 0.16437061341253234, 0.18300330957592004, 0.12048720056029594, 0.09303417099362321, 0.16195055035166084, 0.08824468923816786, 0.14426460697960208, 0.15770834618886986, 0.15666663331844644, 0.13415519654053865, 0.1223094208627683, 0.13119164677428674, 0.09603923152080951, 0.15827825524614614, 0.1137734549084527, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.8044271483685186, 0.8183953163981512, 0.8236349026208423, 0.8034336454388066, 0.5916892410133122, 0.6958081304214228, 0.7084214961598735, 0.6943577466514403, 0.771905685119198, 0.2320459181492176, 0.1940499297220245, 0.21239412295451354, 0.37101279178573, 0.20532833872956047, 0.21258217277955005, 0.20496670414729934, 0.23606080531232743, 0.40086821723637966, 0.1279454132436676, 0.5464423957209995, 0.2114388280325621, 0.2270436422384351, 0.1360558114271837, 0.2051080330671522, 0.2635374170474034, 0.21197242054706145, 0.2285727920983205, 0.2313513384006689, 0.1956066357390951, 0.13385484941692138, 0.22232433632630588, 0.13053834068771064, 0.13595674609921937, 0.26273206019435813, 0.10548882590797637, 0.2317246614635432, 0.01489898722222549, 0.018966050359631614, 0.07812235454771399, 9.999999999998899e-05, 9.999999999998899e-05, 0.03527073213293497, 0.0013383587802873187, 9.999999999998899e-05, 9.999999999998899e-05, 0.11074412138747025, 0.05197347006904052, 0.09815746284761517, 0.05783608213079494, 0.0571737502535008, 0.014594940877249774, 0.12018328920579024, 0.0796303772746152, 0.10415866985555389, 0.05046227272383963, 0.05154773662749701, 0.0628050725773186, 0.1655001124984785, 0.081972866526546, 0.08342063420486534, 0.33248324953936204, 0.10381899013301477, 0.2658487633900649, 0.12529360182063842, 0.10625704002595504, 0.1363464008477242, 0.06883050274137315, 0.08977325341690634, 0.03975696569441389, 0.08565420868939344, 0.11193284333364373, 0.08401367338438781, 0.535048111488232, 0.5484998655724033, 0.5453989045222274, 0.5855584309905559, 0.5302456341170464, 0.5545139464219456, 0.5915670540023064, 0.5646118350758942, 0.5693959566526052, 0.12278207816058351, 0.07971630045959033, 0.09649862508661533, 0.10142972131619299, 0.11517659948467718, 0.14584963186618316, 0.11680984736614775, 0.14214908851973906, 0.13415343973427574, 0.252075851061902, 0.17283510823096426, 0.17473924460693868, 0.2952187155199607, 0.47139595219067976, 0.32972742521594167, 0.22805011542064146, 0.25044701627114996, 0.2197669866260601, 0.24934814834968333, 0.38930127804103243, 0.3390674418361622, 0.35587002988049166, 0.34550934868185945, 0.3764261574540988, 0.24015685281652477, 0.42261173885362235, 0.2153601082432306, 0.22746999474250895, 0.24271871462046435, 0.16152762458833403, 0.23773766966837406, 0.24451989320355028, 0.23012822217612316, 0.199210198245807, 0.21340864114829838, 0.29437983394205436, 0.2641296830414088, 0.22687979268000302, 0.20246154259393523, 0.24368843730888823, 0.2626410062458292, 0.2065760830345712, 0.2581706811175958, 0.21344740951321306, 0.21652624408184207, 0.2214459079380665, 0.25428513357050897, 0.19875968153791423, 0.19736362986469613, 0.8724612168261364, 0.23041134023626886, 0.22312994069436898, 0.21270357314862642, 0.25361386843630784, 0.9309437122059222, 0.940989905226213, 0.1529931502067884, 0.9439665050067813, 0.20144388538045754, 0.20182542302718043, 0.15360274782355532, 0.16853332204523763, 0.17761070438931859, 0.5033519052377307, 0.21281756230515192, 0.6782062760490021, 0.6581859183709943, 0.15534976749045548, 0.15569601062586624, 0.10509966813224803, 0.16780575951228127, 0.75449122938753, 0.20485838055044503, 0.2084453832623573, 0.1914067512006904, 0.19051472054136198, 0.17749202217115656, 0.18928736556651293, 0.2088511611239955, 0.2264491017771284, 0.21285170270901144, 0.08995164534429789, 0.10966581240145756, 0.07980876526593672, 0.13921257258239816, 0.11001367771785642, 0.12151890431924617, 0.11074434415157519, 0.12547587464348364, 0.10721320016089542]}, "mutation_prompt": null}
{"id": "87a00d50-9521-4fe9-b927-024183c09835", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                # Updated line: dynamic learning rate for global best attraction\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = (self.c2 + 0.1 * adapt_coeff**2) * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced global best attraction with dynamic learning rates for better convergence.", "configspace": "", "generation": 70, "fitness": 0.33647725168396136, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9107575726634594, 0.9097664229907262, 0.919310266506697, 0.9154911416443293, 0.9110854257185361, 0.9158022543327903, 0.91203154932884, 0.9141218794173833, 0.9100355962869636, 0.8169930092833646, 0.8192111979301642, 0.8223991632986589, 0.8105967735359905, 0.04742388645501194, 0.8429971534270345, 0.8252399786887789, 0.8357762196635149, 0.8170814994590271, 0.09200069106248898, 0.14174712423799052, 0.1858361964942249, 0.15950071398362398, 0.1900565350914809, 0.11582193154224829, 0.7256318822548422, 0.15840039557042362, 0.12090707510554077, 0.14092727053813237, 0.14090892711498149, 0.15370838178680002, 0.14478028479204208, 0.1343044065005784, 0.1234904797989046, 0.15866457003661816, 0.11556557172621884, 0.1145377743121806, 0.9870219149135304, 0.9897971458183039, 0.9893400028740702, 0.9903398984564524, 0.9876587918584099, 0.9845640517244798, 0.9846034802445428, 0.9856284601670049, 0.9809079147247652, 0.7444192774169515, 0.786601473089775, 0.800971957138705, 0.8024653485862425, 0.7536647836705364, 0.7374504596913858, 0.7803751589443217, 0.744363964249201, 0.7868741300832234, 0.24632512906807147, 0.22409702891555194, 0.23161108771962313, 0.2818119128085663, 0.2752599415878594, 0.28041996282580084, 0.23355964255541972, 0.24654003635321708, 0.40086051578325643, 0.13202487282727182, 0.2129396668293282, 0.2089309986097576, 0.13300310291650097, 0.20361307746085544, 0.13169546797538256, 0.20566376163858624, 0.2223225726725757, 0.2301862745112746, 0.22937567078260768, 0.22321405983225973, 0.23038977669593974, 0.2204156213783175, 0.22627323324458348, 0.21233886225191867, 0.2627026345320731, 0.2507356809437066, 0.2530344626868797, 0.05670870864279054, 0.006551457479963774, 0.008541954789008877, 9.999999999998899e-05, 0.05399455037774037, 9.999999999998899e-05, 0.09698515464250779, 9.999999999998899e-05, 9.999999999998899e-05, 0.17600621014197293, 0.0725645563452777, 0.0723787991815974, 0.07278212264363937, 0.02462411688261168, 0.023436063089022907, 0.13270253509770158, 0.14431526642877457, 0.05973573186754366, 0.0506404395327823, 0.1136987262628858, 0.04750349978085777, 0.1314147432927466, 0.0802159758137363, 0.07899895772987509, 0.07446349142635045, 0.21210689937130434, 0.15904043925998612, 0.050180267108073884, 0.0856280123663622, 0.16244354656533377, 0.1460673922003365, 0.12455969338695738, 0.09262104590740439, 0.10981153997720772, 0.13059222558698802, 0.08424387207732831, 0.5938951687488905, 0.5328037647577177, 0.5177756949453111, 0.5246141705841263, 0.5977193652157116, 0.5541725659469566, 0.5616264709527219, 0.5750488663719664, 0.549541944549035, 0.07994204965247376, 0.09513183708727102, 0.15016225632654057, 0.09717024476694003, 0.15458688836812617, 0.09571464176901334, 0.14370443061878413, 0.12819841344483518, 0.11338698626746424, 0.24300414267681014, 0.5098660964483172, 0.18151996586157548, 0.3086339633182522, 0.35591970612010027, 0.34973594077264836, 0.22712490037062794, 0.1801815230927104, 0.21098162882083704, 0.2896415111097004, 0.3383527309973069, 0.2740941129088327, 0.3607914981030109, 0.47381221883345337, 0.43034939359934654, 0.23561403849394202, 0.3332239029283681, 0.2123513409127249, 0.19603357792735332, 0.3591947957701632, 0.24633848268860292, 0.2404876534144067, 0.25978000406921975, 0.2065743649944769, 0.20628308049164945, 0.23105081712309772, 0.2731282741943053, 0.23997277751122736, 0.29427580319685276, 0.21604694177313943, 0.22244123314395847, 0.2518550835276021, 0.22287573759240087, 0.22104323688814764, 0.27507324732971516, 0.25691221731435243, 0.22483414833636084, 0.2498910958004379, 0.2053175332791215, 0.2180625726306794, 0.2552512919705425, 0.21031442714313375, 0.7946266201260558, 0.19720480452038514, 0.20808208190135602, 0.9380812882708467, 0.9243767381523124, 0.15429300119411704, 0.9358967789804228, 0.2014726893934451, 0.20155512763066097, 0.15354660419478028, 0.1685773071017993, 0.1683170242336981, 0.7338057108863525, 0.21334301436645053, 0.7606815205268094, 0.7716919946399263, 0.15598689123428067, 0.21081128838117225, 0.10505856650946355, 0.7702502425557377, 0.810745664376013, 0.21339260724358566, 0.18719173325274163, 0.21981611842955961, 0.20957870935124878, 0.20880207854752175, 0.22537334127544806, 0.20546865959393368, 0.19988401610421713, 0.23022747339133642, 0.08863845032325879, 0.10335387330639567, 0.09204358475765162, 0.10122034690092518, 0.09586246864770886, 0.1783059233332902, 0.07381665787137504, 0.06853107626075183, 0.10047904521886686]}, "mutation_prompt": null}
{"id": "00e013ed-e366-4f3c-bbb5-aca3544b5ae5", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "762612c7-9559-4683-abd5-cabfe043e06b", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.momentum = 0.9  # Added momentum coefficient\n        self.prev_velocities = np.zeros((self.num_particles, dim))  # Track previous velocities\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)\n            self.c1 = self.c1_base + 0.5 * adapt_coeff\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.w * self.velocities[i] + cognitive_velocity + social_velocity\n                                      + self.momentum * self.prev_velocities[i])  # Applied momentum term\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n                self.prev_velocities[i] = self.velocities[i]  # Update previous velocities\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced a momentum term to enhance velocity updates for improved convergence.", "configspace": "", "generation": 72, "fitness": 0.17077580878959395, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.2891275672437257, 0.2883224679120956, 0.3102474430972483, 0.274997035067332, 0.27888722636659236, 0.289621196318545, 0.2884006686628928, 0.26570779404855127, 0.2745350555911368, 0.0018378855284232332, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002950272221352357, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09302316557055235, 0.08332834963762403, 0.08725982532338783, 0.09504710356530544, 0.08692130358421202, 0.08371853345483338, 0.08727500441410374, 0.08393697071158679, 0.08046707845468115, 0.0854329358811523, 0.07747221896079515, 0.08858534811477659, 0.06490090585768571, 0.0644137722101874, 0.07210784134312853, 0.07116220923044603, 0.06805391383358905, 0.07066580476582074, 0.9917866719370214, 0.9901368333276185, 0.9921886849149658, 0.9919956490926896, 0.9897539113559967, 0.9241878681948867, 0.9849306402453779, 0.9896657170149423, 0.8694808082386594, 0.16500948767749757, 0.17128167908865666, 0.18293709312552353, 0.1842831653400414, 0.15182392224861674, 0.14832723415079074, 0.16433647122835826, 0.16879156431072662, 0.14200457314862414, 0.23239548463315074, 0.20982397047172907, 0.2431249799379831, 0.1819507510658922, 0.15409819552794435, 0.18255588232731745, 0.22615183096774294, 0.2258821965507697, 0.227831957145038, 0.0932866057552626, 0.08630231238433206, 0.08551976692614771, 0.07321233427969986, 0.074903637459385, 0.0745298186838077, 0.11332868579809896, 0.09463138915396885, 0.08507821604406907, 0.08327335788404255, 0.07344158346533136, 0.09102072517481097, 0.09509943213155547, 0.08755103081030158, 0.08830388603143513, 0.09434058450842986, 0.10582840390293624, 0.07935345956481366, 9.999999999998899e-05, 9.999999999998899e-05, 0.009419993672429738, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002344984609536138, 9.999999999998899e-05, 0.10571065795879409, 0.04671729241301348, 0.057411745160997785, 0.07826913759033627, 0.014677058381070474, 0.1338719830733357, 0.08564012520305209, 0.09720604677397571, 0.039839001025135046, 0.00022762732786740791, 9.999999999998899e-05, 0.00010295330618026455, 9.999999999998899e-05, 0.0006990435272690165, 0.00045085655160070903, 0.00015851024230473243, 9.999999999998899e-05, 9.999999999998899e-05, 0.04205249036183545, 0.0361110210945913, 0.02687048926762059, 0.018255513665778378, 0.0013684819777516344, 0.011303887612832075, 0.033903118501088514, 0.01561208597450281, 0.04156521764332155, 0.30224851120806695, 0.29065678836072173, 0.28076378808694114, 0.30195783438294377, 0.2915926396046462, 0.2927189635461179, 0.3041191758780084, 0.2960620439490602, 0.30532028382176624, 0.06476353919599931, 0.06158187119053671, 0.05322574589151885, 0.0933655483599628, 0.07813763543915808, 0.09271843389198908, 0.07518065069826241, 0.07715369505536929, 0.07577362602693938, 0.14956471077422684, 0.16563054345781947, 0.13541580299939648, 0.1553105029684535, 0.1505366561164625, 0.16471100510975845, 0.15563579301441588, 0.16158311720030583, 0.1591852297846159, 0.2149576336964204, 0.19548700139088016, 0.20472949675705376, 0.2153069527311301, 0.227721339667883, 0.24645423736026784, 0.2214783640426321, 0.22433555236913372, 0.21220088791326452, 0.1568749518499979, 0.14691486886540495, 0.1557008847944118, 0.18023900410309035, 0.16386669675115773, 0.17894947985190357, 0.1605962804141634, 0.1388076149390105, 0.1606482263488579, 0.22482956126639286, 0.1925717776762016, 0.2002097223494992, 0.19507189609908293, 0.1941729066987924, 0.21824185872649426, 0.19853851323674665, 0.19006039573585476, 0.20174931536081542, 0.17271183685508873, 0.19361970059789202, 0.17093728173852019, 0.1867188186266875, 0.18002727355809145, 0.1798748860354068, 0.17753159823716125, 0.18844102041883082, 0.1915911712322469, 0.4112022308362129, 0.35845439321361716, 0.14678919298682502, 0.398336911492176, 0.17635211245898685, 0.18072741593136665, 0.1417949659810407, 0.39807295438873236, 0.15394925496928513, 0.07875009014132339, 0.17588810498913132, 0.3388512059453527, 0.21132162184627146, 0.28836101901784783, 0.19246414032905468, 0.17780459163719098, 0.1607993765784328, 0.33907710701901506, 0.18848205184289724, 0.18095192406705662, 0.18236183597929834, 0.18046746783805467, 0.18445394804215998, 0.18558249032196572, 0.19553109990565332, 0.1919884551465132, 0.18224456066831785, 0.07765730295889006, 0.07775491302744741, 0.07788542321135739, 0.08353147906386371, 0.07584697371863225, 0.08187851078912356, 0.08120232613116529, 0.07735757633783635, 0.08057785231529269]}, "mutation_prompt": null}
{"id": "bbaec3aa-975e-416a-9211-825a1c0d83a2", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        levy = np.random.standard_normal(self.dim) * np.random.pareto(1.5, self.dim)  # Utilize Levy flights\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + levy * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced mutation strategies by utilizing Levy flights for improved exploration.", "configspace": "", "generation": 73, "fitness": 0.33810139675805684, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9141626567619666, 0.9079117171478901, 0.9232447098925085, 0.9139840855109915, 0.9095004167212157, 0.9158875957949717, 0.9081377079579566, 0.9153892350590933, 0.9112564080233521, 0.8389769981343155, 0.6489630724879116, 0.8302852834497226, 0.8345765610716058, 0.813562129192662, 0.8420594885859224, 0.05342218078150396, 0.8119930691133839, 0.6198303960462183, 0.11353736439024364, 0.18067716206552686, 0.7562097765570469, 0.14208140756200138, 0.11672278532164604, 0.1588364038503729, 0.1814647818167776, 0.1553341987258, 0.671786319107004, 0.18536696481422832, 0.1586062645640457, 0.10868491995774399, 0.16170868211538458, 0.10540543484758069, 0.14040584984626348, 0.1403277529028092, 0.11292014969295128, 0.12755549727818472, 0.9856653809140175, 0.9854401477703473, 0.9877696124969343, 0.990237142058295, 0.9871295568405088, 0.9847382209527337, 0.9917778418035429, 0.9847654665099923, 0.9812704259216862, 0.6997321113005162, 0.6875969842758431, 0.6495371121010746, 0.7873488611621944, 0.7585951754351591, 0.667587770998531, 0.7569893363832074, 0.7886861862742738, 0.7757625984182497, 0.8929722993459651, 0.33330495986835973, 0.7093167543207441, 0.937373953858801, 0.2196969646176028, 0.3812349246212319, 0.2352932230378133, 0.1977494677017736, 0.3357651994844405, 0.2906453075340071, 0.2092083256974765, 0.22669677529014765, 0.13232768069133294, 0.20193339656962495, 0.20759631354056418, 0.2095778320661229, 0.22508151164738766, 0.20021010993418864, 0.23237930952214114, 0.22486482334059466, 0.2221677180298831, 0.2590195730118282, 0.23573074966499263, 0.31889765883198185, 0.24042492822525685, 0.1316431311202204, 0.2494596483793049, 9.999999999998899e-05, 0.013414096402521114, 0.012710952891209826, 0.051332755326485624, 0.013187576583277627, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09750458740865742, 0.11045691895943766, 0.056621282850769394, 0.16888595120706018, 0.056913280522144616, 0.0062783091741517305, 0.0595152673872984, 0.12023534624173826, 0.06325427993312638, 0.11988478960234317, 0.050848349441728224, 0.07866623339069245, 0.04231025474772865, 0.08021200524789762, 0.12496348754298392, 0.08476408925559986, 0.1265266819787334, 0.10324896851293053, 0.18067082351979913, 0.1138380420733538, 0.04948057762682734, 0.1639964486677019, 0.0899082986191394, 0.11040190754638046, 0.04843783865623086, 0.24507615208113576, 0.10065603788884891, 0.08368708174290873, 0.5209066728273959, 0.6580010255061014, 0.517011962879073, 0.5808189772201939, 0.5650451640492546, 0.6140836012670434, 0.5726237771415443, 0.5617813456815925, 0.5584659374266592, 0.08316653508503657, 0.0820090261908557, 0.11772488979542162, 0.08561667259479577, 0.0770506682273453, 0.08573626261796086, 0.10023112789624156, 0.10913540802702137, 0.13694732158757483, 0.2667917400964931, 0.2653913953235172, 0.4096245106591918, 0.20243227796569785, 0.2680261317796159, 0.1852029074626892, 0.2567781310188849, 0.22481484653606731, 0.29146625893338196, 0.44396986209373734, 0.3746291927024932, 0.2985976269370011, 0.4346917073930884, 0.2837541376483943, 0.40290639067556944, 0.2412745175427845, 0.3590576371362013, 0.6467163888574653, 0.23624676048270665, 0.34331210832119063, 0.20486457346521947, 0.36392947949606325, 0.2181712632731988, 0.21124313145455353, 0.18121780753800754, 0.254597381312095, 0.29573402404069626, 0.26750048706002816, 0.25592212295667804, 0.2524464931555369, 0.21917753767834092, 0.2267708873431914, 0.2348935005675148, 0.2747765720091273, 0.2255377664226378, 0.2331900920988752, 0.22492808405677545, 0.22985205392970187, 0.21613352785265183, 0.2514483842411094, 0.22348687106682663, 0.18779076898551794, 0.20632860019821364, 0.22717366018181173, 0.21701879098720678, 0.9354756734853855, 0.18741671206603783, 0.15447402864772997, 0.9312596917411, 0.20122482650613538, 0.20180708813868198, 0.15383923614973116, 0.1678609827029901, 0.16765792196794171, 0.08326950335271777, 0.21287228671627945, 0.7804793390484736, 0.883120873944719, 0.6363520857661092, 0.21081528347063772, 0.10499189112570928, 0.0948557744909827, 0.9110370481301503, 0.20030702133192257, 0.22487290081042333, 0.21027437562332774, 0.21542426321693542, 0.20925523747157337, 0.1923440711749167, 0.20860929906664682, 0.21618437959440762, 0.23957565804066705, 0.10842064003712804, 0.10102024150332223, 0.10278893273709233, 0.14056315166421895, 0.09247587561013093, 0.1270195454656292, 0.08355565905198115, 0.09434980313782648, 0.10760905804121412]}, "mutation_prompt": null}
{"id": "653cc273-b72e-47ac-94ec-4cf7b8c85b99", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "25ca4b88-083f-417e-8a52-03f8cc8f6642", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "d3623e6c-bb69-4984-bb5c-587a7ac58fae", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n                # Orthogonal learning\n                ortho_basis = np.linalg.qr(np.random.randn(self.dim, self.dim))[0]\n                ortho_positions = self.positions + np.matmul(ortho_basis, self.positions.T).T * 0.05\n                ortho_positions = np.clip(ortho_positions, self.lb, self.ub)\n                for j in range(self.num_particles):\n                    ortho_score = func(ortho_positions[j])\n                    self.evaluations += 1\n                    if ortho_score < self.personal_best_scores[j]:\n                        self.personal_best_scores[j] = ortho_score\n                        self.personal_best_positions[j] = ortho_positions[j].copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = ortho_positions[j].copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced orthogonal learning to enhance exploration by leveraging the orthogonal basis of particles' positions.", "configspace": "", "generation": 76, "fitness": 0.2196744832979044, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.502956853604362, 0.50894047965788, 0.4831183044915247, 0.5164490841158804, 0.5123763187342245, 0.48420834590368855, 0.5167836562851553, 0.4664093949086121, 0.5058272814653078, 0.14680397462554717, 0.05071710262673024, 0.06838104500826048, 0.10341371492436935, 0.05813442077506692, 0.10396804664039194, 0.06193532359460496, 0.07596757703801027, 0.1094966198655607, 0.08018471821118545, 0.12423919815386075, 0.07848048986115741, 0.13714132158438275, 0.1048668439076762, 0.10405462548600042, 0.10869227285375038, 0.13921165066625163, 0.0815368274157876, 0.09514352626042633, 0.1060279056851341, 0.08063203834988142, 0.10374283779819815, 0.07998547429487479, 0.09883865141615333, 0.09634248955624647, 0.11495194428592881, 0.08790823650158086, 0.8532445259799537, 0.8652879791993409, 0.9121761178289696, 0.9038075157401422, 0.843542361154196, 0.8638214958028224, 0.8447246085720375, 0.852552089404713, 0.7900056188268098, 0.25347522939264777, 0.29066684371459905, 0.21618725302133157, 0.2777670882064416, 0.25428701093397144, 0.31877669591358804, 0.2595090069817583, 0.26927598588522794, 0.2285952057903018, 0.5773344826728458, 0.27532928189770256, 0.152212561150333, 0.596568553251516, 0.24336037015955003, 0.24104048096794495, 0.2127912075416346, 0.2562670437805331, 0.21899887886911495, 0.1654993818300725, 0.1579092602236486, 0.17075129486671448, 0.10833542742740354, 0.16015689951025214, 0.18406642975235554, 0.14930974400867836, 0.1320424452507556, 0.13507020153957783, 0.21570388332941126, 0.11161595038932992, 0.1712725597222916, 0.16012916826009715, 0.16224011243181669, 0.16167312978920578, 0.1758978336101864, 0.08559721257873121, 0.16322485567123768, 0.026810861448458123, 0.043111304793049365, 0.043660321977790906, 0.0002102612020922212, 0.00035802328952994067, 0.0007921181070632555, 0.024252302064755926, 9.999999999998899e-05, 0.004745543917104023, 0.1804543148321729, 0.10641762546958311, 0.08420050012883384, 0.06834086968897812, 0.03160149942667889, 0.03787292892003802, 0.06809537533393228, 0.11117862270813117, 0.06097233654934864, 0.01482297660516907, 0.03511962529102097, 0.033898295320914484, 0.002431821114184607, 0.03549921782943677, 0.029497562379044773, 0.030532070393653354, 0.031841706550829296, 0.08670222099909985, 0.086832216125599, 0.12042171794963197, 0.11891833101552252, 0.1006546220438016, 0.0935360007479159, 0.10747116493324227, 0.11973799556749476, 0.08576741895937412, 0.09910869261698885, 0.4095370997401173, 0.4179802661811314, 0.39182468645766966, 0.3893949850818793, 0.3758693758942523, 0.4175040368188411, 0.39009184782878814, 0.4163925647041514, 0.39905513850598506, 0.10394786698868097, 0.1022195196841309, 0.0927889698079487, 0.11970904586803266, 0.12945222397133205, 0.11672660835819992, 0.11934615391488002, 0.1131325726314304, 0.1167594853428372, 0.1504552653024146, 0.23801865124127008, 0.15595024292972648, 0.2610928120985332, 0.24019636452372783, 0.20265740616994932, 0.22329957366267406, 0.35164668446050484, 0.17753850493883327, 0.2579134005136089, 0.2499645861213462, 0.2595970709297526, 0.28995478129033536, 0.28104317789341227, 0.25886621959768086, 0.2999769747563703, 0.2990598401433584, 0.19223788215080118, 0.19273174047168018, 0.22731136485062875, 0.18990969811804936, 0.1728676992645164, 0.2321130558819997, 0.21910035977460063, 0.21445264775142603, 0.18867013230507335, 0.17935218753724058, 0.22193524916164253, 0.22062079488609754, 0.2141168992359268, 0.2097958930243896, 0.23145930139566262, 0.233649966842002, 0.25137241468028326, 0.21954887048688265, 0.20240170703788907, 0.19280959730434577, 0.21297939347309203, 0.21180347159415325, 0.20232604702660617, 0.22167568127898252, 0.2019421364459536, 0.18531775854802912, 0.18393757968903635, 0.18168724124432556, 0.680485982621658, 0.18004610342590988, 0.15138784570837527, 0.6895953051173472, 0.19580873120392406, 0.13329385951649841, 0.1465436793686038, 0.16389240228056623, 0.16122834159678512, 0.5049140019452762, 0.20242696452587505, 0.47981893746976756, 0.2020779064793895, 0.15870001972988323, 0.4573183904631817, 0.2920994412089124, 0.3187316994064794, 0.3256225621523845, 0.1801875393817456, 0.17826554815394535, 0.20603635307968837, 0.20732647588163045, 0.19693357406659262, 0.18419064185046352, 0.17475131528544352, 0.18386807849180342, 0.19006395249630592, 0.0888138310338753, 0.07902887917390311, 0.0891574398377083, 0.10855288511724592, 0.08483143975422458, 0.10457007084403447, 0.08691497889805855, 0.08309296434867719, 0.08608112893016662]}, "mutation_prompt": null}
{"id": "57734bed-b24c-4f03-81f6-ad75b52bd5e6", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            diversity = np.std(self.positions, axis=0).mean()  # Evaluate particle diversity\n            self.w = self.w_min + (self.w_max - self.w_min) * diversity  # Adaptive inertia based on diversity\n            self.c1 = self.c1_base + 0.5 * adapt_coeff\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n            # Random restart mechanism\n            if diversity < 0.01:\n                self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n                self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced particle diversity through random restart mechanism and adaptive inertia based on particle diversity evaluation.", "configspace": "", "generation": 77, "fitness": 0.29100999141468664, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.6915097082659107, 0.755647649498967, 0.732935245931513, 0.7291750573045666, 0.740093634161536, 0.689244117894082, 0.7496748872481521, 0.7228524605905693, 0.7192806012426001, 0.406797895590552, 0.37529321116683745, 0.36082106148136117, 0.5410285602381948, 0.04946715697193793, 0.3222091420364893, 0.3902575960252298, 0.3618015342005917, 0.363415642036256, 0.5536004253537903, 0.1282005743928072, 0.14953013825785366, 0.14903017158353027, 0.1420757398607182, 0.7774377185258452, 0.12860414520120467, 0.12357220256448731, 0.09111407944854233, 0.10800625779017703, 0.13966876606183198, 0.12016052811648947, 0.13609094703782298, 0.0877232546560901, 0.1414532103796804, 0.15129362305938, 0.13410178284616903, 0.11353543227768859, 0.9881601395457759, 0.983069030293374, 0.9919605899744973, 0.9902568673819545, 0.9902150546309159, 0.981403446943778, 0.9580808275199746, 0.9901631321556429, 0.9781562907179197, 0.6863053244377904, 0.6332711028314801, 0.4563305346310226, 0.57890912646766, 0.4517415987053506, 0.5262617034864812, 0.48789116022818624, 0.5104078000992832, 0.5624085925671843, 0.3649282064113565, 0.2262358773772286, 0.6211225748192226, 0.6113651059601852, 0.17637717339876346, 0.21003600596909422, 0.1791522572927735, 0.23225298357415924, 0.6443927090417942, 0.25816247887276444, 0.20254072290588399, 0.1273857087626128, 0.20058774182930106, 0.1920294002088535, 0.1339017448993607, 0.18536080143905231, 0.19230771477178765, 0.1877477221001198, 0.13461889826574347, 0.19699545987127887, 0.23281184847429137, 0.2087956478239431, 0.20172912209929883, 0.2108129730333318, 0.2597466897212344, 9.999999999998899e-05, 0.2406421757782895, 9.999999999998899e-05, 0.022390262497570035, 9.999999999998899e-05, 0.037837390396515014, 9.999999999998899e-05, 0.00013577516525897781, 0.0024593904748207995, 9.999999999998899e-05, 0.00527304842918197, 0.07373220883748799, 0.051864931073181686, 0.12210899081674487, 0.11971708424234495, 0.01696889779870403, 0.02500728268190977, 0.05871353336501761, 0.036185490922794106, 0.043489453026570146, 0.04917594077024545, 0.11381014544200885, 0.05306361293899353, 0.15081723062807173, 0.08371279014910127, 0.0785402447045066, 0.07386245109235312, 0.1074040918961966, 0.08414278921554419, 0.04397061020960713, 0.0190206135023695, 0.043484052940175766, 0.07666492969281402, 0.17149400113546964, 0.26059236423247956, 0.08480434802930481, 0.05377805768613764, 0.15390817202842244, 0.4710211257678969, 0.5261244834559122, 0.5784653269867203, 0.5336147539939471, 0.5638024501023587, 0.5206801479598993, 0.5181342984095919, 0.5363032427733213, 0.5312917449140929, 0.10716483892433948, 0.09114090254192453, 0.10574467492725037, 0.11745252825903774, 0.1199480833396569, 0.1406714188141054, 0.12106162621584371, 0.13052004905373238, 0.10062378302286179, 0.1862618172668965, 0.19980616853593802, 0.2924538538202769, 0.22517563554733155, 0.23543263976217, 0.21107440747208805, 0.1626808380443412, 0.2693077820723826, 0.15825754664030245, 0.3930238500034715, 0.4075535420659123, 0.3480452201986044, 0.37825329417922227, 0.39766601877363694, 0.3283831414408793, 0.41784916009857154, 0.31282694277662004, 0.2164621617836684, 0.3070426115901489, 0.20151773040913945, 0.27898717247506133, 0.2917092645955439, 0.21327026152506312, 0.2640748589098407, 0.2036835377028694, 0.18961712315146506, 0.23369242810668744, 0.19461648440951185, 0.21830481585002603, 0.19535141029745384, 0.21258557267835454, 0.2382598980558761, 0.2425007546371558, 0.23440141188138575, 0.25893097820934596, 0.2217253978974133, 0.24663315891650817, 0.24008851031841805, 0.7198115647152997, 0.2204912087334303, 0.2505740318251062, 0.1795303199698961, 0.23897932382455178, 0.18919724662263826, 0.2393836132702174, 0.9328096235736576, 0.9145973006213901, 0.15191095660011056, 0.8557923264627652, 0.19864115276592087, 0.26755069122941766, 0.16017249655656796, 0.19416799380757865, 0.28674943040824585, 0.45945055382907707, 0.21294693691845545, 0.5244679797118469, 0.24804314722444232, 0.16478778751860335, 0.20515585389265178, 0.11799607602151552, 0.16622663842915064, 0.7167003029321102, 0.1842689523446247, 0.18750141384856822, 0.23977372267660768, 0.18052757369678096, 0.1742435855319815, 0.18540806223174933, 0.23443442283538785, 0.1833998591953072, 0.20635931425581377, 0.08729136529788772, 0.08429188877775684, 0.09259296838658315, 0.11835473112911221, 0.09136406694004795, 0.09718856113014096, 0.09230855225667678, 0.09800952505001803, 0.0910657283191858]}, "mutation_prompt": null}
{"id": "41ab91ab-7604-467a-b8c1-c230e72a2c45", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i]) * adapt_coeff  # Enhanced mutation scaling\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced diversity and local search balance via adaptive mutation scaling.", "configspace": "", "generation": 78, "fitness": 0.3435792368639203, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9188108805110926, 0.9137093105452835, 0.9160930298547793, 0.9115862530475703, 0.9133306286700937, 0.913513657979451, 0.9122407339607514, 0.9076587435131526, 0.9091346086516771, 0.8402371598665559, 0.8238076002318898, 0.04148143371833901, 0.8340640951798367, 0.04716761621904919, 0.8396937697540969, 0.8262715256635285, 0.8300170084449786, 0.7988551553999925, 0.15883717308673528, 0.12352263291904197, 0.1569915441377676, 0.15986791380842025, 0.12539292170266747, 0.16049616980469328, 0.14988367858502716, 0.18834878916458775, 0.0974237499066467, 0.15198790310364052, 0.11066602240302215, 0.45927304228017907, 0.11039127910295043, 0.11640659206393755, 0.09618926838589892, 0.1057033155150019, 0.13962669583828136, 0.13161013051376613, 0.9870367776634208, 0.9897862315582255, 0.9898574855132555, 0.9910021245556917, 0.9876223217773356, 0.9858885845951808, 0.984578979714448, 0.9859781876409878, 0.9830014391146378, 0.7432547108855626, 0.8001548275319859, 0.5370221227847205, 0.8063440043105403, 0.809980710745774, 0.7688869507094427, 0.7869810345117509, 0.7709223494152985, 0.7786268735216557, 0.8547216295603683, 0.2257159306977542, 0.8761874110459923, 0.27941456673011467, 0.19307860970563617, 0.21277914506977735, 0.23626207041598302, 0.2350041009771131, 0.22831055543820034, 0.12289550274352856, 0.41923957982920956, 0.20332689071568244, 0.2474185085980274, 0.13563770360615768, 0.21101552664955636, 0.1885267822033282, 0.21868843888739542, 0.23504020466722264, 0.241406324466799, 0.2371642034828242, 0.23851010934057848, 0.22424374089169452, 0.22197001291207252, 0.2162367755733764, 0.25404848568546257, 0.1428831081501306, 0.13350676014276763, 0.017037803479519997, 9.999999999998899e-05, 0.14084425665738254, 9.999999999998899e-05, 9.999999999998899e-05, 0.0855587038807607, 0.00017810298128784208, 9.999999999998899e-05, 9.999999999998899e-05, 0.1432900342359391, 0.05189711690116661, 0.09273031080553629, 0.07005877181610853, 0.04942462165145567, 0.026178015004325372, 0.12180000846488204, 0.07752596696846026, 0.09847068391388625, 0.05068690183772451, 0.05165481957214013, 0.06145023429051266, 0.1465440514429578, 0.09985075582605352, 0.08234011225022075, 0.14133632118244133, 0.12510844032735235, 0.18096456402205918, 0.11579339466627714, 0.09332580482526387, 0.24113147726032969, 0.07958337880715771, 0.25804673930613986, 0.0397640218661971, 0.08432008622697962, 0.15171908725393024, 0.08360823232045278, 0.5366178965847237, 0.5217809289804748, 0.5398489638840059, 0.5641751987796834, 0.5365131081414427, 0.5686770373605237, 0.6108630105109758, 0.5613173559384235, 0.5910811308459558, 0.1238641795141715, 0.08150206011863725, 0.09539390510057544, 0.10125474999736395, 0.1374447375705533, 0.1151009922935693, 0.10847322150065009, 0.1305605046334296, 0.10561273743844268, 0.2671521746285255, 0.34713818955174924, 0.25783801292701425, 0.5268454253389279, 0.38069371155300524, 0.16429002304039075, 0.2771507587114125, 0.2583759008522182, 0.21930854757666107, 0.3035113899802391, 0.41473431226416924, 0.33365813918321185, 0.5634501703262819, 0.37198570830291455, 0.43218239446751994, 0.2725020727992594, 0.4473202781373581, 0.2326822642790507, 0.30889088226353734, 0.3312408232218065, 0.27022848365769747, 0.23303361583281978, 0.22294820814041394, 0.3136564779120886, 0.20805002004860407, 0.21745026012102509, 0.2626051451224064, 0.2571603015505862, 0.26179896401753444, 0.19049160317302738, 0.2372475355101854, 0.2797225216480962, 0.2303474758014269, 0.288858531837066, 0.21563548297741675, 0.212360704666555, 0.22844048185601917, 0.22735517736781652, 0.21325655509435448, 0.1933715371766731, 0.8695856447815262, 0.22690538141433036, 0.8408000287050186, 0.8189991704069484, 0.7442220259510961, 0.9327690179038062, 0.938163107440817, 0.15386610275062396, 0.9296828022091856, 0.2017861825174413, 0.20176223554442485, 0.15356470196077332, 0.16857871440495964, 0.17747091894407896, 0.6105390622947444, 0.21215248707192336, 0.7390794351518781, 0.7260746802078482, 0.1559700701080866, 0.1549891212238752, 0.10512087886863719, 0.1663939181009415, 0.7654781770126842, 0.1933620452905983, 0.1824810075751644, 0.2313794348028616, 0.19114228094860541, 0.18672488667395215, 0.23823365333461577, 0.20052252817988236, 0.20752539997098762, 0.23585123151988308, 0.0937496300558458, 0.1266070914704609, 0.08828719246723171, 0.10876055110927896, 0.09295164548166635, 0.15178123836095547, 0.09841466369773066, 0.18970440401179922, 0.07345718225299314]}, "mutation_prompt": null}
{"id": "d0db4206-eb5f-4fe1-b384-36f8b24b5406", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            if self.evaluations < self.budget * 0.5:  # Adjust mutation strategy\n                self.mutation_rate *= 1.2\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced convergence by dynamically adjusting mutation strategies based on performance feedback.", "configspace": "", "generation": 79, "fitness": 0.327231250606918, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9173021180242746, 0.9042328354762381, 0.9073787826453609, 0.9080039773718543, 0.8918963110572652, 0.9141505958580102, 0.9157753368560742, 0.911239642338489, 0.9099240194708073, 0.8350500303808785, 0.8118225493214467, 0.8307149931207878, 0.8299901349148551, 0.834291629218681, 0.8349230328826927, 0.8220377299131464, 0.8068705586406079, 0.8085583068939083, 0.12147601910678119, 0.18489806595474867, 0.15747641098820786, 0.16270075061422573, 0.12379659739755733, 0.11590882497896349, 0.08386291512677835, 0.18365172087942516, 0.11400682622826586, 0.15754555816773086, 0.1308051204475662, 0.140388336040421, 0.1303180459397465, 0.11155630706601893, 0.1163417436580525, 0.12961904193250318, 0.1436816133097173, 0.12704269953297043, 0.9874172127704864, 0.989367869861717, 0.9909729508568537, 0.9916859928642481, 0.9867025201730115, 0.987900034957852, 0.9877240275165836, 0.9852282450343632, 0.980524460984635, 0.8027049509337052, 0.8316296246097556, 0.7521853745877104, 0.5938012688261852, 0.5333385548235083, 0.7842998773957097, 0.7544083621101082, 0.7725389586140363, 0.607103714141313, 0.23196058310244405, 0.21167467965851394, 0.23078287774182216, 0.3867030150121362, 0.2127097322064292, 0.21129886049743318, 0.23022241757676498, 0.8904492125160379, 0.23827745512496012, 0.21589396635962455, 0.1340478418526294, 0.21458958046491716, 0.2506898349213156, 0.1333422353691418, 0.1341168854510728, 0.21617629526052384, 0.22792222209057733, 0.133359876892027, 0.24031242528794194, 0.23492334522202873, 0.2574702739770901, 0.24349180625932743, 0.2174284760989248, 0.2455431801077147, 0.26332600334396206, 0.1060693462308856, 0.2505094260958519, 9.999999999998899e-05, 0.005339140547997667, 0.04179853122134258, 0.018234139111070413, 0.14282342092682843, 0.012472624387553144, 0.011601036347997029, 9.999999999998899e-05, 0.11366009435688085, 0.13693923276665576, 0.07277129169770957, 0.12045223686876849, 0.05902282559072303, 0.037881992248676166, 0.0712427839778742, 0.139776974179615, 0.10949497300756117, 0.06239722772968359, 0.051007855797858825, 0.22503257601907523, 0.1306361136056423, 0.21152188107719294, 0.08070427171369321, 0.24695692802034386, 0.14437428345987113, 0.11132437845031873, 0.07563411940896547, 0.06142028753307749, 0.12893425401593905, 0.13721537235437387, 0.2173647544058105, 0.12992551911289918, 0.10804163824085422, 0.09622841294170104, 0.058111534341060866, 0.08351380224875304, 0.5368885423529326, 0.5562471672599014, 0.5270867173557869, 0.5230026847234193, 0.5333278262856658, 0.6515803896950003, 0.5768498457073323, 0.5567611888988944, 0.5998784465581346, 0.11507571798295324, 0.09806839100368847, 0.15808424474302496, 0.10121917743840747, 0.11295191749780875, 0.15641687507932334, 0.13061977233126454, 0.11744441283976281, 0.11074995869470983, 0.3235457295627143, 0.2990010016025547, 0.27599166964831867, 0.2683636450491357, 0.35288549938276315, 0.157017936542873, 0.2257297574464585, 0.36746609817169507, 0.20150545376088203, 0.23163699855140407, 0.3613786045977475, 0.3609077745526612, 0.23685110607440318, 0.44868736613573357, 0.47377875016857474, 0.25883718305535164, 0.309362161974829, 0.39437912325373414, 0.30021348605661347, 0.29598324004221255, 0.17869482673247783, 0.271463205878527, 0.30588924533203066, 0.2615455994131708, 0.16891968399640678, 0.1550633164068782, 0.22391322316660867, 0.23628044589674413, 0.2564378415208871, 0.19685937193705072, 0.2593439460732957, 0.20434624403790214, 0.22560740426491743, 0.22210534575071117, 0.18273895621547187, 0.22491419923235367, 0.2096561619424061, 0.25215065092468325, 0.2268321567811492, 0.2250813828689171, 0.25061088785788643, 0.18776780356053857, 0.20765356586264927, 0.19713507251725082, 0.22087599268120217, 0.9441534347478555, 0.9344632915652056, 0.1543606240008476, 0.9363091682810478, 0.20173160454365202, 0.20164884771810243, 0.16240303341200324, 0.16847769852486805, 0.1539729845265474, 0.08312993138206493, 0.2124739739826501, 0.7720982058253547, 0.1690941885597329, 0.16744021406990028, 0.2127582625309402, 0.10517594155004484, 0.16651148581548025, 0.7725187778805856, 0.23929506487325247, 0.18457039176010193, 0.21105350976900394, 0.22027743580859194, 0.215171721306055, 0.21686493860298317, 0.19792238315214217, 0.19571053877561684, 0.19505189329958117, 0.09736463533187945, 0.1548593119538384, 0.09992312832554995, 0.12481279138506218, 0.11226298026187653, 0.15301624086830357, 0.1063704463134989, 0.12552775092352508, 0.08938936128243968]}, "mutation_prompt": null}
{"id": "f65b2237-4167-4536-afc3-28943e4a5f9a", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_base = 1.5\n        self.c2_base = 1.5\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        adapt_particles = True if self.dim > 20 else False  # Adjust particle count for higher dimensions\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)\n            self.c1 = self.c1_base + 0.5 * adapt_coeff\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)\n\n            if adapt_particles and self.evaluations % (self.budget // 10) == 0:\n                self.num_particles = max(5, int(self.num_particles * (0.9 + 0.2 * np.random.rand())))\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced a dynamic swarm size adjustment to enhance convergence by reallocating resources based on performance.", "configspace": "", "generation": 80, "fitness": 0.3497337747124914, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "0be7f397-b8cc-44d9-9c5a-d0f6e138f556", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.07:  # Adjusted chance for orthogonal search\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced orthogonality-based perturbation for balanced exploration and exploitation enhancement.", "configspace": "", "generation": 81, "fitness": 0.3318684923288954, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9093560209314353, 0.9097216489199917, 0.9156033454496502, 0.9124248626646525, 0.9109528614277789, 0.9231450470071535, 0.9112475602664917, 0.9056585859618971, 0.9123089534668147, 0.8215054661250136, 0.8180200599362429, 0.041853089383504294, 0.8275248129974326, 0.7947167907612355, 0.8417615752282986, 0.8370097599892834, 0.8343805703717784, 0.05728554242176398, 0.7795097472278522, 0.16170141001232474, 0.743765552667428, 0.16001023818288573, 0.15260055557561614, 0.1599371940342127, 0.1811935079419471, 0.6426503304397724, 0.1812150319029604, 0.1589416975186596, 0.12816375772349586, 0.12883598978202826, 0.18429355181578644, 0.12503802927989505, 0.13104113318661026, 0.1455891723475906, 0.13857217477198924, 0.152202730892121, 0.9876905411548362, 0.987290875163745, 0.9896107555748395, 0.9906561756441441, 0.9871390313927603, 0.9856553568799025, 0.9855298188790871, 0.9846285758495341, 0.9824860451371282, 0.7554152845160882, 0.7445263463095813, 0.7541911001568353, 0.744255484511473, 0.7255120412211479, 0.733759641791894, 0.7983184456802601, 0.7764765785472123, 0.7582020694567245, 0.23259507031764237, 0.16978342736279772, 0.3483533952313872, 0.2816010494419029, 0.2107606086320014, 0.21400749180705736, 0.23433597072530465, 0.5917008965658004, 0.2378643789067194, 0.1303827640803975, 0.2074090977158869, 0.2012755094601374, 0.21028390442671074, 0.1312229739690307, 0.23173428740692703, 0.21079218123691312, 0.21397246110887846, 0.2168668735656354, 0.21425613044590452, 0.1287958003941574, 0.29840966416893466, 0.21670707797920874, 0.20830997763989811, 0.2093165059026757, 0.2514942006089327, 0.07236616298402454, 0.24469797915052682, 0.028534812600384818, 0.040997086746123235, 0.12231201754781973, 0.09697437530614028, 0.0515582093986201, 0.1218986388272848, 9.999999999998899e-05, 9.999999999998899e-05, 0.16260304724602903, 0.09279443260501519, 0.04438435650041339, 0.10433424858771234, 0.06665322660374673, 0.015586341003561932, 0.027485721743415903, 0.19187996335508672, 0.09014579877638296, 0.1126593397021316, 0.05145576239851324, 0.06822348680461165, 0.10912156197968348, 0.14598101219362636, 0.07950378761107235, 0.11915144273861022, 0.2636131734199475, 0.19736118919087042, 0.3408640621117446, 0.164118528316624, 0.07991259281286145, 0.1215088270039647, 0.03946449682070308, 0.20815562629658246, 0.04604033008598485, 0.21151293420494932, 0.12202835179983462, 0.08308853241863057, 0.574284692356635, 0.5245215779521515, 0.5788595582588876, 0.557735324815952, 0.6617796496469548, 0.56418417012457, 0.5749898221884768, 0.5834936222082647, 0.5519700549923727, 0.13174069164136581, 0.1030086771276909, 0.10125807485748195, 0.07446099634413528, 0.09408648545681275, 0.10685131939801829, 0.11814243089821852, 0.14353136625669727, 0.11078924093036735, 0.2634909017689696, 0.4020977783493008, 0.3820298347863643, 0.3395583149062954, 0.25455608188968437, 0.1984974094969295, 0.3448331983147146, 0.16017798861377053, 0.18474961457723105, 0.31400719414117106, 0.3925346798350211, 0.39823402064424995, 0.5249740442418187, 0.36286205600988974, 0.4068351020923222, 0.2475094361709358, 0.4361821762295145, 0.23237760481155867, 0.2212676129175506, 0.42772004972093847, 0.21309090389162444, 0.18763947795506541, 0.24012972069299166, 0.28619079620208177, 0.23149162258861855, 0.20973869337415274, 0.29039595326163603, 0.2256818452872199, 0.2136863941725502, 0.22818942319704638, 0.32744385796616327, 0.2607924562564453, 0.2158334722866544, 0.2365242208087025, 0.18405935420764963, 0.20506018718768304, 0.18927114097287667, 0.21083877923645644, 0.24943031407095617, 0.19106471167464245, 0.21094381420811592, 0.21105371337312273, 0.22728203065978003, 0.21782286065741263, 0.193664199850345, 0.9499204516361828, 0.9322945700574224, 0.15402112015728198, 0.9424368302049437, 0.20198179508420788, 0.20186122619633184, 0.1627690314910969, 0.16856728767617535, 0.1764668367972978, 0.0832091261448713, 0.21379199446647446, 0.5775849310204513, 0.16878451833271524, 0.1688150325809591, 0.2120988181890059, 0.10512714182930027, 0.16657665044830372, 0.7683001076890275, 0.18657846967846825, 0.19479218914312857, 0.18338700308704026, 0.2399736803388839, 0.20205067298018553, 0.19320698479848786, 0.22778209815604722, 0.25015546081613815, 0.20746262146090377, 0.08533162367726776, 0.13016906188508093, 0.09677902827151086, 0.10413539586376297, 0.10362663759203894, 0.13952793423967158, 0.10642867347158758, 0.12162501080921062, 0.09598584528180165]}, "mutation_prompt": null}
{"id": "44a1c57f-0c0f-4400-80ab-1e62c2997d44", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduced adaptive social and cognitive coefficients to balance exploration and exploitation dynamically.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9262702431407954, 0.9148594460310632, 0.9063387763949986, 0.9142712625047023, 0.9127339273524163, 0.9095649703888047, 0.9154725474926575, 0.9128814169291702, 0.9055000198240348, 0.8324040400171913, 0.8242988467449727, 0.7998781625530047, 0.8231090025887196, 0.8115050726927082, 0.818676435914229, 0.8253096063893535, 0.8276533885308485, 0.8246461213991618, 0.15119229617752694, 0.7351935509511611, 0.1504919025764162, 0.1845364547635867, 0.1658004472160175, 0.1838558294245286, 0.5618270762601548, 0.15755097071094637, 0.11705025881821984, 0.14165489856307178, 0.14275895597659694, 0.1443894420778542, 0.12477591196088311, 0.12348170165599259, 0.09905888995268619, 0.16147835554898227, 0.15301741084945042, 0.1549269152194196, 0.9870374389592013, 0.9897861863714369, 0.9898546706246687, 0.991000081563323, 0.9876223217773356, 0.9858886208617071, 0.9845795937420591, 0.9859781876409878, 0.9830013064966866, 0.7661982029904428, 0.8215163592999083, 0.6352574214738915, 0.8221256194314605, 0.7923202636142836, 0.6753582336151828, 0.7520080531571773, 0.7825408743825233, 0.8132121682443145, 0.9045703870894739, 0.16957337774518788, 0.38771356443634664, 0.27935316390536724, 0.19307860970563617, 0.19365470071391344, 0.17782763907026167, 0.7433579646972546, 0.23616040569379926, 0.1233896504519707, 0.44819507263108793, 0.21425509831389677, 0.24606820636183124, 0.13582798978475785, 0.1984395351445457, 0.22432629413945004, 0.20310907389762445, 0.23566627153994146, 0.23899971337729842, 0.2150790589560101, 0.24709885037852886, 0.23785370039582854, 0.22149110632722435, 0.181620279285293, 0.2619862038212477, 0.1436004929665876, 0.1336931063863307, 0.029706044339370963, 9.999999999998899e-05, 0.06696519049914407, 9.999999999998899e-05, 0.0089005020891193, 0.018381779967715506, 0.0012534769249612498, 9.999999999998899e-05, 0.037284419258058366, 0.14022434814405793, 0.04115253041979339, 0.09063855150971556, 0.06896049980466068, 0.036800165387260164, 0.038926717024587054, 0.10638303178756925, 0.09216357234706318, 0.10303853730434509, 0.05007936439806615, 0.05140998930767349, 0.06014348993810492, 0.15208816196526875, 0.07915614523519476, 0.08024574060869161, 0.1454531488756482, 0.12840958638472277, 0.18426907960326766, 0.12287181072867248, 0.08270780917625886, 0.22523814899888672, 0.06356224432441904, 0.09554974214533118, 0.04072255378296619, 0.08434703793039966, 0.1487767629837219, 0.08402678357682924, 0.5377039780029708, 0.5273798665066571, 0.5210898066464109, 0.5605574111411302, 0.5490478626076243, 0.5371467139565993, 0.5970394038363774, 0.5760087041122813, 0.6121459793580561, 0.12449044766689343, 0.1305827277623044, 0.14962162055988715, 0.08956776310443315, 0.09872569697117084, 0.14369603955426669, 0.13090387282093907, 0.14034664705096989, 0.11794810744275985, 0.2701668585910021, 0.27497121079602715, 0.31621299751050735, 0.39426656658518666, 0.2135836535346869, 0.23727954655130057, 0.327578354851945, 0.18683930548688277, 0.23163863735432566, 0.375566617887213, 0.5111076614888694, 0.3191451034053444, 0.39135358665784903, 0.2672283958210927, 0.37946575454548825, 0.24524324747103132, 0.5205025335879929, 0.22957835449355768, 0.23072529643700634, 0.32585278514979543, 0.17323636481823035, 0.20268110078444856, 0.24123054763896434, 0.2653207553399277, 0.22346415979768586, 0.1962720949886989, 0.30715132906021025, 0.26428305675025343, 0.23751476884829603, 0.22860180916228323, 0.22882430742918114, 0.24869442975736744, 0.2349086477625073, 0.20263633979317586, 0.191865719011018, 0.20114931496805155, 0.8313000850248715, 0.2271352847178052, 0.856935810407552, 0.19180788397328274, 0.2548808094455335, 0.20635935295534846, 0.22898274367827898, 0.8353834527636812, 0.22327043250371303, 0.9364860566884041, 0.9398991273743026, 0.15386936110558924, 0.9310136200520575, 0.2017844382917795, 0.20174799246728603, 0.15364322536774122, 0.16853441365790744, 0.1773888313451123, 0.6269841714947137, 0.21250991520473483, 0.8243956519745412, 0.822964323509923, 0.15596750487223832, 0.15424780006795713, 0.10511871745990142, 0.16641188508879845, 0.7965083209593781, 0.19431586384555988, 0.2081929983432821, 0.20993594694524764, 0.19656621943421226, 0.2976553623813806, 0.23539645787925645, 0.199092617295053, 0.19374036397386574, 0.22777418051914045, 0.08949363977711944, 0.1329557193036608, 0.1009497686274754, 0.1162595837615259, 0.10673796505553035, 0.1399014284850162, 0.09771210423397747, 0.1211693005633584, 0.08914409797475087]}, "mutation_prompt": null}
{"id": "f0a6f82c-a6bd-4c1e-977d-0ea8c27c90c5", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.05, 0.05, self.dim)  # Refined step size\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced adaptive velocity control and mutation strategy for improved convergence.", "configspace": "", "generation": 83, "fitness": 0.33738175598386894, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9186431428956043, 0.9173832178176053, 0.9115868770468604, 0.9231836742683069, 0.9138652838557554, 0.9126031499523364, 0.9151455422892648, 0.9102508511175758, 0.9174995383961011, 0.8279544731097993, 0.8160937901246615, 0.042834265158545715, 0.8231493473676594, 0.8160635794901745, 0.8423763355884719, 0.8301739063575695, 0.81936933159132, 0.8127828424395, 0.09649306674883551, 0.14357628937660516, 0.16122743174652043, 0.17167886885028583, 0.14153638339490082, 0.1587029517278732, 0.09430886121778526, 0.17799897879332638, 0.11922795879750991, 0.15734168120496783, 0.14273997761345159, 0.11708212184051503, 0.104234564763653, 0.13066261052928785, 0.13934471856274266, 0.11019068153767053, 0.14461063668141938, 0.1407445200207258, 0.9870374389592013, 0.9897858874149252, 0.989864338704123, 0.9909728919364486, 0.9876223217773356, 0.9858876047634386, 0.9845801420218229, 0.9859785678775272, 0.9829951145362248, 0.7924021433041731, 0.8420458129258706, 0.815957093746414, 0.7985715296943942, 0.8085050486352146, 0.5479383768489128, 0.7710332885946932, 0.7350387900358075, 0.8107301465683676, 0.23231300399085708, 0.22721584620174629, 0.3340787117204408, 0.27892189840271453, 0.26860873822258957, 0.20826926415950042, 0.17407800494645143, 0.837067230269897, 0.24545424027149287, 0.21712667763188298, 0.25893273655388194, 0.2103079608145444, 0.2051612628213365, 0.13593791704826763, 0.2051760090881577, 0.21002344929414252, 0.21991647972315254, 0.23423565591225215, 0.23224985118529606, 0.21108932724260732, 0.25012881758378547, 0.23020166791192942, 0.1339658624544363, 0.1311262093218073, 0.2565812226993164, 0.10611063439971435, 0.1330987810556007, 0.046696940073985393, 9.999999999998899e-05, 0.10141718806946187, 0.1296908356475116, 0.11473025175700946, 0.0033221854738296752, 0.0010197742463600168, 9.999999999998899e-05, 9.999999999998899e-05, 0.14953379134004774, 0.06594648098805844, 0.09192323745890985, 0.06684111984393382, 0.010999419225817264, 0.03416998486555134, 0.1722197575306953, 0.06800263645686078, 0.12120402374165662, 0.05144678298219607, 0.05065364479553047, 0.06020272597250009, 0.16734738516015846, 0.3343926193755852, 0.08185545156768514, 0.1439877203018466, 0.15379107682180715, 0.19499132963046784, 0.1378395442353212, 0.1595128542234967, 0.21674030311966563, 0.08361777992913844, 0.10065742541856126, 0.04329837950561666, 0.0843530292331216, 0.15696217216729857, 0.31269798302524643, 0.5304583521580684, 0.5886080739024002, 0.5901159131010767, 0.5755183684580591, 0.6472778738877842, 0.5777603037550918, 0.6047073377719498, 0.5595977801997749, 0.5661621809017868, 0.11172071137641648, 0.13098596737170343, 0.1338576445154389, 0.10487593288923458, 0.14096652491520767, 0.09794848776203102, 0.13006423246303567, 0.15793324706103817, 0.11588661151904867, 0.2545386843192562, 0.21778559138361275, 0.34614386810526754, 0.20006276800918588, 0.44886408127533073, 0.16646936617499264, 0.268664555505157, 0.19507663455097513, 0.2076819708386688, 0.3567919067329425, 0.44213469264428096, 0.32991570499430856, 0.3802119696849099, 0.52219307964513, 0.3421589450556157, 0.23300431096762675, 0.569230235125106, 0.22496381696463486, 0.3617844109318513, 0.27037509983163843, 0.17256188996691713, 0.21439156055909903, 0.23833307544256466, 0.3074291178446158, 0.17804549319318086, 0.19601011013921332, 0.23153412944099927, 0.24337719305684336, 0.2550184429961798, 0.270877361600282, 0.24390614962082213, 0.2916965297203008, 0.2485956542509945, 0.23423767041930355, 0.21801554516598232, 0.2015491051316306, 0.22790937325947092, 0.22713568846690513, 0.21138109490012424, 0.22677198392331532, 0.7679895966719889, 0.19899143452409418, 0.2017881073402713, 0.2300767084414005, 0.2255267427142964, 0.938293438180144, 0.9424787297690023, 0.15375932700673933, 0.9258995240127965, 0.20176383115149898, 0.20173434606951013, 0.15358736241471083, 0.16853294043797773, 0.17701275184359944, 0.6251679389995235, 0.2124604179951315, 0.816187166405836, 0.841257135743732, 0.15594432253335289, 0.1544796179988983, 0.10509431132708946, 0.16631002156984687, 0.75898032571316, 0.20448317796456394, 0.2275290863249233, 0.22181394880563599, 0.2126467580744963, 0.19488103906814813, 0.23007468758248795, 0.19601987402055265, 0.23688266991097284, 0.2295117379311027, 0.10623931858096036, 0.13238908031127883, 0.10052304936854184, 0.11302326845765853, 0.10580906439509585, 0.13627268428935735, 0.10098831058333213, 0.12888996509697337, 0.10253978130380914]}, "mutation_prompt": null}
{"id": "a9bc5c5d-3db4-4f0b-8060-7b787291daa8", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        sinusoidal_influence = np.sin(self.evaluations / self.budget * np.pi)  # Added sinusoidal influence\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i]) * sinusoidal_influence\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced mutation strategy by incorporating a sinusoidal influence for improved local search.", "configspace": "", "generation": 84, "fitness": 0.3349707750278839, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9149592541854211, 0.912882308179751, 0.9069690312982096, 0.9149275845987278, 0.9078226187502737, 0.9183859014222707, 0.9158411343974029, 0.9081668015080574, 0.9009794000870976, 0.8219350806926182, 0.8070184481572128, 0.8149618138180919, 0.8060313856470253, 0.8218212629396536, 0.839958458324724, 0.8200042234115918, 0.8162424789085203, 0.819025975540047, 0.10955949141990351, 0.1798862353354247, 0.15870516130759027, 0.15844191797977125, 0.12768205648502773, 0.14352272101904473, 0.18271562143029507, 0.13521938422529023, 0.18521981491615136, 0.14195166622502653, 0.11063632535989198, 0.15606800965842815, 0.14519026976799065, 0.1434858491548423, 0.1398267443519099, 0.15360575051516956, 0.15889446123897966, 0.11354373911739635, 0.9855194567221548, 0.9897917615357882, 0.9893239904980532, 0.9914502766189407, 0.9876223217773356, 0.9858890796506065, 0.9839739816743875, 0.9859781876409878, 0.9824705848199007, 0.8269331946845075, 0.7264252912869373, 0.8206104634526885, 0.7692727977544132, 0.8175511409507206, 0.7305572456751562, 0.8084164420061244, 0.750035212988756, 0.7552287695799179, 0.3190605876462905, 0.17059223506678667, 0.22843324670603493, 0.9099384809867757, 0.19362848412665767, 0.2768816869318218, 0.23523435366231704, 0.2353224270401857, 0.24299319402079522, 0.21655815733982464, 0.2115259343435374, 0.20598108290449568, 0.23134136199234034, 0.1351632688924339, 0.20229186686466505, 0.22069300441822948, 0.214286530858951, 0.22323407135389473, 0.21174299539583386, 0.3444264468177295, 0.22364205571483609, 0.1345101249428471, 0.13497181406346992, 0.21182783137601424, 0.24424626750115563, 0.1388627512952315, 0.2644488065141788, 0.007892888449363311, 0.09690196651624172, 0.10702079637300144, 9.999999999998899e-05, 0.008875335697087539, 0.01868134153542067, 9.999999999998899e-05, 9.999999999998899e-05, 0.05723514548727193, 0.12469370291275939, 0.03672859486386226, 0.0713861958136549, 0.06407822417532738, 0.023426811116753155, 0.022669969052337757, 0.1407619110671411, 0.08387654618940255, 0.1967784215772015, 0.0508259651282742, 0.1309255427287499, 0.11942989429253248, 0.17337055348872565, 0.10739907560071826, 0.07974761809037367, 0.12426588521644921, 0.0846404849959248, 0.16199232307989553, 0.043447845803134655, 0.20919842515272447, 0.08230722359985809, 0.039447793509019946, 0.25711152687295025, 0.09931856860620669, 0.08485489639279498, 0.21286847290880095, 0.08386405381850148, 0.5589633676179443, 0.5609671475745651, 0.5326112577535023, 0.5389828737973181, 0.5788456629521594, 0.664906099020906, 0.5733317470420789, 0.6042433088056351, 0.5834195176786694, 0.0804980977480867, 0.07271632427854724, 0.15774105539873018, 0.10453491640629653, 0.15902982927023346, 0.11566354514286248, 0.09954454711741967, 0.13502377765135587, 0.12187430371774721, 0.27495926738314624, 0.24527799474230783, 0.23257135099437332, 0.28727211325717095, 0.2534408023867112, 0.1753005426435963, 0.37955669585426544, 0.18436718548844666, 0.2082464270072354, 0.2805196215562784, 0.35779222842835223, 0.3116299151681524, 0.394589168617568, 0.3633430648131015, 0.40300981483476095, 0.5774369716733974, 0.26073835313228255, 0.2220457761732637, 0.1830015715482448, 0.25071114363551694, 0.18648801178070606, 0.20887931697040663, 0.253759287687948, 0.15322191176590116, 0.16600466802446467, 0.1991143950447768, 0.3228572925509149, 0.25471509204399145, 0.2423511594850679, 0.23552249900829703, 0.21267073522345448, 0.2667776265409698, 0.23113795798148917, 0.20143823572088781, 0.28902107333011307, 0.2101905661829916, 0.25321580454350756, 0.21095989717671582, 0.25237455786470464, 0.19432195466879698, 0.8669182978203243, 0.25438889418387234, 0.2004693956525928, 0.23052393419702544, 0.18255732450118312, 0.932629705959723, 0.9205536529821504, 0.1541117158592641, 0.9431429361118219, 0.20194420217517117, 0.20172090917562147, 0.15433412393017587, 0.16854441092752004, 0.1681153999056656, 0.08315583574085283, 0.21088482106894002, 0.8266986004465421, 0.8598217152275419, 0.15565197339570058, 0.15546008324999527, 0.10523111945555996, 0.16602419719931671, 0.8221637971046247, 0.19452138423148624, 0.20321190760065766, 0.21839731665689377, 0.2097418491343227, 0.21342783349514916, 0.23813351906103197, 0.20452361144160036, 0.21239189643436784, 0.2044455349607851, 0.09597491434441963, 0.09254803924844834, 0.08217888881638313, 0.1511700155321294, 0.11279146203398738, 0.12012701397671843, 0.09662611183991243, 0.11741850743075644, 0.09997947202236357]}, "mutation_prompt": null}
{"id": "02d51f8d-b3f8-400e-b0bf-0c7f1dd38d13", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.5, self.dim) * (self.global_best_position - self.positions[i])  # Modified mutation\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim) * adapt_coeff  # Change: dynamic local search range\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced convergence by introducing dynamic adaptive local search strategies based on the current best-known solution.", "configspace": "", "generation": 85, "fitness": 0.3372294321408536, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9183638197345225, 0.9108398673054648, 0.9066381337090096, 0.914103049733034, 0.9066488477892645, 0.9073849030189854, 0.910237411634554, 0.9101980458821797, 0.9095394998360627, 0.8186663480646383, 0.8404211996935765, 0.04204120070220907, 0.8334188497631562, 0.821659499854124, 0.818869728905638, 0.8336731794300096, 0.8118840224439214, 0.8259149756124442, 0.1563844683822625, 0.7591702818859032, 0.15423856873003117, 0.18311665822675338, 0.13342395788292394, 0.16010005965092788, 0.14948704844747318, 0.17801544732700514, 0.15022622878666136, 0.140917539515807, 0.1569442434421644, 0.14434290396475846, 0.14261449565819584, 0.12349755245562177, 0.11424770909138793, 0.16142977433245975, 0.14387037633813926, 0.14184776699137913, 0.9870374389592013, 0.9897861830732654, 0.9898547278352214, 0.9909996257440506, 0.9876223217773356, 0.9858886127080659, 0.9845795992766754, 0.9859781876409878, 0.9830012444362659, 0.8029473053181883, 0.8078244172477502, 0.7644057525010985, 0.7718138895825559, 0.7816645166794174, 0.7258817829263277, 0.7804826409761847, 0.7829970693385953, 0.7792131183413564, 0.3887968615688038, 0.16957337774518788, 0.36062216427025273, 0.3757267792480611, 0.19307860970563617, 0.19363473637351547, 0.23164484313633393, 0.36133577074347145, 0.23616040569379926, 0.12344749456678417, 0.3930024578449124, 0.21914021471199863, 0.2517279933976886, 0.135804505303891, 0.21116975716029351, 0.21759317609936146, 0.20972641146781157, 0.22439757507311642, 0.2351931677164385, 0.22313597027133103, 0.2536349280257528, 0.2278057770447648, 0.22053410251685057, 0.20421848814418453, 0.26179176916532565, 0.1435845274782207, 0.13250310358297934, 0.012364014272196244, 9.999999999998899e-05, 0.07680214932012586, 9.999999999998899e-05, 0.007572385024718464, 0.01984923109795711, 0.001522879581202008, 9.999999999998899e-05, 9.999999999998899e-05, 0.1481670463288599, 0.03924476085298301, 0.08952605302835814, 0.06801905717391732, 0.04006436895851462, 0.031785755007188166, 0.13353303847476783, 0.08525314133761608, 0.12874266818016944, 0.05118403039416408, 0.05144694897840185, 0.060131070497152495, 0.15215300522638187, 0.080012328693995, 0.08148502998300189, 0.15577548432110166, 0.12826394838244848, 0.17749243287059957, 0.1204220937493905, 0.08254122911915163, 0.2247017655139062, 0.06475553559593394, 0.10170083524485285, 0.04009949229912768, 0.08435229515773701, 0.15471009952509107, 0.0836429678173648, 0.5900021051568113, 0.5806411618166298, 0.5268886502777321, 0.577958878341758, 0.5594731903439224, 0.5600035097910587, 0.5937274181856618, 0.5670649938374606, 0.6232976538142814, 0.12446948987797968, 0.13037584827270188, 0.14983283568097572, 0.08983767074152149, 0.09819218803186958, 0.14364000060504023, 0.13086749105011608, 0.14046454391059593, 0.11795336158157699, 0.27577384307828834, 0.27886943700517997, 0.2961848545888577, 0.5613264343308793, 0.2538684678626201, 0.24243427117109717, 0.2615089388126789, 0.2696712311431394, 0.21071792309455561, 0.3640780774181358, 0.4155229345035284, 0.42655847917894363, 0.37204791255850866, 0.2706189406261881, 0.35411931986398326, 0.2538157022179869, 0.5060103403420186, 0.21131116546572337, 0.24640527202061369, 0.2895418925891239, 0.18096486755960572, 0.2566914565102467, 0.24523558146951918, 0.26166373699168755, 0.2005737716883843, 0.21334657970534376, 0.355242834789125, 0.23277007501015035, 0.24184444535531913, 0.1939100117205902, 0.26316915751546754, 0.24707324493343952, 0.2284162249396342, 0.2376861838851272, 0.21868245943421194, 0.19542179475307897, 0.22749168241090245, 0.20996262079486683, 0.8554566290498926, 0.18128485456361043, 0.2548650804308974, 0.20634401552937687, 0.22898180209667462, 0.25419989863327175, 0.22586749849689547, 0.9327434166311713, 0.9361316679218493, 0.15387395498579737, 0.9274389256305167, 0.2017784838924167, 0.20174994147652425, 0.15363352572357003, 0.16853450824735738, 0.1773761287607315, 0.656709049326843, 0.21251257598416706, 0.8381170557633246, 0.8239203398163807, 0.15596640876635792, 0.1543052426315975, 0.10511703046167353, 0.16645570579769464, 0.7589328880626287, 0.1999205709497942, 0.200961870166246, 0.21302576567521492, 0.21787599490742038, 0.1876246881005661, 0.19918602414734743, 0.19872863519710504, 0.2151367037267471, 0.20374338019324534, 0.08764505578213844, 0.13176271459033628, 0.10296842277275664, 0.11639789282387847, 0.10705857537889629, 0.1400715510761278, 0.10715825994061856, 0.12678413150542944, 0.08492910950251009]}, "mutation_prompt": null}
{"id": "3fad3208-ed03-4aea-ab44-0a65df3311c6", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.12  # Increased mutation rate slightly\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.12 + 0.4 * (self.evaluations / self.budget)  # Adjusted mutation rate usage\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutant = self.positions[i] + np.random.normal(0, 0.6, self.dim) * (self.global_best_position - self.positions[i])  # Increased perturbation factor\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhanced mutation strategy by introducing controlled perturbation to improve convergence balance.", "configspace": "", "generation": 86, "fitness": 0.3365755006990326, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9150134221506718, 0.9085595839761537, 0.9130078194248058, 0.9094874840432834, 0.9057374144137749, 0.9046513284551787, 0.9047278535459136, 0.9143576506040151, 0.9045561788942327, 0.810341281160351, 0.8337561213653238, 0.8168995035811661, 0.8299578588357727, 0.8340142187498992, 0.8344497710677776, 0.05452129333821398, 0.8127432674913802, 0.8312517542609507, 0.12113200501893939, 0.15933290640560904, 0.12401157681466413, 0.1869542613384001, 0.12518167059780394, 0.18552471068455045, 0.1255848632544465, 0.15138005786226372, 0.08375554002309238, 0.14176839997580704, 0.14935325576665148, 0.13046837979608628, 0.15597715091157294, 0.13899260156563165, 0.15813501352899462, 0.13397340641332012, 0.18314104750625548, 0.15551419602354288, 0.9874053800900117, 0.9893655034001152, 0.9909792803907932, 0.9905754213563916, 0.986694534895301, 0.9878529492403294, 0.9877206075269259, 0.9852297851540377, 0.9869053935844654, 0.7806890127077967, 0.8311660075383751, 0.7914923672778839, 0.7164743995202012, 0.7375497835691653, 0.7604013195843701, 0.795551207784346, 0.7950294720738477, 0.797811742846515, 0.23131699375597037, 0.22694173822638175, 0.855537912162329, 0.9000896784844508, 0.3629917735184047, 0.22021710869169286, 0.24303881668726823, 0.2338685724252939, 0.857897683613894, 0.1762019887933035, 0.20757099263568846, 0.22005248652876264, 0.25908541448647426, 0.13348658481033848, 0.21344569852654383, 0.21490596000400775, 0.20675593688398264, 0.18049998907809872, 0.23376296446023992, 0.22590507603332943, 0.13221601279307849, 0.21784297089620375, 0.1354316917940026, 0.30311554051649725, 0.25795973443185916, 0.1012220940046642, 0.12976364172190313, 0.11350796163983234, 9.999999999998899e-05, 0.06565812517606462, 0.02461284927272611, 0.11482073532451198, 9.999999999998899e-05, 0.003117190148430038, 9.999999999998899e-05, 0.01413951275535641, 0.15245744531014027, 0.028140466606469627, 0.10550773205002006, 0.06143501135609708, 0.027626056769388008, 0.049311320921371804, 0.24540994287480788, 0.129853728207468, 0.06825024695140602, 0.05169871334020393, 0.26693195103363254, 0.050493426843449596, 0.14462614086065495, 0.09911216887432384, 0.13630239006012834, 0.29165843330599306, 0.10303733715405328, 0.07487812121788284, 0.059482301476019184, 0.17042947446726087, 0.046046711488733294, 0.18869265342122243, 0.22812573238145462, 0.07179061185217561, 0.08392842334857264, 0.08469520785391993, 0.0934865951081929, 0.576056796080759, 0.6328020899148518, 0.5273633609736033, 0.5652313088115979, 0.5420829551640644, 0.5737881138984038, 0.5785072234175174, 0.5913455686518545, 0.5837460122296623, 0.08323094039890988, 0.08808970324975796, 0.09517442801998877, 0.13057974323890942, 0.14082437262426106, 0.15622738217459664, 0.11742759515156886, 0.11586415529806904, 0.13283700703857593, 0.2222879545960864, 0.323828214979453, 0.44077301997524787, 0.2260630436935075, 0.3744751116465681, 0.2279096851106126, 0.3100730002426847, 0.17007116647557796, 0.17806255386399283, 0.37513343871746907, 0.3749675646906414, 0.3486559197327094, 0.20544105592021555, 0.277776878728095, 0.4124632975040846, 0.24699199955408735, 0.35681651078617693, 0.20833714475061693, 0.25845340372864223, 0.21642617308658685, 0.21079553451923072, 0.23179478200662662, 0.308488143056482, 0.3578138053004931, 0.17642277714872867, 0.21452953826063936, 0.11385282579196132, 0.24933618929333512, 0.26150770898901, 0.20860438785558222, 0.25153754963387476, 0.246889688332538, 0.20615432741768502, 0.25534306499227866, 0.21313900086367432, 0.24262064857289167, 0.8195864612994694, 0.25275478682856, 0.2150139378407161, 0.21535517494582423, 0.25469704405385385, 0.20117273384727596, 0.22771496070476438, 0.23872853745454448, 0.19989813627425823, 0.9359482291672856, 0.9369312183148086, 0.15394316576073575, 0.9338497541674647, 0.201734626896089, 0.20186082371538439, 0.16270565555091632, 0.1685086125360734, 0.15389276546181063, 0.08314541185366653, 0.2129054493441398, 0.7057846248303155, 0.761587484391858, 0.15490898391954688, 0.2122772486924327, 0.10519579821836433, 0.1662139709817526, 0.7805754121374238, 0.19898478580164203, 0.2133532437355472, 0.22982154760792572, 0.20419940522702107, 0.20481559557646212, 0.2044607700294938, 0.21854188392658813, 0.1943342147119974, 0.2188503681373445, 0.0987407570230493, 0.09607224648563206, 0.10394665098246603, 0.12997138362127336, 0.10354684126556712, 0.11960891829538634, 0.0881306400648747, 0.11804611913545326, 0.08517711121493599]}, "mutation_prompt": null}
{"id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Improve local search by introducing a controlled Gaussian mutation for refined exploitation.", "configspace": "", "generation": 87, "fitness": 0.35309418884589233, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "89a6b1cf-adc5-4d49-a446-44858846f4e0", "metadata": {"aucs": [0.9124648713627627, 0.9194687384331905, 0.9111667808335107, 0.9214140405987428, 0.9017871402244848, 0.9183405232113874, 0.9053301507616025, 0.916825357283994, 0.9121079612282584, 0.819882703781949, 0.839701513440585, 0.829896969391934, 0.8442568267883991, 0.8349863023872007, 0.828635445636815, 0.831021505349542, 0.7981421789287857, 0.8340661723727738, 0.1322432412042459, 0.7658107427551635, 0.1527010278742913, 0.16089280154935226, 0.11030031191073209, 0.10000674610455607, 0.1588626020048448, 0.12517529341741662, 0.17739129744891924, 0.1401097302002663, 0.11561174471972846, 0.11364560978547689, 0.15582835706824227, 0.13096518056415696, 0.12126787732766675, 0.11496177793856277, 0.12379487756155305, 0.15411657330276962, 0.9869731186658104, 0.9897903749811952, 0.989308050596518, 0.9910518552311641, 0.9876223217773356, 0.9858883777826924, 0.9845630409244831, 0.9859781876409878, 0.9830087802719016, 0.8218180372239174, 0.6506217941387991, 0.8056329302635754, 0.8035286608545008, 0.8337349879880482, 0.7725603147603606, 0.7847735490665548, 0.7948529616253148, 0.8202344586997751, 0.39567324566971407, 0.22679371355420797, 0.7571280917808032, 0.2143050061439672, 0.27811054666311397, 0.21447283366100267, 0.23196596472195963, 0.3913821801525149, 0.20924380594281455, 0.22673969027577723, 0.21710694861272795, 0.30454425048779676, 0.20922415885878964, 0.13508155402283306, 0.18690384621334366, 0.2129911143224421, 0.2075291282008339, 0.20135811311753637, 0.22850564491405712, 0.15300146276818505, 0.23304617145801143, 0.21818744299434267, 0.17777350717626672, 0.38421712552956766, 0.25252485289357685, 0.13891561002785513, 0.23524870117109886, 0.13770645310465812, 0.008029879524361738, 0.07779328057518009, 9.999999999998899e-05, 0.011557979626956927, 0.04900505154366874, 0.00031192885483455335, 9.999999999998899e-05, 0.002847998599732282, 0.13674269725604593, 0.055515897459649355, 0.10650417526842271, 0.057158469644564724, 0.026626223125225668, 0.04262389060519056, 0.13203989735618793, 0.08630601225944812, 0.13334330274286854, 0.05083574996999396, 0.05122528378187885, 0.09168801431625684, 0.1784626322530123, 0.16893700954504898, 0.08100730275297119, 0.32581183347519715, 0.1839476193450218, 0.12602769854387152, 0.09854422803494545, 0.2601402911093006, 0.11084059921738632, 0.03953680770424928, 0.18606288379898084, 0.2308549245031587, 0.08505158873849505, 0.18284343331080233, 0.08353196967409582, 0.5840296948660415, 0.532082746349819, 0.5657321273975486, 0.5988956279925954, 0.5605955455807488, 0.5352514248451634, 0.5582306664725787, 0.5964030103955718, 0.5658203572907102, 0.0715741153948638, 0.07901704338331506, 0.12460157682175832, 0.09933026770727715, 0.09057967522852173, 0.1555071620450772, 0.10905413963460087, 0.15636385297430766, 0.11774076515205578, 0.2028069845591305, 0.2119536032735193, 0.2629974227503339, 0.26661843240453786, 0.20965801232062353, 0.33394137948919755, 0.1965546983272236, 0.17518114537198504, 0.1979149541176194, 0.3857443175673808, 0.5100643617121714, 0.2964840616221103, 0.2714757510090028, 0.47552591669098787, 0.3586815229393917, 0.36068092897761317, 0.5971346044060013, 0.21578047363570818, 0.17079222584133236, 0.21901300835774895, 0.24321025674166086, 0.24108550119445205, 0.35762778925109395, 0.20414974102092676, 0.16960504332637627, 0.19227234544387006, 0.27372877390606865, 0.2588570802071174, 0.22150771305199723, 0.2569582282383097, 0.22503380150784813, 0.24499647548871295, 0.25118919560559105, 0.24485779302722566, 0.21448431935082224, 0.19921342015464238, 0.8467830798634104, 0.22708230701774978, 0.20326771612578054, 0.2523319309679022, 0.8535414957131036, 0.8584480672312684, 0.8111671342367789, 0.18969174574197922, 0.22283993459250329, 0.9422442626018116, 0.9411426435889365, 0.1539883398825168, 0.9353374623205781, 0.20177660239765494, 0.20166793055445853, 0.15405167029595068, 0.16856838911422567, 0.1678297203276936, 0.8616428787544843, 0.21151909767173582, 0.7106328770383353, 0.8703967684025841, 0.15581224741387212, 0.21092608589969075, 0.10539408642163983, 0.1661653709368125, 0.8492976102956556, 0.19247310650403915, 0.2393848488005489, 0.2193806443687285, 0.2028005758235869, 0.19875411127198006, 0.21499058028009344, 0.18909556153740636, 0.19582406216279102, 0.20998992041161102, 0.11205325374823805, 0.11167940705605561, 0.09992339156912511, 0.1022026311280475, 0.1058831904623061, 0.14986448720289314, 0.09450513982902298, 0.0839519604619019, 0.1066888840587582]}, "mutation_prompt": null}
{"id": "a8bcf9ba-49c1-49c3-825b-c1acf4e45143", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Improve local search by introducing a controlled Gaussian mutation for refined exploitation.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9124648713627627, 0.9194687384331905, 0.9111667808335107, 0.9214140405987428, 0.9017871402244848, 0.9183405232113874, 0.9053301507616025, 0.916825357283994, 0.9121079612282584, 0.819882703781949, 0.839701513440585, 0.829896969391934, 0.8442568267883991, 0.8349863023872007, 0.828635445636815, 0.831021505349542, 0.7981421789287857, 0.8340661723727738, 0.1322432412042459, 0.7658107427551635, 0.1527010278742913, 0.16089280154935226, 0.11030031191073209, 0.10000674610455607, 0.1588626020048448, 0.12517529341741662, 0.17739129744891924, 0.1401097302002663, 0.11561174471972846, 0.11364560978547689, 0.15582835706824227, 0.13096518056415696, 0.12126787732766675, 0.11496177793856277, 0.12379487756155305, 0.15411657330276962, 0.9869731186658104, 0.9897903749811952, 0.989308050596518, 0.9910518552311641, 0.9876223217773356, 0.9858883777826924, 0.9845630409244831, 0.9859781876409878, 0.9830087802719016, 0.8218180372239174, 0.6506217941387991, 0.8056329302635754, 0.8035286608545008, 0.8337349879880482, 0.7725603147603606, 0.7847735490665548, 0.7948529616253148, 0.8202344586997751, 0.39567324566971407, 0.22679371355420797, 0.7571280917808032, 0.2143050061439672, 0.27811054666311397, 0.21447283366100267, 0.23196596472195963, 0.3913821801525149, 0.20924380594281455, 0.22673969027577723, 0.21710694861272795, 0.30454425048779676, 0.20922415885878964, 0.13508155402283306, 0.18690384621334366, 0.2129911143224421, 0.2075291282008339, 0.20135811311753637, 0.22850564491405712, 0.15300146276818505, 0.23304617145801143, 0.21818744299434267, 0.17777350717626672, 0.38421712552956766, 0.25252485289357685, 0.13891561002785513, 0.23524870117109886, 0.13770645310465812, 0.008029879524361738, 0.07779328057518009, 9.999999999998899e-05, 0.011557979626956927, 0.04900505154366874, 0.00031192885483455335, 9.999999999998899e-05, 0.002847998599732282, 0.13674269725604593, 0.055515897459649355, 0.10650417526842271, 0.057158469644564724, 0.026626223125225668, 0.04262389060519056, 0.13203989735618793, 0.08630601225944812, 0.13334330274286854, 0.05083574996999396, 0.05122528378187885, 0.09168801431625684, 0.1784626322530123, 0.16893700954504898, 0.08100730275297119, 0.32581183347519715, 0.1839476193450218, 0.12602769854387152, 0.09854422803494545, 0.2601402911093006, 0.11084059921738632, 0.03953680770424928, 0.18606288379898084, 0.2308549245031587, 0.08505158873849505, 0.18284343331080233, 0.08353196967409582, 0.5840296948660415, 0.532082746349819, 0.5657321273975486, 0.5988956279925954, 0.5605955455807488, 0.5352514248451634, 0.5582306664725787, 0.5964030103955718, 0.5658203572907102, 0.0715741153948638, 0.07901704338331506, 0.12460157682175832, 0.09933026770727715, 0.09057967522852173, 0.1555071620450772, 0.10905413963460087, 0.15636385297430766, 0.11774076515205578, 0.2028069845591305, 0.2119536032735193, 0.2629974227503339, 0.26661843240453786, 0.20965801232062353, 0.33394137948919755, 0.1965546983272236, 0.17518114537198504, 0.1979149541176194, 0.3857443175673808, 0.5100643617121714, 0.2964840616221103, 0.2714757510090028, 0.47552591669098787, 0.3586815229393917, 0.36068092897761317, 0.5971346044060013, 0.21578047363570818, 0.17079222584133236, 0.21901300835774895, 0.24321025674166086, 0.24108550119445205, 0.35762778925109395, 0.20414974102092676, 0.16960504332637627, 0.19227234544387006, 0.27372877390606865, 0.2588570802071174, 0.22150771305199723, 0.2569582282383097, 0.22503380150784813, 0.24499647548871295, 0.25118919560559105, 0.24485779302722566, 0.21448431935082224, 0.19921342015464238, 0.8467830798634104, 0.22708230701774978, 0.20326771612578054, 0.2523319309679022, 0.8535414957131036, 0.8584480672312684, 0.8111671342367789, 0.18969174574197922, 0.22283993459250329, 0.9422442626018116, 0.9411426435889365, 0.1539883398825168, 0.9353374623205781, 0.20177660239765494, 0.20166793055445853, 0.15405167029595068, 0.16856838911422567, 0.1678297203276936, 0.8616428787544843, 0.21151909767173582, 0.7106328770383353, 0.8703967684025841, 0.15581224741387212, 0.21092608589969075, 0.10539408642163983, 0.1661653709368125, 0.8492976102956556, 0.19247310650403915, 0.2393848488005489, 0.2193806443687285, 0.2028005758235869, 0.19875411127198006, 0.21499058028009344, 0.18909556153740636, 0.19582406216279102, 0.20998992041161102, 0.11205325374823805, 0.11167940705605561, 0.09992339156912511, 0.1022026311280475, 0.1058831904623061, 0.14986448720289314, 0.09450513982902298, 0.0839519604619019, 0.1066888840587582]}, "mutation_prompt": null}
{"id": "6d50318c-e86c-4cf8-a34e-7b5e2c5bd57b", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        reset_cycle = int(self.budget * 0.1)  # Restart every 10% of the budget\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n            if self.evaluations % reset_cycle == 0 and self.evaluations < self.budget:  # New reset condition\n                self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))  # Random restart\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhance diversity with a periodic restart mechanism to escape local optima.", "configspace": "", "generation": 89, "fitness": 0.35236780907011905, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9124648713627627, 0.9194687384331905, 0.9111667808335107, 0.9214140405987428, 0.9017871402244848, 0.9183405232113874, 0.9053301507616025, 0.916825357283994, 0.9121079612282584, 0.819882703781949, 0.839701513440585, 0.7972887290061705, 0.8442568267883991, 0.8349863023872007, 0.8000199498819525, 0.831021505349542, 0.7981421789287857, 0.8181642337610537, 0.1322432412042459, 0.7658107427551635, 0.14204927924915267, 0.16089280154935226, 0.11030031191073209, 0.10000662509432945, 0.1588626020048448, 0.12517529341741662, 0.17843443349360755, 0.1401097302002663, 0.11561174471972846, 0.1131585361679095, 0.15582835706824227, 0.13096518056415696, 0.1312001862453701, 0.11724670243141133, 0.12379487756155305, 0.15384105911776202, 0.9869731186658104, 0.9897903749811952, 0.989308050596518, 0.9910518552311641, 0.9876223217773356, 0.9858883777826924, 0.9845630409244831, 0.9859781876409878, 0.9830087802719016, 0.8218180372239174, 0.6506217941387991, 0.7553835160935285, 0.8035286608545008, 0.8337349879880482, 0.7330974749917804, 0.7847735490665548, 0.7948529616253148, 0.7837525134579615, 0.39567324566971407, 0.22679371355420797, 0.8162504021919191, 0.2143050061439672, 0.27811054666311397, 0.21447283366100267, 0.23196596472195963, 0.3913821801525149, 0.22484679722687406, 0.2250690923065214, 0.21710694861272795, 0.30904311059962564, 0.20874909277329445, 0.13508155402283306, 0.19631935760061492, 0.21244539165664134, 0.2075291282008339, 0.20901500661934946, 0.22772737650076802, 0.15300146276818505, 0.22418381905144802, 0.2219645256712598, 0.17777350717626672, 0.38630715956672, 0.2525877829822286, 0.13891561002785513, 0.2301217592956214, 0.13757887010821523, 0.008029879524361738, 0.07682281140617575, 9.999999999998899e-05, 0.011557979626956927, 0.04814205735315902, 0.0001345500585284709, 9.999999999998899e-05, 0.0009300685755968541, 0.13550673411579306, 0.055515897459649355, 0.09840917502586088, 0.0570557445380786, 0.026626223125225668, 0.043200600369616926, 0.13274405952293034, 0.08630601225944812, 0.12831235158456822, 0.05083574996999396, 0.05122528378187885, 0.091680816969262, 0.17846315473981844, 0.16893700954504898, 0.08100729680538676, 0.3258094560295327, 0.1839476193450218, 0.12602275704199217, 0.09854422803494545, 0.2601402911093006, 0.11083352265137159, 0.03953680770424928, 0.18606288379898084, 0.23071296049827883, 0.08505158873849505, 0.18284343331080233, 0.08353142097775912, 0.5831835406303798, 0.532082746349819, 0.5761487655980211, 0.598521587534419, 0.5605955455807488, 0.5314863358113746, 0.5545673598045286, 0.5964030103955718, 0.5644674877886069, 0.07157411539504788, 0.07901704338331506, 0.12460044730890218, 0.09933026770727715, 0.09057967522852173, 0.15474423706621931, 0.10905033127046027, 0.15636385297430766, 0.11773885735837908, 0.20266423801553024, 0.2119536032735193, 0.2642578915177455, 0.2666166096339032, 0.20965801232062353, 0.32794307699848446, 0.19653454773029289, 0.17518114537198504, 0.19337028652446975, 0.38574431749521454, 0.5100643617121714, 0.29512018641467685, 0.27147575065699114, 0.47552591669098787, 0.35739655639620926, 0.3606809176663065, 0.5971346044060013, 0.21545844989821605, 0.17082427920332555, 0.21901300835774895, 0.2373307911350454, 0.24108549803788204, 0.35762778925109395, 0.20276568696328556, 0.169605043224345, 0.19227234544387006, 0.2738307196878612, 0.25847299995963924, 0.22150771305199723, 0.2568126292975641, 0.22674618805839097, 0.24499647548871295, 0.24724620661901386, 0.2424385402179382, 0.21448431935082224, 0.20014986770397125, 0.8467830798634104, 0.22708230701774978, 0.2212619682440603, 0.2523319309679022, 0.8535414957131036, 0.8384087414937231, 0.8111671342367789, 0.18969174574197922, 0.22283915375966934, 0.9422442626018116, 0.9411426435889365, 0.15398833988066796, 0.9353374623205781, 0.20177660239765494, 0.2016679305472946, 0.15405167029595068, 0.16856838911422567, 0.1678297160956116, 0.8616428787544843, 0.21151909767173582, 0.7079950079775283, 0.8703967684025841, 0.15581224741387212, 0.21092608017615355, 0.10539408642163983, 0.1661653709368125, 0.8343128073543851, 0.19339088824279393, 0.2393848488005489, 0.23373580900780366, 0.2031165041451729, 0.19875411127198006, 0.20331955173389638, 0.18799549006416005, 0.19582406216279102, 0.22737431589038948, 0.11207289791796082, 0.11167940705605561, 0.09907519278385024, 0.1025357577501903, 0.1058831904623061, 0.15155464780195071, 0.09450421748815296, 0.0839519604619019, 0.1063187196961155]}, "mutation_prompt": null}
{"id": "c222593d-110a-4b92-8b60-abff974acd7f", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                \n                ortho_direction = np.random.randn(self.dim)\n                ortho_direction /= np.linalg.norm(ortho_direction)\n                orthogonal_component = np.dot(self.velocities[i], ortho_direction) * ortho_direction\n                self.velocities[i] = self.w * (self.velocities[i] - orthogonal_component) + cognitive_velocity + social_velocity \n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduce orthogonal learning for velocity update to enhance exploration and convergence.", "configspace": "", "generation": 90, "fitness": 0.30474180889310304, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9183180123492967, 0.9207314803862571, 0.9132199567431668, 0.9233380111356728, 0.9265648740319613, 0.9256375938333625, 0.9176533259771991, 0.9285437987288045, 0.9260957974890202, 0.09562458989531153, 0.15571587041743729, 0.11370064838782579, 0.15010676993124727, 0.04529543925194557, 0.1021978754257058, 0.10712071469646456, 0.11045196001724511, 0.04502442806445073, 0.16022313465610893, 0.1672219004597253, 0.10337952512259185, 0.1658764399767857, 0.15251761981629985, 0.13700475168239756, 0.14650947700400685, 0.11536245938708345, 0.10979494454857175, 0.15936683638049198, 0.11127407701543712, 0.09267385035751285, 0.10669250150984155, 0.09945366116462151, 0.08410156509751887, 0.17133955870136652, 0.15545528199746894, 0.10413905261805323, 0.9903593196226552, 0.9863236437101905, 0.9873783845499721, 0.9837401976832674, 0.986599186911997, 0.9820684721059195, 0.9817092250084243, 0.9836259643030707, 0.9815947189489912, 0.8172852782801855, 0.8204500488694219, 0.7785310187078391, 0.7958084730950927, 0.7516785647383744, 0.8103488377379513, 0.7856387855214333, 0.7850740440566442, 0.8022607597021313, 0.21605856318408545, 0.2219565213977135, 0.22653860802219572, 0.21550465556147103, 0.27913926633736597, 0.21496986012624952, 0.23648095732829022, 0.23227807024673253, 0.9082426928519314, 0.20806185819297518, 0.12801315601372787, 0.19675513809094258, 0.20325476192141978, 0.21058619327529826, 0.24454519051933, 0.210047355930438, 0.21613624799232822, 0.21708784057936148, 0.24966011837872348, 0.21779766173846893, 0.2651888107115503, 0.22768830641215598, 0.20116159464811678, 0.21987962944098394, 0.252487026893187, 0.22133611630416372, 0.2515796663789751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013170091116422422, 9.999999999998899e-05, 0.0253590889742501, 0.0070691868920028655, 9.999999999998899e-05, 9.999999999998899e-05, 0.08801240163311908, 0.058556408838447704, 0.16526791780362693, 0.09691367892060365, 0.02903876872854194, 0.031361660372544065, 0.13422249266442066, 0.12015729286677301, 0.06971002595627018, 0.11019804395967525, 0.3245961674656953, 0.13994449239882745, 0.10212608523108269, 0.09632359847858296, 0.18548470218150992, 0.07580861255460913, 0.20504881216713577, 0.07593095417912232, 0.11609624112558325, 0.09527668984199367, 0.33900410871077513, 0.2116698991535395, 0.07273722330414889, 0.25880650010738504, 0.1787185688501537, 0.06989999936363367, 0.09532403793065714, 0.5278891035257225, 0.5617735605335119, 0.6228820179802746, 0.5056493843308164, 0.5712469630880502, 0.5796788540827043, 0.5828449046740318, 0.5628930235679529, 0.557069755112157, 0.11515877385220752, 0.1821283430348486, 0.11464060004454935, 0.15486305123742872, 0.11739971723731302, 0.10168489142594406, 0.1396748883809179, 0.16133491964675228, 0.16207326143094591, 0.25371379288333396, 0.21783819878967714, 0.41057700313362866, 0.2330310821982282, 0.3044191227483538, 0.3255919394409432, 0.36161367884911166, 0.19259762507676292, 0.43096854142798535, 0.31438957067482487, 0.3125343094287094, 0.3511808783360397, 0.4821492346611458, 0.5066910382013027, 0.29790599650839944, 0.23228874197895877, 0.5913029844123141, 0.4797046785776068, 0.19716001942657546, 0.2725732299095093, 0.27842684271506424, 0.25119330001281215, 0.4990082206640045, 0.24349334362833008, 0.19977117864714256, 0.20801916075484173, 0.31202829624180684, 0.23795815017918753, 0.25364289341450175, 0.21268609852249187, 0.19439082802059282, 0.26433069568468304, 0.2621360664645719, 0.3048776023580342, 0.2179926488481514, 0.20880920918758827, 0.20786693269816703, 0.21127270810613896, 0.24339468761611593, 0.1915172206503486, 0.21123474722856417, 0.19885767437477786, 0.189614494428062, 0.19719240003292438, 0.20932509636991747, 0.9257098372364583, 0.1888300564839086, 0.1543890981535927, 0.931499174957524, 0.20128195230671808, 0.20198340164665596, 0.16815463673540976, 0.16805999154098028, 0.16795890135530556, 0.6599844325939144, 0.2127859930631003, 0.5853717288004978, 0.212485594870644, 0.16990017653143918, 0.21328695818041765, 0.10537080314145875, 0.16897550513785242, 0.6394405018926721, 0.18997239430261292, 0.25127372212147225, 0.2131323985992145, 0.2228230704524633, 0.21781163276952098, 0.1947184173183386, 0.21306144162105367, 0.18066597461186829, 0.19977180432784525, 0.09349577030887124, 0.09123764901881348, 0.09033955066891597, 0.13304629522276923, 0.10092990835078186, 0.09206664552197541, 0.09229561948028242, 0.11078566864359618, 0.10010350818181046]}, "mutation_prompt": null}
{"id": "f09f0dec-6dd1-44ff-8d5b-c639afd4caab", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search_radius = 0.1 + 0.4 * (self.evaluations / self.budget)  # Dynamic expansion\n                    local_search = self.positions[i] + np.random.uniform(-local_search_radius, local_search_radius, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduce a dynamic local search neighborhood expansion based on evaluation count to enhance exploration.", "configspace": "", "generation": 91, "fitness": 0.34917866462127034, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9194600043313504, 0.9085079138731335, 0.9117214021967786, 0.9221527712151382, 0.9029519102789725, 0.9200651922740988, 0.9154585922961876, 0.917824506206244, 0.9087768879739441, 0.8309291451777376, 0.8461647814296285, 0.8117311854025229, 0.842946208964556, 0.8134348277974508, 0.830406306753515, 0.0534537278192081, 0.8183857275731405, 0.8467004214330839, 0.14143876918538312, 0.5810425134334396, 0.1395467825688973, 0.12456955550103499, 0.18018017140526355, 0.11487088564087067, 0.15999567039459395, 0.17858341103353936, 0.12250156312276284, 0.14114997157954112, 0.11558602358643622, 0.10843297551970221, 0.1781252029237106, 0.11750568173286324, 0.17265333164553454, 0.09909916139879638, 0.14078532815503308, 0.143199397199805, 0.9869731186658104, 0.9897903961156446, 0.9893079617727975, 0.9910601631379169, 0.9876223217773356, 0.9858884213074853, 0.9845630409244831, 0.985978183105928, 0.9830091940438455, 0.5368539462254094, 0.7711360319691059, 0.7245215348277507, 0.5719571208651282, 0.7559211511464432, 0.8297578041457494, 0.7346428715347997, 0.695309942450208, 0.7999456416295964, 0.3893359303154139, 0.22686837148418804, 0.8487136652573264, 0.24984022888292934, 0.2768033063961678, 0.21443650403217185, 0.23651651971953214, 0.378511549688926, 0.20953354996271512, 0.19982556654677297, 0.19197777287268047, 0.3025387230212102, 0.1944029362764459, 0.13502105583913804, 0.20349264258656152, 0.21944377399278026, 0.21734670448315496, 0.21440426022168613, 0.21674986163631038, 0.15216804819775265, 0.23085756182507033, 0.1894789148686944, 0.20097953408908453, 0.5848883338763187, 0.2700547896074086, 0.13838563716881958, 0.2495202588549471, 0.09778742639979043, 0.015916651423691253, 0.09486820908732718, 9.999999999998899e-05, 0.10528013225055488, 0.04890304622602237, 0.0024634825289191475, 9.999999999998899e-05, 0.0003401081003032713, 0.1437335026845079, 0.04089543635937021, 0.1024977536405195, 0.04234115855736764, 0.028634583148771653, 0.043188683610761114, 0.1389917558419269, 0.1273573549739534, 0.13837607010964714, 0.051065394387043495, 0.05096047357615152, 0.09040188788210712, 0.19142709688537207, 0.1670186358057898, 0.07941157840583768, 0.32298507242581176, 0.17921642340228883, 0.12119995347539403, 0.09364761208405403, 0.2721202868113831, 0.11601018858429046, 0.0396275827310576, 0.16952019499910642, 0.2043985072240071, 0.08506709128665446, 0.16152372673389237, 0.09526659095362577, 0.5372143949687098, 0.5172450072735761, 0.5976351113214834, 0.5651948067713777, 0.5992101742949933, 0.5629393968898484, 0.5790846627443185, 0.5894848642770467, 0.5607252047908892, 0.07180499028931264, 0.07900918114134292, 0.11286333904429724, 0.11937703777826014, 0.09625964741977855, 0.1241179599014618, 0.10917569253533033, 0.156597552437591, 0.13934207453323777, 0.2727438530061227, 0.19918743943793138, 0.26308735367131497, 0.314555649813415, 0.3430492783028207, 0.3097339988972726, 0.23101800765409453, 0.19307262034317407, 0.22719404421560352, 0.41120404138588706, 0.3422470421769158, 0.24694776916758554, 0.3460910990791263, 0.5269303205275131, 0.3431065771595365, 0.3508940562417564, 0.4362172333819586, 0.21846161737488412, 0.1628138859429903, 0.23343811861430064, 0.21952939962329765, 0.22888911904075016, 0.3701690797809235, 0.297499154499289, 0.17189039381008153, 0.21545162044052302, 0.3242273104728026, 0.20446764068952517, 0.27089123052430697, 0.25512381649920035, 0.25282077786742363, 0.235097159925846, 0.2379644414353348, 0.21126233428189312, 0.23486994598404531, 0.23592738764025645, 0.8603506099414062, 0.2522314870838037, 0.22343990619247112, 0.25230863669692405, 0.8836833647601683, 0.8570991017753259, 0.7994942208012537, 0.19098392666688335, 0.2490242215955497, 0.9418280510530748, 0.943784557707634, 0.15398775772153517, 0.9318272593282528, 0.2017751659369833, 0.20166412461950955, 0.15404996541718596, 0.16856970012536499, 0.16784534006446028, 0.8619002299398415, 0.21179176588563653, 0.6902894160351363, 0.7824035748986196, 0.1558308252388586, 0.21093792801690348, 0.10539394373258715, 0.1661643143664825, 0.8577321693928728, 0.21299293545800235, 0.24267854399052136, 0.21979647764976185, 0.20274577298353968, 0.1993421948155859, 0.20330516673762655, 0.21847278996792208, 0.20152594169868165, 0.20739427608875272, 0.09051874754591804, 0.08206641538290549, 0.08192562413768267, 0.1596885126337354, 0.10670028205281579, 0.1682261911046129, 0.10259073861646306, 0.09494548167214778, 0.1066115743695909]}, "mutation_prompt": null}
{"id": "599e79a6-4c34-4f4f-a2ff-d58fdd518f6b", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                        diff_vector = random_particle - self.positions[np.random.randint(self.num_particles)]\n                        mutant += 0.1 * diff_vector  # Differential mutation strategy\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduce differential mutation and adaptive velocity scaling for improved exploration-exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.34189001247603745, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.30.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9146860083568693, 0.9069581927423565, 0.920735279327112, 0.9113874344005328, 0.9077077301411439, 0.9205467366661274, 0.9197573505637343, 0.9020623803303356, 0.916761709247923, 0.8302879368945018, 0.04250441445164488, 0.8302115819170814, 0.8322550254424181, 0.8317282694978079, 0.8109240424194517, 0.834338253955754, 0.8383664309640688, 0.8097961795035518, 0.1010214053101206, 0.18092577050633896, 0.16333227233908398, 0.12400801968868636, 0.15690759105825725, 0.12012642152425956, 0.18347367206673437, 0.14143562897460993, 0.18106008936365092, 0.17659866948706204, 0.11465421206605475, 0.1497609310066811, 0.159646633392854, 0.13931341181981483, 0.15540182564365135, 0.18745900142543104, 0.11642733046917253, 0.09191330321246316, 0.9875258990534028, 0.9839968461657591, 0.9903943484479825, 0.9921550319406884, 0.9843337318572148, 0.9860785088807574, 0.9845941614210295, 0.9875523413954663, 0.9816466196840431, 0.6867731819553283, 0.8149241414375176, 0.8230831757013402, 0.7074477686936207, 0.7827361720408144, 0.8289313004370323, 0.7851916300049421, 0.804543615978916, 0.7803154998989472, 0.23243034669224927, 0.21582909028089947, 0.2272216625476352, 0.1950385062391098, 0.44870276734624504, 0.28258212019421514, 0.23332529304271998, 0.8934702884990928, 0.7984433111297902, 0.12416015131347236, 0.22336113827308102, 0.21546229636429026, 0.2567588404446377, 0.21395979682230448, 0.12232980681346106, 0.2214095943558384, 0.20415972430677765, 0.20364316866296317, 0.23883872439845066, 0.21903483430976312, 0.21676436111985387, 0.20288930018315277, 0.217411555211943, 0.2297291455516427, 0.2859677960152275, 0.24649145402457995, 0.2623150928545932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05084514025518838, 9.999999999998899e-05, 9.999999999998899e-05, 0.0416291909558435, 9.999999999998899e-05, 0.003099128707162113, 0.1210453029421904, 0.045530766226864805, 0.12430319286336489, 0.07564202112497387, 0.020010052081950058, 0.04215146787650226, 0.17944571724222735, 0.0985407291192445, 0.06640892003576138, 0.051016777918382106, 0.10785061137636553, 0.4660115479063581, 0.10437054575318783, 0.11944822552573242, 0.08116850480338744, 0.08386647114015999, 0.10454646681074242, 0.14895697508113082, 0.09505396305547642, 0.14719500259591822, 0.12316775119202539, 0.09822361750857123, 0.01606680976487873, 0.169642276348694, 0.0857053700280217, 0.05797510909473602, 0.08316115765417376, 0.5430247633084286, 0.5246148773713126, 0.5437734700710954, 0.525349070334069, 0.6150873743170606, 0.5419040347050053, 0.5753403082132699, 0.5843859483170822, 0.5821233185298245, 0.09503449992550506, 0.08858868769796469, 0.12458280337977756, 0.11419125054015256, 0.12400954709692213, 0.11182324859639281, 0.1617688155374346, 0.12976538785700686, 0.08768997829674496, 0.40490205100630006, 0.2767905861071833, 0.3604839919267615, 0.4440184827297238, 0.3078621748899103, 0.2206531724935621, 0.21539577982941438, 0.22126947754657056, 0.192259734573209, 0.3004435021954841, 0.3030449878940381, 0.3417806240392497, 0.3168693925135574, 0.28579728871415866, 0.4773601611365198, 0.2609462883666279, 0.4567616622903886, 0.21328884777888324, 0.1751227087688958, 0.3442222224876397, 0.24218958320534334, 0.25831485255382136, 0.28209137846526, 0.2747707433706468, 0.20604304362641312, 0.2234670353345617, 0.25741964657653116, 0.2307536381675861, 0.24328055339507348, 0.23620395910349878, 0.21268959050380587, 0.23660343709082898, 0.24630223542930085, 0.23275190239832932, 0.23597180315096067, 0.23628196996181505, 0.22676073228970606, 0.25408988860684245, 0.1997769133359637, 0.19377756201160357, 0.8448812103347227, 0.22504021077948, 0.1983251136587454, 0.8671751421951176, 0.253656262484807, 0.9108580056911808, 0.9377249359477938, 0.15462908154449562, 0.9417509947502983, 0.20185082284418454, 0.20159299912575812, 0.16219319453346093, 0.16803118941733086, 0.1680772185225996, 0.6629790617639275, 0.21133573722375198, 0.8742557577515088, 0.8679761968025425, 0.16978705301574915, 0.1561021632421118, 0.10532102218603034, 0.16901723924096645, 0.8145782577522835, 0.1794563087580705, 0.2262029792602127, 0.21791890567782735, 0.2190032857648444, 0.20806918280476017, 0.2165016434941126, 0.19215997555906994, 0.21224249605029877, 0.21968796652563338, 0.09561377984097585, 0.11037657581150995, 0.10701782432952311, 0.09871382946784357, 0.09440756308623643, 0.09383212742562497, 0.10251452249266424, 0.10358918919271909, 0.1008105773529624]}, "mutation_prompt": null}
{"id": "14588310-6bdd-4042-8215-6ba6f310d7f9", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < (self.mutation_rate * 0.8 + adapt_coeff * 0.1):\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Introduce orthogonal exploration with a refined adaptive velocity perturbation for improved convergence.", "configspace": "", "generation": 93, "fitness": 0.32566799872879815, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.916271626123537, 0.9009453263722454, 0.9067570218633745, 0.9029943629447351, 0.9120919707299839, 0.9011589439211568, 0.9019812388692352, 0.8983483728831373, 0.9066999410112275, 0.07671137875588607, 0.8099321535282844, 0.8164400581147175, 0.8100099055021314, 0.8247853831726818, 0.8004508561328595, 0.7922983616460976, 0.8134958289468708, 0.8011895828438875, 0.12327975709384209, 0.13040893418392696, 0.12684975520379727, 0.11561794700489858, 0.123677741050636, 0.14449857046923265, 0.13858516801723875, 0.1563320398441168, 0.172058894099554, 0.18201480233051037, 0.10996920542568112, 0.12730583259211348, 0.11431964712207754, 0.11359123140991212, 0.12024912871652471, 0.15585735395392952, 0.11381169857192819, 0.09530150468163645, 0.9891006383899367, 0.9860935075058301, 0.9903631748151895, 0.9899420345440311, 0.9869005236360155, 0.9877323372304645, 0.9868313027162051, 0.9882189200768763, 0.9841187994784574, 0.8167256788299481, 0.8010749072357983, 0.8035866528761898, 0.789101026333779, 0.7437100518711777, 0.7429658233751304, 0.7630025406673082, 0.7621157134926563, 0.706660170663285, 0.19964073375278157, 0.22658012695150198, 0.22899738372831557, 0.38154767589366756, 0.1945400202579851, 0.20614185575574817, 0.5660666022878658, 0.17451453117460003, 0.2338014612201813, 0.2238394461271872, 0.13220447503561394, 0.20400881507108515, 0.22101434505540485, 0.13124613134898644, 0.23007818888539577, 0.1953547548316672, 0.2146380927771102, 0.3989333199019538, 0.20714957429394887, 0.18499285379596075, 0.22073142424104342, 0.19243026859865286, 0.22751662607452794, 0.2156530454332598, 0.2568906625657007, 0.2533864934189479, 0.24584334522282592, 0.060440725239620074, 9.999999999998899e-05, 9.999999999998899e-05, 0.17914669061051047, 0.005945088584312197, 9.999999999998899e-05, 0.025893179790503207, 0.00900520842025565, 0.0910483914347997, 0.04943906836459133, 0.05932109794810325, 0.10455041231612794, 0.06626276650293073, 9.999999999998899e-05, 0.04985903887804288, 0.10391546882255642, 0.06573243762397885, 0.06732636135502212, 0.05062160211935118, 0.12205233207373878, 0.15614773206768773, 0.1945512508851559, 0.08131773379817564, 0.13436991702455925, 0.07299131437326067, 0.17949738155709716, 0.08866190866334933, 0.07289291353408078, 0.04898640629008133, 0.23574890792402037, 0.14584613034827654, 0.11556890568173817, 0.08521718029642067, 0.09266258352793011, 0.05750475885592443, 0.08278980403828429, 0.5334029069084054, 0.5272135003900695, 0.536417003439863, 0.5850272837326056, 0.5368953724645076, 0.5544724594771719, 0.5581036644534192, 0.5722905402776423, 0.5831562455452446, 0.17729217260071195, 0.0801332028188122, 0.1289295984837614, 0.09272579035838957, 0.15278667540551727, 0.09830127415624124, 0.11939082311733396, 0.15396789335413286, 0.08072670511574709, 0.361260205033304, 0.23203189131869006, 0.25619767406965643, 0.332851629750213, 0.31846788469864373, 0.17069787077698861, 0.2250227336469719, 0.20250203782434573, 0.3241404017956745, 0.4515147084579457, 0.3795426008103687, 0.47430945478300945, 0.35808601771716053, 0.276989975505593, 0.28287976747272303, 0.34130731729255215, 0.23725582548783164, 0.38199598299384174, 0.23148622333513325, 0.16049633291390786, 0.20744504939636033, 0.1953697110391811, 0.21686464813769346, 0.24376967632950408, 0.21725456401715348, 0.28074021907460023, 0.09007031282014089, 0.24908947823562821, 0.2029945091766331, 0.2134306706999347, 0.20352372959480935, 0.21026228059340002, 0.222535846769497, 0.2289204584994533, 0.2758796069078545, 0.2554942661937304, 0.19796474628227845, 0.23786769409059239, 0.8537294337192542, 0.21292409233964216, 0.25137175587556115, 0.201099284681714, 0.199444407976069, 0.19988201249048432, 0.199460525370027, 0.9304798527266949, 0.9338481476684486, 0.15426674164956933, 0.9408720576854459, 0.20100819933841096, 0.17014305744386948, 0.16747133591491437, 0.16801764335399716, 0.16671401874788772, 0.5507950770978097, 0.21251844265580822, 0.6677938160008061, 0.794125789717589, 0.156288514277098, 0.21340786645811138, 0.1051367768300342, 0.16864473099164767, 0.5962353891437742, 0.1845351848146507, 0.20350602617418534, 0.19382865795629634, 0.2058437835110073, 0.1924961460812732, 0.19357846099751252, 0.18213942137592043, 0.21436984192623154, 0.23273239712004057, 0.09343176402385689, 0.07357530908753163, 0.09030365347750124, 0.143803661339165, 0.08444564449681691, 0.1396192288617707, 0.1038934773195378, 0.09109467297226181, 0.08767202656330664]}, "mutation_prompt": null}
{"id": "7a62adb8-9652-4b33-90db-f134f5e4ee37", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)\n            self.c1 = self.c1_base + 0.5 * adapt_coeff\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.2, self.dim)  # Adjusted Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.3, 0.3, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV_Refined", "description": "Enhance global search by introducing adaptive range scaling and improved mutation strategy within allowed modification limits.", "configspace": "", "generation": 94, "fitness": 0.3466543119194658, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9130480225901445, 0.916951537365861, 0.9122074403635312, 0.9249232246543008, 0.9094923487660586, 0.9150226364191549, 0.9113093996848082, 0.9138453865622418, 0.9189903314303354, 0.8250258771288036, 0.8448549960531834, 0.8184689253567895, 0.832505382168683, 0.8215336147562717, 0.8313874980921865, 0.813086737628322, 0.8235703565211513, 0.8224458530481618, 0.7325785914441938, 0.7456241606006304, 0.175954491070634, 0.14662044975682997, 0.7624546993058566, 0.12960932956910332, 0.7727037951749015, 0.1779427501448636, 0.15700242590214109, 0.1252248481557463, 0.09493918925515499, 0.15898643673938806, 0.1562954391236, 0.1200933143490649, 0.11338065293267519, 0.122812763161817, 0.1431318323271047, 0.09749637308158887, 0.9857942819227943, 0.9897949672678809, 0.9893132162223921, 0.9915966719670389, 0.9876214497696082, 0.9858883915703277, 0.9845766367984675, 0.985595718271736, 0.9825212725002305, 0.7921065977662158, 0.7852522078030485, 0.7935697643610365, 0.45530433993367647, 0.7792285451260621, 0.811688857548723, 0.7959064206332196, 0.7185400697711983, 0.8187954933630699, 0.2799883484837524, 0.228868195132642, 0.22832819422943884, 0.38412403634960024, 0.21261737686979942, 0.20508739303454526, 0.2352291801644093, 0.23605802232563033, 0.2375058793175836, 0.37759547073369326, 0.2244970430857367, 0.2944022052826577, 0.20726199481745822, 0.13591806735355094, 0.20299535558936965, 0.20984011318665463, 0.2106162573392537, 0.21777326544473796, 0.2284855960308133, 0.1316323225010272, 0.20888742314602404, 0.2286066629999325, 0.13480876337219905, 0.24154432229711575, 0.23945041018350566, 0.10366229493765244, 0.2487474464330489, 0.005429994553343587, 9.999999999998899e-05, 0.14907412380570928, 0.007420875308730146, 0.032209275881997956, 0.03197082282568864, 9.999999999998899e-05, 0.1297151234161853, 0.09458745650141376, 0.12569278487482993, 0.04782677355823639, 0.08015260908974542, 0.0674609855323246, 0.020701501084820162, 0.03766591763548821, 0.13614092463197358, 0.08217773111664861, 0.12289383979306145, 0.05140287856608161, 0.05089359442599761, 0.09216768109375939, 0.17496825580260522, 0.25290460218459954, 0.08047462380853088, 0.15329037481205154, 0.19558203492155335, 0.27501409658291853, 0.10998861991056141, 0.32677465604835365, 0.04357393987094038, 0.04031476225411912, 0.13355807308759504, 0.14940712766876552, 0.08622578601476294, 0.17075782152847374, 0.08395098803746748, 0.546708734293694, 0.5543823244846708, 0.5650739422769884, 0.5617545039531713, 0.5742855489736347, 0.548004448882727, 0.581582682909477, 0.5725375281346388, 0.6072441905838786, 0.11697113173146356, 0.08360688024484064, 0.10875123111240825, 0.10013285056071086, 0.13138876395760657, 0.1202175934176779, 0.16091033635254248, 0.12253312362549984, 0.1179984505483972, 0.28099008253736235, 0.3107556920210993, 0.25713180611281106, 0.3303118066123518, 0.2056921841809204, 0.22232898331701934, 0.344820337299677, 0.1725922950299822, 0.21706602119073293, 0.34770380376361854, 0.39726849845955736, 0.3667599290904151, 0.324723315719884, 0.36131777429674994, 0.3125077885232247, 0.2531030451442614, 0.3558373144634238, 0.17452094788848171, 0.18250410457703614, 0.2696766140940551, 0.23310809155360868, 0.24692406522969423, 0.28595149706215506, 0.15924656691703898, 0.17995789796029438, 0.22767185476381446, 0.33516760985560123, 0.2266307738750477, 0.21956439662500715, 0.225224107601654, 0.19899376563367, 0.23236509275569717, 0.22094892129985744, 0.24209391053508666, 0.2228718652549252, 0.23107079668259511, 0.22394044303837302, 0.2018013994418929, 0.24443113731130472, 0.2097045607516953, 0.7102309883436992, 0.21296621615318012, 0.8450635755354468, 0.21168136751034716, 0.21314979652024957, 0.925454313164976, 0.9347205055846445, 0.15429914350147989, 0.9233537172456481, 0.20183891946005927, 0.2017163403172495, 0.15436112151248615, 0.1685472233887434, 0.16799844998858493, 0.08311354504381574, 0.21195121050998922, 0.8848319014008433, 0.9217441011354663, 0.1557712872863054, 0.21111987816302247, 0.10539565116698812, 0.16737144262744497, 0.7763998132623554, 0.18130425726646937, 0.21861917790314633, 0.22057010537071542, 0.2455984984616837, 0.22279973680634146, 0.1869181803116432, 0.22367424839400218, 0.28551207507560916, 0.2103314465818028, 0.09181098667588339, 0.10388285884285631, 0.08802126517520625, 0.11216232808178195, 0.09779987301997972, 0.1497153067262056, 0.09371233484592689, 0.0947157618017036, 0.10601874977174197]}, "mutation_prompt": null}
{"id": "83737cdf-bb62-4ca4-bcdd-811601e689a6", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        last_global_best_score = self.global_best_score  # New variable to track the last best score\n        stagnation_counter = 0  # Counter for stagnation detection\n\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)\n            self.c1 = self.c1_base + 0.5 * adapt_coeff\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)\n\n            # Adjust parameters based on performance feedback\n            if self.global_best_score >= last_global_best_score:\n                stagnation_counter += 1\n                if stagnation_counter > 10:  # If no improvement for 10 cycles, increase exploration\n                    self.v_max *= 1.05  # Slightly increase velocity max to boost exploration\n                    self.mutation_rate *= 1.05  # Slightly increase mutation rate\n            else:\n                stagnation_counter = 0\n\n            last_global_best_score = self.global_best_score  # Update the last best score\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhance exploration by dynamically adjusting velocity limits and mutation rates based on performance feedback.", "configspace": "", "generation": 95, "fitness": 0.3514431818753087, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9124648713627627, 0.9194687384331905, 0.9111667808335107, 0.9214140405987428, 0.9017871402244848, 0.9183405232113874, 0.9053301507616025, 0.916825357283994, 0.9056654712836227, 0.819882703781949, 0.8229534976157513, 0.8194721744122668, 0.8442568267883991, 0.8349863023872007, 0.8372671751973124, 0.826218819567722, 0.8239742179897105, 0.8207290673683588, 0.1322433423151902, 0.7721873334418345, 0.1735126675989077, 0.16089280154935226, 0.1274777859706926, 0.16811216019003028, 0.1588626020048448, 0.14354873972860893, 0.14984318427230225, 0.11512147162012554, 0.11561174471972846, 0.12832524048516702, 0.12936160183538015, 0.13096518056415696, 0.09958946531405977, 0.14135070708609287, 0.12379480904870488, 0.12888029178326155, 0.9869731186658104, 0.9897903749811952, 0.989308050596518, 0.9910518552311641, 0.9876223217773356, 0.9858883777826924, 0.9845630409244831, 0.9859781876409878, 0.9830087802719016, 0.8218180372239174, 0.6506217941387991, 0.742190434433041, 0.8035286608545008, 0.8337349879880482, 0.7725603147603606, 0.7847735490665548, 0.7948529616253148, 0.8202344586997751, 0.3325839022637831, 0.22692567684366816, 0.8687012353365164, 0.2142563546799804, 0.27815342565720425, 0.2144748103493599, 0.23196596472195963, 0.3675503005724984, 0.2291373089919313, 0.22673969027577723, 0.20433123148281707, 0.30454425048779676, 0.20922415885878964, 0.13514745197216693, 0.18690384621334366, 0.21850976275897005, 0.2075291282008339, 0.213818036887356, 0.2225216512910263, 0.15300146276818505, 0.21491382986365193, 0.21818744299434267, 0.13457093367987094, 0.37877862286477115, 0.25393578165451547, 0.13891561002785513, 0.24542267134897233, 0.1359396134908757, 0.05534621292816411, 0.07990178590684793, 9.999999999998899e-05, 0.006665079041967004, 0.04900505154366874, 0.0020398835874231303, 9.999999999998899e-05, 0.002847998599732282, 0.130229536295833, 0.05232232834197226, 0.11470436155215813, 0.05398113559302109, 0.031441341493780195, 0.036897175625474676, 0.14969978636399506, 0.08167996741315475, 0.11902919856956418, 0.05083574996999396, 0.05156610304109022, 0.100040857165835, 0.15632105196793544, 0.16893700954504898, 0.08100730275297119, 0.32581183347519715, 0.1839476193450218, 0.12602769854387152, 0.09854422803494545, 0.28007760926485226, 0.11084059921738632, 0.045174129297388066, 0.18606288379898084, 0.2046084189119559, 0.08521672144540404, 0.18284343331118647, 0.08353196967409582, 0.5840296948660415, 0.5143047827836077, 0.5657321273975486, 0.5993692071223757, 0.5671544300408699, 0.5352514248451634, 0.5526321497030103, 0.5964030103955718, 0.5763302110895197, 0.084637049637312, 0.08444383173531045, 0.12455360335144305, 0.1123354125326036, 0.1424772735048524, 0.15499068861947707, 0.11002448981885082, 0.1578025534241556, 0.11774653850953365, 0.2264435891967853, 0.30363977363616945, 0.26030917154300637, 0.20229287922110306, 0.48616720249338163, 0.21221972236556663, 0.2049767799563319, 0.18367601109939935, 0.17722943421925197, 0.3857442461993207, 0.30912005513203744, 0.2962093807648225, 0.3392085386362462, 0.35784460523254624, 0.3586815161848954, 0.36068092897761317, 0.47059672387122964, 0.2180614927673835, 0.15813552712370782, 0.2111109554625309, 0.21778851841458058, 0.22077954264313016, 0.25012483051999157, 0.2095811089616677, 0.17026277147453073, 0.19230011903057098, 0.27372883851088037, 0.24608055015780572, 0.2492925675471388, 0.20981916390671107, 0.23269212546998708, 0.2435070918879625, 0.20792327924315734, 0.26084094323234963, 0.2746653624339883, 0.19567279052491693, 0.8620592156044892, 0.25453535403901295, 0.8460402431441727, 0.25292228714927345, 0.8523867187156244, 0.20216814808795625, 0.7963997959243904, 0.18969174574197922, 0.20980566419884517, 0.9422442626018116, 0.9411426435889365, 0.1539883398825168, 0.9383048612803438, 0.20177434407640737, 0.20166793055445853, 0.1540562551675766, 0.16856223457073993, 0.1678297203276936, 0.8616428787544843, 0.21151909767173582, 0.6727891102160575, 0.8703967684025841, 0.15581224741387212, 0.21092608589969075, 0.10539322350095304, 0.1661653709368125, 0.8492976102956556, 0.1993821585552784, 0.21195270875497663, 0.2085887423349818, 0.1879136004568761, 0.20044769496326154, 0.19668755091291767, 0.20307702711258102, 0.186993480346058, 0.20765136651743354, 0.10247535913775518, 0.10661730084192445, 0.10089451020598994, 0.11109931911336735, 0.10475903070947057, 0.1519902304262799, 0.10381365866505954, 0.09700229669352178, 0.10877796069936863]}, "mutation_prompt": null}
{"id": "547d3780-2d57-4323-9595-0f23c5188354", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    # Adaptive local search with Lvy flight\n                    levy_step = np.random.standard_cauchy(self.dim) * 0.1\n                    local_search = self.positions[i] + levy_step\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Refine the exploitation phase by introducing adaptive local search using a Lvy flight step.", "configspace": "", "generation": 96, "fitness": 0.3353059463341992, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.30.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9113372020055318, 0.9089798437796472, 0.9160184295256797, 0.9155863214696631, 0.9064543986768594, 0.9098647036878282, 0.9138557356102223, 0.9077832423900958, 0.9165551941494732, 0.8297242215557422, 0.8367845830464421, 0.8199945097384163, 0.833619583778681, 0.04860112994874288, 0.8356187658273689, 0.05266097272984083, 0.8396027731762601, 0.8366847370239621, 0.7294294525164674, 0.11943042509176538, 0.17218328414437234, 0.14387223824878315, 0.1839214962899528, 0.13348829940949292, 0.18435420362547594, 0.15931917305786925, 0.11815633790195568, 0.12460267275664172, 0.13349303923761724, 0.1375191760377691, 0.11527733539061735, 0.11130288265966459, 0.15444518929894913, 0.1736439761378602, 0.1418993130430778, 0.1047267711961758, 0.9892559100172449, 0.9837559386721229, 0.9924939605167309, 0.9878610075989039, 0.9902259721770206, 0.9873505120189485, 0.9865989632065776, 0.9877931857228319, 0.9845391663393099, 0.784390063491502, 0.610787047007673, 0.777524192901982, 0.7940468349705727, 0.7515326205366327, 0.7626645062885102, 0.6736995279062383, 0.7917453027278991, 0.7792637857153346, 0.390220631904742, 0.16704714319197156, 0.3624416575983508, 0.359543336377507, 0.20815806129799852, 0.1941514161447686, 0.868174156931695, 0.177798775554888, 0.8594788753257148, 0.12827938855352894, 0.19776755382888878, 0.211985109955532, 0.20605005075070726, 0.21011444916329847, 0.21457645351295118, 0.214978028231689, 0.22383272299564805, 0.20864607913346378, 0.18813754819752038, 0.11932216222390546, 0.1977106319677009, 0.2257085219307835, 0.23931187003646526, 0.1363869811894296, 0.20902668781263134, 0.24054820322779524, 0.21688923356490153, 0.1006725199991001, 0.004996306485131163, 0.19254911544378106, 0.04345661573970683, 9.999999999998899e-05, 0.011165819751763006, 0.01025702466998335, 9.999999999998899e-05, 0.11023534131344459, 0.06223404287588963, 0.04836689423356588, 0.092540762580816, 0.07698509044523327, 0.0437488816438425, 0.03562818911694576, 0.08705901816111472, 0.06709697521998914, 0.10503329417259777, 0.05092158581073314, 0.1665951305771256, 0.2267085650029489, 0.15914584861981962, 0.08022922449765213, 0.08052344611773932, 0.11371032791766211, 0.07583664805549983, 0.07487894905860981, 0.04358979059918566, 0.0426362502365315, 0.08150661310416396, 0.049320573942019164, 0.0067368941412178085, 0.0983174924554654, 0.15065294193998724, 0.08771905892183918, 0.10477543776490694, 0.5437956131352896, 0.529887032298209, 0.5401179344387931, 0.5389140158102665, 0.5879485645004884, 0.5468138560173722, 0.5876608380751214, 0.5575798145387333, 0.5761064389039333, 0.11640612531035455, 0.14662508068527036, 0.12405859665337393, 0.13098433114006747, 0.1805382096996051, 0.09290147273209515, 0.18942535107866842, 0.11150922427387433, 0.09864677056596971, 0.21006449903321422, 0.32067846809386114, 0.3652991304375791, 0.24176586556232738, 0.3230139994044081, 0.21278284355486965, 0.28050354923132437, 0.28652179928203136, 0.16930164038171858, 0.3633957616598136, 0.3230352094131991, 0.19129572682586782, 0.333926196746023, 0.4358082848977901, 0.39430100341293184, 0.23974382482152146, 0.2834761143902722, 0.2458889981501745, 0.24553740111154299, 0.25174625362156755, 0.16887030892438748, 0.2970495040753347, 0.28015621829503523, 0.19576641379715387, 0.17797064762669434, 0.21591135676539552, 0.21211761844920507, 0.232715837550298, 0.21597282076115654, 0.23726738255751967, 0.31246846937946293, 0.19668299111019705, 0.20242605088425814, 0.2292572355336021, 0.22575414525137072, 0.2288208723019678, 0.2537224258740213, 0.8528895701513841, 0.7193477209903082, 0.22441991843569253, 0.8537587178284087, 0.198338544786971, 0.222675031924927, 0.2081016896620399, 0.21150364318969628, 0.9276388265634938, 0.9286770024201498, 0.15435863443610265, 0.9454090353914539, 0.2008687088283404, 0.5025908281801399, 0.15817719938056307, 0.1675567806010262, 0.16735347846633664, 0.7471107833758079, 0.21357013021672544, 0.6853006801528295, 0.2128519198569322, 0.16824503082269404, 0.21126173071321042, 0.10545502380917371, 0.1678472288396099, 0.7934873169723083, 0.2080259532932076, 0.21636046272936882, 0.19413831366065737, 0.19668386798302173, 0.20140579975605455, 0.2398116528223394, 0.187696148200318, 0.1903749204669959, 0.2428020415173202, 0.10212501856539913, 0.1043081294985081, 0.09179905371586594, 0.12946897782604627, 0.10028506466166787, 0.09991084365852387, 0.11313778509450079, 0.09360001115085692, 0.10578253536196824]}, "mutation_prompt": null}
{"id": "f4011927-1317-4430-812e-6d27255e2000", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.normal(0, 0.1, self.dim) * (random_particle - self.positions[i])  # Dual Gaussian mutation\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhance the exploration phase by increasing mutation diversity with dual Gaussian distributions.", "configspace": "", "generation": 97, "fitness": 0.34556170326862545, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9133281284388107, 0.9139102420092191, 0.9206307897062226, 0.9188114875512317, 0.9188562611549373, 0.9210460115145841, 0.9182669930572219, 0.9066987736636294, 0.9231943427381974, 0.8221949202401417, 0.8357219605101962, 0.8406673080024097, 0.8411048389012781, 0.8187621624258073, 0.8371776384559759, 0.8088475683235676, 0.8453873566654001, 0.8063479864096963, 0.1567251569217829, 0.12989698830632335, 0.18125559037897887, 0.18787289153133802, 0.16172980440184803, 0.08123254261261259, 0.16100482324916465, 0.14296120448374383, 0.187451716160421, 0.14197871498544357, 0.13140013844832332, 0.11550006043054784, 0.1438744115986127, 0.10577659273893225, 0.11019033426362945, 0.15623776889627428, 0.09689117105837941, 0.14380665766333756, 0.985326832088008, 0.9875784262542178, 0.9892383754170809, 0.9915353229365904, 0.988818091940409, 0.986600257484367, 0.9835263005633118, 0.9829320496473881, 0.9814567062916498, 0.6205841792230182, 0.7881315296386295, 0.7992164250548346, 0.7971401856493543, 0.6005981213568816, 0.8022304751202277, 0.7960073545765036, 0.7817485680187891, 0.7972747428856448, 0.2312307430100199, 0.22593230695796207, 0.1846903896138825, 0.21421984990742948, 0.20928463603945635, 0.28129518276278787, 0.6709911603476172, 0.5521304998323944, 0.5791083264613341, 0.2096960894284451, 0.2575965078139105, 0.21864497484721646, 0.2143708544309756, 0.200277908738705, 0.1339304252319634, 0.20841107055500452, 0.2124556335129535, 0.21526343741940113, 0.19677355997671941, 0.3072581102934009, 0.25716161794126124, 0.258755776839807, 0.18064933739596745, 0.1330157231603174, 0.2410188170376525, 0.21139823496166654, 0.21564482781160887, 9.999999999998899e-05, 0.006028977780415112, 0.1552845282348757, 0.02648949632553499, 0.036340838199260594, 0.04764043253986949, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003995316089563383, 0.09341081276919816, 0.06485850508025237, 0.11195387546213698, 0.05728794830975026, 0.03504085112908217, 0.02605765661326498, 0.165476643816577, 0.08439915460813097, 0.09331618310324175, 0.051939432239310745, 0.03698402289851033, 0.07394649193320979, 0.14537362275079435, 0.08005253102343102, 0.08105242365815724, 0.07729292551347167, 0.10186594916706071, 0.09364194918010238, 0.08415453545127638, 0.19320401783624808, 0.5737735257431316, 0.16513055436823887, 0.006696300942414357, 0.08825165470108809, 0.18195801357263353, 0.05627648265991925, 0.08432953701904478, 0.5203918722788182, 0.5410972761532444, 0.570284023345681, 0.5816155949501463, 0.558208477418978, 0.5486791290303465, 0.6044424207892318, 0.575299687447876, 0.5669142508748932, 0.11098749147921172, 0.1170694345251968, 0.14376974337933246, 0.09647981040030118, 0.10704764755248197, 0.13229636580436743, 0.10487735530530795, 0.10539909456626517, 0.12379515002671271, 0.4427393328007141, 0.19998704225428854, 0.2695252517935818, 0.38375202329170266, 0.27614190074519096, 0.14530046512438222, 0.21188776796701592, 0.30598032859172897, 0.41482006153985507, 0.30512822449915045, 0.3761612860816579, 0.4615012042206903, 0.36064020305301014, 0.5062869533253443, 0.42650191091217216, 0.25093424693199684, 0.5435757266132408, 0.21213975521100847, 0.2255915907150099, 0.21645649136939593, 0.29139238520026545, 0.17119405136300136, 0.3165199033605791, 0.27487504744607105, 0.24340446701241758, 0.3268431558091177, 0.2418559233999802, 0.2716470881772137, 0.2556532068645443, 0.24017030952814233, 0.23789049036866172, 0.2542144089284408, 0.2221863552910689, 0.2397257480064462, 0.22419171514876624, 0.27117042708242833, 0.19722593783926323, 0.22592157289767711, 0.2249331608725217, 0.8830831045375817, 0.869617838851469, 0.20583999578969914, 0.2099617214358599, 0.1896200791058077, 0.18398648174857357, 0.927772905946074, 0.18813007091866718, 0.1547003055607984, 0.9467613403613679, 0.9375678136013498, 0.20167134421303412, 0.16751189921178156, 0.1675885894289897, 0.1677147833490915, 0.6727876330272797, 0.21357010878054894, 0.7203313989581275, 0.8141253818879518, 0.16917028781068566, 0.20891859571297522, 0.10533805366738347, 0.16971184420052743, 0.792821369601209, 0.18724775696152984, 0.2230233957445854, 0.19994550265429833, 0.19017312915780282, 0.20230305270749593, 0.22811574727161288, 0.2359582719570098, 0.22166764223053992, 0.2041418889759986, 0.08255557721174012, 0.09774391203767341, 0.08485775546474528, 0.16175937665808238, 0.10394857288172965, 0.16532429684266647, 0.1082980270525663, 0.10410116817833692, 0.08903724674813962]}, "mutation_prompt": null}
{"id": "1ca2ed67-d761-41bd-b8c0-408aa5fb9ea6", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n            # Introduce random sampling technique for diversity\n            if self.evaluations < self.budget and np.random.rand() < 0.1:\n                random_sample = np.random.uniform(self.lb, self.ub, self.dim)\n                random_score = func(np.clip(random_sample, self.lb, self.ub))\n                self.evaluations += 1\n\n                if random_score < self.global_best_score:\n                    self.global_best_score = random_score\n                    self.global_best_position = np.clip(random_sample, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhance convergence by introducing a random sampling technique for better diversity and premature convergence prevention.", "configspace": "", "generation": 98, "fitness": 0.33005301909921364, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.9150936532824905, 0.9121241075650379, 0.9162704174037798, 0.907898933383925, 0.9086263107476135, 0.9069240973291818, 0.9235898579927841, 0.9208910095858911, 0.9152699815265619, 0.8387309128622504, 0.8239452675190402, 0.8175055318633762, 0.8250958850649996, 0.7938188026283343, 0.8325776249977297, 0.7728550872245148, 0.8178662714611062, 0.8353249756416553, 0.18401368771467075, 0.151271047597613, 0.15235087108886636, 0.2613298534134727, 0.12975643996943365, 0.1299515358174671, 0.09119170778229069, 0.15784474779140834, 0.11319642064432478, 0.12245535403355812, 0.14045518435237958, 0.1396688593500256, 0.12334100486107236, 0.14126682662992784, 0.13164486510201534, 0.1435441426807238, 0.11652682724337227, 0.15416360580341737, 0.9850788429621761, 0.9845452834490792, 0.9920025778883895, 0.9905847223352753, 0.9845163327576123, 0.9776202464082308, 0.9864303357955098, 0.9822575358180127, 0.9683826700677773, 0.7087936015477163, 0.8060130281310572, 0.8144212700092162, 0.5924329780880964, 0.5251722751113539, 0.786512266705139, 0.7932652943250231, 0.8011234195000589, 0.7929832927724886, 0.23164417747805077, 0.2280420208613958, 0.21692235878020372, 0.1945110654225325, 0.18981139503476496, 0.19784232766340248, 0.23573236350657012, 0.9059633669934746, 0.8924580011767573, 0.2060689386667932, 0.2569323415853533, 0.20518039600931692, 0.22412807968529214, 0.13291615657779143, 0.20232602662370736, 0.21603152237527556, 0.20471875223933989, 0.21036683959957792, 0.2260367783920031, 0.1506892027974429, 0.1335003762613156, 0.13468760786984002, 0.2408696370091613, 0.19811636887438877, 0.2610912675948279, 0.20700599173034906, 0.2579845035358952, 0.04710800420364225, 9.999999999998899e-05, 0.06181124761905432, 9.999999999998899e-05, 0.010228068405207513, 9.999999999998899e-05, 0.0017698145735086657, 9.999999999998899e-05, 0.012595073516654898, 0.10943059354157869, 0.04701638960232957, 0.08308737131625221, 0.0668916936623043, 0.01761020617741038, 0.03502439713662786, 0.13554740087711892, 0.10813161261871596, 0.09160919529990175, 0.17149006754357254, 0.17830712269125792, 0.19094724120276274, 0.07870275927074832, 0.08023886390113566, 0.1758800689042721, 0.20876565386854595, 0.1434406143632645, 0.07600665314789823, 0.04374547244923799, 0.29848281962644185, 0.07506540334361123, 0.017091761737826672, 0.009749893461477255, 0.18910258538585756, 0.09211093649973368, 0.08377198348919301, 0.08408060005801798, 0.5451786163827513, 0.5565902888682517, 0.5268667594172401, 0.5579928840149847, 0.5773872463976009, 0.5658609891338058, 0.5842329499815349, 0.5668360384883295, 0.5451355777431006, 0.08022734683255606, 0.08740925195719262, 0.12047493630098194, 0.143984948257727, 0.11734559243292642, 0.14564941024526612, 0.1397065323685649, 0.08231999925821487, 0.11874866292062647, 0.27881467434947216, 0.29956008920637045, 0.2946009834385528, 0.28256268670375917, 0.23293898771501176, 0.34528303497455126, 0.2521746034846719, 0.1851228463231096, 0.2150260549750478, 0.3505823258025875, 0.3112681003953366, 0.39074619780543507, 0.2875222940689708, 0.38203183834193044, 0.3547545016396436, 0.24635591418409852, 0.374237841453676, 0.17394250188786942, 0.25244306511691117, 0.28640749518449393, 0.29518425766440126, 0.17518541561220535, 0.41332127450877576, 0.34095261603466287, 0.20038080048640827, 0.21805050342392063, 0.10217460995215788, 0.2067891901641864, 0.2202846208537389, 0.22138859727243676, 0.20888799573194394, 0.2367731013718647, 0.24406064282287399, 0.2129145154219002, 0.21650594422779346, 0.22947353472052068, 0.21154199604887414, 0.2215323965854724, 0.1862646317015325, 0.2259284784262534, 0.2225566882000477, 0.24614924802077787, 0.2195808433619051, 0.2115387710948109, 0.20684689383397492, 0.9440037056442757, 0.9302742692364594, 0.15476899445485193, 0.9467204248040975, 0.20118085262302698, 0.20172020640048627, 0.15389292019504408, 0.1685539511612687, 0.16728652433839764, 0.8990036625551514, 0.21363005317556527, 0.7181198319553528, 0.16931117862016276, 0.20874435869338126, 0.212090797384327, 0.10536418977539164, 0.1680353225139961, 0.7821779979643528, 0.1892060053045449, 0.21148424001568822, 0.20012174504286484, 0.21527339723355454, 0.18693582582576573, 0.1941980182676436, 0.20333161472206496, 0.2358996111656365, 0.1978727047986234, 0.09067221485474053, 0.07409298656826635, 0.09724467413098936, 0.1288276838140433, 0.10720863682182169, 0.1484187288381581, 0.09995590134315002, 0.0973322657203658, 0.08856787640151764]}, "mutation_prompt": null}
{"id": "d443ad72-3c21-4f63-b896-da66075914d2", "solution": "import numpy as np\n\nclass HybridPSO_ADM_AdaptiveV:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 10 + 2 * int(np.sqrt(self.dim))\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1_base = 1.5  # base cognitive component\n        self.c2_base = 1.5  # base social component\n        self.mutation_rate = 0.1\n        self.v_max_base = 0.2 * (self.ub - self.lb)  # base max velocity\n        self.v_max = self.v_max_base\n\n        self.positions = np.random.uniform(self.lb, self.ub, (self.num_particles, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.num_particles, float('inf'))\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            adapt_coeff = 1 - (self.evaluations / self.budget)\n            self.w = self.w_min + (self.w_max - self.w_min) * np.exp(-10 * self.evaluations / self.budget)  # Modified inertia weight adaptation\n            self.c1 = self.c1_base + 0.5 * adapt_coeff  # Adaptive cognitive component\n            self.c2 = self.c2_base + 0.5 * (1 - adapt_coeff)  # Adaptive social component\n            self.mutation_rate = 0.1 + 0.4 * (self.evaluations / self.budget)\n            self.v_max = self.v_max_base * (1 - self.evaluations / self.budget)  # Adaptive max velocity\n\n            for i in range(self.num_particles):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            for i in range(self.num_particles):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_velocity + social_velocity\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)\n\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lb, self.ub)\n\n                if np.random.rand() < self.mutation_rate * 0.8:\n                    if np.random.rand() < 0.5:\n                        mutation_vector = np.random.normal(0, 0.3, self.dim)  # Reduced Gaussian mutation\n                        mutant = self.positions[i] + mutation_vector * (self.global_best_position - self.positions[i])\n                    else:\n                        random_particle = self.positions[np.random.randint(self.num_particles)]\n                        mutant = self.positions[i] + np.random.uniform(-0.5, 0.5, self.dim) * (random_particle - self.positions[i])\n                    mutant_score = func(np.clip(mutant, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if mutant_score < score:\n                        self.positions[i] = np.clip(mutant, self.lb, self.ub)\n                        if mutant_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = mutant_score\n                            self.personal_best_positions[i] = mutant.copy()\n\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant.copy()\n\n                    local_search = self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_score = func(np.clip(local_search, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if local_search_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = local_search_score\n                        self.personal_best_positions[i] = np.clip(local_search, self.lb, self.ub).copy()\n\n                if self.evaluations < self.budget and np.random.rand() < 0.06:  # Increased orthogonal mutation rate\n                    ortho_direction = np.random.randn(self.dim)\n                    ortho_direction /= np.linalg.norm(ortho_direction)\n                    ortho_step = self.positions[i] + ortho_direction * (self.ub - self.lb) * 0.1 * (1 - adapt_coeff)  # Added adaptivity\n                    ortho_score = func(np.clip(ortho_step, self.lb, self.ub))\n                    self.evaluations += 1\n\n                    if ortho_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = ortho_score\n                        self.personal_best_positions[i] = np.clip(ortho_step, self.lb, self.ub).copy()\n                        if ortho_score < self.global_best_score:\n                            self.global_best_score = ortho_score\n                            self.global_best_position = np.clip(ortho_step, self.lb, self.ub).copy()\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_ADM_AdaptiveV", "description": "Enhance mutation strategy by introducing adaptive orthogonal mutation to improve global exploration while retaining previous adaptive mechanisms.", "configspace": "", "generation": 99, "fitness": 0.3495664519978189, "feedback": "The algorithm HybridPSO_ADM_AdaptiveV got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "629d78df-c855-4856-a7a7-5b2520bf7f4a", "metadata": {"aucs": [0.919138639729268, 0.9167644554666003, 0.9131077682137467, 0.9132110951686776, 0.9002130247754451, 0.9116867256022724, 0.9139550080781865, 0.91888636627418, 0.9098673496419468, 0.8365826552242256, 0.8221535126062657, 0.8391050486916253, 0.8234889346593751, 0.8240858243522164, 0.8333456415216017, 0.8255992597692974, 0.81645738614419, 0.8147136358747841, 0.14146803221280224, 0.18196647996755633, 0.14414541876574094, 0.39792589988060956, 0.13718751175947563, 0.12744672438584748, 0.10082222701343635, 0.13064979645788588, 0.09922636049886535, 0.14263494001496002, 0.10747781309161086, 0.09528496824670651, 0.11710990758075945, 0.14299513641859107, 0.12304427640002391, 0.14199663585933575, 0.11625324421299377, 0.1212994008751892, 0.9882344358600486, 0.9890007603462421, 0.9893077186827872, 0.9900711961321563, 0.9876118087899597, 0.9831445005718062, 0.9846641182278291, 0.9860122081153531, 0.9783387297440482, 0.822154779234639, 0.7984897102212755, 0.7877615409811154, 0.6543565151952191, 0.6701383070288116, 0.7687103279032019, 0.7171780699548796, 0.7239173668079278, 0.8143099056289979, 0.23175701502552482, 0.9091161296246129, 0.2287983885188175, 0.3836909009115915, 0.2812745672186726, 0.2815107530881422, 0.17786871302066598, 0.4700617054066656, 0.2246693299596635, 0.20741751864605806, 0.20002962181729522, 0.20529881996123034, 0.20786542013897202, 0.13460112398968993, 0.1572934902188552, 0.3962786811003851, 0.21754111475304905, 0.20755223963507297, 0.2096902047692183, 0.22303149210107887, 0.3480924114063101, 0.197154913887864, 0.24551342354803252, 0.18474682215254157, 0.24068283029462878, 0.10229584101022504, 0.2459050732188528, 9.999999999998899e-05, 9.999999999998899e-05, 0.09054420384136264, 9.999999999998899e-05, 0.05981663100772927, 0.043676557135089, 9.999999999998899e-05, 9.999999999998899e-05, 0.03263988532918416, 0.1199030673521978, 0.03353354898739547, 0.10492204627821466, 0.10167777100511388, 0.0153264203531569, 0.036965100096930104, 0.19840312716841024, 0.08238654891957253, 0.0979766145662061, 0.053535821198109956, 0.05249518290791877, 0.08444005200003868, 0.07967329917030241, 0.16802533382045293, 0.07922800524720974, 0.08595484596438441, 0.19828057719728476, 0.10330897670926864, 0.04328775181816069, 0.16204504452980018, 0.045381720075421406, 0.06348115837299961, 0.19324964261566135, 0.03878188448578235, 0.08407005921689903, 0.23778417978309552, 0.08352201340987575, 0.5305620856452931, 0.5971373870985265, 0.5415747257902315, 0.550437194680425, 0.6318680053049286, 0.5914091415406737, 0.6133875279391008, 0.5972537129255941, 0.5685816956340165, 0.10606263070414967, 0.07987746861405554, 0.09300678526553097, 0.09089027701121155, 0.1300489898909747, 0.1290688132753527, 0.09666261418152011, 0.11703755244706848, 0.15669367480242058, 0.2679311514324708, 0.2258977714325855, 0.21084821427582834, 0.2259956462581365, 0.35473315644876524, 0.4235399309485218, 0.23608959222619885, 0.18856376195730107, 0.22478264078820775, 0.3270103230551076, 0.48929442160683934, 0.37324968423436344, 0.35534533690127024, 0.33100488234609515, 0.29066235459005363, 0.2608908493671098, 0.4968406277153714, 0.23026722169922342, 0.3139400167517502, 0.2977444687337538, 0.2178445560766089, 0.24087621078264032, 0.295403883147217, 0.2378477108351711, 0.23310663612171412, 0.19812620705490946, 0.3022235492597447, 0.2670273012606924, 0.239287365050025, 0.2478213912461461, 0.25362197697756805, 0.20267880094517454, 0.20603823776989105, 0.2256556081287252, 0.2332452286000063, 0.23132680977213838, 0.8486844248642025, 0.2505710592675723, 0.22700555934071076, 0.22465884883411757, 0.874356562265088, 0.2241210266489464, 0.8404914579677598, 0.8135774163189533, 0.2504347283773847, 0.9442181284327681, 0.9156693674886046, 0.15370596474870635, 0.9387616303840817, 0.201812437554877, 0.20151220933657932, 0.15362567425336726, 0.16855991116395141, 0.16840546867865558, 0.8443703856318696, 0.21268221448778768, 0.7989461078358497, 0.8794567226586779, 0.15514368151744784, 0.21101232699500094, 0.10529483586802812, 0.16668760159857643, 0.9167838615978119, 0.195472515869761, 0.1973964559247683, 0.1890907636113187, 0.18653370614350684, 0.21554838295128076, 0.22654514028860884, 0.20303246556362542, 0.24060773257913037, 0.22155505373182727, 0.10017707167998469, 0.100285532502989, 0.09227975598678295, 0.10774013821466999, 0.09687135212824649, 0.1364934722288399, 0.09343973660625782, 0.09051013433944988, 0.09464607766252098]}, "mutation_prompt": null}
