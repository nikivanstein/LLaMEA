{"id": "fe024a7a-96fa-4e64-95cd-cb9570c79fbe", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.5\n        self.crossover_rate = 0.9\n        self.iterations = self.budget // self.population_size\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "HybridPSODE", "description": "A hybrid algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to balance exploration and exploitation effectively for robust optimization.", "configspace": "", "generation": 0, "fitness": 0.23574302210524245, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": null, "metadata": {"aucs": [0.49641800562649896, 0.5788608102346722, 0.5472702577496766, 0.5938585835823318, 0.5125377660181563, 0.5099168483096681, 0.512265916695064, 0.6004719940548229, 0.6250271697139478, 0.17462006969563337, 0.18531573887118702, 0.16720480997806275, 0.2456257313208865, 0.11750190078063183, 0.16691589390532846, 0.03177505827080007, 0.012060225056819918, 0.15966842768703848, 0.09587933937870585, 0.13085179059605556, 0.10073579773910879, 0.14279404981538169, 0.1381183450846627, 0.12252976082064126, 0.11053286684855035, 0.1125101835016381, 0.14738666069936812, 0.09379839322816574, 0.07904524955031977, 0.12531539976701767, 0.1031406223861735, 0.1211028075543149, 0.11826993735336533, 0.1268180313473184, 0.09498329290023433, 0.1015329102061685, 0.9642819431970507, 0.9759806639600448, 0.9738281688835356, 0.9774198312609697, 0.977981672676157, 0.9765514704449021, 0.9781994357388845, 0.9811677072069686, 0.9848268251779305, 0.26448489295187605, 0.2361794561298055, 0.2890764482220215, 0.24111151195151792, 0.15776730607208844, 0.2726003491693717, 0.33027507830774483, 0.34715718078374413, 0.3030007913311944, 0.5663200252204683, 0.24760501177458516, 0.6194980561986843, 0.5726093242743504, 0.46245711342585105, 0.6509232952280829, 0.6133133285808006, 0.4026165259702339, 0.422673991246289, 0.1555281859502604, 0.17823763674899895, 0.14140306450971818, 0.1626014452900847, 0.13505865391021976, 0.15264503094915294, 0.14635166852530568, 0.13400485019062758, 0.21735538612470073, 0.1621554956858665, 0.10269415597277043, 0.17372425218672083, 0.11754917840474133, 0.16400301594648659, 0.1726878964929749, 0.20083065334679395, 0.11700956095233084, 0.15933016074515127, 0.013401480892797024, 9.999999999998899e-05, 9.999999999998899e-05, 0.03095788749081818, 0.019998388383525745, 0.028212224858752744, 9.999999999998899e-05, 0.0037757590006032293, 9.999999999998899e-05, 0.08998789467261759, 0.044762701767389945, 0.05724314589385593, 0.0748405924855573, 0.011418150978024677, 0.007100012638628361, 0.06141766288692829, 0.05350613706580587, 0.029084307682251564, 0.023232729035479127, 0.025608105513918455, 0.06758934715076503, 0.07536470181995625, 0.03192217570584033, 0.07669141049671957, 0.055438952658069085, 0.041485501761238774, 0.03737570677400204, 0.09270903212307313, 0.03852486968300384, 0.09942160307237358, 0.06969771413981485, 0.12920933351379504, 0.0995915917893142, 0.06829376239853624, 0.05364293018539468, 0.08555165423335342, 0.41520011273633506, 0.44375222702710415, 0.4681701823523221, 0.4914799637045597, 0.2080607825402414, 0.44715195856870815, 0.4287327344815304, 0.43645446181033254, 0.3911560347637024, 0.11471807324542604, 0.09455863422121491, 0.09836269335905623, 0.10393050879350374, 0.08848558896318193, 0.12433001562183776, 0.09409253072811274, 0.09306845353709392, 0.12283152467499259, 0.14863431260761595, 0.15947002263321997, 0.14474470714026866, 0.20788455511913695, 0.2754898018842741, 0.1813472782621206, 0.2921402432710848, 0.19049776387579853, 0.2129315120444899, 0.21418975925942774, 0.2344786549008251, 0.29410819371754093, 0.24135250985867496, 0.20919255757012745, 0.28953101039234597, 0.2861016712653983, 0.3076303066464908, 0.3401689056241708, 0.1590591769438593, 0.22665090663556187, 0.23078936601668987, 0.2601952750555637, 0.19654286766076146, 0.18496221311516836, 0.24012298347260919, 0.25327889255655733, 0.1432170484212465, 0.19695866798946438, 0.18327574257160784, 0.23570420289615512, 0.20173088315340137, 0.18405186698305964, 0.2485568677022768, 0.2309131229904403, 0.19407194180770715, 0.22930693205303632, 0.2075036375622572, 0.2043304749895306, 0.18998589056660242, 0.2176796540159921, 0.1947194383147638, 0.2547476568107484, 0.20850864532757418, 0.19235954387898635, 0.23745851193359524, 0.11237131489640928, 0.12454804272557574, 0.16559465529078976, 0.18683498618653493, 0.19420233299222855, 0.1591604375471899, 0.13970238331569163, 0.16937466258763834, 0.7434256694621839, 0.4857912354046998, 0.1552298361633262, 0.5525709568520387, 0.5747429759228482, 0.6332870394099923, 0.47010278489848045, 0.1682174128034667, 0.10439305042284774, 0.09405622241011702, 0.20647555229690995, 0.20207251234647117, 0.20131719619858246, 0.2115957574333136, 0.19620756456179356, 0.19113317515263006, 0.2073464079258419, 0.1841836947701444, 0.18879357472794256, 0.08261199284636878, 0.07080185296652819, 0.07514318570849332, 0.08670629976931854, 0.07851948203292813, 0.08440032930953545, 0.08031158813804085, 0.07627134360167787, 0.07868679462762507]}, "mutation_prompt": null}
{"id": "d2984bc3-4821-4308-8017-49df77e04b67", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": 0.27404823917889937, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "fe024a7a-96fa-4e64-95cd-cb9570c79fbe", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "525692ca-ead0-4744-8935-1d08ee79faca", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "2ff88c9d-704b-4978-a3e6-0bf493312102", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "4b7f0f1d-5fcd-4614-a774-5fc7957d6cb0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n\n    def dynamic_parameters(self, evals):\n        progress = evals / self.budget\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * progress))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * progress))\n        self.inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * progress\n\n    def increase_diversity(self):\n        worst_idx = np.argmax(self.best_personal_scores)\n        if self.best_personal_scores[worst_idx] > np.median(self.best_personal_scores):\n            self.particles[worst_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.velocities[worst_idx] = np.random.uniform(-0.5, 0.5, self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # Increase diversity to avoid local optima\n            self.increase_diversity()\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSODE with an adaptive inertia weight and diversity mechanism for improved exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.21665647102200533, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.5073973014685212, 0.47701845195361503, 0.4748509465522551, 0.5170196871215714, 0.46622893882410976, 0.540925255192397, 0.5173648795843611, 0.5590335003700502, 0.5453795264647228, 0.21171873942658725, 0.21392295328232946, 0.17517820377610538, 0.20750235954196705, 0.21352697032956003, 0.24085561649233755, 0.16270378850902412, 0.14933240305976436, 0.1383908620085702, 0.11317434830387096, 0.12996443675426694, 0.10268847395114011, 0.09652195641590477, 0.1180283356560814, 0.0851147825717371, 0.10709742714002546, 0.09657543317888462, 0.2324866686626823, 0.08517216294380725, 0.08889878586517208, 0.09832297461353867, 0.10659553600274407, 0.07973838473823358, 0.10278656036481448, 0.10055216447663629, 0.09920814539744949, 0.09779405353654747, 0.9779790786027943, 0.9778653118425865, 0.9851304760935798, 0.9850271588666231, 0.9777504527934887, 0.9699107436849522, 0.9738319166332857, 0.9850131663472744, 0.978529382887437, 0.28835968948724444, 0.2640060712582266, 0.28535984078693377, 0.25544605913386664, 0.2029772217054182, 0.29379035347246973, 0.2908766842534365, 0.24981787917174414, 0.23867370411536282, 0.21179430882863903, 0.19614768569475405, 0.197685297754853, 0.19149913587793954, 0.18768039866865782, 0.17767166492119957, 0.18224128917502969, 0.16328778424857338, 0.18904906143540456, 0.1437797200839772, 0.14039221107741906, 0.15340899096548088, 0.07492932777406858, 0.11187926781788793, 0.13287428116250177, 0.18177005513784739, 0.08579973191490009, 0.1587040900676886, 0.15486230957178937, 0.07823907202754743, 0.13131310274254682, 0.09514739800531768, 0.10228900082681247, 0.10830021334592, 0.10743395086216645, 0.1493679369342431, 0.14977884151354626, 9.999999999998899e-05, 0.025155006937148228, 9.999999999998899e-05, 0.00013064140537988322, 0.017290462619857894, 0.007565518468448107, 0.001703354182453043, 0.00019890017963553053, 9.999999999998899e-05, 0.03290938842858182, 0.011019839250467012, 0.11753053948802261, 0.11990876976693965, 0.014170105435040381, 0.035460750279785125, 0.08564753085136911, 0.0772741088581339, 0.03935866229830787, 0.03224426577813955, 0.02281122818760417, 0.05851233896016894, 0.05030325167574956, 0.07067538575709964, 0.03806911403961566, 0.040579051893130824, 0.06520144936251093, 0.03929709142865179, 0.04550726532785321, 0.07849406711662577, 0.09267370672788788, 0.10598940259026535, 0.0956309577650325, 0.11415790699186257, 0.052212625370739674, 0.10287734503558676, 0.06017948347808544, 0.3781102017447505, 0.37818680619029665, 0.38847503594381794, 0.3855192814889846, 0.39326767388480144, 0.3724759880244969, 0.36779950229165104, 0.3881597814090444, 0.3900618336631182, 0.07174925890872141, 0.08517257201048012, 0.08091924903116121, 0.11058185576270685, 0.1003523725308012, 0.08720278420548055, 0.07662063664007224, 0.09986174833360051, 0.1549629181322476, 0.14615514022500697, 0.21533579205649522, 0.18821129480567356, 0.15693264502649384, 0.1515042294699548, 0.14473901135703093, 0.24789398077710834, 0.1619477939055438, 0.19921870275196563, 0.2280565186607657, 0.29346720673182347, 0.28830053244208786, 0.3087329618651402, 0.2534470493433405, 0.2870260217241932, 0.2721990233079469, 0.34300252003286613, 0.25202107547270725, 0.1824927849980712, 0.18111694918834387, 0.22307585980635392, 0.19230073922350266, 0.22778976656718763, 0.18754252460745024, 0.21505099393816796, 0.22861602847306584, 0.1420931544446481, 0.20650720166446468, 0.18370228464273974, 0.18023562714591868, 0.1997510149041304, 0.19468926401215114, 0.20722282318813356, 0.18534109262019371, 0.1756006678984119, 0.20881155648858996, 0.18872171107393065, 0.22986468756350875, 0.17327644639474604, 0.19144490370889267, 0.2160213677515983, 0.17170854467198993, 0.17078971851697278, 0.1947539731664052, 0.1957479764424126, 0.16872213889952148, 0.17028112058516276, 0.16271733507810837, 0.5577569159417965, 0.18663151903860886, 0.5506633595206709, 0.5732888075662164, 0.1598658010845897, 0.581981138540308, 0.38059555205741813, 0.3103333209100353, 0.33942439256495693, 0.1881554101770888, 0.18574167319895363, 0.1855469869560996, 0.4108981394568212, 0.2017190319147496, 0.19616563614514648, 0.22726213776861093, 0.17674437887459427, 0.20223118447332644, 0.18665528235398687, 0.1800616482043852, 0.1906208966429177, 0.18166596508592148, 0.18862536820431264, 0.19180695275632464, 0.07382566351026854, 0.07564371528317881, 0.07261669236468027, 0.08593246690510259, 0.08472666954573815, 0.07378044863196354, 0.07835563078897334, 0.08777253570936305, 0.0792593107178936]}, "mutation_prompt": null}
{"id": "cb20bff2-f120-4f9f-a3e9-1d2367580da1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 40\n        self.population_size = self.pop_size_initial\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.pop_size_initial\n        self.diversity_threshold = 0.1\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.3 + 0.7 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.3 + 0.7 * np.sin(np.pi * evals / self.budget))\n\n    def adjust_population_size(self, evaluations):\n        if evaluations % (self.budget // 10) == 0:\n            diversity_measure = np.mean(np.std(self.particles, axis=0))\n            if diversity_measure < self.diversity_threshold:\n                self.population_size = max(10, self.population_size - 5)\n            else:\n                self.population_size = min(self.pop_size_initial, self.population_size + 5)\n            self.particles = self.particles[:self.population_size]\n            self.velocities = self.velocities[:self.population_size]\n            self.best_personal_positions = self.best_personal_positions[:self.population_size]\n            self.best_personal_scores = self.best_personal_scores[:self.population_size]\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            self.adjust_population_size(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.6 - 0.4 * (evaluations / self.budget)\n                cognitive = 1.7 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.7 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSODE with stochastic adaptive population size and diversity preservation for improved convergence.", "configspace": "", "generation": 5, "fitness": 0.27340199799184794, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.696510390326176, 0.7481374649976249, 0.7358941870468185, 0.7647053094794382, 0.7582932697671523, 0.7709519640548124, 0.739572105911517, 0.7313750168308943, 0.7465357560602915, 0.17845688953455097, 0.5691180974245778, 0.499595658190652, 0.588569905623479, 0.5347478071422407, 0.5699209651243693, 0.5846905325400485, 0.5703876839152079, 0.13718386111626002, 0.1329424848593297, 0.11023780025691743, 0.11870434976693922, 0.13116564033503786, 0.12961112752245585, 0.1349894845801718, 0.1424630870203919, 0.13913970733646497, 0.12078196665314134, 0.1402746979275642, 0.1309605421372797, 0.13794130977956243, 0.47076295616055863, 0.1017831538060121, 0.12405696383955533, 0.09626366848220225, 0.09690535748992957, 0.1059765242490428, 0.9720972771104084, 0.9767731738435437, 0.9773913785604086, 0.9850413555124098, 0.9844358091118214, 0.9742181357789945, 0.9786388581605717, 0.9752842094678619, 0.9712505755154914, 0.5398338188263492, 0.5175846055617357, 0.5650544740659219, 0.5036353782516204, 0.6069059429348072, 0.5259624587932135, 0.0860846345361751, 0.5435490642128238, 0.05145767986457883, 0.7464900631660489, 0.3659835299538198, 0.17073220676773948, 0.2765308608375827, 0.1945671080830963, 0.21333173879232858, 0.3382489370238977, 0.14041583865732588, 0.7100862137080822, 0.1652028148256297, 0.18550073786965593, 0.1691670503637389, 0.08733772569291764, 0.1176342705896457, 0.18689787650779932, 0.20213485154824284, 0.1655824059201495, 0.11943730385224427, 0.22799285180066287, 0.19262196426370481, 0.12061791618015683, 0.14990687019753057, 0.22519445628180979, 0.17917559691969964, 0.22597987978911316, 0.2076097839652914, 0.19460452979364395, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004371938784505369, 9.999999999998899e-05, 9.999999999998899e-05, 0.007631656487986582, 9.999999999998899e-05, 0.05355751430428357, 0.0756698012806637, 0.10320661549123322, 0.07687199075190332, 0.0830697437516299, 0.018181782628971632, 0.02210316051512451, 0.034602093367135045, 0.040420139313789516, 0.07141825451354433, 0.026977710935410903, 0.11291067285507506, 0.04043804071558699, 0.0719175485374377, 9.999999999998899e-05, 0.07664586717145516, 0.07564328184682123, 0.07902730947893766, 0.13510350636879775, 0.16896074696184682, 0.0403952487246414, 0.20246412448359952, 0.11764179140012287, 0.03555129458881201, 0.10264097917047366, 0.0735282931407848, 0.052879240672549566, 0.0776978488406106, 0.48317871784514166, 0.5085926581268996, 0.4875792245058679, 0.4928959925855063, 0.538698823354089, 0.5241220620082907, 0.4887160644602636, 0.5126041414901008, 0.5271357003663716, 0.12581152429037135, 0.10353401902293247, 0.11599836957263909, 0.16554655711055588, 0.10494974884982367, 0.1465956700832448, 0.10122774399486134, 0.10273067108559464, 0.11921833664958337, 0.2072315517282618, 0.2461228471578304, 0.23987651800324505, 0.18178466474432853, 0.2492941247555891, 0.19661826597852827, 0.3850557230564635, 0.2225076798696881, 0.18387135511171815, 0.23591436124832843, 0.45906509195003553, 0.36689424298561657, 0.333963134091243, 0.20935287866828423, 0.3787878593662575, 0.3745139326333551, 0.5384183929283641, 0.24692145578223312, 0.21145367870168097, 0.255262753509377, 0.2342018697493481, 0.2462190357280334, 0.24067391453576104, 0.23707088716962832, 0.2529974027473497, 0.26359266991841834, 0.2187529081640135, 0.24636246750927016, 0.221490762689161, 0.20960794194897303, 0.2088623110533595, 0.22152054673437316, 0.21100148829429344, 0.23311358241198943, 0.17985855279624252, 0.1927609533281941, 0.2125456902548093, 0.21901200284675348, 0.18699256878014325, 0.613172595435522, 0.194926311839683, 0.23570916017582522, 0.21662630848570874, 0.2018505257761516, 0.20950371764207532, 0.12881059421278462, 0.20401517861574803, 0.16171231977649803, 0.777416836728579, 0.19510971100390517, 0.16839096308554724, 0.14034368835827626, 0.1690669933553156, 0.19203497230879096, 0.6062403369548084, 0.1545227964036523, 0.12653861018686985, 0.16476800416908477, 0.16735133716936668, 0.20859642568144532, 0.27451519414861547, 0.1038556287684167, 0.6147215368496324, 0.21924863488148094, 0.1861457785766264, 0.1982179660489456, 0.21491444800798398, 0.1851613293565575, 0.17873685169900322, 0.24782432770939444, 0.19167260236261818, 0.20085249073658806, 0.0847546873135947, 0.08919574921378881, 0.08831789334215046, 0.10645561495601774, 0.08083296525435801, 0.08683690535282806, 0.10920507364704446, 0.07394423385786686, 0.09194481953068534]}, "mutation_prompt": null}
{"id": "c86d501a-62a2-46ce-9aff-639faf3a7652", "solution": "import numpy as np\n\nclass QuantumInspiredHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = self.quantum_initialization()\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def quantum_initialization(self):\n        # Quantum-inspired initialization around the center of the bounds\n        center = (self.lower_bound + self.upper_bound) / 2\n        return np.random.normal(center, (self.upper_bound - center) / 2, (self.population_size, self.dim))\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def adaptive_neighborhood_search(self, i):\n        # Introduce an additional local search mechanism for enhanced exploration\n        local_best = np.copy(self.particles[i])\n        local_score = func(local_best)\n        for _ in range(3):  # Three local trials\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate = np.clip(local_best + perturbation, self.lower_bound, self.upper_bound)\n            score = func(candidate)\n            if score < local_score:\n                local_best, local_score = candidate, score\n        return local_best, local_score\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles and apply local search\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n                # Adaptive local search\n                local_best, local_score = self.adaptive_neighborhood_search(i)\n                if local_score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = local_score\n                    self.best_personal_positions[i] = local_best\n                    if local_score < self.best_global_score:\n                        self.best_global_score = local_score\n                        self.best_global_position = local_best\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "QuantumInspiredHybridPSODE", "description": "Quantum-inspired Hybrid PSODE leverages quantum-inspired initialization and adaptive neighborhood search for enhanced convergence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {}, "mutation_prompt": null}
{"id": "8fd446cd-87e8-4ceb-a82d-a33d74b10241", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "802a0905-eac2-465d-8dc2-a9029c11194e", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "052a149c-d736-4440-90dc-da3e6ed23d79", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.inertia_weight = 0.5 + 0.4 * (1 - evals / self.budget)  # Adaptive inertia weight\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = self.inertia_weight\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptiveHybridPSODE", "description": "Incorporate adaptive inertia and hybrid strategies to enhance convergence by adjusting the exploration-exploitation balance dynamically.", "configspace": "", "generation": 9, "fitness": 0.19966840143982686, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.4170467745970814, 0.4065598003196722, 0.46015374485380467, 0.5563114631875317, 0.38930664584866603, 0.18716389685803636, 0.379941296576482, 0.4264691417827795, 0.4658327651710221, 0.028091353833521127, 0.02399405034384905, 0.019080983987216138, 0.02605952492538055, 9.999999999998899e-05, 0.0826349877146404, 0.07454105228336794, 0.10038858546607321, 0.12111706655418586, 0.13427599385676936, 0.0903597381824135, 0.12426097363918853, 0.10141112875039071, 0.11264738231440408, 0.0922789545461532, 0.1495259789352189, 0.0984137707961934, 0.164816913758282, 0.08484240972064616, 0.10393225123871486, 0.09296923721907902, 0.08698759653463328, 0.10191928575414877, 0.09315008466799213, 0.09674725263228523, 0.09206200608798842, 0.09665636066859973, 0.9812013830264402, 0.9780437859008674, 0.9771299408251974, 0.977584932101423, 0.9777651233027534, 0.9764991377057305, 0.9779907803555169, 0.9750342695518595, 0.9846047697215342, 0.22371618033049745, 0.2814396403464783, 0.24148595942012818, 0.25296020763464866, 0.25588680324031676, 0.24496306604154094, 0.23000643461339243, 0.22958054153498364, 0.2368688289544746, 0.2721026469845308, 0.2708357692805057, 0.1556273951744328, 0.1960860371157792, 0.35018942880645354, 0.18712819675544679, 0.22360415615142293, 0.393590844625318, 0.36786974388679505, 0.1286016320133142, 0.10035255582102054, 0.06197065246223232, 0.09251352973798344, 0.12534501037513712, 0.12136206801029437, 0.13443007768114223, 0.10624410400427964, 0.113027838425526, 0.11432979158792755, 0.11939830276859575, 0.13920562193428654, 0.12909709969234096, 0.1348413117096856, 0.09857417367127075, 0.17303028121185782, 0.1049488281027321, 0.14864362371417505, 0.012980526882076626, 9.999999999998899e-05, 0.01434387428231998, 0.019049647210578002, 0.000172466997645504, 9.999999999998899e-05, 0.004060609845727647, 9.999999999998899e-05, 9.999999999998899e-05, 0.0317656764217783, 0.02379396129376965, 0.039109257360241956, 0.060467626166771926, 0.014480970457469988, 0.008005977478331205, 0.08595058370196562, 0.05949897704232621, 0.056785023461217166, 0.02694653492155319, 0.004712469597788149, 0.025049596081391456, 0.03149835344420604, 0.04034463996821791, 0.02333499043098164, 0.024040658379392177, 0.021207277735837082, 0.027163780327565834, 0.054746416600176095, 0.028679224460510522, 0.08279114189029002, 0.111517696126472, 0.10479466484966071, 0.11288028600386535, 0.07655606794439862, 0.04013063595509925, 0.05332634793996982, 0.3750322032244945, 0.3338912621990303, 0.3690409811173523, 0.3961973810584867, 0.3719219295052484, 0.3738282420852147, 0.38909265001553717, 0.3430465416262526, 0.3647083902324558, 0.09571884863749924, 0.09565637789491188, 0.08002171441061368, 0.10373269226428306, 0.11522193574042017, 0.12531034440610256, 0.08058350665688685, 0.07927805522451781, 0.08615935965286303, 0.18183641682535012, 0.20323653751722892, 0.1592367006794353, 0.16091509521005232, 0.20470287393199027, 0.22087784192819415, 0.373622677495854, 0.2779798108283721, 0.14413915003991273, 0.24669342093369429, 0.23416365861122956, 0.2645798270717824, 0.2546532169206541, 0.27917198375055663, 0.2571805472326385, 0.2553984480641559, 0.3055780111936255, 0.2686490067927072, 0.16548582652660004, 0.16883360990250562, 0.18947114640461427, 0.1679878415794921, 0.18127504921189552, 0.1618599557884316, 0.1841032732178043, 0.19797990407639132, 0.17402634997885358, 0.20227368524403566, 0.20645573586637356, 0.18870111455224492, 0.1797711284701936, 0.18705810056435035, 0.17918802630506092, 0.19254808542508473, 0.18761114447483618, 0.18117309084117428, 0.20331136888085366, 0.1775055040900133, 0.17598379868907, 0.2018841968364733, 0.17744547052129345, 0.17541826404955552, 0.2325026580336783, 0.26133386106071677, 0.18878620187361062, 0.14978014197964296, 0.18612785150597932, 0.19549848599956354, 0.1826401980298854, 0.19386670109980675, 0.5456031706501256, 0.09983060610019534, 0.16984654652253428, 0.20661662263131397, 0.41283798458677223, 0.15515682377398388, 0.3259182384675089, 0.19756984871469396, 0.30142446246569576, 0.40109265705190533, 0.20305341935591836, 0.10424561514011588, 0.14760893190633617, 0.18571031889275202, 0.19224865248198186, 0.18554052047664604, 0.18316780012766143, 0.18363985783609593, 0.22021592906583942, 0.19097314072825056, 0.1853623406594428, 0.19360625954951094, 0.07766557059029222, 0.07371051825000219, 0.0772266405954215, 0.08126088160504441, 0.0754747650619858, 0.08658762802671904, 0.06932216578086048, 0.08082034542696004, 0.0777421152420662]}, "mutation_prompt": null}
{"id": "0b29a1ea-1e89-47d4-b945-8e5b393c2906", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.opposition_factor = 0.2\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def opposition_based_learning(self, particles):\n        oppositions = self.lower_bound + self.upper_bound - particles\n        scores = np.array([func(ind) for ind in oppositions])\n        return oppositions, scores\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            oppositions, opposition_scores = self.opposition_based_learning(self.particles)\n            for i, (opp, opp_score) in enumerate(zip(oppositions, opposition_scores)):\n                evaluations += 1\n                if opp_score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = opp_score\n                    self.best_personal_positions[i] = opp\n                    if opp_score < self.best_global_score:\n                        self.best_global_score = opp_score\n                        self.best_global_position = opp\n            \n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.uniform(size=(2, self.dim))\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSODE with opposition-based learning for improved exploration and convergence speed.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {}, "mutation_prompt": null}
{"id": "790e1898-8e03-4f75-9a6c-9a6185cf2e50", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "0c15a539-1d65-4c89-85d4-36c84c93695c", "solution": "import numpy as np\n\nclass SynergisticPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Slightly increased for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.9  # Adjusted for more aggressive exploration\n        self.initial_crossover_rate = 0.85\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.perturbation_strength = 0.1  # New parameter for perturbation\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n\n                # Perturbation Strategy: Introduce random perturbation\n                if np.random.rand() < 0.1:\n                    perturbation = np.random.uniform(-self.perturbation_strength, self.perturbation_strength, self.dim)\n                    trial = np.clip(trial + perturbation, self.lower_bound, self.upper_bound)\n\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "SynergisticPSODE", "description": "Synergistic Particle Swarm with Adaptive Differential Evolution and Perturbation Strategy for Improved Convergence and Diversity.", "configspace": "", "generation": 12, "fitness": 0.2626810036892457, "feedback": "The algorithm SynergisticPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.6589297026635528, 0.6730888082062934, 0.6433109923753713, 0.6816973502584303, 0.6351860932821476, 0.6679580362250979, 0.6472035303590308, 0.6751584726613533, 0.6294237238623759, 0.30147047171940133, 0.3368192368027021, 0.3205296256969423, 0.39988465001805584, 0.34241455293000245, 0.4250356907138736, 0.3395716784853522, 0.34789608528701577, 0.262153693312868, 0.12748882569701925, 0.1391371740577615, 0.1222903936328299, 0.14137302698753718, 0.3290981668602747, 0.14991963906514227, 0.11211146439285025, 0.11399964872328783, 0.12359677823422976, 0.13051957519209445, 0.10453728731570355, 0.11374986380691876, 0.1283504378088388, 0.12101454603067563, 0.1210609518701311, 0.10103246031336, 0.09114397968397281, 0.09461758814053778, 0.9732582921478861, 0.9727765878199219, 0.9816579168178748, 0.9607554507885092, 0.9705009604883457, 0.9703873474213309, 0.9722094921871226, 0.9723970023821707, 0.9805497474975061, 0.37975486234844225, 0.352835235360234, 0.34991071564679266, 0.3650017620328512, 0.45119714288903934, 0.3960578559701412, 0.3557923436220928, 0.4098875300519321, 0.3486428340851647, 0.2056783864388816, 0.2943194048423816, 0.566737441899875, 0.1929244636177252, 0.2481641496944912, 0.6506893886105558, 0.43900892982819273, 0.4444114258294971, 0.17303198495389205, 0.32611195226056866, 0.14751245227249743, 0.14435615768811172, 0.16626954527908222, 0.11625308960383773, 0.15577876299207072, 0.15445055628527005, 0.18134218263189317, 0.18355496675279215, 0.15788456343716717, 0.17461218809805157, 0.16805021606743453, 0.16322674959816208, 0.18002897549637686, 0.18385726704338445, 0.18990647249372905, 0.11981031175068169, 0.2017845742287323, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03769553248077895, 0.06282032744109078, 9.999999999998899e-05, 0.005660540140179915, 9.999999999998899e-05, 9.999999999998899e-05, 0.06321284775704483, 0.10328839193450001, 0.053720426812718824, 0.03911599922331477, 0.032568032848632744, 0.07061859764334455, 0.04049457565815551, 0.07169815438496374, 0.07752189711636037, 0.09916948977910267, 0.021420647449043484, 0.03525860198237496, 0.04968679711083057, 0.04957741354705758, 0.056673557226652016, 0.05080322174842333, 0.03687238467120024, 0.04704139528112261, 0.20534308829994818, 0.09819681847581052, 0.12867619581254508, 0.11744161074626114, 0.10576957652664021, 0.08918147303245527, 0.054114975725797376, 0.0466562011850572, 0.06617245053687182, 0.46859172140864414, 0.4296010600639686, 0.4762754224120376, 0.4850575644212213, 0.4795350760186743, 0.47063967883012825, 0.4924784627282135, 0.4338352176503063, 0.4140330689209337, 0.10932741557228787, 0.09721962870162792, 0.10288888594542656, 0.12337855795133568, 0.10797477776789388, 0.13874794502907317, 0.11571344312777476, 0.11788928310697244, 0.10889607948723312, 0.3083365778235616, 0.2686991562241309, 0.15673042198586806, 0.2989172150710945, 0.41894042458088376, 0.1547772228008375, 0.3392402926939403, 0.29918784211815463, 0.2830946510079857, 0.28648855027355213, 0.22422332516427956, 0.3250539838089338, 0.2579301014500849, 0.3251691870904029, 0.36351936059017154, 0.3944150073911171, 0.375159968797365, 0.2658683859125467, 0.17883384051498885, 0.22301481247790655, 0.2363719172980947, 0.15570681933895614, 0.23034647363811256, 0.24587660314269044, 0.2857484142322094, 0.24857570909995363, 0.32506375725989967, 0.19691600240083984, 0.19292787145870816, 0.22216936318485359, 0.20253924770191611, 0.18532826640626332, 0.20743105119601446, 0.19280646544868696, 0.19543908840634328, 0.21650169014886878, 0.2099519342269075, 0.21679790312805647, 0.19935096517862416, 0.43861346263181433, 0.21683568130716369, 0.1927964836728222, 0.1952549243422489, 0.19811105564485565, 0.22525414270161415, 0.7784769994797471, 0.20899940874961975, 0.15089377628264522, 0.681897789037018, 0.19816012070404943, 0.14667079349768575, 0.1405152946372651, 0.17853686050781048, 0.1435066984353187, 0.5654341906364505, 0.11242013243414217, 0.2083879009787475, 0.6016754295014889, 0.6055645810034253, 0.16346894100514742, 0.1106560554065843, 0.11120712938626709, 0.6417995692599047, 0.1961035750856689, 0.1905416036965868, 0.1865621550309159, 0.1902456381035582, 0.18997400456200053, 0.2206569808019151, 0.19831796069859042, 0.1958901018146929, 0.18612519162561003, 0.11738398597937016, 0.08838020936836022, 0.0837488169936812, 0.08971699288780766, 0.08273485556349769, 0.07867493080978749, 0.09230409383219196, 0.09060168942520175, 0.0972883650322347]}, "mutation_prompt": null}
{"id": "efc05161-ff92-464a-8791-419e8dc7d9f5", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "a9088992-d08e-49c2-8f05-786f791300e9", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "ba2f2171-d807-4a34-ad25-5a14719c2951", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "0b8af8d2-0e3e-41a4-9465-19ea1ab2fb4a", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "7e2d818b-1123-4174-b6bc-38eda564b319", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "58128924-3f01-4433-b1d3-31e64349f78b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.neighborhood_size = 5  # New parameter for dynamic topology\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def adaptive_inertia(self, evals):\n        return 0.9 - (0.9 - 0.4) * (evals / self.budget)  # Adaptive inertia\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = self.adaptive_inertia(evaluations)\n                neighbors = np.random.choice(self.population_size, self.neighborhood_size, replace=False)\n                best_neighborhood_position = min(neighbors, key=lambda idx: self.best_personal_scores[idx])\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_personal_positions[best_neighborhood_position] - self.particles[i])\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSODE incorporating dynamic neighborhood topology and adaptive inertia for improved exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.1945008405783009, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.4975097532109978, 0.5242459112886824, 0.5157482161419378, 0.5320754848691244, 0.5278493771478662, 0.5181586513424052, 0.5061407482474148, 0.5138221203760927, 0.5206941840862473, 0.25695830441199297, 0.23330207251154012, 0.24804544465366685, 0.2359381387060433, 0.22837691685508466, 0.22773692174063576, 0.27105335844447886, 0.2461623529039415, 0.2445405221418523, 0.0825904887421317, 0.08554624709706782, 0.08660354089615885, 0.06680946865650583, 0.08261769432461041, 0.07886229768697539, 0.08360266158661767, 0.07470276090354633, 0.08053808687281017, 0.07619972079503201, 0.064836317011985, 0.07071327013487294, 0.0783182641560819, 0.06957427690984874, 0.08698013790461046, 0.07360919916166586, 0.07290804222428582, 0.07214506414429056, 0.9763724225693969, 0.9759638626749724, 0.976004173245854, 0.9716130404934507, 0.9782140272201616, 0.9755091316516747, 0.9691283261248288, 0.980406256109385, 0.9769283045983237, 0.25762832287772486, 0.05809028619440837, 0.2737664212002535, 0.26138743410768794, 0.1331597138853149, 0.2626169795311931, 0.2517559993511749, 0.08699416249623304, 0.2461887382460909, 0.20614469031569072, 0.23227089784193666, 0.18770969991504083, 0.20806348143841757, 0.18281396809050898, 0.2727274401588966, 0.2636044855771864, 0.21622322070099986, 0.2905482497968698, 0.11423290971373501, 0.10498730076825191, 0.1065811308348813, 0.1019342141201447, 0.08665741545715677, 0.10309431377866585, 0.11315849330304228, 0.1129862538319023, 0.12199193627112104, 0.10346294371404308, 0.009708740275579997, 0.10658975605052634, 0.10203099145285977, 0.10949213170024863, 0.10040073830015173, 0.05609500024145986, 0.08414577694142877, 0.10849589113829916, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00022680588355128428, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05560952717981893, 0.06572058168268757, 0.053013070709868604, 0.046709365986544626, 0.03069953520509827, 0.0323780145037772, 0.05451452345564978, 0.08223176707694779, 0.05676947080623618, 9.999999999998899e-05, 0.015797231293804948, 9.999999999998899e-05, 0.031076404614967523, 0.01383639796320657, 0.015305488478257079, 0.0073902416356715905, 9.999999999998899e-05, 0.016669762526522525, 0.052589747143951926, 0.04591536522238571, 0.05036808805856052, 0.08088754669230347, 0.06902428500800684, 0.06198551338426683, 0.05987388557273976, 0.04384355568533249, 0.03904196006976379, 0.36798541304694954, 0.3484217946504303, 0.3744579808563401, 0.39535639573167536, 0.3755325551164447, 0.38390452912798056, 0.36379600689410907, 0.379388682522109, 0.38022972419718504, 0.07893274496890168, 0.09072079096787933, 0.07977320026632384, 0.0729904363929127, 0.08139108662095118, 0.08460730261967642, 0.07711210319490214, 0.08708023847781465, 0.06736084334706816, 0.13657670956341317, 0.15183666166661403, 0.12775522395046301, 0.1378362965523956, 0.14417110189377635, 0.13142229328225985, 0.12213708612206009, 0.13567312393861464, 0.1463895737475419, 0.280055005544798, 0.2641888779031656, 0.25869597943644307, 0.22804974194460403, 0.23616692777434678, 0.24192364755768447, 0.2912666783388027, 0.30255291501079695, 0.3007791949546006, 0.16989575126947565, 0.176485990964938, 0.16090547761707386, 0.18527576076091667, 0.14270362311162532, 0.1478086725785437, 0.1834490975934343, 0.1968114886256801, 0.19742974138761116, 0.15930675130043115, 0.1685377317006581, 0.17976089535086337, 0.16115455887872154, 0.1922185767049247, 0.17312815183570618, 0.1672680514107613, 0.16433068524630412, 0.16491009023970105, 0.16989000222422368, 0.15728843788266478, 0.1730539686823861, 0.1746134253181324, 0.15986133484211618, 0.1608026295665015, 0.16872776468487938, 0.1679853749524507, 0.17590758634378711, 0.15955214919092087, 0.42813502533996906, 0.1923130960121261, 0.1564848572508909, 0.3108102392177269, 0.1658339435557613, 0.158669132531697, 0.3073083227382456, 0.16517848590681838, 0.16036913044353496, 0.1482423873250147, 0.1599195186314848, 0.22686043325346383, 0.18995405946746402, 0.1835250695146483, 0.1978200732013322, 0.1900897335645123, 0.20412762358696435, 0.18153670043598402, 0.1719910467677206, 0.1861959396788534, 0.18004273291995576, 0.1783022706753311, 0.1987790628934366, 0.1929151161042587, 0.19021802877748417, 0.18235865789852157, 0.06323772339927569, 0.0612051801257838, 0.06079670352101907, 0.0690005791670143, 0.058237383869965575, 0.06829709285022467, 0.06601783259867589, 0.0693825949213609, 0.06646931988279992]}, "mutation_prompt": null}
{"id": "4413f1ac-cf38-432a-a37f-4c86a19b7c5b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.quorum_threshold = self.population_size // 2  # New parameter for quorum sensing\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n    \n    def quorum_sensing(self, current_best_score):\n        # Adjust behavior based on quorum threshold\n        if np.sum(self.best_personal_scores < current_best_score) > self.quorum_threshold:\n            return 1.5 * self.scale_factor, 0.3 * self.crossover_rate  # Encourage exploration\n        return self.scale_factor, self.crossover_rate  # Default behavior\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            if evaluations >= self.budget:\n                break\n            self.dynamic_parameters(evaluations)\n            adjusted_scale_factor, adjusted_crossover_rate = self.quorum_sensing(self.best_global_score)\n            \n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < adjusted_crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSODE with stochastic quorum sensing for diversified swarm behavior and faster convergence.", "configspace": "", "generation": 19, "fitness": 0.27404823917889937, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "ffb9aa21-690e-45ac-94a2-e66a3f2ea7af", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.alpha = 1.5  # Lvy flight parameter\n\n    def levy_flight(self):\n        u = np.random.normal(0, 1, self.dim) * (1.0 / abs(np.random.normal(0, 1))**(1.0 / self.alpha))\n        return u * 0.01  # Scale the Lvy flight step\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions with adaptive learning rate\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i] + self.levy_flight()\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSODE with Lvy flight for improved exploration and adaptive learning rates for faster convergence.", "configspace": "", "generation": 20, "fitness": 0.19482795857584628, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.38007280976589053, 0.3700268405575149, 0.3835588746619363, 0.40747297239364366, 0.4110506834353099, 0.3864601387263442, 0.4324525924594874, 0.3875432422049254, 0.3759557528549282, 0.031089318562452117, 0.03525073865441086, 0.04671907231455641, 0.01837612363762897, 0.02301051663366449, 0.03924626321860125, 0.05396877098315067, 0.00484457750435463, 0.019904595042078976, 0.06244345086714509, 0.08578268044628845, 0.09846960202698285, 0.11647072982648243, 0.08324445304589612, 0.1062786583997084, 0.11070562355537439, 0.09353372267572757, 0.1076580690328437, 0.09326533982482765, 0.09940652150553919, 0.08132684411199331, 0.07925273758703077, 0.08900964215440277, 0.08475810978830833, 0.10086728871543471, 0.08161073369543759, 0.07823114630797101, 0.9727518344130621, 0.9838430371186597, 0.9768648715236155, 0.9720629804213268, 0.9709060390548351, 0.9707838478393953, 0.9794810689837727, 0.9816478262846327, 0.9854917323811515, 0.24364355911292945, 0.1875678889702571, 0.22865682089131856, 0.25455942800861997, 0.2370759499579066, 0.23874471937698583, 0.24422711429323896, 0.20066317140180412, 0.1972003185771547, 0.47076117702636877, 0.25832578840503373, 0.20598824529749804, 0.1895466544972525, 0.1529279505893979, 0.1545502570696432, 0.4350591187107272, 0.4227522541846285, 0.12405739325881515, 0.19529040327308778, 0.10727332455817395, 0.12812065584984067, 0.06443826741862446, 0.11265288410423824, 0.14695017569383761, 0.1355964314614726, 0.1169661780146547, 0.115392612580829, 0.09205453190437052, 0.08510831796915086, 0.1387692144013909, 0.10278019978639463, 0.10228792020217448, 0.12306964183070668, 0.12257695196403906, 0.10080767740575336, 0.1567768714186164, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011009803199502066, 9.999999999998899e-05, 0.01239677406077222, 0.005081824225736997, 0.04758172389174453, 0.06315867167386224, 0.031198612663809078, 0.0318614224589443, 0.05957064804085621, 0.029934872326601858, 0.0725883371104965, 0.07650284068330371, 0.02046246824693332, 0.014697483540717649, 0.001730939114982677, 9.999999999998899e-05, 0.01790674652708435, 0.005145052301003705, 9.999999999998899e-05, 0.0017029747063521672, 9.999999999998899e-05, 0.0005823204056805142, 0.08514940898362233, 0.06963970847769796, 0.06683670157264254, 0.06205561662066561, 0.08651172284599329, 0.07951456841877147, 0.048187711648329024, 0.044787211719645725, 0.0806058617428127, 0.3365136164839635, 0.35188389006252996, 0.3708864400319961, 0.37806893519062157, 0.3418781358088391, 0.3450063705683638, 0.3652964095042277, 0.3596855046489864, 0.35501675096895546, 0.08837359762096564, 0.11127739063738595, 0.09560884349160081, 0.10659249463844112, 0.09170986608176068, 0.10566416903119569, 0.090127841075889, 0.09298668492623707, 0.08080333768364834, 0.19135991941907493, 0.18716841560250885, 0.21643256701461466, 0.20809206680033, 0.1608450384233272, 0.13190253364742444, 0.26553140715296963, 0.20420914310363458, 0.2234783649134845, 0.23820793588494094, 0.14255457090952928, 0.2713174694765984, 0.2655420532029321, 0.2600871799095976, 0.2609470358098517, 0.26465154786400247, 0.2774346431621899, 0.26100876500416037, 0.18061877329988618, 0.19585208802740195, 0.20945172803444112, 0.21957524726307132, 0.17656260719465722, 0.1829319849400698, 0.22161227575482345, 0.20144232520838468, 0.22127650562123324, 0.199262329529582, 0.18905556577586435, 0.20206813569429238, 0.17899723482854202, 0.1845761992508439, 0.1860083632169761, 0.19865126116773657, 0.19875464031892276, 0.15405491376425506, 0.17742988419083527, 0.1751279488426455, 0.1902472469688392, 0.21152163703921745, 0.1865717494242196, 0.17504839720358945, 0.23993465550391335, 0.17305075475829235, 0.16541575308610368, 0.19889130365569185, 0.15988003713969023, 0.16039053810413229, 0.18778641226315507, 0.18812805928362708, 0.15636697884100015, 0.1566436878729468, 0.41655725342748406, 0.5344782354387723, 0.4033432918258929, 0.15092756518750772, 0.16122711834271863, 0.19059520492542004, 0.287027945735864, 0.17446049194096447, 0.20888339440616177, 0.20232079836636907, 0.44598681059615986, 0.18575951369243804, 0.18247403892782832, 0.1744224981301592, 0.19309739168600093, 0.18988298861245012, 0.18611889411470184, 0.19349207471822194, 0.19596129800248796, 0.22211601154579153, 0.0817563672203212, 0.08988908828720354, 0.08274576623064789, 0.0733949866863568, 0.07223385911586178, 0.07881427589743084, 0.08869544138177465, 0.0793276707103836, 0.07273575169703783]}, "mutation_prompt": null}
{"id": "a131e389-b3f4-43eb-be06-6ec8a89d1480", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "e9dfd353-6dd4-48db-bcd9-df0d26ad82cf", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "3a6cccb0-169c-461f-bbc0-e84ae1a49a17", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Adaptive Hybrid PSODE with dynamic parameters adjustment to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7534453553531428, 0.6888843487210856, 0.6912645376682962, 0.778165277443081, 0.7177343353586354, 0.7077180570564526, 0.7159748477026036, 0.7144103942757527, 0.6675934589414212, 0.4528880338303358, 9.999999999998899e-05, 0.49960822648293757, 0.47104000789180767, 0.43811659141275694, 0.039846512880974516, 0.41562127922171166, 0.013125037666778527, 0.4057023269702549, 0.1007331623380745, 0.14596123868025457, 0.1512522240526809, 0.1287859136613344, 0.14853425779239404, 0.13235884346656746, 0.1354853560965268, 0.13172451296459453, 0.12424839353517092, 0.10446989773427262, 0.12270511821249497, 0.11127497593622704, 0.1276160726990383, 0.08805871890208306, 0.12714963163321824, 0.10582575862876165, 0.1254379124407169, 0.14075241351935897, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.46364926109897253, 0.5364220882833548, 0.4300517992887539, 0.44795653050101014, 0.5040529436820305, 0.5487075497201266, 0.4669358222546274, 0.49107542147407335, 0.4491337496637423, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1488654749517878, 0.20416985542663502, 0.1869564933230733, 0.20520491339720714, 0.09589993993762835, 0.2112481090905317, 0.20280738996268521, 0.16309513502037298, 0.18749845351538852, 0.18318492113148632, 0.17330706348751612, 0.1257108737806677, 0.12239878957773798, 0.11411664728106408, 0.12303224024703663, 0.22168731655061424, 0.15066556480025706, 0.2211192539160335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024422278662123098, 0.03961500973997922, 0.02853589504312093, 0.00027608598313311195, 0.0035467204371759653, 0.046172721488432544, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.025456976728895242, 0.12579520051820037, 0.08244595371343877, 0.1473653980447196, 0.05790651048839501, 0.043088732718311595, 0.20163652077836902, 0.06773275336529949, 0.09619644014142614, 0.18055525593939836, 0.058048268184397456, 0.22113474934157762, 0.102389641515362, 9.999999999998899e-05, 0.14348379345677875, 0.08060890266936316, 0.07585553230485076, 0.07561874414379688, 0.5370171948498506, 0.4756650408016152, 0.5130634391143876, 0.20877864106333732, 0.48512503983866195, 0.5282492686236024, 0.5179464617509677, 0.48411053378510804, 0.49187243166926375, 0.11457979866878554, 0.1015671888052293, 0.07654536183452709, 0.09443685328047757, 0.09763148030514546, 0.38693484513434917, 0.12154457344807157, 0.13859513705734794, 0.09421289172170089, 0.2627606589720817, 0.1660050199876214, 0.1771754207774946, 0.32157246982388765, 0.2635543637029416, 0.20095186731946058, 0.14588617111409552, 0.2244646275485095, 0.332694631669889, 0.37229950391032296, 0.4185566488794501, 0.3283809331220353, 0.2041614492546554, 0.22124026855965362, 0.37731935740959044, 0.3559341575551429, 0.44389692887280163, 0.4475189413925379, 0.15233634782967087, 0.26025559923652986, 0.2542856874324354, 0.28552846659252074, 0.18162135605589314, 0.269875661537313, 0.2297359843687362, 0.27439430197026804, 0.22603033206910372, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.41448629957370353, 0.19056778764646087, 0.19574391432148408, 0.18839171042716274, 0.22214787607804176, 0.22827731390792938, 0.47456715395418625, 0.19157611505853145, 0.21111587439599366, 0.16219790459121397, 0.12803655457540208, 0.17820688433203125, 0.8462162413141306, 0.19815806381480472, 0.16457531395071978, 0.13997596788775213, 0.1689717961613032, 0.16658316769018544, 0.6916795357742297, 0.1556410889330968, 0.6172029744213121, 0.6380572736720216, 0.11245383295064038, 0.1548275226881799, 0.104487661114392, 0.5307621876102393, 0.6409052778095896, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.13057039344403898, 0.08127438557507372, 0.1321755677209807, 0.09896847778843076, 0.07880290884652619, 0.11309644568335098, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "16e8c213-9681-4003-a4f3-6cb562249181", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n        new_inertia = 0.9 - 0.5 * (evals / self.budget)\n        return np.clip(new_inertia, 0.4, 0.9)\n\n    def adaptive_local_search(self, position):\n        local_search_radius = 0.1 * (self.upper_bound - self.lower_bound)\n        return np.clip(position + np.random.uniform(-local_search_radius, local_search_radius, self.dim), self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            inertia = self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n            # Adaptive local search\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                local_trial = self.adaptive_local_search(self.best_personal_positions[i])\n                score = func(local_trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = local_trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = local_trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE", "description": "Introducing a dynamic inertia weight and adaptive local search to enhance PSO and DE integration for improved convergence.", "configspace": "", "generation": 24, "fitness": 0.22117499096062487, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.4494507282877266, 0.4693013505366461, 0.45965943094359696, 0.5412163791141995, 0.5011855904924558, 0.46346946910554343, 0.5099739166839029, 0.4954157886568298, 0.48859317834846494, 0.1607967003224421, 0.15085837120833545, 0.15265774733695248, 0.07664398290958685, 0.17632465858664637, 0.18363328943338997, 0.14315481796241003, 0.17212953288233734, 0.12936679915193416, 0.10495246580818363, 0.09588651717097796, 0.10286382539155525, 0.10965987948611378, 0.10409995292203911, 0.10327204300335813, 0.10444291066631373, 0.16159402226969521, 0.10101131928798113, 0.08818823055754688, 0.07014515192726012, 0.10020512876214582, 0.10210028667541504, 0.10700844329927217, 0.07159052283563105, 0.09741335788968941, 0.08739015910735792, 0.08008740644332124, 0.9763600478816525, 0.9774060051585756, 0.9668718341810038, 0.9733681323979403, 0.9783734004809288, 0.9666622967511582, 0.9764799157465883, 0.968641928286268, 0.9743523937965847, 0.24674781198096074, 0.25710064976580727, 0.25328647720178854, 0.2952179430341595, 0.2592793212517771, 0.262651627752733, 0.27727517495294973, 0.26389996080282285, 0.26120749031037527, 0.2992136907962232, 0.4332047789900376, 0.20138742154847566, 0.26345799752854304, 0.5020002540235615, 0.2372561074124624, 0.2676718400012974, 0.2869353503499483, 0.29219396370101336, 0.11789358173993769, 0.07163883693864992, 0.1224837965539497, 0.1268241063780009, 0.12257503663783553, 0.1370257337245987, 0.14140513410212718, 0.13581722538289154, 0.13400475413812307, 0.14296884220437, 0.1077829626922252, 0.11130433053756827, 0.14149600601450496, 0.10226139381612409, 0.12109348369687611, 0.1331534245385494, 0.11484222326336258, 0.11038049326810173, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011805728102676216, 0.022904380188578766, 0.007831033525516062, 0.001300203950013068, 9.999999999998899e-05, 0.0013855641168389887, 9.999999999998899e-05, 0.051568986327874655, 0.0917751026631688, 0.10553166456879826, 0.029518129462979048, 0.043630914245599506, 0.07433684587984113, 0.09482928830585957, 0.07270187019397256, 0.04550675773132551, 0.010548437600212845, 0.007055372926378145, 0.013640437834837038, 0.031435098626724, 0.040513348308208186, 0.04493100460330168, 0.060308236277124116, 0.09527239445597346, 0.011710382813077014, 0.09535060627705838, 0.08868974797691376, 0.11703126557032606, 0.10008153875519621, 0.07799576349630677, 0.06384336524157752, 0.1022895325232539, 0.06797079031750142, 0.10532976590822218, 0.3754743999780781, 0.36141746999097035, 0.3792793517609584, 0.3908146160099569, 0.3881093422017726, 0.3981183521632575, 0.35846206838171424, 0.37570595518532934, 0.3844332230366102, 0.09738524623695433, 0.13172155527416907, 0.11369481212191279, 0.09994972690200388, 0.08965238296471834, 0.09876419637918865, 0.08483691200156374, 0.10102699477750698, 0.104488994462833, 0.17170319149032875, 0.14924023112987284, 0.22663943467112635, 0.17865247537311502, 0.1943047141532338, 0.17482053459745517, 0.19145561883284667, 0.24056275249541836, 0.13144053737645567, 0.3050299541577963, 0.26212375081969197, 0.28865814015781566, 0.276516091374684, 0.2458946726511554, 0.2683791805693788, 0.2748066059743076, 0.26596852610994304, 0.2962237359737703, 0.216092956226015, 0.19345840725888686, 0.1961906075238823, 0.18936186946604394, 0.19452279015519458, 0.20820930623747436, 0.18259470772750497, 0.210453882915839, 0.1985579152766721, 0.20065247397635455, 0.1781481178899914, 0.19139418476213754, 0.1865088383861585, 0.21271752484896145, 0.18455561306193657, 0.20338751161559177, 0.19915901067737996, 0.20435685891218014, 0.19522324472651575, 0.18160468551265074, 0.19716334601822316, 0.18991831930379532, 0.1686885316522514, 0.17626638797131888, 0.19328691523600183, 0.30885034245957665, 0.18395839850196183, 0.18879115155409842, 0.20133880378433, 0.5430749454806223, 0.5410186291023528, 0.1914071491981244, 0.5545406666113437, 0.5124437911567836, 0.16920675718914957, 0.431688302655746, 0.40669953602078446, 0.20772413270252787, 0.19978918892350006, 0.36149722953424646, 0.19082706364027058, 0.42242292063542186, 0.3850296229037362, 0.20618788763345064, 0.42568128291346663, 0.19107465248413102, 0.18982326917641734, 0.19114805271634994, 0.19159292920296167, 0.1960312487930247, 0.18609034212281472, 0.19063665483432812, 0.17391742456494153, 0.18658673378288648, 0.07614815826711674, 0.08526600822288177, 0.0769012662503814, 0.08123727102966494, 0.07748660345516822, 0.07507712525793808, 0.07797597209314677, 0.0785410812965196, 0.08025875560243434]}, "mutation_prompt": null}
{"id": "19fef952-c5f4-4203-8a36-f7966e0f1a65", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.adaptive_inertia = lambda evals: 0.9 - 0.5 * (evals / self.budget)\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def perturbation(self, particle):\n        noise = np.random.normal(0, 0.1, self.dim)\n        return np.clip(particle + noise, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = self.adaptive_inertia(evaluations)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles with perturbation\n            for i in range(self.population_size):\n                trial_particle = self.perturbation(self.particles[i])\n                score = func(trial_particle)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial_particle\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = trial_particle\n\n            # DE Part: Mutation and Crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptiveHybrid", "description": "Enhanced Adaptive Hybrid Algorithm with perturbation and adaptive inertia for improved convergence.  ", "configspace": "", "generation": 25, "fitness": 0.2410258699962714, "feedback": "The algorithm EnhancedAdaptiveHybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.5940888762179354, 0.5796724164293066, 0.5896361195877513, 0.6031186670239652, 0.5880724362220981, 0.6058042246906562, 0.582209618277012, 0.5991003830895725, 0.6001079020637443, 0.3033041836979371, 0.25698955590449635, 0.29943092596904886, 0.2658584075545166, 0.27642718046643144, 0.23676368383843605, 0.04022080405372275, 0.05649718784653557, 0.2922861830410797, 0.12076985412047547, 0.2220375556522869, 0.15144960696332344, 0.10257624932755594, 0.11508061994079488, 0.09962774868855051, 0.10663928144262846, 0.11601024568318519, 0.10516003844880872, 0.10150547286933398, 0.11311684787323761, 0.09124299882669207, 0.11653078949000117, 0.0893501417773006, 0.09580296219573448, 0.09689314657532777, 0.09776930047661458, 0.08878785985563642, 0.9744874377018595, 0.9752762535555853, 0.9742818670225154, 0.9824355883351606, 0.9682552001266845, 0.966430702849777, 0.9725172998276499, 0.9757628369551081, 0.9815279472253999, 0.33612502761833407, 0.33869519237463874, 0.2997455918732831, 0.32269675335360426, 0.33300936170335294, 0.32595875523433315, 0.32964052635086416, 0.3291184689029846, 0.30346679883234506, 0.21827127891499254, 0.29554591603527913, 0.4399863577271397, 0.5231738229637845, 0.2553613980424464, 0.1873619135584137, 0.2256925163761081, 0.551426040135957, 0.3217612713265602, 0.13290873493285638, 0.16754306958686738, 0.14926908146025986, 0.09051944155389613, 0.15609811800899165, 0.1488471888373648, 0.16621967567949014, 0.14603104975131298, 0.16198710460965793, 0.13581389844225178, 0.10183977850680637, 0.12315468159986886, 0.13757613737066277, 0.13850608337164305, 0.15547062633886255, 0.14474178458222509, 0.15130663720327542, 0.1922333802272702, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1550791866893635, 0.03623830580493759, 0.08986930653059566, 0.031949247945619264, 0.09366251482937837, 0.01960123180747031, 0.018887586392590472, 0.10035632488883184, 0.04399798176591507, 0.020955537853568074, 0.11428913337753055, 0.02478206005714778, 0.0387182945016713, 0.04599244719545059, 0.0390617565294511, 0.04630712347753452, 0.05239206659712181, 0.03502193419145827, 0.1039854826025155, 0.14839423998943235, 0.040235787345925256, 0.13544325609206176, 0.05999265485530725, 0.08716603796554079, 0.08371934165008721, 0.12787840986473797, 0.08620714629121173, 0.4206694156766908, 0.4248947323574517, 0.44605843158399416, 0.49292961760868526, 0.42528111600588536, 0.4422656356532205, 0.4178825962664984, 0.43063351006531114, 0.4233701754692518, 0.09313439911044008, 0.09413041271843159, 0.09646185819956588, 0.10003508592610111, 0.10439104271977562, 0.10689333175263804, 0.12517095911880538, 0.1044301945026227, 0.09806807996417843, 0.30383881624043974, 0.271740649570572, 0.3191730344931234, 0.22066952442170218, 0.25662850887863853, 0.15155845385070243, 0.20187286426598527, 0.18230707119598677, 0.16280342292754035, 0.3287224829178379, 0.3123152899971513, 0.301883252093066, 0.3124352074832567, 0.32267224904670433, 0.3258686825992312, 0.3736741257219893, 0.35587933991862974, 0.35729253152088736, 0.25418620742188813, 0.21147893700981002, 0.26136059232908215, 0.2243725335615926, 0.1898393203388976, 0.17951655720791082, 0.23255040371338143, 0.24174394226716978, 0.2359552837993938, 0.1949542798716415, 0.1848911981606518, 0.197850980252826, 0.19948332619885134, 0.1809938228386735, 0.18664156010663013, 0.2080652639983721, 0.19097041790472336, 0.19728210692514692, 0.20979588423667705, 0.4079646528909492, 0.3834301804691337, 0.1932422971032235, 0.19800939688868135, 0.3166054414682695, 0.18113714896018196, 0.3093467876040009, 0.20057793621795916, 0.15815752116400927, 0.1392581027824652, 0.16517540174344414, 0.14445973021623415, 0.19403921513712907, 0.6966221046286695, 0.1399399950384742, 0.6723889102086182, 0.1460401634197377, 0.42158003297333724, 0.1539655037473887, 0.20629418947660672, 0.47470140907509795, 0.16712741649218443, 0.12729493012778714, 0.20793201949800444, 0.20569180823406819, 0.5473356248259348, 0.1783331022233644, 0.18795657345418548, 0.19388825559142742, 0.20462142924261184, 0.17956442529200978, 0.17995287922516923, 0.1836598352186367, 0.19550467510423808, 0.1877822543199099, 0.07390828500135993, 0.08236978070806922, 0.07483050520977508, 0.06781099329923546, 0.0920584571002413, 0.09416849944872907, 0.09250537125382219, 0.0821696707059687, 0.07311381615605117]}, "mutation_prompt": null}
{"id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.2752003646796141, "feedback": "The algorithm AdaptiveHybridPSODE_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "d2984bc3-4821-4308-8017-49df77e04b67", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "cde10d5e-88e6-49fb-ac54-76db1e94f45c", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "a11d3bc3-25fc-4579-95b7-e1fe6ab05d81", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "2c0485b8-611b-4e36-8977-77e6fffa768b", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.15  # Adjusted for new dynamic\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                adaptive_inertia = 0.9 - 0.5 * (evaluations / self.budget)  # Enhanced adaptive inertia\n                cognitive = 1.7 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.7 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = adaptive_inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with adaptive mutation scaling\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                dynamic_scale_factor = self.scale_factor * (1 + 0.1 * (current_diversity / self.diversity_threshold))\n                mutant = np.clip(a + dynamic_scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce boundary-driven mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.6, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "Introduces adaptive inertia and dynamic mutation scaling for improved exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.1832497322691767, "feedback": "The algorithm AdaptiveHybridPSODE_v3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.37750099606309795, 0.34056748224692, 0.4278610219382467, 0.4622052004580084, 0.39422251932216745, 0.2791542816487016, 0.44008592301697447, 0.4059737524707796, 0.39760289519240477, 0.08274056903998794, 0.08293836466843219, 0.14213586038766424, 0.020150347734297802, 0.06135777803942455, 0.06608095712597484, 0.03785846147778993, 0.07011567648925443, 0.07217853366644011, 0.07654067425989286, 0.09654649819188654, 0.07281549414581989, 0.09381727235776727, 0.09128347859681474, 0.06410884104445813, 0.09802773598232761, 0.08504168367444709, 0.08078967460551356, 0.09535095976711505, 0.08263752833294513, 0.07111894398836704, 0.07845000219218545, 0.08225351106211931, 0.0679386978330172, 0.07998048321687912, 0.0679495099022821, 0.09114882995081974, 0.9952415539988392, 0.9775356349235367, 0.9776927804396186, 0.9851947739598178, 0.9868706448783192, 0.9836836896047769, 0.9784853513668071, 0.9814485868170902, 0.994092845731315, 0.18607391269427342, 0.17204820436316204, 0.1642342515079097, 0.13384086697758812, 0.160367182041651, 0.14715134659533347, 0.22009893248123846, 0.1675593481972344, 0.12629358392236478, 0.23118565531221735, 0.20267454464036117, 0.18812581523059757, 0.19395721903576835, 0.44667183228885887, 0.20407440564295376, 0.1682732952414404, 0.23070296623458553, 0.18507346086985144, 0.09484903340296202, 0.0950895743787743, 0.07028240288017418, 0.11214625658438215, 0.08989874902150663, 0.09576037787927105, 0.09435495725632048, 0.09502324876790558, 0.0986765009199333, 0.1784288211344658, 0.04706430798900141, 0.056666534210073394, 0.13665034343739768, 0.13016850313299688, 0.09992207269252373, 0.12008204901593, 0.08303532869306529, 0.12776310004093627, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014249873743688024, 0.020340626855528954, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011592696561827376, 0.037097698306227334, 0.03481444423242408, 0.07135766355093454, 0.10326644823795617, 0.001043465869523641, 0.06663623432859644, 0.01679608304241431, 0.026475515331915056, 0.006071906877871847, 0.008166640494129518, 0.011126625280244884, 0.04819104744287617, 0.022419763785228808, 0.022362415117606727, 0.03039065782165218, 0.029297933706534218, 0.018756498329734694, 0.09829560314794727, 0.02171707904426201, 0.028431698956695395, 0.031146035133605032, 0.0417965503802612, 0.06726360321323921, 0.041163994920753844, 0.0390040587853131, 0.040999296443082534, 0.3611370185694843, 0.36982832389864584, 0.3245002596144909, 0.32588850010041126, 0.310210954218053, 0.3790050235528186, 0.40418342074737523, 0.3612233822165497, 0.3382431207243094, 0.09852241353615576, 0.07585953268796508, 0.06867226804179172, 0.08332760357626978, 0.07765854961642504, 0.09565102674307036, 0.0918593477531664, 0.06527618212557207, 0.07896216318826788, 0.15212502406133677, 0.1520957939673786, 0.1457698695170515, 0.13542793788457985, 0.1745488292078906, 0.257090592191596, 0.2170963736321211, 0.1634151163495946, 0.1665764661670015, 0.11918035032753937, 0.20108736643659908, 0.2505146365883628, 0.2487312259006298, 0.22953381061431666, 0.2298774641796203, 0.2661241389717909, 0.26914493903893943, 0.27354377621140513, 0.1669773365150099, 0.18842340167277427, 0.13351891888832756, 0.22447593526214848, 0.11897612085303166, 0.14689941497582115, 0.16770497469904255, 0.20207219793548092, 0.20025898428126254, 0.17031684103819733, 0.17083334639535075, 0.17251236185291585, 0.1620717758788478, 0.16110341537358852, 0.16661499078596864, 0.1871407269531581, 0.1756360746675113, 0.17142909170184972, 0.1703215791586874, 0.19482421975298547, 0.17572770250032355, 0.1935673782293551, 0.1976224251940576, 0.17592181556935516, 0.17978929698353918, 0.17502271466324804, 0.1776299056705184, 0.1413846195888897, 0.133153317633685, 0.1602946146725167, 0.5049541512641533, 0.17558258887641498, 0.301516713911959, 0.1793449601816881, 0.15936676382665704, 0.18523481310620005, 0.2933703125746038, 0.1890599517782583, 0.15782624016009317, 0.43747917712085793, 0.2821857072728232, 0.19394478809667304, 0.19603339955910448, 0.20447350180503931, 0.201284233216098, 0.20150936934082697, 0.1709734428032581, 0.1924462166731422, 0.17626797188566956, 0.19578175345366045, 0.18411027849256234, 0.19579804221200037, 0.18464136850690782, 0.1897385787727781, 0.08516189745716396, 0.06763318662767126, 0.0712293372970988, 0.08489101250692621, 0.059365910067037286, 0.08292739894764234, 0.08125566910178328, 0.061191736698882226, 0.06333332457832808]}, "mutation_prompt": null}
{"id": "c57fa485-defb-44ab-9cfb-155ace90a9e4", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "0caaf854-3621-4524-8254-4b8a140209a3", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "3413f595-c13e-4c6b-83b5-c5fc2b4113e4", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "30572ae9-ddd1-462e-89b3-14792e2413ce", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "d0304b30-11ac-4e36-822e-0bad6fc464d5", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "05b7cc3d-7294-4fea-b4ea-a86c7545751b", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "e15b6ca8-74e3-477e-827d-bfaa44086a02", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "fd12cc5e-88fd-4603-a818-639531728b17", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "dcf21ca7-1d79-437f-ba34-42ce2e703af8", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "eb907a84-7c19-4fd5-998d-1257f21eaafd", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "c58ea245-12fb-49f4-9f08-63af577ce096", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "91db85f8-c661-40cb-aa0d-0f8c0393943b", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "1ef4562c-1160-468c-b62b-df716145966d", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "124a9c67-c793-4da0-baed-fc5ade1cf804", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def boltzmann_selection(self, current_score, new_score, temperature):\n        if new_score < current_score:\n            return True\n        return np.exp(-(new_score - current_score) / temperature) > np.random.rand()\n\n    def __call__(self, func):\n        evaluations = 0\n        temperature = 1.0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = np.clip(inertia * self.velocities[i] + cognitive + social, -1.0, 1.0)  # Clamping velocities\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if self.boltzmann_selection(self.best_personal_scores[i], score, temperature):\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n            temperature *= 0.99  # Simulated annealing for selection pressure decay\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptivePSODE", "description": "An enhanced adaptive PSO-DE algorithm with Boltzmann selection and velocity clamping to improve convergence speed and stability.", "configspace": "", "generation": 43, "fitness": 0.2581386327845071, "feedback": "The algorithm EnhancedAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.36231800000732683, 0.39234499694467573, 0.3812408624545123, 0.3567278912607871, 0.38348331854911166, 0.4080879051414942, 0.364163258778069, 0.3960059428304886, 0.33737869882813953, 0.3787325638841167, 0.26250363616862027, 0.28689923355344926, 0.2927328088420582, 0.2857321391255043, 0.27701858485033304, 0.2267495674586988, 0.26378349124698675, 0.28507286799511145, 0.19420904696668628, 0.19148058144644664, 0.28614528319988797, 0.12973455392470024, 0.1513875638047648, 0.13235681102019536, 0.26646222077825255, 0.21000699319790495, 0.25227952015701494, 0.13748647158786298, 0.11630967726202956, 0.13523486005291563, 0.1614902675905121, 0.11566177861834481, 0.14107467831257803, 0.1355617350166085, 0.129016049901023, 0.11229484214375185, 0.9457027941152916, 0.9556717719786063, 0.9291603980663725, 0.9701600163529148, 0.9497402522972238, 0.9505028389710213, 0.9471657432957733, 0.9447647783478548, 0.9493591917298738, 0.31379595749402767, 0.4510718964665975, 0.27508863006571804, 0.33641248241371335, 0.35853745041187446, 0.31079348983711685, 0.30659810973934687, 0.3143182775371791, 0.4624621063368204, 0.7507143432037231, 0.576873935627218, 0.3517509498048268, 0.3539061840666089, 0.3908239475041282, 0.3589442753753129, 0.3709450226559794, 0.32368795792423144, 0.3355272023201835, 0.337223742011056, 0.19383993991416082, 0.18200186830282206, 0.14318662176184316, 0.3573290466322111, 0.19649762716062502, 0.17990857849219777, 0.2039049733574958, 0.21583825141350232, 0.19047847391534956, 0.19124802932034424, 0.20715576463633822, 0.23331417957955802, 0.1747041340218204, 0.17881972945505675, 0.22536055345697592, 0.216222547458914, 0.20614756794257438, 0.003380585224977195, 0.0031958663171753887, 0.04808902657813019, 0.05421284010289751, 9.999999999998899e-05, 9.999999999998899e-05, 0.0052292773667855785, 0.10273302834380538, 0.02745239198388061, 0.12752305346973847, 0.12842124020866486, 0.08332904346641645, 0.07117487284271651, 0.045111263724461614, 0.08976011573073861, 0.08426935761621412, 0.08939057730842381, 0.06734849421210276, 0.11216589725724913, 0.09437154926788371, 0.1309866627642574, 0.12956149763593094, 0.06570352635383458, 0.12096936694300475, 0.0998801184541207, 0.13227249396800855, 0.15164180024985563, 0.18523534883666404, 0.049384220431637926, 0.13469705456894132, 0.19140903557774858, 0.20234776086594397, 0.09734723969731784, 0.20719697530402326, 0.1061662383478863, 0.08048486763582163, 0.38292725420125284, 0.32760204193586384, 0.33403790397163124, 0.3278179675496029, 0.3818947635471561, 0.3277864269035011, 0.3412361707559789, 0.32706846995827354, 0.3846003538930156, 0.14510817690664457, 0.11070156251083885, 0.15414527474292006, 0.14712210600127895, 0.13225161725978285, 0.13835443604418218, 0.13054379976071284, 0.13147947576038566, 0.1624832427087176, 0.3174076211998855, 0.3090365019208552, 0.28804274526497586, 0.25877979230511816, 0.2131488930502522, 0.22745571110165752, 0.2757608944603951, 0.23659513161769508, 0.21195071873595017, 0.2771250465509917, 0.29081779497609195, 0.27847544868628715, 0.2711681570638781, 0.29315436537224837, 0.2681220993821044, 0.2805086552171806, 0.270874132556402, 0.2781974475233713, 0.22374859323050011, 0.2518211222106028, 0.22424610524396682, 0.28627890599800454, 0.2019957121844661, 0.23746135179013395, 0.21076637491665307, 0.2837118572761782, 0.2081857338251326, 0.24644125745730605, 0.20911665479382568, 0.2335126428286941, 0.22205348671426772, 0.2354492875321028, 0.21163206156333747, 0.22573769533695165, 0.21999411801135382, 0.20987294048033733, 0.23077178863912828, 0.3272578306770576, 0.20323436720532895, 0.18873604600483618, 0.20625697500902507, 0.20225020216275336, 0.3385662201706445, 0.1849955513519156, 0.20951375939768724, 0.18434073256983263, 0.16599952041813015, 0.1781242110666994, 0.5772425819921894, 0.19701582708084708, 0.19584012005756235, 0.5644606791215455, 0.5851384389341046, 0.15782097369874104, 0.4693780190313298, 0.15663121398275237, 0.43434561168766117, 0.497263436469505, 0.3932855243842921, 0.20811754940917504, 0.4996452676616343, 0.10464579401799423, 0.45539095221217496, 0.20173367000554976, 0.21055138894402237, 0.19298850909797893, 0.19606987326943437, 0.17270778626642191, 0.19188623987320275, 0.19532673853484284, 0.1938844694352696, 0.2058890498027297, 0.11796908705731857, 0.09816287828012815, 0.09719058262761737, 0.09295528228053296, 0.10791759935744272, 0.11703334164619938, 0.09630947187256644, 0.10466446110512095, 0.09315393046110787]}, "mutation_prompt": null}
{"id": "76ab806e-8436-4de3-b807-8060c49c81f9", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "a052ef12-8a88-4839-b479-8aa5fd454dab", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "99798797-9745-48d0-8c2c-07e375900d7f", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "e28d8bc1-408e-475e-8694-4422b15ea1d2", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "4ec44684-2bc9-4cb0-997f-877d8f299525", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "2af017ad-0b04-4cb4-b57a-406f9363a02c", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "e94b1ec5-a5ab-42a6-a17e-de93c7d06491", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1\n\n    def dynamic_parameters(self, evals):\n        sin_cos_factor = (0.5 + 0.5 * np.sin(np.pi * evals / self.budget) * np.cos(np.pi * evals / self.budget))\n        self.scale_factor = self.initial_scale_factor * sin_cos_factor\n        self.crossover_rate = self.initial_crossover_rate * sin_cos_factor\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.5 + 0.4 * (1 - evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i] or np.random.rand() < 0.05:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "A hybrid PSO-DE algorithm with adaptive exploration-intensification dynamics and survival-based selection to boost convergence speed.", "configspace": "", "generation": 50, "fitness": 0.18505098414193047, "feedback": "The algorithm AdaptiveHybridPSODE_v3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.3906376222266936, 0.3976924489827396, 0.3911695948976718, 0.3876523903326351, 0.4311150442087194, 0.48850033239876833, 0.41640304519760984, 0.37700070421262855, 0.3691629320969766, 0.032613646126685825, 0.03122604572770593, 0.04722069661527817, 0.06536554410532824, 0.07169360652884393, 0.03295668888137937, 0.12278751445506986, 0.10262702272818691, 0.05923826275994504, 0.1015582813343463, 0.11531761078287384, 0.06261113581988442, 0.09374930832588724, 0.09624857591427372, 0.10841876035900189, 0.08713532590166362, 0.10741236649041608, 0.0814725412227153, 0.08658265221782946, 0.08783169194563611, 0.10321007630246837, 0.09038944046744202, 0.0861206365846452, 0.09673469833570814, 0.09821878053110744, 0.08452717107313579, 0.09013152663361923, 0.9770392206381466, 0.9705936801436352, 0.9779555969246196, 0.9775806618419863, 0.9781325291111324, 0.9798184795249455, 0.9788729233616632, 0.9765049971469342, 0.9776817346044968, 0.19718713023717738, 0.058816664915013694, 0.17490821385728217, 0.13960797703763894, 0.13815869875938203, 0.21960634636012555, 0.08560546285861614, 0.1430136867684385, 0.2680388584596167, 0.19618213486896785, 0.17802176476379172, 0.2538681069229144, 0.18914954321733912, 0.23644835332586378, 0.18861328676677835, 0.14321286828139146, 0.24736594963874992, 0.19394865324561728, 0.13119330540506147, 0.11393815570793175, 0.09877870909660746, 0.11453386326269288, 0.039372996555887996, 0.0828067296128775, 0.12436710427075215, 0.0946145945016218, 0.12422676145380829, 0.042890608760356885, 0.07648599129748368, 0.11057714356072301, 0.09245956557648971, 0.08839955970709923, 0.1280663654229064, 0.08031798011936608, 0.08393965170381723, 0.11524649897456096, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012498677642047706, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03779009989145632, 0.03510023542954821, 0.0575503288037742, 0.026157350117498757, 0.013648160976984958, 0.07892183550051546, 0.056716834526559845, 0.024540762217468592, 0.056774236392423516, 0.008535317691898858, 0.025687752158711552, 0.07688555725639257, 0.01349871448862372, 0.016634267905478728, 0.03107793286658944, 0.008109842050778915, 0.024809780062273967, 0.0273404438671343, 0.018162105886100344, 0.028863821303720227, 0.006793245651129265, 0.06930278286610014, 0.05355685108766228, 0.06522375905821642, 0.05288155039565645, 0.03788477338751395, 0.06563573850110882, 0.3062321499955494, 0.34757731104526524, 0.36225114549880155, 0.359163429339901, 0.38096367731541436, 0.3875174555097356, 0.36389298072705767, 0.40544303283551253, 0.34758257018310756, 0.07388273074451446, 0.09560306927563611, 0.06245044486787832, 0.07632425789004849, 0.07432945503893729, 0.07895139668078865, 0.06456437323714292, 0.10403198365006083, 0.07903030631501329, 0.1847617658908427, 0.21123078600669842, 0.15842628341467935, 0.1480972606554415, 0.13024089752841905, 0.14553319945039545, 0.22977545345802108, 0.14177482941819375, 0.1610297282599228, 0.2124818928846942, 0.21876910032015195, 0.25268183252344256, 0.21253699123069014, 0.2553137756210414, 0.2508159493014942, 0.21898213850090764, 0.22943816447713739, 0.2210545180913659, 0.14975252856065235, 0.16649803655002493, 0.20605560283934388, 0.14213747690772782, 0.16057843554943252, 0.2065662316521072, 0.2217757693868817, 0.1814483424716935, 0.19803101875997386, 0.1822498230643863, 0.1691744347055656, 0.18209560490765275, 0.18518101634755546, 0.18189738787686915, 0.17068755611960063, 0.16852796068596076, 0.20024886816436216, 0.17880729722174327, 0.18501095507142717, 0.18109993081572795, 0.1776441166346674, 0.17925899663395306, 0.19464779173771873, 0.1838167765218165, 0.16913422096012076, 0.19956803776155596, 0.19728578926092677, 0.5481761794633098, 0.16284663969833657, 0.16455580093411737, 0.5573852345541481, 0.1716698578139374, 0.17673583529294756, 0.3042170025042358, 0.1891361909180832, 0.41444028913239117, 0.16718415152976063, 0.15594686953318582, 0.25947053786288865, 0.2591272295360023, 0.1820846702245409, 0.26049748289108576, 0.19350344993123558, 0.14428060254913944, 0.18871728411869004, 0.1849160844847011, 0.18411088920982488, 0.18177204378315526, 0.18335488544698741, 0.17946635751971685, 0.18629537678127994, 0.18675398672980803, 0.1913857526373386, 0.19599164703655603, 0.06950753594207182, 0.07647829290664099, 0.0757461947017034, 0.06404543270054164, 0.06520237932147988, 0.08540031528147007, 0.058585564585520444, 0.06383406324806606, 0.06638222108316238]}, "mutation_prompt": null}
{"id": "e269feae-d6a1-4f10-9d9c-8cfd70f8b9d0", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE_v1:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n        self.inertia_weight = 0.9 - 0.5 * (evals / self.budget)  # Adaptive inertia weight\n        self.cognitive_coeff = 2.0 - 0.5 * (evals / self.budget) # Adaptive learning rate for personal best\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def local_search(self, position):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        candidate_position = np.clip(position + perturbation, self.lower_bound, self.upper_bound)\n        return candidate_position\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + \\\n                                     self.cognitive_coeff * r1 * (self.best_personal_positions[i] - self.particles[i]) + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n            # Local search enhancement\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                local_candidate = self.local_search(self.particles[i])\n                score = func(local_candidate)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = local_candidate\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = local_candidate\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = local_candidate\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedHybridPSODE_v1", "description": "Enhanced hybrid PSO-DE algorithm with adaptive inertia, learning rates, and local search integration for improved convergence speed.", "configspace": "", "generation": 51, "fitness": 0.20084250400168516, "feedback": "The algorithm EnhancedHybridPSODE_v1 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.4548602650673502, 0.4195998854062385, 0.418716996773702, 0.4833364549706204, 0.41701082579309723, 0.42194082651498843, 0.4208232144665801, 0.45429263600120084, 0.37018495733111145, 0.10906961921542169, 0.04940956975708599, 0.06433063610855683, 0.10267644210812465, 0.08655982640987203, 0.12586329138289654, 0.06253145327265897, 0.16325299649627245, 0.08860013487482354, 0.10356532559010523, 0.11247849022290901, 0.09694198751073091, 0.10162480843692956, 0.0970642189083264, 0.10652391749014845, 0.08895819197419974, 0.08452319779461015, 0.09939895553234623, 0.07309998538817197, 0.11083732962487247, 0.07920330391956265, 0.09543530329464978, 0.07386709593492147, 0.08215764957889027, 0.07557881053179549, 0.10343281022677198, 0.0786627525911272, 0.9762760433938559, 0.9774215135736996, 0.9661779977612249, 0.9686166993040715, 0.9782341097030519, 0.9666438767946136, 0.9767192965351787, 0.9684512147870064, 0.9741761787776043, 0.24033705254263826, 0.19635460682246397, 0.25816451511829575, 0.22770971196301204, 0.2652617246871718, 0.21427855533043916, 0.21123796679055062, 0.22860101199022442, 0.2327779905936227, 0.34978569818171756, 0.3197841991250815, 0.203811421066731, 0.26539453045795836, 0.18461470795034518, 0.1996407534152428, 0.19092493031407465, 0.18814453223098404, 0.13630409250593223, 0.10954165020408002, 0.1206166613959122, 0.09785124687658331, 0.10346030906859083, 0.10259989482080378, 0.10447035338533062, 0.12230564936309052, 0.13126933614517255, 0.13596874036432438, 0.12158813114371603, 0.13419902188497812, 0.09773959054557713, 0.12982206632196935, 0.0902478935892308, 0.12963001881078018, 0.1381966590001772, 0.13521194957284588, 0.14509310935086328, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026502893702178176, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016359827406539074, 9.999999999998899e-05, 0.09128561858846862, 0.053780934505070044, 0.05237603206938457, 0.0874897269631314, 0.011440757370207222, 0.039300885713671074, 0.054097674835789755, 0.017490285185208787, 0.045778179908482874, 0.011523607892910515, 0.010721975860970123, 0.01678489641408709, 0.006722649804727143, 0.02118826371487814, 0.032352734130114746, 0.01545281233312834, 0.009743134479970661, 0.02444515110563683, 0.02783789473087106, 0.048975963231018604, 0.05961257948754939, 0.07749978673098012, 0.06228542242302082, 0.07236879601324675, 0.04796428857652446, 0.05730612546140168, 0.05136881557256434, 0.37583803830824103, 0.32465609184721944, 0.3665636526187318, 0.3554956347968855, 0.34760642063698144, 0.3916563230507689, 0.3615109617400498, 0.350493596163279, 0.3761773231821993, 0.08186684333077188, 0.08784672456392928, 0.08465115914959354, 0.08704542180414299, 0.11011352862704715, 0.1084369333063867, 0.08099672339576358, 0.06277691592074786, 0.08596518973490141, 0.1524025119504755, 0.14691066813912967, 0.28419652695427977, 0.20329604312381155, 0.15063965891944686, 0.13671877702889834, 0.21007273638136625, 0.1982402399745059, 0.20807832941700566, 0.24840343045380087, 0.24976066977394673, 0.25869932159746134, 0.26703678380076135, 0.25408835180909195, 0.25663855856278206, 0.28895228760488567, 0.2412247512486786, 0.2797230387961763, 0.1555857114227972, 0.20663131588392902, 0.18729362613021505, 0.1898570453388736, 0.20611630159458116, 0.1766666372651372, 0.18308773418303037, 0.18082238806629214, 0.20515295560399405, 0.1957536665295273, 0.21918675287450007, 0.17951326875962736, 0.22594235257066853, 0.1727995476789771, 0.2088195336148383, 0.18883941138011895, 0.18299938973797125, 0.19457232173263472, 0.24982265953368799, 0.18380062864883373, 0.17956647825726446, 0.17429501778104295, 0.18030195866570398, 0.20337267824172955, 0.18338047992969875, 0.22789282653640253, 0.1914914422594972, 0.1570675194678517, 0.12861682564963062, 0.55007235951842, 0.5033622884950036, 0.17932863452605852, 0.5627002471604283, 0.11266497848887269, 0.16911110663321105, 0.19790557515488416, 0.34419047515421275, 0.3317722571022692, 0.30285945705120665, 0.18989245891727313, 0.18076266056432855, 0.41641222788690857, 0.23210465009818448, 0.2064678765855148, 0.4322821128272244, 0.19418403357777292, 0.1855227880425796, 0.19280068333107314, 0.20148924179921457, 0.18128735611415925, 0.17885534795705493, 0.1854432968317009, 0.19044735637432186, 0.17664971452150835, 0.06621669535584951, 0.07732568829522857, 0.0689957992377016, 0.06931497646322782, 0.07611788812544584, 0.06140383880745215, 0.08049795388235292, 0.07446770656167978, 0.0869372402601355]}, "mutation_prompt": null}
{"id": "66c752b3-be63-440b-8350-05d5cf643502", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n\n    def dynamic_parameters(self, evals):\n        # Introduce adaptive inertia weight reduction\n        self.inertia_weight = 0.9 - 0.5 * (evals / self.budget)\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate particles and select elite\n            elite_index = np.argmin(self.best_personal_scores)\n            elite_particle = self.particles[elite_index]\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with elite-driven strategy\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b = self.particles[np.random.choice(idxs, 2, replace=False)]\n                mutant = np.clip(elite_particle + self.scale_factor * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "A dynamically adaptive hybrid PSO-DE with enhanced particle update using adaptive inertia weight, and elite selection for better convergence.", "configspace": "", "generation": 52, "fitness": 0.2139709154066041, "feedback": "The algorithm AdaptiveHybridPSODE_v3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.5553254765128632, 0.5507606552819722, 0.5414128340080868, 0.6140242492196086, 0.5486654990607676, 0.5777944102396027, 0.5849711947118021, 0.579326635726097, 0.5848395098638852, 9.999999999998899e-05, 9.999999999998899e-05, 0.20501130765708875, 9.999999999998899e-05, 9.999999999998899e-05, 0.036981320930532635, 9.999999999998899e-05, 0.002671701848971142, 0.027696176060942324, 0.0638388679579599, 0.09973569968393858, 0.1029094134273375, 0.10890919781134367, 0.08928349029480431, 0.09816865907363626, 0.1118978055041081, 0.11071557146997202, 0.12450178411868873, 0.12806502071331893, 0.07159233616516669, 0.08906347493445632, 0.09813179466946331, 0.0860880567173935, 0.08927899534761896, 0.08144066579969389, 0.09078592795712215, 0.10565491152002937, 0.9787723619413302, 0.9807860711940674, 0.9827868040686949, 0.9775638597421958, 0.9723916798988543, 0.9754483494924178, 0.9788407967098783, 0.9831269663160506, 0.9766118093876335, 0.34924123205721347, 0.05843588106319764, 0.057159400224328416, 0.36533900403401653, 0.1386992868845649, 0.33632137581243415, 0.0830781421420661, 0.08740027773161074, 0.08023082053367181, 0.19686437750515273, 0.2799182843853557, 0.20579260824108736, 0.19488945132111035, 0.15466352739668832, 0.5160404966444656, 0.21299062921330325, 0.1402586683588103, 0.19511679676617288, 0.17116112583451426, 0.1542397028077347, 0.14713260408156947, 0.09775409950207525, 0.15578892924410104, 0.08942133497303872, 0.14593404247276376, 0.13811463663040535, 0.14004914589442652, 0.04810722704431192, 0.05164148835911542, 0.11970062670839343, 0.12018629270301828, 0.14544580669222473, 0.1554602850907273, 0.136848229687914, 0.16109165058018393, 0.15546684216565265, 9.999999999998899e-05, 9.999999999998899e-05, 0.038113358229882044, 0.00040213634813413, 0.00010031516479247493, 9.999999999998899e-05, 0.004152086523200316, 9.999999999998899e-05, 9.999999999998899e-05, 0.08115503179488548, 0.019407003691705005, 0.02017603218254449, 0.06395872241073741, 0.004559183089221763, 0.02070439470223484, 0.04712298387295599, 0.04288329001789348, 0.04009174411044114, 0.06340895908785238, 0.10680968479189179, 0.07763974721740019, 0.08450719427047881, 0.03794253564897265, 0.05252578699706245, 0.1275253646058151, 0.04610304234348406, 0.03719580719058069, 0.02783023674886209, 0.030399136729464038, 0.007804364948297171, 0.09689123086995655, 9.999999999998899e-05, 0.1165030601129654, 0.05664051814057325, 9.999999999998899e-05, 0.0565407750193595, 0.418264637232575, 0.447766552303818, 0.40615248285656136, 0.3995086420492824, 0.45723379407616116, 0.40469593766511824, 0.4020920714722893, 0.4722458714792567, 0.45324416735248485, 0.111969557683819, 0.11839357017920937, 0.05611333053641809, 0.0874099874959271, 0.0759180706054956, 0.07571532455445429, 0.0790556570058607, 0.09491999230894488, 0.07089039944364872, 0.13075497050877072, 0.1804628224140552, 0.19770473772479946, 0.254402259299231, 0.19879102696597106, 0.13982057262712155, 0.16761542356622594, 0.2381930531118993, 0.23946837775001606, 0.22316596851612647, 0.2823772027048631, 0.3335393058107057, 0.3041558277980563, 0.2829270123819234, 0.32353784252193896, 0.3514270522586488, 0.24453274099195765, 0.31267113657696444, 0.18836296040827616, 0.15532185415829358, 0.21833725684595728, 0.19156280011457516, 0.12329885250960726, 0.23908135410060827, 0.23933209243818576, 0.22598409804956343, 0.2251504144935793, 0.19637485295815416, 0.1999385316297797, 0.2078567228123488, 0.18608820099640677, 0.16818412885738032, 0.19826608481765928, 0.21271085798212508, 0.1787608600395153, 0.23629728591993238, 0.2014437665624793, 0.19466938608740525, 0.21522407228759988, 0.1845649866060014, 0.18196863286680942, 0.18069440330117648, 0.20506113580516516, 0.3724713008384004, 0.1996134397089091, 0.6699874490774265, 0.19909302765221504, 0.19366519983324615, 0.5652781645102515, 0.19487223096171435, 0.19188878401793796, 0.09980247040015833, 0.16708280627125183, 0.6706136164935044, 0.48628085353140704, 0.15193514307249334, 0.16583163756482844, 0.20441101852218613, 0.5539102238995122, 0.20133109933205573, 0.1855972107673577, 0.1855459712471531, 0.6557396860846549, 0.19012993433469572, 0.19040313709391954, 0.19518906238436973, 0.18208667927556965, 0.2046098985514867, 0.20309894004647822, 0.20134027219972095, 0.19391428544138467, 0.23172192842832395, 0.073396913374141, 0.08960642140882169, 0.0960107537817958, 0.08282891308086915, 0.06679243359909959, 0.11037715808462256, 0.08835664784089425, 0.06829098350281404, 0.0807896584431621]}, "mutation_prompt": null}
{"id": "0dda36f4-7e2e-44d4-843c-7abfa46757af", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "d888185e-aa46-4b55-8237-c3b8a53ba1cb", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1\n\n    def dynamic_parameters(self, evals):\n        evaluation_ratio = evals / self.budget\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evaluation_ratio))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evaluation_ratio))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def regional_search(self):\n        region_size = 0.5 * (self.upper_bound - self.lower_bound)\n        regional_center = np.mean(self.particles, axis=0)\n        return np.random.uniform(regional_center - region_size, regional_center + region_size, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions with adaptive inertia\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.9 - 0.5 * (evaluations / self.budget)\n                cognitive = 2.0 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 2.0 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with regional search\n            if current_diversity < self.diversity_threshold and evaluations < self.budget - self.population_size:\n                self.particles = self.regional_search()\n                evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "An adaptive hybrid PSO-DE with adaptive inertia, dynamic mutation, and diversity-triggered regional search to enhance convergence speed.", "configspace": "", "generation": 54, "fitness": 0.17008851481564238, "feedback": "The algorithm AdaptiveHybridPSODE_v3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.33545746568936463, 0.3504184845115914, 0.3238800272794813, 0.4348742679879699, 0.4429084589370009, 0.3684565778712787, 0.3188832444708003, 0.33634060237332597, 0.3368004352701085, 0.025728507684269375, 0.01720529552222838, 0.014059255802339465, 0.08151362159018705, 9.999999999998899e-05, 0.05935375044907509, 0.018416473790515586, 0.024211822331977273, 0.06939163570556062, 0.08133935543747517, 0.08387054188497, 0.08060291936795638, 0.09249365036796553, 0.06363275381175337, 0.05847939509532263, 0.08761972370693816, 0.08790248182128868, 0.09745412259663067, 0.07746724220081302, 0.05900397890956033, 0.04993988535663907, 0.07948841439207877, 0.07220174759931164, 0.06408889702097853, 0.06438849257496482, 0.06843153235470456, 0.08251761189521645, 0.9818528682065484, 0.9776707310303727, 0.9836926136152988, 0.9849321229183821, 0.9848638050228238, 0.9776089794763804, 0.9851771865073354, 0.9853780515052749, 0.9781896788179383, 0.18607406959037698, 0.05627748578897318, 0.05667515953057589, 0.1935133741263957, 0.11854304153992057, 0.16910518229627847, 0.19918088486022467, 0.17719638860934772, 0.11762307961728435, 0.2799659757689884, 0.15345160529932456, 0.2418230130457647, 0.2283861224131123, 0.17956246938068054, 0.18711653582389132, 0.20574754059002331, 0.13632335090049086, 0.19184299083273504, 0.09184834775186157, 0.08222364579120045, 0.10004747427661675, 0.05722534178440497, 0.07534852202816489, 0.052166400711372574, 0.14533144378769414, 0.07985992682972154, 0.09240043116172514, 0.08898287223195422, 0.039850345369346174, 0.08259637100020423, 0.06976840716479438, 0.08448750686643525, 0.11183105413063599, 0.11445515128991701, 0.10584327952126238, 0.09568553960175707, 0.007640767548083516, 9.999999999998899e-05, 0.007716192619252937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006509367714435665, 9.999999999998899e-05, 0.016244437670270395, 0.014485474874463167, 0.04878762343507492, 0.10018414256652575, 0.023408798119431418, 0.06748963649473771, 0.040565153341910465, 0.011018072389465172, 0.08678106986115186, 0.0023551837461224245, 0.017577577814185674, 0.011807082397912949, 0.009509485800007877, 0.011340307458825749, 0.01705462779786071, 0.01210843753369939, 0.013556768888435156, 0.0168956167061195, 0.04797818855146907, 0.009245556401883959, 0.0041645058943750035, 0.06962267088337992, 0.08485212237566409, 0.06906712445625163, 0.0742900561084272, 0.03882197152278499, 0.048036172830982604, 0.3547979050510882, 0.3370515530301914, 0.3574416051303668, 0.3570332886897176, 0.31572258922839036, 0.3294620172291932, 0.3096444281733278, 0.3045834613323216, 0.32277907175646536, 0.09120481663620028, 0.0793126850164052, 0.10849871356722196, 0.08953473009563206, 0.06840632570345528, 0.09464606147716637, 0.0654199590194281, 0.0792193880820099, 0.08278305011396592, 0.14948555598811453, 0.15264544342986375, 0.16705964552095087, 0.13276336214495166, 0.19503967471938477, 0.1558447938247256, 0.16290033257417513, 0.17089006093375114, 0.14943156301511828, 0.2156921936745958, 0.2040909733122327, 0.21162540186563472, 0.2062719174044042, 0.24616338223567524, 0.22517734139766166, 0.21171988496796434, 0.270707583135809, 0.24011514609601847, 0.15976040710686235, 0.11763530613078965, 0.18802779575700834, 0.15185971242836327, 0.15403315902335524, 0.17176971613239433, 0.1749004143909345, 0.17325002255075872, 0.13248496042533842, 0.17276375856820947, 0.15727369773000133, 0.1700047449763491, 0.17443579462272374, 0.18155526343882156, 0.18919020432465739, 0.15340293419761586, 0.18029994933341098, 0.17356789230949854, 0.17245798000735724, 0.19284828573768675, 0.18939585122234803, 0.15088705820696047, 0.17165376310487535, 0.17829117216314194, 0.16301186546734936, 0.2065038368273201, 0.1668802967996973, 0.15146684481500217, 0.16122241774363943, 0.17421897677832132, 0.16922454311569657, 0.17737339249254347, 0.16069120600980535, 0.11912551176757313, 0.16908178110284477, 0.1683025081861238, 0.29113189430773767, 0.22862650859863298, 0.21881545891930199, 0.17488529959828725, 0.10802065563416396, 0.16783637130502538, 0.1947044880465698, 0.18270034582901784, 0.19862643739983543, 0.22342380924950211, 0.18042976809161715, 0.2274948836075581, 0.1940275795466606, 0.17151149273173838, 0.1912045267516893, 0.2014698535182149, 0.17624636310709052, 0.1851303217604351, 0.05881204793169814, 0.07525393410198189, 0.06769646259179785, 0.06409559091620287, 0.07107843879851372, 0.06531218864698873, 0.06975333607981338, 0.06794874045640831, 0.06835866714765904]}, "mutation_prompt": null}
{"id": "1c0ad16e-1a11-4a59-88f5-dc749e009e4a", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "85472aa5-b4b8-4c7d-9006-5dd83ecfe704", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "2ca899d1-0d0c-404a-957e-d53f5dfc796e", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "8fe63074-583e-421a-a556-ecfa89900e2c", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.min_population_size = 10\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = 0.5 + 0.3 * np.sin(2 * np.pi * evals / self.budget)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(2 * np.pi * evals / self.budget)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def update_population_size(self, evals):\n        self.population_size = max(self.min_population_size, int(40 * (1 - evals / self.budget)))\n        self.particles = self.particles[:self.population_size]\n        self.velocities = self.velocities[:self.population_size]\n        self.best_personal_positions = self.best_personal_positions[:self.population_size]\n        self.best_personal_scores = self.best_personal_scores[:self.population_size]\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n            self.update_population_size(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.5 + 0.4 * (1 - evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "A self-adaptive hybrid PSO-DE algorithm with time-varying population size and dynamic velocity control for improved convergence speed.", "configspace": "", "generation": 58, "fitness": 0.228121186572155, "feedback": "The algorithm AdaptiveHybridPSODE_v3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.5641428707117824, 0.5188480608925967, 0.5469256628983625, 0.5701841388417066, 0.503403128301293, 0.5228702889359809, 0.5226753865515991, 0.6075789886260636, 0.528597547622869, 0.10296312330088708, 0.3058678140306923, 0.2895029877380598, 0.29807574308927265, 0.0, 0.34026459833613487, 0.2890187550719231, 0.0, 0.29147027116305346, 0.10243738378264311, 0.10728679006626551, 0.253586939004663, 0.10835313740891439, 0.10788429688485435, 0.10797592612144491, 0.12480697588938439, 0.11681104291322075, 0.12437413277155573, 0.1016262181579154, 0.18290820293386523, 0.306147489293795, 0.09934790021999196, 0.1051121222925574, 0.10959521260043259, 0.0946979629862168, 0.11223384705424155, 0.08027203804326599, 0.9707946310840698, 0.978601421218066, 0.9766970192539054, 0.9756390436405863, 0.979392057242787, 0.9774654676442386, 0.9853201564247919, 0.9837080336035177, 0.9854461226425255, 0.3027261552914673, 0.33786040864016453, 0.31808755424471213, 0.3278899597185465, 0.3192730182234542, 0.28826910242149795, 0.3485821482246334, 0.3785623927939734, 0.31436849943078826, 0.27823579770334284, 0.26216684173345817, 0.19555374184471774, 0.23809271460073, 0.2985715292890856, 0.18684929642944936, 0.2571139716896894, 0.28046658821255865, 0.5987528801439934, 0.14546473556609252, 0.1391344088912927, 0.13966469691369343, 0.14168315696876033, 0.12024371991836125, 0.13303303048355297, 0.12196954135555294, 0.14410878677279948, 0.1256903413137812, 0.08773138164318206, 0.07269693069633865, 0.13902569822106947, 0.17017613638231976, 0.1227269154695334, 0.09849477794340933, 0.1384290316166762, 0.1406350998231456, 0.11408985174844077, 0.0, 0.009947627836160655, 0.0, 0.010610041797366798, 0.020022768253322276, 0.0, 0.0, 0.0, 0.0, 0.08291645940558279, 0.08371672995430968, 0.05731925660975179, 0.08492732158579763, 0.012219817181185477, 0.009890628710002014, 0.06173704233220356, 0.09365412913276883, 0.041345998333566, 0.025677635539563037, 0.01114525004144784, 0.06430101609454375, 0.08067424173907767, 0.09749287202332557, 0.043159493907668156, 0.045391222470446024, 0.03653468734844678, 0.045294329128792055, 0.04950769871913252, 0.0291079111395236, 0.06607472566613704, 0.1482915910416701, 0.13160745491925485, 0.15988813892935505, 0.0692778884317855, 0.07984898909303939, 0.066507770640723, 0.37486301130416955, 0.3892107313179114, 0.36985695461789514, 0.3954725660970867, 0.4068517949648097, 0.45110988476575176, 0.3967430544420687, 0.37140131656216924, 0.37746613635781456, 0.09816668107597348, 0.12624749545959346, 0.07771705474805934, 0.08840992598000119, 0.0950510068830559, 0.09745419689278101, 0.08797980208377498, 0.13059124314913428, 0.10116021385346319, 0.20994679805284655, 0.180468047193719, 0.17808518869959244, 0.17726289240973714, 0.21941800551057156, 0.14514862791035799, 0.13778075974714976, 0.20345775391977083, 0.16710469127845717, 0.2559129489445835, 0.23274543368228273, 0.26909988583773436, 0.3738776094752134, 0.2148036792424628, 0.17750668228025568, 0.31710829642703686, 0.3167696488684094, 0.34006445689798226, 0.21702741458905817, 0.22480195818815285, 0.24863155932256797, 0.17109837237003211, 0.16441702948691872, 0.22901896028272173, 0.20415542964164268, 0.2541338271832978, 0.2101030438323922, 0.21363266144185133, 0.17291397005042453, 0.1804016832909061, 0.20796165969994718, 0.19727250995683332, 0.1721373840482996, 0.18779357358007287, 0.1909433564571067, 0.2103683567086786, 0.20516060056251162, 0.1749928193730852, 0.18041567776967482, 0.1817234647103848, 0.17786610573223838, 0.19768255525967138, 0.39042678357754135, 0.20579238671964006, 0.19379922652893355, 0.14424940570974576, 0.16306997160326298, 0.15825752208355748, 0.1815792233739344, 0.17355584773228527, 0.3505411761088508, 0.11855979321545507, 0.18585627265983162, 0.6185263604912463, 0.38304552970532935, 0.15203304962762554, 0.5157976461584749, 0.3076070192287551, 0.27760471082873606, 0.4593941759962258, 0.151626280852745, 0.20625178074006612, 0.5173541269251888, 0.21924722387610895, 0.18384034712697606, 0.1887791542649787, 0.2086610457152881, 0.19129313319340113, 0.1810329513795943, 0.2020027339099677, 0.19942420002419092, 0.18628103033056242, 0.08467123145964128, 0.07860057482119298, 0.08735764941581403, 0.08065357678821916, 0.08173188803131692, 0.09035015441001082, 0.08209290697937066, 0.06817749847530608, 0.0726597413817528]}, "mutation_prompt": null}
{"id": "6d3d92b2-87c8-47f0-9b2f-e1be90fc92ef", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "c61a7f6f-9a7f-41a3-acd9-e742f41074a1", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n        self.inertia_weight = 0.9 - 0.5 * (evals / self.budget)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def local_search(self, particle):\n        local_step = 0.1\n        neighbors = [particle + local_step * np.eye(self.dim)[i] for i in range(self.dim)]\n        neighbors = [np.clip(n, self.lower_bound, self.upper_bound) for n in neighbors]\n        best_local = particle\n        best_local_score = np.inf\n        for neighbor in neighbors:\n            score = func(neighbor)\n            if score < best_local_score:\n                best_local_score = score\n                best_local = neighbor\n        return best_local, best_local_score\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = self.inertia_weight\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n                if evaluations < self.budget:\n                    local_best, local_score = self.local_search(self.particles[i])\n                    if local_score < self.best_personal_scores[i]:\n                        self.particles[i] = local_best\n                        self.best_personal_scores[i] = local_score\n                        if local_score < self.best_global_score:\n                            self.best_global_score = local_score\n                            self.best_global_position = local_best\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE with adaptive inertia weights, exploration-exploitation balance management, and local search integration for improved convergence speed.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {}, "mutation_prompt": null}
{"id": "1a2dae65-3367-428c-a746-f08f4b903800", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "2f4e01a5-2548-4598-8d86-436b51b8effb", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "1ddcb8cc-6113-4bb7-8924-0822793638bc", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "a60b32b5-e5a1-4b8c-b9f6-b0c156f06234", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "929578cd-eee6-4560-9e97-b36ddb742fa8", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "bcf3a750-7291-4424-ae06-89bf7d7b0f83", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "32e2703c-0427-4ce9-b932-49dba2a190e9", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "ca4a3a57-0214-405a-9136-7c6248a463a9", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "b4836d2a-dac4-4ffb-b908-30854278e8f8", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # New parameter for diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        # Computes diversity as the average pairwise distance between particles\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            # PSO Part: Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            # Evaluate particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            # DE Part: Mutation and Crossover with edge-based mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Introduce edge-based mutation if diversity is low\n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v2", "description": "A dynamically adaptive hybrid PSO-DE with population diversity management and edge-based mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7551285612478735, 0.6642892881944674, 0.6742327896333586, 0.7600148003384344, 0.663509542281873, 0.6932107498659978, 0.6836555500914244, 0.7028798081959666, 0.6643065049203474, 0.43461199536454187, 0.20993311810097948, 0.5006942024072856, 0.42122608417204344, 0.4217738607147371, 0.42853918093004517, 0.4171161099145084, 0.30703159252761125, 0.38976632493559227, 0.12805879175005408, 0.18296041235612592, 0.1512224349618596, 0.13433483588385065, 0.14850547703400863, 0.14652937326267368, 0.20341414840258187, 0.1375338611192879, 0.12822769630365505, 0.1122973188186781, 0.12803552221813175, 0.12069365858955428, 0.13223507647153876, 0.09879466667215497, 0.13285994436995407, 0.11797420160604088, 0.1316619087012989, 0.17762876400286953, 0.980032843708995, 0.9702474945831367, 0.9716275977325419, 0.9790981771951259, 0.9847661721566532, 0.9766264866123355, 0.9779628334267925, 0.9792245962175988, 0.9776472342930875, 0.3937081901535734, 0.48421442622414645, 0.3569956949676658, 0.42580600818824876, 0.4533552224652483, 0.4839647884674617, 0.4175719167427572, 0.43342688379442695, 0.37846975873577926, 0.21772101087539308, 0.6956060733191636, 0.5298185422589949, 0.26648900749525106, 0.6663163147116964, 0.21545918368206773, 0.21781647063508525, 0.6339480348059836, 0.20301175134745908, 0.1491668947643271, 0.192173547046239, 0.20162136860016022, 0.19587878054314056, 0.11309747790349889, 0.20393307616684664, 0.1995454695701102, 0.16314246730845716, 0.17261209456551518, 0.18078827982170187, 0.17228492282150254, 0.12534320845620772, 0.12149239621123231, 0.11389446625699096, 0.12341919392271516, 0.22056602144055137, 0.16448853697793564, 0.2048481407499324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015564030940549811, 0.038874449303481384, 0.02853405911807183, 0.0002034221941418224, 0.003521791092488402, 0.04517349816403071, 0.03946723802157959, 0.07434912475860089, 0.08105979804816565, 0.07959082614439283, 0.028268987672433243, 0.1129081873193114, 0.05368203100471658, 0.021064045652588015, 0.052332860374604606, 0.02365892099763678, 0.12566851395530232, 0.07860724695347077, 0.13245507128256906, 0.05622226791206153, 0.042421067671959856, 0.1909212449019918, 0.06337813326116737, 0.10025014698011359, 0.17314012938454182, 0.05762021564169029, 0.2312796779709172, 0.09622646604763174, 0.08344881569309692, 0.1407805801961758, 0.08003506086941614, 0.07577579314087601, 0.07548746612571067, 0.5424441650704795, 0.44976656476200394, 0.5481623536877627, 0.39858417515707845, 0.4741492212214322, 0.47581360193500555, 0.4798154046074605, 0.45905845294517156, 0.47611397072519823, 0.11457904070058156, 0.10159070032163187, 0.07654403419317446, 0.09443115186549023, 0.09762776870270995, 0.33279850846273074, 0.12149875293762213, 0.13859958310223774, 0.10476962735539541, 0.26467584125778265, 0.16593595946135997, 0.1756070996248209, 0.2953237286468531, 0.26241637469722123, 0.1989205369996243, 0.14873320834554393, 0.21427874018870485, 0.3597735699876534, 0.3658055075832545, 0.3980180064502461, 0.32957758925637104, 0.20813121665092915, 0.22062430303014446, 0.40796506883230255, 0.3683252553907349, 0.36475013770681397, 0.3537404932299901, 0.15243069691626754, 0.2606101593593343, 0.2478038768720866, 0.28027021229385707, 0.18115701559324682, 0.26258631220800976, 0.230223196217756, 0.2763247025136869, 0.22531385295267536, 0.21898668985316383, 0.18588833346472167, 0.1818751140955004, 0.17512055180135744, 0.19626341736064845, 0.24352645697974362, 0.202014234243456, 0.21330805034111233, 0.23432379745142373, 0.37694228346844805, 0.19134300340086752, 0.20065960917860481, 0.19163299587463423, 0.22214429957185244, 0.2282799996586572, 0.47566263594524094, 0.21306524779811442, 0.2111155363572289, 0.16219787196129531, 0.12803638063635558, 0.17820620633561524, 0.8466790107310406, 0.19815804314296603, 0.16459626005505157, 0.15916410661473235, 0.16897182973296987, 0.16658379572508097, 0.6858774071322742, 0.1556411959947065, 0.5902337658079622, 0.6223588804751842, 0.14850916618491372, 0.15482744254438074, 0.10448765233895552, 0.5585665077756226, 0.6418839534448257, 0.20509073597662997, 0.20829600670392034, 0.2145543206033762, 0.1868712058787786, 0.18421916473247024, 0.1841732804390781, 0.19657006783161768, 0.18097939034014965, 0.19172200820852825, 0.1306702268767429, 0.08127438557507372, 0.1321755677209807, 0.0989690262321945, 0.07880290884652619, 0.11309623634093546, 0.08400411460154078, 0.08416751829171354, 0.0884527490166076]}, "mutation_prompt": null}
{"id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.9  # Adjusted for improved convergence\n        self.initial_crossover_rate = 0.85  # Adjusted crossover rate\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.15  # Tweaked threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.4 + 0.6 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.4 + 0.6 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.6 - 0.4 * (evaluations / self.budget)  # More aggressive inertia adaptation\n                cognitive = 1.4 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.4 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "An adaptive swarm intelligence algorithm utilizing improved dynamic parameter tuning with enhanced diversity preservation strategies for faster convergence.", "configspace": "", "generation": 70, "fitness": 0.2943535440632153, "feedback": "The algorithm AdaptiveHybridPSODE_v3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "bcf5917b-8b79-4d29-9781-078edca3aa0f", "metadata": {"aucs": [0.7671889576591918, 0.7099035062699042, 0.7307289937591189, 0.7667243173694104, 0.766775476226334, 0.752087365653294, 0.7669890411835496, 0.7432540462825117, 0.7399030939056355, 0.5080265638137363, 0.5351141824831049, 0.566108980545948, 0.5473234418641677, 0.49948046589767037, 0.5204047166959946, 0.593717065461858, 0.546473147538048, 0.5105610722991389, 0.22810695474980602, 0.3424098564777849, 0.13697132441285942, 0.1568389633107008, 0.1420304917699321, 0.16092856575382086, 0.13987449130301388, 0.28387486152469543, 0.15784237333582818, 0.1280211319886876, 0.14453714969444753, 0.11964116213791787, 0.11021234650939349, 0.1209948445511122, 0.14053203045595786, 0.1345033458045859, 0.19495928108114768, 0.191832248276131, 0.9732842391677099, 0.9726635803099712, 0.9725625870939715, 0.9711844928668053, 0.9733397396302214, 0.9722963621159846, 0.9663622680642325, 0.9699549466467396, 0.960601565238871, 0.578962859021797, 0.5068216341920627, 0.5240946902684889, 0.559375428106646, 0.5550075387600183, 0.5577472710416729, 0.49830302678282423, 0.5057306856711228, 0.5287508365788788, 0.22402825392123837, 0.778795554213721, 0.35395163862712975, 0.21288253623910192, 0.2643224070828787, 0.2086780769062646, 0.7769677778309678, 0.17635818504183698, 0.23002287772194263, 0.19307807495325924, 0.21858661400011414, 0.18572333182021694, 0.12608153447139814, 0.21468954072355595, 0.18443612940180643, 0.2594344345687507, 0.169382491289646, 0.16893326505941408, 0.2075879651582303, 0.2052986442124104, 0.18407409944691722, 0.20564793087808053, 0.14070394639654316, 0.1268520762105496, 0.20368208889830197, 0.21656863789047598, 0.22153653937492668, 9.999999999998899e-05, 9.999999999998899e-05, 0.04220812238251925, 0.04348036522102117, 0.021957928893093448, 0.006210020707288266, 9.999999999998899e-05, 0.05269403112015969, 0.006246001181047678, 0.07160808402781882, 0.08367909112344474, 0.09678721252234768, 0.06439252259632666, 0.026608324556568697, 0.03523401488081568, 0.08845816181393384, 0.08201221849344564, 0.06652552384871702, 0.10379887427069101, 0.03506955795189137, 0.09583743712334802, 0.06238536371200676, 0.06831022220272698, 0.1509058074141849, 0.12824574563087643, 0.08091656353617416, 0.07209102266123135, 0.15323226950213775, 0.037451277707310715, 0.13517733978943014, 0.11440969635665788, 0.06155165633647863, 0.16048364094935064, 0.15308450719885802, 0.04578440162634945, 0.08103266801413811, 0.5041949637635877, 0.4930486083270553, 0.47432274711804245, 0.5012241867233365, 0.5704194486357363, 0.5240651615184484, 0.4978309936419423, 0.5269269774663529, 0.5422853513140239, 0.12186345653454411, 0.10902137043649796, 0.10091538050236215, 0.1020781889489879, 0.13954827854216234, 0.13789721480315054, 0.14552413874742165, 0.13710511256162006, 0.08916071281406912, 0.37494592774662594, 0.3146158379895414, 0.3871773872423252, 0.2804615035495871, 0.38997620624047324, 0.21104722223577843, 0.24942653313003116, 0.18293605961909465, 0.20302282054132736, 0.336869267414285, 0.40642389731968864, 0.3824013612381738, 0.44073986420321276, 0.4013381955901183, 0.38927166578058636, 0.366863137205221, 0.461824620389817, 0.2761261120300472, 0.19290496412534008, 0.28805534057022764, 0.2338467042724547, 0.2397769308197416, 0.28626856270602796, 0.3002048796658904, 0.25599688648638574, 0.33365772471288924, 0.32019266825411064, 0.2320907409093762, 0.206657696453298, 0.20575930111533325, 0.23009167087780302, 0.24345244210670625, 0.20885067992167528, 0.21609570358677777, 0.3169775832378725, 0.22112037151771213, 0.5563630979379153, 0.19100237188368596, 0.226307082598048, 0.20064353662590395, 0.2326521344216651, 0.21466816325557492, 0.20102254887489068, 0.19823845967608278, 0.21869674651128956, 0.27996907013322814, 0.18341777571921702, 0.16288932031317127, 0.2772081077197922, 0.1992485903341492, 0.18730888242417987, 0.12635296922212313, 0.16086096874085964, 0.7947362386747938, 0.7103889293285129, 0.15583300828546343, 0.1252400905163913, 0.5880560374016026, 0.20805406688249672, 0.1510963849422695, 0.16163535915244398, 0.27128753208664724, 0.16156723769342785, 0.18573526273527674, 0.20712297518144462, 0.19818800193057606, 0.23042557024416332, 0.19750536081399572, 0.18560630051046145, 0.18781742390304645, 0.1952050964608738, 0.21118830219673435, 0.12903749123846175, 0.08895078463094941, 0.1385882276234095, 0.082690971468389, 0.13699094249729893, 0.07731298206951509, 0.12787500398292773, 0.09770651220927917, 0.11437889610044727]}, "mutation_prompt": null}
{"id": "28497bca-9436-4b4c-b8f2-60a5ab8dc0ce", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.9  # Adjusted for improved convergence\n        self.initial_crossover_rate = 0.85  # Adjusted crossover rate\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.15  # Tweaked threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.4 + 0.6 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.4 + 0.6 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.6 - 0.4 * (evaluations / self.budget)  # More aggressive inertia adaptation\n                cognitive = 1.4 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.4 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "An adaptive swarm intelligence algorithm utilizing improved dynamic parameter tuning with enhanced diversity preservation strategies for faster convergence.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.7671889576591918, 0.7099035062699042, 0.7307289937591189, 0.7667243173694104, 0.766775476226334, 0.752087365653294, 0.7669890411835496, 0.7432540462825117, 0.7399030939056355, 0.5080265638137363, 0.5351141824831049, 0.566108980545948, 0.5473234418641677, 0.49948046589767037, 0.5204047166959946, 0.593717065461858, 0.546473147538048, 0.5105610722991389, 0.22810695474980602, 0.3424098564777849, 0.13697132441285942, 0.1568389633107008, 0.1420304917699321, 0.16092856575382086, 0.13987449130301388, 0.28387486152469543, 0.15784237333582818, 0.1280211319886876, 0.14453714969444753, 0.11964116213791787, 0.11021234650939349, 0.1209948445511122, 0.14053203045595786, 0.1345033458045859, 0.19495928108114768, 0.191832248276131, 0.9732842391677099, 0.9726635803099712, 0.9725625870939715, 0.9711844928668053, 0.9733397396302214, 0.9722963621159846, 0.9663622680642325, 0.9699549466467396, 0.960601565238871, 0.578962859021797, 0.5068216341920627, 0.5240946902684889, 0.559375428106646, 0.5550075387600183, 0.5577472710416729, 0.49830302678282423, 0.5057306856711228, 0.5287508365788788, 0.22402825392123837, 0.778795554213721, 0.35395163862712975, 0.21288253623910192, 0.2643224070828787, 0.2086780769062646, 0.7769677778309678, 0.17635818504183698, 0.23002287772194263, 0.19307807495325924, 0.21858661400011414, 0.18572333182021694, 0.12608153447139814, 0.21468954072355595, 0.18443612940180643, 0.2594344345687507, 0.169382491289646, 0.16893326505941408, 0.2075879651582303, 0.2052986442124104, 0.18407409944691722, 0.20564793087808053, 0.14070394639654316, 0.1268520762105496, 0.20368208889830197, 0.21656863789047598, 0.22153653937492668, 9.999999999998899e-05, 9.999999999998899e-05, 0.04220812238251925, 0.04348036522102117, 0.021957928893093448, 0.006210020707288266, 9.999999999998899e-05, 0.05269403112015969, 0.006246001181047678, 0.07160808402781882, 0.08367909112344474, 0.09678721252234768, 0.06439252259632666, 0.026608324556568697, 0.03523401488081568, 0.08845816181393384, 0.08201221849344564, 0.06652552384871702, 0.10379887427069101, 0.03506955795189137, 0.09583743712334802, 0.06238536371200676, 0.06831022220272698, 0.1509058074141849, 0.12824574563087643, 0.08091656353617416, 0.07209102266123135, 0.15323226950213775, 0.037451277707310715, 0.13517733978943014, 0.11440969635665788, 0.06155165633647863, 0.16048364094935064, 0.15308450719885802, 0.04578440162634945, 0.08103266801413811, 0.5041949637635877, 0.4930486083270553, 0.47432274711804245, 0.5012241867233365, 0.5704194486357363, 0.5240651615184484, 0.4978309936419423, 0.5269269774663529, 0.5422853513140239, 0.12186345653454411, 0.10902137043649796, 0.10091538050236215, 0.1020781889489879, 0.13954827854216234, 0.13789721480315054, 0.14552413874742165, 0.13710511256162006, 0.08916071281406912, 0.37494592774662594, 0.3146158379895414, 0.3871773872423252, 0.2804615035495871, 0.38997620624047324, 0.21104722223577843, 0.24942653313003116, 0.18293605961909465, 0.20302282054132736, 0.336869267414285, 0.40642389731968864, 0.3824013612381738, 0.44073986420321276, 0.4013381955901183, 0.38927166578058636, 0.366863137205221, 0.461824620389817, 0.2761261120300472, 0.19290496412534008, 0.28805534057022764, 0.2338467042724547, 0.2397769308197416, 0.28626856270602796, 0.3002048796658904, 0.25599688648638574, 0.33365772471288924, 0.32019266825411064, 0.2320907409093762, 0.206657696453298, 0.20575930111533325, 0.23009167087780302, 0.24345244210670625, 0.20885067992167528, 0.21609570358677777, 0.3169775832378725, 0.22112037151771213, 0.5563630979379153, 0.19100237188368596, 0.226307082598048, 0.20064353662590395, 0.2326521344216651, 0.21466816325557492, 0.20102254887489068, 0.19823845967608278, 0.21869674651128956, 0.27996907013322814, 0.18341777571921702, 0.16288932031317127, 0.2772081077197922, 0.1992485903341492, 0.18730888242417987, 0.12635296922212313, 0.16086096874085964, 0.7947362386747938, 0.7103889293285129, 0.15583300828546343, 0.1252400905163913, 0.5880560374016026, 0.20805406688249672, 0.1510963849422695, 0.16163535915244398, 0.27128753208664724, 0.16156723769342785, 0.18573526273527674, 0.20712297518144462, 0.19818800193057606, 0.23042557024416332, 0.19750536081399572, 0.18560630051046145, 0.18781742390304645, 0.1952050964608738, 0.21118830219673435, 0.12903749123846175, 0.08895078463094941, 0.1385882276234095, 0.082690971468389, 0.13699094249729893, 0.07731298206951509, 0.12787500398292773, 0.09770651220927917, 0.11437889610044727]}, "mutation_prompt": null}
{"id": "8d482514-623c-4faf-876e-3c6b589a38e1", "solution": "import numpy as np\n\nclass DynamicMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Adjusted population size for a clearer exploration-exploitation balance\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8  # Balanced scale factor for convergence\n        self.initial_crossover_rate = 0.9  # Higher crossover rate to promote diversity\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.12  # Adjusted to refine diversity control\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.3 + 0.7 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.3 + 0.7 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.5 * (evaluations / self.budget)  # Modified inertia adaptation for efficiency\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                if current_diversity > self.diversity_threshold:  # Different mutation strategy based on diversity\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "DynamicMultiStrategyOptimizer", "description": "A dynamic multi-strategy optimizer enhancing exploration and exploitation balance via adaptive mutation and inertia strategies.", "configspace": "", "generation": 72, "fitness": 0.253194035720771, "feedback": "The algorithm DynamicMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.644473741547236, 0.6738465151315971, 0.6248639937414637, 0.6683576385326399, 0.6601030102117864, 0.6329146668148602, 0.6236126789667806, 0.646049273915694, 0.6730428354650395, 0.21182749972204007, 0.06945836114460868, 0.4267545522023327, 0.1200223741134061, 0.3066967824954777, 0.15871968559558736, 0.3962429211396037, 0.3916295998112751, 0.43509748337305065, 0.1254154645843093, 0.1269442260671918, 0.10833860484582125, 0.1180098126493826, 0.1173501348848629, 0.13031693596227611, 0.14005696480701768, 0.1307806647332893, 0.12194403682969024, 0.10229078227274313, 0.118592205112512, 0.12869958019351502, 0.12541987376836583, 0.13352523273726924, 0.10027017879009559, 0.10679754245747886, 0.09338170177354366, 0.0942784671333371, 0.9550483128651045, 0.9578525580671033, 0.9697075129432249, 0.9650999465198924, 0.9605844416306865, 0.977527112472776, 0.9699616830140491, 0.9681707170306498, 0.9665235992559836, 0.359472824374771, 0.3859356493846672, 0.39812129872161717, 0.3775650580921389, 0.14438692765127203, 0.18111470544350128, 0.2808292653045352, 0.4080036367251949, 0.40781435265996635, 0.6573560303558108, 0.6106605830058771, 0.21099875576747784, 0.20904183933735832, 0.18910912592484297, 0.17706527106065661, 0.12471499212138937, 0.2303988400842074, 0.24183382659509756, 0.17517142030581656, 0.16969409242237055, 0.17767556827088504, 0.13087425948962206, 0.15887317150266134, 0.17723404768942475, 0.16351671525209077, 0.11626438111575621, 0.12446250764443922, 0.17854582312480738, 0.13319533019800744, 0.17134145009960844, 0.1638538447226633, 0.15442508176456993, 0.1782866149498168, 0.14574406132641815, 0.17744473954691165, 0.14246520500973403, 9.999999999998899e-05, 0.018149173148668374, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007464674621009859, 9.999999999998899e-05, 0.0015761074117454088, 0.048848558818857635, 0.06764996975980664, 0.06495794933229482, 0.05035802979415327, 0.06723705609301889, 0.03913155171827565, 0.04106856816244797, 0.038970586262642604, 0.06006477884382255, 0.053334462689248574, 0.022426473916812073, 0.024131233072673952, 0.03478199637956114, 0.10761416349274455, 0.06381083764481299, 0.047285724578425614, 0.057938901274675714, 0.06304449802629974, 0.07058529939185887, 0.13220743249178524, 0.025901544524590148, 0.037292671400101285, 0.12219619370200996, 0.16590744020489934, 0.10960483981572311, 0.044192815841925914, 0.08796323941882112, 0.11575268582975717, 0.46260036672023686, 0.5061413965845594, 0.467018440147404, 0.48398712716080416, 0.45023064620356823, 0.49087869596481004, 0.4911046209014186, 0.43255661146948665, 0.46088509990479865, 0.07747204405033825, 0.11776257920479749, 0.08159049236959182, 0.11708007672347465, 0.12648290210890645, 0.11587397156416324, 0.08793541432998919, 0.10197011444063775, 0.1263117795811739, 0.16559075554588232, 0.2009659662513057, 0.2546543741682161, 0.21396156668226318, 0.2929688726166255, 0.3153399473704468, 0.2367915093127836, 0.21022036126392352, 0.21297135192735195, 0.3730331596413923, 0.39552132482926905, 0.3147835466313875, 0.23228263885617395, 0.338218835112326, 0.2931138574155777, 0.337426840608832, 0.3935526673140044, 0.347729318518764, 0.2124778074161754, 0.21263718583982072, 0.2629360158964502, 0.15423741746484954, 0.22653716073733488, 0.24601590253474026, 0.2999154236995448, 0.2993240249729031, 0.1790525892915672, 0.2092717260291611, 0.22100875100188278, 0.21400529137427993, 0.20933867052582766, 0.17902107413477586, 0.20359157350324442, 0.23717815209451099, 0.19765671305573218, 0.24806340437379104, 0.19813047130413064, 0.20588916615824615, 0.1932377806779535, 0.18717343873667536, 0.19622678012948136, 0.1813083183145403, 0.1776093636477788, 0.19087521100061788, 0.20646514178311914, 0.7622231421415273, 0.18191299058956145, 0.794474635526413, 0.6803283716122996, 0.199670095306266, 0.19657238073577976, 0.7565806073014081, 0.16892286034049886, 0.20303063227220586, 0.6844086324703136, 0.2052480238346006, 0.20043272755076724, 0.20925272365557734, 0.2045494833820667, 0.16974603239320618, 0.18129985706808105, 0.19637337693980084, 0.524365733700569, 0.1889070568770077, 0.17834006780069778, 0.20768343504020736, 0.21889251334081483, 0.19631013590463786, 0.1731048176588712, 0.17306641374275256, 0.18758206376960562, 0.1958163194603303, 0.08719374855082185, 0.08281537923073123, 0.0937713872746212, 0.10312453453575532, 0.10601885130936994, 0.08979899906654976, 0.14157183770292936, 0.09373448175464216, 0.07455087461331822]}, "mutation_prompt": null}
{"id": "fff21d46-8689-4658-b664-25578f245753", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.9  # Adjusted for improved convergence\n        self.initial_crossover_rate = 0.85  # Adjusted crossover rate\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.15  # Tweaked threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.4 + 0.6 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.4 + 0.6 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.6 - 0.4 * (evaluations / self.budget)  # More aggressive inertia adaptation\n                cognitive = 1.4 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.4 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "An adaptive swarm intelligence algorithm utilizing improved dynamic parameter tuning with enhanced diversity preservation strategies for faster convergence.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.7671889576591918, 0.7099035062699042, 0.7307289937591189, 0.7667243173694104, 0.766775476226334, 0.752087365653294, 0.7669890411835496, 0.7432540462825117, 0.7399030939056355, 0.5080265638137363, 0.5351141824831049, 0.566108980545948, 0.5473234418641677, 0.49948046589767037, 0.5204047166959946, 0.593717065461858, 0.546473147538048, 0.5105610722991389, 0.22810695474980602, 0.3424098564777849, 0.13697132441285942, 0.1568389633107008, 0.1420304917699321, 0.16092856575382086, 0.13987449130301388, 0.28387486152469543, 0.15784237333582818, 0.1280211319886876, 0.14453714969444753, 0.11964116213791787, 0.11021234650939349, 0.1209948445511122, 0.14053203045595786, 0.1345033458045859, 0.19495928108114768, 0.191832248276131, 0.9732842391677099, 0.9726635803099712, 0.9725625870939715, 0.9711844928668053, 0.9733397396302214, 0.9722963621159846, 0.9663622680642325, 0.9699549466467396, 0.960601565238871, 0.578962859021797, 0.5068216341920627, 0.5240946902684889, 0.559375428106646, 0.5550075387600183, 0.5577472710416729, 0.49830302678282423, 0.5057306856711228, 0.5287508365788788, 0.22402825392123837, 0.778795554213721, 0.35395163862712975, 0.21288253623910192, 0.2643224070828787, 0.2086780769062646, 0.7769677778309678, 0.17635818504183698, 0.23002287772194263, 0.19307807495325924, 0.21858661400011414, 0.18572333182021694, 0.12608153447139814, 0.21468954072355595, 0.18443612940180643, 0.2594344345687507, 0.169382491289646, 0.16893326505941408, 0.2075879651582303, 0.2052986442124104, 0.18407409944691722, 0.20564793087808053, 0.14070394639654316, 0.1268520762105496, 0.20368208889830197, 0.21656863789047598, 0.22153653937492668, 9.999999999998899e-05, 9.999999999998899e-05, 0.04220812238251925, 0.04348036522102117, 0.021957928893093448, 0.006210020707288266, 9.999999999998899e-05, 0.05269403112015969, 0.006246001181047678, 0.07160808402781882, 0.08367909112344474, 0.09678721252234768, 0.06439252259632666, 0.026608324556568697, 0.03523401488081568, 0.08845816181393384, 0.08201221849344564, 0.06652552384871702, 0.10379887427069101, 0.03506955795189137, 0.09583743712334802, 0.06238536371200676, 0.06831022220272698, 0.1509058074141849, 0.12824574563087643, 0.08091656353617416, 0.07209102266123135, 0.15323226950213775, 0.037451277707310715, 0.13517733978943014, 0.11440969635665788, 0.06155165633647863, 0.16048364094935064, 0.15308450719885802, 0.04578440162634945, 0.08103266801413811, 0.5041949637635877, 0.4930486083270553, 0.47432274711804245, 0.5012241867233365, 0.5704194486357363, 0.5240651615184484, 0.4978309936419423, 0.5269269774663529, 0.5422853513140239, 0.12186345653454411, 0.10902137043649796, 0.10091538050236215, 0.1020781889489879, 0.13954827854216234, 0.13789721480315054, 0.14552413874742165, 0.13710511256162006, 0.08916071281406912, 0.37494592774662594, 0.3146158379895414, 0.3871773872423252, 0.2804615035495871, 0.38997620624047324, 0.21104722223577843, 0.24942653313003116, 0.18293605961909465, 0.20302282054132736, 0.336869267414285, 0.40642389731968864, 0.3824013612381738, 0.44073986420321276, 0.4013381955901183, 0.38927166578058636, 0.366863137205221, 0.461824620389817, 0.2761261120300472, 0.19290496412534008, 0.28805534057022764, 0.2338467042724547, 0.2397769308197416, 0.28626856270602796, 0.3002048796658904, 0.25599688648638574, 0.33365772471288924, 0.32019266825411064, 0.2320907409093762, 0.206657696453298, 0.20575930111533325, 0.23009167087780302, 0.24345244210670625, 0.20885067992167528, 0.21609570358677777, 0.3169775832378725, 0.22112037151771213, 0.5563630979379153, 0.19100237188368596, 0.226307082598048, 0.20064353662590395, 0.2326521344216651, 0.21466816325557492, 0.20102254887489068, 0.19823845967608278, 0.21869674651128956, 0.27996907013322814, 0.18341777571921702, 0.16288932031317127, 0.2772081077197922, 0.1992485903341492, 0.18730888242417987, 0.12635296922212313, 0.16086096874085964, 0.7947362386747938, 0.7103889293285129, 0.15583300828546343, 0.1252400905163913, 0.5880560374016026, 0.20805406688249672, 0.1510963849422695, 0.16163535915244398, 0.27128753208664724, 0.16156723769342785, 0.18573526273527674, 0.20712297518144462, 0.19818800193057606, 0.23042557024416332, 0.19750536081399572, 0.18560630051046145, 0.18781742390304645, 0.1952050964608738, 0.21118830219673435, 0.12903749123846175, 0.08895078463094941, 0.1385882276234095, 0.082690971468389, 0.13699094249729893, 0.07731298206951509, 0.12787500398292773, 0.09770651220927917, 0.11437889610044727]}, "mutation_prompt": null}
{"id": "2db28fdb-4976-48dc-82d8-1761b387caaa", "solution": "import numpy as np\n\nclass QuantumAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Slightly increased population for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.85  # Slightly adjusted for balance between exploration and exploitation\n        self.initial_crossover_rate = 0.8  # Adjusted for better mixing\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # Adjusted for effective diversity control\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n        self.quantum_weight = 1.5 * np.exp(-evals/self.budget)  # Introduced quantum adaptation\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def quantum_mechanism(self, position):\n        # Quantum-inspired position update\n        return position + self.quantum_weight * (np.random.rand(self.dim) - 0.5)\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.5 * (evaluations / self.budget)  # Fine-tuned inertia adaptation\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                position = np.copy(self.particles[i])\n                if current_diversity < self.diversity_threshold:\n                    position = self.quantum_mechanism(position)  # Apply quantum update when diversity is low\n                score = func(position)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = position\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = position\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "QuantumAdaptiveHybridPSODE", "description": "Enhanced adaptive algorithm integrating quantum-inspired mechanisms for improved convergence and diversity.", "configspace": "", "generation": 74, "fitness": 0.26654684101285436, "feedback": "The algorithm QuantumAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.7132063965761375, 0.694318051825852, 0.7264474182948772, 0.7321577957350716, 0.7232605962211527, 0.7220707595613636, 0.7105183391316521, 0.7146485807408027, 0.7090559116743971, 0.4497864703528116, 0.4832514999200661, 0.4798015684709167, 0.4570788651775607, 0.43869652161166006, 0.03798632482350728, 0.43721873400518796, 0.4712998896175462, 0.37609934432470304, 0.10814753833098201, 0.1425518439159683, 0.13760553153776367, 0.1333449745542311, 0.11929515477598562, 0.2652181940506536, 0.1366852671631006, 0.140896148125901, 0.13299129366584217, 0.10073036376673283, 0.10225341176148939, 0.0972581443678342, 0.12975339365484528, 0.1370268348406325, 0.1238044849995733, 0.1287688524666899, 0.11446406087492633, 0.13732982949315187, 0.9655173833984999, 0.9657720102110653, 0.9694502615347647, 0.9682870168714041, 0.9767099459365781, 0.9678385524587173, 0.9690343424539, 0.9769791093528071, 0.9780794094992993, 0.5161476213572684, 0.45088625101850355, 0.39751285506459555, 0.4550591506411463, 0.3392002633449386, 0.3044602332608336, 0.4630871256715302, 0.45934406609550593, 0.4108393976202307, 0.2123698979932721, 0.5236677229712552, 0.21915929870069628, 0.1891895765660504, 0.18886650492800172, 0.26409311100177835, 0.17541948518247086, 0.23169197125425112, 0.6822663370008109, 0.17001369792617804, 0.1665000707432095, 0.11196882992594726, 0.1639949738480404, 0.16848854606235086, 0.12037076282619252, 0.18834194300782214, 0.1593494878133912, 0.18322578368035836, 0.12210991111429048, 0.08628273620353943, 0.15801306363834433, 0.1651887663875128, 0.18722490535111935, 0.18539466934118143, 0.1825082070004138, 0.18245379947755513, 0.19815989522610733, 9.999999999998899e-05, 0.002913235952200166, 0.026421274005309137, 9.999999999998899e-05, 0.06909615179738215, 9.999999999998899e-05, 9.999999999998899e-05, 0.01647836070883202, 0.005158901473974242, 0.08537762873502797, 0.09023748192712844, 0.04646901294649519, 0.023611213656513197, 0.07826767520157885, 0.063551562228365, 0.0723033086516196, 0.04210549171004074, 0.06495275070442752, 0.02497849545529729, 0.17047694746118036, 0.03636761500794006, 0.10862731025247974, 0.08028183789192267, 0.06789872154008048, 0.06784372865542176, 0.07338124850298466, 0.08311705039905504, 0.009172898444662292, 0.132994716853434, 0.058214780533051624, 0.04314035535941729, 0.10944320959000065, 0.16448702653455416, 0.05290355762151899, 0.060521110569851544, 0.0757403670279787, 0.5215399168892884, 0.48966687592429003, 0.45898304106017984, 0.5464843036590008, 0.5032271260134871, 0.4788292991473194, 0.48565379649922036, 0.4945314829480547, 0.5173997782694548, 0.10431199433877503, 0.10709457763177865, 0.10711964405923735, 0.10429889036330497, 0.103343183329352, 0.11056766207388025, 0.13609007485072666, 0.0795418985295091, 0.11296026777267798, 0.16099717293279714, 0.18884935246039836, 0.18346541466083321, 0.24119708249876093, 0.26126547063080063, 0.21905485310855133, 0.4312574701400911, 0.19151336026464694, 0.14801853200531367, 0.29225133656122515, 0.4177120183250851, 0.2475949550679858, 0.22513672617429314, 0.28641789577777754, 0.3472991874177628, 0.3660889616261289, 0.4686213469162691, 0.43851434978928505, 0.22302167644049287, 0.168749042249975, 0.23434033819221545, 0.19019402899235016, 0.20531841208260115, 0.2774907005685232, 0.3813535826986386, 0.2782643288726513, 0.31323016250875246, 0.20206955545732352, 0.21265165629411809, 0.18907910778259152, 0.2085297391023465, 0.21918968244506043, 0.22268996191981427, 0.21251035838846422, 0.2258001563422144, 0.21021002100590414, 0.439548167429464, 0.2318383777201708, 0.2157106258796787, 0.20778080858696468, 0.23416751704476035, 0.1936757613978568, 0.21766947300949768, 0.18844369758947455, 0.181365569613667, 0.17329587285760495, 0.16250757022214335, 0.8252777058369903, 0.19697308582997597, 0.1984941489103792, 0.1974816920062772, 0.14131929305038116, 0.16883801264717335, 0.7999566916812106, 0.5471024442674559, 0.20749225841528574, 0.11066725793499099, 0.12702647084328733, 0.16739887373092222, 0.47859762206533973, 0.0933016585463935, 0.20612538875852238, 0.6371072315090751, 0.18328679742351328, 0.1980702942001511, 0.18696971465817191, 0.20217995604014827, 0.20623870800912525, 0.17809798864335968, 0.19144407296037957, 0.1737802905827628, 0.20312574556309704, 0.08736241667449962, 0.07846526059784897, 0.10044694979382873, 0.08572962603805157, 0.09187758739127616, 0.11361159541504873, 0.10819115357376052, 0.10260535936419457, 0.0893966846257801]}, "mutation_prompt": null}
{"id": "9ae32a63-4b03-43d3-a894-f84ec60f156d", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size for enhanced exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.85  # Adjusted for better exploration-exploitation balance\n        self.initial_crossover_rate = 0.9  # Adjusted crossover rate for diversity\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # Tweaked threshold for better diversity management\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(2 * np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def cooperative_update(self):\n        subgroups = np.array_split(np.random.permutation(self.population_size), 3)\n        for group in subgroups:\n            local_best_score = np.inf\n            local_best_position = None\n            for idx in group:\n                score = func(self.particles[idx])\n                if score < local_best_score:\n                    local_best_score = score\n                    local_best_position = self.particles[idx]\n            if local_best_score < self.best_global_score:\n                self.best_global_score = local_best_score\n                self.best_global_position = local_best_position\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.5 - 0.3 * (evaluations / self.budget)  # More dynamic inertia adaptation\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n            self.cooperative_update()\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.6, mutant, edge_mutation)  # Altered mutation probability\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid algorithm combining cooperative multi-swarm strategies with adaptive parameter tuning for improved convergence.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {}, "mutation_prompt": null}
{"id": "c149fb8d-3955-48a3-9981-0f08aa84bdf4", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.9  # Adjusted for improved convergence\n        self.initial_crossover_rate = 0.85  # Adjusted crossover rate\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.15  # Tweaked threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.4 + 0.6 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.4 + 0.6 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.6 - 0.4 * (evaluations / self.budget)  # More aggressive inertia adaptation\n                cognitive = 1.4 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.4 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "An adaptive swarm intelligence algorithm utilizing improved dynamic parameter tuning with enhanced diversity preservation strategies for faster convergence.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.7671889576591918, 0.7099035062699042, 0.7307289937591189, 0.7667243173694104, 0.766775476226334, 0.752087365653294, 0.7669890411835496, 0.7432540462825117, 0.7399030939056355, 0.5080265638137363, 0.5351141824831049, 0.566108980545948, 0.5473234418641677, 0.49948046589767037, 0.5204047166959946, 0.593717065461858, 0.546473147538048, 0.5105610722991389, 0.22810695474980602, 0.3424098564777849, 0.13697132441285942, 0.1568389633107008, 0.1420304917699321, 0.16092856575382086, 0.13987449130301388, 0.28387486152469543, 0.15784237333582818, 0.1280211319886876, 0.14453714969444753, 0.11964116213791787, 0.11021234650939349, 0.1209948445511122, 0.14053203045595786, 0.1345033458045859, 0.19495928108114768, 0.191832248276131, 0.9732842391677099, 0.9726635803099712, 0.9725625870939715, 0.9711844928668053, 0.9733397396302214, 0.9722963621159846, 0.9663622680642325, 0.9699549466467396, 0.960601565238871, 0.578962859021797, 0.5068216341920627, 0.5240946902684889, 0.559375428106646, 0.5550075387600183, 0.5577472710416729, 0.49830302678282423, 0.5057306856711228, 0.5287508365788788, 0.22402825392123837, 0.778795554213721, 0.35395163862712975, 0.21288253623910192, 0.2643224070828787, 0.2086780769062646, 0.7769677778309678, 0.17635818504183698, 0.23002287772194263, 0.19307807495325924, 0.21858661400011414, 0.18572333182021694, 0.12608153447139814, 0.21468954072355595, 0.18443612940180643, 0.2594344345687507, 0.169382491289646, 0.16893326505941408, 0.2075879651582303, 0.2052986442124104, 0.18407409944691722, 0.20564793087808053, 0.14070394639654316, 0.1268520762105496, 0.20368208889830197, 0.21656863789047598, 0.22153653937492668, 9.999999999998899e-05, 9.999999999998899e-05, 0.04220812238251925, 0.04348036522102117, 0.021957928893093448, 0.006210020707288266, 9.999999999998899e-05, 0.05269403112015969, 0.006246001181047678, 0.07160808402781882, 0.08367909112344474, 0.09678721252234768, 0.06439252259632666, 0.026608324556568697, 0.03523401488081568, 0.08845816181393384, 0.08201221849344564, 0.06652552384871702, 0.10379887427069101, 0.03506955795189137, 0.09583743712334802, 0.06238536371200676, 0.06831022220272698, 0.1509058074141849, 0.12824574563087643, 0.08091656353617416, 0.07209102266123135, 0.15323226950213775, 0.037451277707310715, 0.13517733978943014, 0.11440969635665788, 0.06155165633647863, 0.16048364094935064, 0.15308450719885802, 0.04578440162634945, 0.08103266801413811, 0.5041949637635877, 0.4930486083270553, 0.47432274711804245, 0.5012241867233365, 0.5704194486357363, 0.5240651615184484, 0.4978309936419423, 0.5269269774663529, 0.5422853513140239, 0.12186345653454411, 0.10902137043649796, 0.10091538050236215, 0.1020781889489879, 0.13954827854216234, 0.13789721480315054, 0.14552413874742165, 0.13710511256162006, 0.08916071281406912, 0.37494592774662594, 0.3146158379895414, 0.3871773872423252, 0.2804615035495871, 0.38997620624047324, 0.21104722223577843, 0.24942653313003116, 0.18293605961909465, 0.20302282054132736, 0.336869267414285, 0.40642389731968864, 0.3824013612381738, 0.44073986420321276, 0.4013381955901183, 0.38927166578058636, 0.366863137205221, 0.461824620389817, 0.2761261120300472, 0.19290496412534008, 0.28805534057022764, 0.2338467042724547, 0.2397769308197416, 0.28626856270602796, 0.3002048796658904, 0.25599688648638574, 0.33365772471288924, 0.32019266825411064, 0.2320907409093762, 0.206657696453298, 0.20575930111533325, 0.23009167087780302, 0.24345244210670625, 0.20885067992167528, 0.21609570358677777, 0.3169775832378725, 0.22112037151771213, 0.5563630979379153, 0.19100237188368596, 0.226307082598048, 0.20064353662590395, 0.2326521344216651, 0.21466816325557492, 0.20102254887489068, 0.19823845967608278, 0.21869674651128956, 0.27996907013322814, 0.18341777571921702, 0.16288932031317127, 0.2772081077197922, 0.1992485903341492, 0.18730888242417987, 0.12635296922212313, 0.16086096874085964, 0.7947362386747938, 0.7103889293285129, 0.15583300828546343, 0.1252400905163913, 0.5880560374016026, 0.20805406688249672, 0.1510963849422695, 0.16163535915244398, 0.27128753208664724, 0.16156723769342785, 0.18573526273527674, 0.20712297518144462, 0.19818800193057606, 0.23042557024416332, 0.19750536081399572, 0.18560630051046145, 0.18781742390304645, 0.1952050964608738, 0.21118830219673435, 0.12903749123846175, 0.08895078463094941, 0.1385882276234095, 0.082690971468389, 0.13699094249729893, 0.07731298206951509, 0.12787500398292773, 0.09770651220927917, 0.11437889610044727]}, "mutation_prompt": null}
{"id": "1766c3c1-e9c1-4191-8928-c6002c3028bf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8  # Adjusted for improved convergence\n        self.initial_crossover_rate = 0.9  # Adjusted crossover rate\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.12  # Tweaked threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.5 * (evaluations / self.budget)  # More aggressive inertia adaptation\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < 0.3:  # Introduce occasional mutation\n                    mutant += np.random.normal(0, 0.1, self.dim)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedAdaptiveHybridPSODE", "description": "A novel hybrid PSO and DE algorithm with enhanced adaptive dynamic parameter control and mutation strategies for improved convergence.", "configspace": "", "generation": 77, "fitness": 0.2666152347493156, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.6277480505881718, 0.6707792431481976, 0.5927725386862053, 0.6463269447885446, 0.6554839055923297, 0.6998031267250782, 0.648073396612274, 0.6498462002697033, 0.6759292753828754, 0.40809713792359326, 0.08318111255148308, 0.20112746620475996, 0.3091700042922013, 0.1589437710274344, 0.3892261587641854, 0.36905380537766463, 0.452738028465126, 0.40668035667225855, 0.11831019456435277, 0.10652431382773087, 0.12953803536356168, 0.11993511828635073, 0.14253844386079784, 0.12020458167684678, 0.13622711158748713, 0.3508965079177757, 0.10300181532521058, 0.11474560787686172, 0.135991751861273, 0.09422742259234096, 0.11564016195119908, 0.1205887023919946, 0.12035761489120611, 0.10220598598442177, 0.10095081769140801, 0.14234463777866335, 0.966227756185601, 0.9781681971279398, 0.9680605129794272, 0.9676026678118747, 0.9661826280566769, 0.9663980275664308, 0.9760538796916912, 0.9763666905021426, 0.9726794954135329, 0.46333773160753056, 0.3881544429194359, 0.43744168633940594, 0.35577288097625714, 0.3857375123827331, 0.398721413864388, 0.42894131179289063, 0.39537462587213257, 0.38692086486649946, 0.6370572910896606, 0.6624633075906691, 0.21631830888253922, 0.34457608402438944, 0.2577755445391291, 0.1983566314393974, 0.2242377013116854, 0.2217349644881369, 0.5638228491654171, 0.15855860563489022, 0.11217728461233123, 0.13882220152382396, 0.19529958655186996, 0.11183895445870384, 0.10943274429212069, 0.16317586352682023, 0.1494103671985595, 0.09635074933010224, 0.14034323132816295, 0.09889111516863014, 0.15355871137152932, 0.16242979157970838, 0.1411053374214647, 0.17447300643965902, 0.19392089944276802, 0.19954881935320312, 0.18167768611720625, 9.999999999998899e-05, 0.031690546263819286, 9.999999999998899e-05, 0.01006110001959637, 0.13914331224623278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042318280853346546, 0.024557791077104985, 0.06722520796954123, 0.0322089609597479, 0.042128187479921864, 0.09113759409286781, 0.031786878348863845, 0.1198060771768884, 0.0603040595631652, 0.09890992764400786, 0.022136654415650603, 0.029493116614416448, 0.04218850645799144, 0.06240611365965543, 0.15498163548199895, 0.06084894174697986, 0.06672767828710024, 0.047738288132540996, 0.10626101252696696, 0.08190162378529853, 0.14703648006559145, 0.12218787006805665, 0.10839393558913235, 0.08429977918819953, 0.21638399184939283, 0.05095642767196473, 0.06942150746927178, 0.12804653910128327, 0.4860052731998721, 0.4743417523667467, 0.44280557228768225, 0.46539590476890114, 0.46527792939901624, 0.4400569639102492, 0.47471126631481364, 0.43955807689822646, 0.45158421730157994, 0.08958765273575642, 0.0859990752503158, 0.1109308650180254, 0.12074765022489298, 0.1205308193138157, 0.11784667128198834, 0.13815937879956441, 0.08959036595896197, 0.11073362360846495, 0.2100623703525194, 0.19397776705189218, 0.2669882180329841, 0.25247774686634183, 0.21756950018215293, 0.2137814793477285, 0.14895932810449664, 0.22590939528709697, 0.13822153481887578, 0.396216206448352, 0.16706428427854825, 0.3415680577109459, 0.35747658722576414, 0.38399763876547777, 0.31861551462334714, 0.3803556324468743, 0.4000833798631087, 0.3558440272905776, 0.18854759986900094, 0.19447692047082443, 0.29907001857272597, 0.247722649598482, 0.2582096800733309, 0.18397214819025876, 0.3134418362402671, 0.27381422715477877, 0.19329560313557081, 0.21006778944398918, 0.18731227164298803, 0.24516054974700396, 0.21696733236400345, 0.21414389449336146, 0.1895746729729929, 0.21066421482978936, 0.23906330642368, 0.23671937898998718, 0.20519477202087677, 0.17646865367249542, 0.20766683905336847, 0.2273318665155486, 0.22837478617225804, 0.22712201808529453, 0.2190690085206619, 0.19591906336393827, 0.21957520238627304, 0.20242025910478167, 0.16439817665150314, 0.20627347623152736, 0.7547902468347836, 0.19564377198827798, 0.6766075302589007, 0.7881758542891043, 0.16775351159824203, 0.6316826843360757, 0.43562736167954597, 0.20583499171971464, 0.44346241872786396, 0.20068233887044684, 0.11149629226688007, 0.5631383608204601, 0.20753847270013404, 0.5329591678606713, 0.6266193636057378, 0.18820285331312847, 0.17882172301470345, 0.22879153836460586, 0.22018375581623828, 0.1781450073801838, 0.19170526918629127, 0.18493135382689474, 0.19628101732529246, 0.1820924730755018, 0.08327766544507542, 0.11243059235856123, 0.0903376246732911, 0.08665190095468733, 0.09558541723280489, 0.07972202107352933, 0.09262863728306236, 0.08825599079223989, 0.09586621570438725]}, "mutation_prompt": null}
{"id": "db83a558-9b66-4041-bf93-f6b292123d47", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Adjusted population size\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8  # Enhanced convergence factor\n        self.initial_crossover_rate = 0.9  # Tweaked crossover rate\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.strategy_switch_threshold = 0.2  # New threshold for strategy switch\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.7 - 0.5 * (evaluations / self.budget)  # Enhanced inertia adaptation\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.strategy_switch_threshold:\n                    mutation_strategy = np.random.choice(['edge', 'center'])\n                    if mutation_strategy == 'edge':\n                        edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                        mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                    else:\n                        center = (self.lower_bound + self.upper_bound) / 2\n                        center_mutation = np.random.uniform(center-1, center+1, self.dim)\n                        mutant = np.where(np.random.rand(self.dim) < 0.3, mutant, center_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "HybridAdaptiveSwarmOptimizer", "description": "A hybrid adaptive swarm intelligence algorithm integrating multi-strategy selection to enhance exploration and exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.2614126102977315, "feedback": "The algorithm HybridAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.65154944681401, 0.6463659078403623, 0.6483020543093487, 0.6189539862000191, 0.6664706496657229, 0.6558076307979788, 0.61642063362276, 0.618265570643134, 0.6744778677403875, 0.26141481623710283, 0.3976329306919032, 0.3462411264549343, 0.3440162423791131, 0.337030725228037, 0.36924817826311285, 0.41455399488669387, 0.3490593491753623, 0.3671892131297182, 0.1308861415583138, 0.15265950848306198, 0.12007800761336274, 0.11042406657770698, 0.1258436521330759, 0.11608695503506739, 0.13455404357276146, 0.14506571996040096, 0.14942630429994475, 0.19014958360006995, 0.09759218745852616, 0.10041900183876373, 0.13495403189464028, 0.13744772504014313, 0.10208951316663262, 0.10867644097958162, 0.09463414825497696, 0.1227751114233091, 0.9445444329914092, 0.9769852868671455, 0.9692315016857216, 0.9780075373582212, 0.9677126204100998, 0.9720054422700395, 0.9506844747028302, 0.9722250993963801, 0.9647578230252579, 0.40187104813575747, 0.4189189151135462, 0.3900983092938737, 0.40272837339359824, 0.43882828448007016, 0.4059787882548078, 0.35352723572135414, 0.37909184595597145, 0.34366550687843056, 0.6908594048656536, 0.2164852665259246, 0.6768667920779152, 0.32921359694866936, 0.7030826071455842, 0.1948427080936901, 0.6318498735718067, 0.1590955043216734, 0.2294594947703933, 0.1680346763597672, 0.17205294596769927, 0.16401424061262515, 0.08866333115308167, 0.1691642433031142, 0.18004026969031128, 0.1760763066752854, 0.14179490479022827, 0.14886903516292171, 0.1645039676243477, 0.15659952197029647, 0.166961892534099, 0.14949433694102332, 0.1532866633383836, 0.1813309654421299, 0.20139558240548172, 0.1830150413727336, 0.2120458675053012, 0.005618867860151422, 0.01082897331650634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002894530221673408, 0.07230510970493575, 0.0776684755265078, 0.06652827884061174, 0.16714210396384932, 0.07503251760250695, 0.03576349807845236, 0.012998385157464876, 0.0643663072880194, 0.0630805483424729, 0.0668651148745224, 0.09260327265270207, 0.034270257550921945, 9.999999999998899e-05, 0.13869585770211912, 0.14850342665773975, 0.06932691162420435, 0.06341470242454639, 0.06251586002326837, 0.13644677504580227, 0.0757267281786499, 0.0376902363426912, 0.1577367447040835, 0.07294685741347184, 0.12922247785834262, 0.11955404648325363, 0.04552187830008847, 0.07681349491951239, 0.06890122497360751, 0.4226705293739734, 0.4239328243321987, 0.43398109509085436, 0.5117375004353998, 0.4820408227692451, 0.43407020743858526, 0.47904475091858134, 0.4727409803603274, 0.4929540388779038, 0.11683885979532638, 0.09369530680059346, 0.08815320645761071, 0.12979299608588335, 0.11625228820129052, 0.11971391920083063, 0.08766755906215928, 0.11351891138236547, 0.13796312687781465, 0.259577377674449, 0.37188023926832603, 0.3440260767660882, 0.21549357719100526, 0.3507744159687415, 0.17508691068713145, 0.21658170694386003, 0.14528521316143028, 0.2912266317082335, 0.3155706841189021, 0.3055934051677508, 0.3277964042721304, 0.38051901794019694, 0.3370812432891537, 0.33192800919799736, 0.3598267585031476, 0.27517096976432354, 0.36293360727997437, 0.2739670568497631, 0.2227747458609971, 0.24451000998432426, 0.2899263582777538, 0.23021071905201596, 0.2095901311739078, 0.27024822267027526, 0.2351490821869544, 0.2903973557756101, 0.2241810789283174, 0.19748835047810898, 0.1752185644225015, 0.19560444163869128, 0.20395967428371453, 0.21052585848176886, 0.20715202555047485, 0.1898069221394062, 0.2087121942463015, 0.21009679640942303, 0.20795951132655777, 0.20498015502167644, 0.21139394468295836, 0.18962888169606218, 0.19780686456682683, 0.18093740961737825, 0.20551465341728525, 0.18813151636773062, 0.15248870207590481, 0.16108765755690113, 0.7870573982974859, 0.12533938404227374, 0.1954952109564727, 0.7243097803586469, 0.14540359874053865, 0.15550968897798811, 0.2009281415676799, 0.1546338006944643, 0.20626929513952075, 0.20532048742410736, 0.5359938367089057, 0.16626304381728063, 0.4768738855952913, 0.20974997297428022, 0.15405460310368657, 0.20849785959125744, 0.18832104416477657, 0.18160056235017064, 0.17586943702754487, 0.1921230927310691, 0.1842488365160031, 0.2170402263989849, 0.18237270677555273, 0.2036094917966691, 0.17526136974126916, 0.08267852830879818, 0.08257445258488882, 0.08743551785009618, 0.09539182944440927, 0.0870319111720812, 0.11543189944717613, 0.08496459319134242, 0.13013792537458102, 0.08645285663395497]}, "mutation_prompt": null}
{"id": "56bfcf70-2d5e-45f5-9d60-b363f640af63", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.9  # Adjusted for improved convergence\n        self.initial_crossover_rate = 0.85  # Adjusted crossover rate\n        self.scale_factor = self.initial_scale_factor\n        self.crossover_rate = self.initial_crossover_rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.15  # Tweaked threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.4 + 0.6 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.4 + 0.6 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.6 - 0.4 * (evaluations / self.budget)  # More aggressive inertia adaptation\n                cognitive = 1.4 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.4 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "AdaptiveHybridPSODE_v3", "description": "An adaptive swarm intelligence algorithm utilizing improved dynamic parameter tuning with enhanced diversity preservation strategies for faster convergence.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.7671889576591918, 0.7099035062699042, 0.7307289937591189, 0.7667243173694104, 0.766775476226334, 0.752087365653294, 0.7669890411835496, 0.7432540462825117, 0.7399030939056355, 0.5080265638137363, 0.5351141824831049, 0.566108980545948, 0.5473234418641677, 0.49948046589767037, 0.5204047166959946, 0.593717065461858, 0.546473147538048, 0.5105610722991389, 0.22810695474980602, 0.3424098564777849, 0.13697132441285942, 0.1568389633107008, 0.1420304917699321, 0.16092856575382086, 0.13987449130301388, 0.28387486152469543, 0.15784237333582818, 0.1280211319886876, 0.14453714969444753, 0.11964116213791787, 0.11021234650939349, 0.1209948445511122, 0.14053203045595786, 0.1345033458045859, 0.19495928108114768, 0.191832248276131, 0.9732842391677099, 0.9726635803099712, 0.9725625870939715, 0.9711844928668053, 0.9733397396302214, 0.9722963621159846, 0.9663622680642325, 0.9699549466467396, 0.960601565238871, 0.578962859021797, 0.5068216341920627, 0.5240946902684889, 0.559375428106646, 0.5550075387600183, 0.5577472710416729, 0.49830302678282423, 0.5057306856711228, 0.5287508365788788, 0.22402825392123837, 0.778795554213721, 0.35395163862712975, 0.21288253623910192, 0.2643224070828787, 0.2086780769062646, 0.7769677778309678, 0.17635818504183698, 0.23002287772194263, 0.19307807495325924, 0.21858661400011414, 0.18572333182021694, 0.12608153447139814, 0.21468954072355595, 0.18443612940180643, 0.2594344345687507, 0.169382491289646, 0.16893326505941408, 0.2075879651582303, 0.2052986442124104, 0.18407409944691722, 0.20564793087808053, 0.14070394639654316, 0.1268520762105496, 0.20368208889830197, 0.21656863789047598, 0.22153653937492668, 9.999999999998899e-05, 9.999999999998899e-05, 0.04220812238251925, 0.04348036522102117, 0.021957928893093448, 0.006210020707288266, 9.999999999998899e-05, 0.05269403112015969, 0.006246001181047678, 0.07160808402781882, 0.08367909112344474, 0.09678721252234768, 0.06439252259632666, 0.026608324556568697, 0.03523401488081568, 0.08845816181393384, 0.08201221849344564, 0.06652552384871702, 0.10379887427069101, 0.03506955795189137, 0.09583743712334802, 0.06238536371200676, 0.06831022220272698, 0.1509058074141849, 0.12824574563087643, 0.08091656353617416, 0.07209102266123135, 0.15323226950213775, 0.037451277707310715, 0.13517733978943014, 0.11440969635665788, 0.06155165633647863, 0.16048364094935064, 0.15308450719885802, 0.04578440162634945, 0.08103266801413811, 0.5041949637635877, 0.4930486083270553, 0.47432274711804245, 0.5012241867233365, 0.5704194486357363, 0.5240651615184484, 0.4978309936419423, 0.5269269774663529, 0.5422853513140239, 0.12186345653454411, 0.10902137043649796, 0.10091538050236215, 0.1020781889489879, 0.13954827854216234, 0.13789721480315054, 0.14552413874742165, 0.13710511256162006, 0.08916071281406912, 0.37494592774662594, 0.3146158379895414, 0.3871773872423252, 0.2804615035495871, 0.38997620624047324, 0.21104722223577843, 0.24942653313003116, 0.18293605961909465, 0.20302282054132736, 0.336869267414285, 0.40642389731968864, 0.3824013612381738, 0.44073986420321276, 0.4013381955901183, 0.38927166578058636, 0.366863137205221, 0.461824620389817, 0.2761261120300472, 0.19290496412534008, 0.28805534057022764, 0.2338467042724547, 0.2397769308197416, 0.28626856270602796, 0.3002048796658904, 0.25599688648638574, 0.33365772471288924, 0.32019266825411064, 0.2320907409093762, 0.206657696453298, 0.20575930111533325, 0.23009167087780302, 0.24345244210670625, 0.20885067992167528, 0.21609570358677777, 0.3169775832378725, 0.22112037151771213, 0.5563630979379153, 0.19100237188368596, 0.226307082598048, 0.20064353662590395, 0.2326521344216651, 0.21466816325557492, 0.20102254887489068, 0.19823845967608278, 0.21869674651128956, 0.27996907013322814, 0.18341777571921702, 0.16288932031317127, 0.2772081077197922, 0.1992485903341492, 0.18730888242417987, 0.12635296922212313, 0.16086096874085964, 0.7947362386747938, 0.7103889293285129, 0.15583300828546343, 0.1252400905163913, 0.5880560374016026, 0.20805406688249672, 0.1510963849422695, 0.16163535915244398, 0.27128753208664724, 0.16156723769342785, 0.18573526273527674, 0.20712297518144462, 0.19818800193057606, 0.23042557024416332, 0.19750536081399572, 0.18560630051046145, 0.18781742390304645, 0.1952050964608738, 0.21118830219673435, 0.12903749123846175, 0.08895078463094941, 0.1385882276234095, 0.082690971468389, 0.13699094249729893, 0.07731298206951509, 0.12787500398292773, 0.09770651220927917, 0.11437889610044727]}, "mutation_prompt": null}
{"id": "05f8a739-8c98-4532-8612-cccdfe01845e", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE_v1:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Slightly increased for improved exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Adjusted for improved convergence\n        self.crossover_rate = 0.9  # Adjusted crossover rate for better exploration\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # Tweaked threshold for enhanced diversity management\n\n    def update_dynamic_params(self, evals):\n        self.scale_factor = 0.8 * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = 0.9 * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        diffs = np.subtract.outer(self.particles[:, 0], self.particles[:, 0])\n        return np.mean(np.abs(diffs))\n\n    def local_search(self, position):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.update_dynamic_params(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                inertia = 0.7 - 0.5 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.6 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.6 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n            # Additional local search for exploiting nearby potential\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    local_position = self.local_search(self.particles[i])\n                    score = func(local_position)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = local_position\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = local_position\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedHybridPSODE_v1", "description": "An enhanced swarm intelligence algorithm incorporating adaptive local search and refined parameter adjustments for improved convergence speed.", "configspace": "", "generation": 80, "fitness": 0.23245461721846802, "feedback": "The algorithm EnhancedHybridPSODE_v1 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.6046824303650893, 0.5285178425249868, 0.5620129235593043, 0.5408694451830094, 0.5645928947807544, 0.5120769343009883, 0.5189319318669905, 0.5881650560671206, 0.5681046186015601, 0.2244045653519574, 0.23802695764207538, 0.1240463741268748, 0.23467151869368807, 0.21347706165912583, 0.2425046824638042, 0.1965821497647423, 0.2154472231948209, 0.23208267419390305, 0.10115630072944004, 0.11709571964909427, 0.09656946891811513, 0.13150006721607965, 0.11099144231503555, 0.10698506942910024, 0.11809629812178069, 0.13640035927188598, 0.13214690204216217, 0.10577720507574828, 0.09604328572995458, 0.08089254688758807, 0.11170485564546229, 0.11837167360081458, 0.11022448198143886, 0.12382987290529124, 0.09142806086948607, 0.10467135276212791, 0.9317647501552452, 0.9531801122058012, 0.9661849245314074, 0.9656369232581704, 0.9516307121534386, 0.9508821042525695, 0.95238143635781, 0.9618944901391685, 0.9351951035094193, 0.31357322509463936, 0.2793491199054341, 0.2672315329742093, 0.3340557059464814, 0.28851468510576284, 0.27268034272368347, 0.3168659745006661, 0.3178909590653606, 0.3220761737715204, 0.32233097112222187, 0.21526021599147038, 0.5860019258605149, 0.27069173249619916, 0.6347696188567737, 0.1961514045909617, 0.3707618871314262, 0.4835256133204522, 0.33086901087510767, 0.10302327257989441, 0.14406115244680717, 0.18735851478960897, 0.10658801234719018, 0.1323087221124164, 0.16473641969404906, 0.16830269439242052, 0.09087264363223635, 0.14958373674728498, 0.14044367833587934, 0.09669126450685761, 0.15103414323534348, 0.12234554014196952, 0.12745188589388579, 0.20154962616942218, 0.11166659616250252, 0.11436083296913291, 0.1530020690197098, 9.999999999998899e-05, 0.0022967705287195717, 0.0032952497246773182, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002333227639399582, 0.02582766027326522, 0.05894269024150567, 0.029222245493439547, 0.128587083634492, 0.04485773850667085, 0.07295610784294404, 0.025452617270820155, 0.06593911827961074, 0.13167523011348714, 0.07463342217042324, 0.030446920203546113, 0.04055355235731328, 0.012539461580126421, 0.05756344294628457, 0.03347579568454473, 0.06103465779733919, 0.03328983414382869, 0.07543090339853586, 0.03096290966610471, 0.0682518897807628, 0.08936568545020784, 0.100701884339927, 0.11748005050678512, 0.15267905111328894, 0.026398656240676943, 0.04860419080817191, 0.06793550066506504, 0.12522270297474114, 0.4136157501883544, 0.44971115632954983, 0.3963226557605952, 0.4231480159385538, 0.44649922677277487, 0.4209976700937895, 0.4257947581227082, 0.42318934809766484, 0.4168270138387511, 0.12000068213232717, 0.1108390952930185, 0.12462907521339095, 0.10898267661188787, 0.1374274736551202, 0.10189404929760071, 0.09611164053023624, 0.09463018810108459, 0.103772294808116, 0.19218028264136866, 0.16229869421065435, 0.27314191575761027, 0.2168482007620509, 0.1733528901319078, 0.1795535053683166, 0.27641140039110335, 0.23715861755271095, 0.22829378903418995, 0.28385355310041116, 0.3029230952092794, 0.27218880547444235, 0.2947796445090277, 0.31317232226155023, 0.31854030769571107, 0.34384315339237126, 0.3139817402063856, 0.3291443677173874, 0.23728218380776167, 0.22067312722525412, 0.23268361467570897, 0.1813238907295316, 0.15803866080606055, 0.22552489867985392, 0.2545205209202883, 0.2950574440700795, 0.23396550348413825, 0.2110354475457964, 0.2239516728651142, 0.1961758878171742, 0.19349268081587467, 0.21265001692435248, 0.20728194721155746, 0.18322972024494089, 0.26047602812558657, 0.198779926859467, 0.21259608785349227, 0.2051313552436359, 0.2188557954506739, 0.35814452516169326, 0.20379363283065244, 0.32042839370930953, 0.19038032598426358, 0.18300088162274075, 0.18909409867200078, 0.15190667944005987, 0.15990070157844527, 0.7245543466628899, 0.14284285040253708, 0.19403241046275876, 0.190596439727016, 0.1397301061182894, 0.17009334624156058, 0.15415402481643903, 0.15095413444544536, 0.20069915855471765, 0.1660638973259383, 0.16531872867638797, 0.16633415743142344, 0.4331319589591278, 0.2928370555200823, 0.1620327985153659, 0.5502371423090187, 0.1951224279011038, 0.18231214025246323, 0.1938726784005138, 0.2014725168624384, 0.18502972706550835, 0.18001074455550947, 0.18943545099848214, 0.18763084778186834, 0.1885738274984683, 0.0807754340408352, 0.08931638813245113, 0.07643528508361574, 0.07876628404737929, 0.09348270012143933, 0.07574533594603128, 0.08560689190199466, 0.10156197306930537, 0.07772944286255001]}, "mutation_prompt": null}
{"id": "f2db6f43-09ad-460e-8966-a9ec96d8d483", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Adjusted population size for exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.85  # Subtle adjustment for convergence\n        self.initial_crossover_rate = 0.9  # Increased crossover rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # More sensitive threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.5 - 0.3 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.6, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizer", "description": "An enhanced swarm-based optimization algorithm with adaptive dynamic exploration and exploitation balancing for improved convergence efficiency.", "configspace": "", "generation": 81, "fitness": 0.2977404917950543, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "9440aa1e-7401-44a0-9b4f-4f7d528b27dc", "metadata": {"aucs": [0.7873735211004558, 0.7510879262362643, 0.7585180256460895, 0.7389902116523035, 0.7718647416762775, 0.775657991913916, 0.7762066639937368, 0.7736269432763563, 0.7407061985694982, 0.5199919318828887, 0.5909571019641116, 0.42913800273252534, 0.5115694475062527, 0.5728858525784097, 0.5429193123339109, 0.5576507171646499, 0.5129179624492375, 0.4551982025499207, 0.4070324454073826, 0.10704237581849652, 0.33884337298460065, 0.3348705007770105, 0.1464789622260969, 0.36623447809152965, 0.1451036092508191, 0.16274649973831878, 0.19473865017913394, 0.1256120128060707, 0.1324618465679943, 0.11483727015280765, 0.13774530079705383, 0.12440650146664445, 0.13841421724876313, 0.12941168385003798, 0.13758661437061415, 0.15985527765323526, 0.9448254247051189, 0.9769951147930914, 0.9692622293498611, 0.9747494753764656, 0.9675827278034648, 0.9768295538746795, 0.956662700172372, 0.9678719561930156, 0.9576433014212594, 0.4794968100271628, 0.5107458147858144, 0.500864557931393, 0.5153058292321011, 0.5046565123968861, 0.17690563831533745, 0.5382418591921018, 0.4600887849156867, 0.483607817371674, 0.2220407957649202, 0.699915644321186, 0.359144107993973, 0.20868405516292954, 0.8146689495882524, 0.7720675197471134, 0.21923615993886703, 0.20447533814376762, 0.23119630147560033, 0.19793546206182078, 0.17197361635666186, 0.14273126254911528, 0.18564899907222232, 0.1735675625321772, 0.16748504001114128, 0.17090651389992906, 0.1469530188739997, 0.18589080994879636, 0.19295915190904045, 0.10078317770894918, 0.17655349652476993, 0.2020804830849856, 0.21972015663181377, 0.14820756451635386, 0.15134825203562918, 0.20422425513124576, 0.2178992135341037, 9.999999999998899e-05, 0.004419577536056929, 0.04614251507095091, 0.03257639526994538, 0.04444682155597168, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02989087113161981, 0.09086224617314675, 0.07407543656645688, 0.07900272884867932, 0.032341941448128075, 0.0815099522892544, 0.038747458553372804, 0.10912521522915408, 0.06664350806293218, 0.05575531867352168, 0.05819275578585348, 0.032360795575969714, 0.12565252260813287, 0.06083435794486214, 0.06563690602896333, 0.07847549174906943, 0.12722927550935004, 0.12089301212502801, 0.12691222806249258, 0.039505282583523704, 0.09525314100826743, 0.1317815415936655, 0.12627359109731096, 0.14058561220748578, 0.054979127461302624, 0.07648050686123875, 0.07806331452935189, 0.4886976463881343, 0.5370291696649303, 0.5204216559397822, 0.5764915455301935, 0.4893426260011925, 0.5417469652231275, 0.5159297309749542, 0.537338871541675, 0.5313992158586365, 0.10829290518804735, 0.10251143618808511, 0.11137674907541417, 0.10281695116926826, 0.12596021896886356, 0.11201675367037167, 0.13267351434381502, 0.13120902196286188, 0.1091016014802797, 0.34940025863354185, 0.21415785372135387, 0.18797523425755946, 0.19344781447118087, 0.30773898351645523, 0.25705445350832246, 0.24670449422834073, 0.2051386787124706, 0.26896604533936896, 0.3589596643345626, 0.36679614024001295, 0.31325018121261805, 0.3588556386172034, 0.4043865250242882, 0.4507972387821466, 0.3840175321309295, 0.45453359507973234, 0.43102924038707713, 0.254544262576066, 0.2884694462273899, 0.24515132693462383, 0.2171915940594803, 0.2856420918608935, 0.27324310228149074, 0.31813634277915204, 0.33561292741208637, 0.19280665930882324, 0.2109653131921957, 0.212036228010277, 0.21086093220192292, 0.19290160608792162, 0.20544910450843978, 0.2011823084206864, 0.2199160504576846, 0.20243440632535326, 0.2040933735908459, 0.2385582594176765, 0.21646053742642157, 0.19632788924966638, 0.19094998391203555, 0.2405214000451691, 0.6386579530706349, 0.2439736178424884, 0.1929357318075956, 0.21259996585475127, 0.15562182177270856, 0.1614780857348873, 0.8161693349810039, 0.1564866025961228, 0.1982009600712632, 0.19621189669554173, 0.14118071359260653, 0.7977916638202609, 0.2020299628331571, 0.5442029050188573, 0.2094803062608176, 0.1685606167137399, 0.16727099106685495, 0.20695554307988318, 0.669264887681049, 0.2104488123164716, 0.67983829165854, 0.7879021157261776, 0.19309704884576717, 0.1808230193159247, 0.18317050674929103, 0.20039812146008218, 0.18670075092526783, 0.20969695373613706, 0.1936880189701291, 0.19662169558466602, 0.20324440561723334, 0.08820528472625588, 0.12722859333673842, 0.09581746555598092, 0.08491247470609975, 0.09361169000222125, 0.09046743406336188, 0.08720053292898611, 0.09353046757106098, 0.11878284565667696]}, "mutation_prompt": null}
{"id": "07be44b4-e4db-4123-a019-3ff601e23599", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Adjusted population size for exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.85  # Subtle adjustment for convergence\n        self.initial_crossover_rate = 0.9  # Increased crossover rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # More sensitive threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.5 - 0.3 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.6, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizer", "description": "An enhanced swarm-based optimization algorithm with adaptive dynamic exploration and exploitation balancing for improved convergence efficiency.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2db6f43-09ad-460e-8966-a9ec96d8d483", "metadata": {"aucs": [0.7873735211004558, 0.7510879262362643, 0.7585180256460895, 0.7389902116523035, 0.7718647416762775, 0.775657991913916, 0.7762066639937368, 0.7736269432763563, 0.7407061985694982, 0.5199919318828887, 0.5909571019641116, 0.42913800273252534, 0.5115694475062527, 0.5728858525784097, 0.5429193123339109, 0.5576507171646499, 0.5129179624492375, 0.4551982025499207, 0.4070324454073826, 0.10704237581849652, 0.33884337298460065, 0.3348705007770105, 0.1464789622260969, 0.36623447809152965, 0.1451036092508191, 0.16274649973831878, 0.19473865017913394, 0.1256120128060707, 0.1324618465679943, 0.11483727015280765, 0.13774530079705383, 0.12440650146664445, 0.13841421724876313, 0.12941168385003798, 0.13758661437061415, 0.15985527765323526, 0.9448254247051189, 0.9769951147930914, 0.9692622293498611, 0.9747494753764656, 0.9675827278034648, 0.9768295538746795, 0.956662700172372, 0.9678719561930156, 0.9576433014212594, 0.4794968100271628, 0.5107458147858144, 0.500864557931393, 0.5153058292321011, 0.5046565123968861, 0.17690563831533745, 0.5382418591921018, 0.4600887849156867, 0.483607817371674, 0.2220407957649202, 0.699915644321186, 0.359144107993973, 0.20868405516292954, 0.8146689495882524, 0.7720675197471134, 0.21923615993886703, 0.20447533814376762, 0.23119630147560033, 0.19793546206182078, 0.17197361635666186, 0.14273126254911528, 0.18564899907222232, 0.1735675625321772, 0.16748504001114128, 0.17090651389992906, 0.1469530188739997, 0.18589080994879636, 0.19295915190904045, 0.10078317770894918, 0.17655349652476993, 0.2020804830849856, 0.21972015663181377, 0.14820756451635386, 0.15134825203562918, 0.20422425513124576, 0.2178992135341037, 9.999999999998899e-05, 0.004419577536056929, 0.04614251507095091, 0.03257639526994538, 0.04444682155597168, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02989087113161981, 0.09086224617314675, 0.07407543656645688, 0.07900272884867932, 0.032341941448128075, 0.0815099522892544, 0.038747458553372804, 0.10912521522915408, 0.06664350806293218, 0.05575531867352168, 0.05819275578585348, 0.032360795575969714, 0.12565252260813287, 0.06083435794486214, 0.06563690602896333, 0.07847549174906943, 0.12722927550935004, 0.12089301212502801, 0.12691222806249258, 0.039505282583523704, 0.09525314100826743, 0.1317815415936655, 0.12627359109731096, 0.14058561220748578, 0.054979127461302624, 0.07648050686123875, 0.07806331452935189, 0.4886976463881343, 0.5370291696649303, 0.5204216559397822, 0.5764915455301935, 0.4893426260011925, 0.5417469652231275, 0.5159297309749542, 0.537338871541675, 0.5313992158586365, 0.10829290518804735, 0.10251143618808511, 0.11137674907541417, 0.10281695116926826, 0.12596021896886356, 0.11201675367037167, 0.13267351434381502, 0.13120902196286188, 0.1091016014802797, 0.34940025863354185, 0.21415785372135387, 0.18797523425755946, 0.19344781447118087, 0.30773898351645523, 0.25705445350832246, 0.24670449422834073, 0.2051386787124706, 0.26896604533936896, 0.3589596643345626, 0.36679614024001295, 0.31325018121261805, 0.3588556386172034, 0.4043865250242882, 0.4507972387821466, 0.3840175321309295, 0.45453359507973234, 0.43102924038707713, 0.254544262576066, 0.2884694462273899, 0.24515132693462383, 0.2171915940594803, 0.2856420918608935, 0.27324310228149074, 0.31813634277915204, 0.33561292741208637, 0.19280665930882324, 0.2109653131921957, 0.212036228010277, 0.21086093220192292, 0.19290160608792162, 0.20544910450843978, 0.2011823084206864, 0.2199160504576846, 0.20243440632535326, 0.2040933735908459, 0.2385582594176765, 0.21646053742642157, 0.19632788924966638, 0.19094998391203555, 0.2405214000451691, 0.6386579530706349, 0.2439736178424884, 0.1929357318075956, 0.21259996585475127, 0.15562182177270856, 0.1614780857348873, 0.8161693349810039, 0.1564866025961228, 0.1982009600712632, 0.19621189669554173, 0.14118071359260653, 0.7977916638202609, 0.2020299628331571, 0.5442029050188573, 0.2094803062608176, 0.1685606167137399, 0.16727099106685495, 0.20695554307988318, 0.669264887681049, 0.2104488123164716, 0.67983829165854, 0.7879021157261776, 0.19309704884576717, 0.1808230193159247, 0.18317050674929103, 0.20039812146008218, 0.18670075092526783, 0.20969695373613706, 0.1936880189701291, 0.19662169558466602, 0.20324440561723334, 0.08820528472625588, 0.12722859333673842, 0.09581746555598092, 0.08491247470609975, 0.09361169000222125, 0.09046743406336188, 0.08720053292898611, 0.09353046757106098, 0.11878284565667696]}, "mutation_prompt": null}
{"id": "2a3ee29c-3dbf-4d79-b865-220ad37079d5", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Adjusted population size for exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.85  # Subtle adjustment for convergence\n        self.initial_crossover_rate = 0.9  # Increased crossover rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # More sensitive threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.5 - 0.3 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.6, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizer", "description": "An enhanced swarm-based optimization algorithm with adaptive dynamic exploration and exploitation balancing for improved convergence efficiency.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2db6f43-09ad-460e-8966-a9ec96d8d483", "metadata": {"aucs": [0.7873735211004558, 0.7510879262362643, 0.7585180256460895, 0.7389902116523035, 0.7718647416762775, 0.775657991913916, 0.7762066639937368, 0.7736269432763563, 0.7407061985694982, 0.5199919318828887, 0.5909571019641116, 0.42913800273252534, 0.5115694475062527, 0.5728858525784097, 0.5429193123339109, 0.5576507171646499, 0.5129179624492375, 0.4551982025499207, 0.4070324454073826, 0.10704237581849652, 0.33884337298460065, 0.3348705007770105, 0.1464789622260969, 0.36623447809152965, 0.1451036092508191, 0.16274649973831878, 0.19473865017913394, 0.1256120128060707, 0.1324618465679943, 0.11483727015280765, 0.13774530079705383, 0.12440650146664445, 0.13841421724876313, 0.12941168385003798, 0.13758661437061415, 0.15985527765323526, 0.9448254247051189, 0.9769951147930914, 0.9692622293498611, 0.9747494753764656, 0.9675827278034648, 0.9768295538746795, 0.956662700172372, 0.9678719561930156, 0.9576433014212594, 0.4794968100271628, 0.5107458147858144, 0.500864557931393, 0.5153058292321011, 0.5046565123968861, 0.17690563831533745, 0.5382418591921018, 0.4600887849156867, 0.483607817371674, 0.2220407957649202, 0.699915644321186, 0.359144107993973, 0.20868405516292954, 0.8146689495882524, 0.7720675197471134, 0.21923615993886703, 0.20447533814376762, 0.23119630147560033, 0.19793546206182078, 0.17197361635666186, 0.14273126254911528, 0.18564899907222232, 0.1735675625321772, 0.16748504001114128, 0.17090651389992906, 0.1469530188739997, 0.18589080994879636, 0.19295915190904045, 0.10078317770894918, 0.17655349652476993, 0.2020804830849856, 0.21972015663181377, 0.14820756451635386, 0.15134825203562918, 0.20422425513124576, 0.2178992135341037, 9.999999999998899e-05, 0.004419577536056929, 0.04614251507095091, 0.03257639526994538, 0.04444682155597168, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02989087113161981, 0.09086224617314675, 0.07407543656645688, 0.07900272884867932, 0.032341941448128075, 0.0815099522892544, 0.038747458553372804, 0.10912521522915408, 0.06664350806293218, 0.05575531867352168, 0.05819275578585348, 0.032360795575969714, 0.12565252260813287, 0.06083435794486214, 0.06563690602896333, 0.07847549174906943, 0.12722927550935004, 0.12089301212502801, 0.12691222806249258, 0.039505282583523704, 0.09525314100826743, 0.1317815415936655, 0.12627359109731096, 0.14058561220748578, 0.054979127461302624, 0.07648050686123875, 0.07806331452935189, 0.4886976463881343, 0.5370291696649303, 0.5204216559397822, 0.5764915455301935, 0.4893426260011925, 0.5417469652231275, 0.5159297309749542, 0.537338871541675, 0.5313992158586365, 0.10829290518804735, 0.10251143618808511, 0.11137674907541417, 0.10281695116926826, 0.12596021896886356, 0.11201675367037167, 0.13267351434381502, 0.13120902196286188, 0.1091016014802797, 0.34940025863354185, 0.21415785372135387, 0.18797523425755946, 0.19344781447118087, 0.30773898351645523, 0.25705445350832246, 0.24670449422834073, 0.2051386787124706, 0.26896604533936896, 0.3589596643345626, 0.36679614024001295, 0.31325018121261805, 0.3588556386172034, 0.4043865250242882, 0.4507972387821466, 0.3840175321309295, 0.45453359507973234, 0.43102924038707713, 0.254544262576066, 0.2884694462273899, 0.24515132693462383, 0.2171915940594803, 0.2856420918608935, 0.27324310228149074, 0.31813634277915204, 0.33561292741208637, 0.19280665930882324, 0.2109653131921957, 0.212036228010277, 0.21086093220192292, 0.19290160608792162, 0.20544910450843978, 0.2011823084206864, 0.2199160504576846, 0.20243440632535326, 0.2040933735908459, 0.2385582594176765, 0.21646053742642157, 0.19632788924966638, 0.19094998391203555, 0.2405214000451691, 0.6386579530706349, 0.2439736178424884, 0.1929357318075956, 0.21259996585475127, 0.15562182177270856, 0.1614780857348873, 0.8161693349810039, 0.1564866025961228, 0.1982009600712632, 0.19621189669554173, 0.14118071359260653, 0.7977916638202609, 0.2020299628331571, 0.5442029050188573, 0.2094803062608176, 0.1685606167137399, 0.16727099106685495, 0.20695554307988318, 0.669264887681049, 0.2104488123164716, 0.67983829165854, 0.7879021157261776, 0.19309704884576717, 0.1808230193159247, 0.18317050674929103, 0.20039812146008218, 0.18670075092526783, 0.20969695373613706, 0.1936880189701291, 0.19662169558466602, 0.20324440561723334, 0.08820528472625588, 0.12722859333673842, 0.09581746555598092, 0.08491247470609975, 0.09361169000222125, 0.09046743406336188, 0.08720053292898611, 0.09353046757106098, 0.11878284565667696]}, "mutation_prompt": null}
{"id": "f1e03ebf-a10c-4c45-b265-9c6e18f13f49", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Adjusted population size for exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.85  # Subtle adjustment for convergence\n        self.initial_crossover_rate = 0.9  # Increased crossover rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # More sensitive threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.5 - 0.3 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.6, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizer", "description": "An enhanced swarm-based optimization algorithm with adaptive dynamic exploration and exploitation balancing for improved convergence efficiency.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2db6f43-09ad-460e-8966-a9ec96d8d483", "metadata": {"aucs": [0.7873735211004558, 0.7510879262362643, 0.7585180256460895, 0.7389902116523035, 0.7718647416762775, 0.775657991913916, 0.7762066639937368, 0.7736269432763563, 0.7407061985694982, 0.5199919318828887, 0.5909571019641116, 0.42913800273252534, 0.5115694475062527, 0.5728858525784097, 0.5429193123339109, 0.5576507171646499, 0.5129179624492375, 0.4551982025499207, 0.4070324454073826, 0.10704237581849652, 0.33884337298460065, 0.3348705007770105, 0.1464789622260969, 0.36623447809152965, 0.1451036092508191, 0.16274649973831878, 0.19473865017913394, 0.1256120128060707, 0.1324618465679943, 0.11483727015280765, 0.13774530079705383, 0.12440650146664445, 0.13841421724876313, 0.12941168385003798, 0.13758661437061415, 0.15985527765323526, 0.9448254247051189, 0.9769951147930914, 0.9692622293498611, 0.9747494753764656, 0.9675827278034648, 0.9768295538746795, 0.956662700172372, 0.9678719561930156, 0.9576433014212594, 0.4794968100271628, 0.5107458147858144, 0.500864557931393, 0.5153058292321011, 0.5046565123968861, 0.17690563831533745, 0.5382418591921018, 0.4600887849156867, 0.483607817371674, 0.2220407957649202, 0.699915644321186, 0.359144107993973, 0.20868405516292954, 0.8146689495882524, 0.7720675197471134, 0.21923615993886703, 0.20447533814376762, 0.23119630147560033, 0.19793546206182078, 0.17197361635666186, 0.14273126254911528, 0.18564899907222232, 0.1735675625321772, 0.16748504001114128, 0.17090651389992906, 0.1469530188739997, 0.18589080994879636, 0.19295915190904045, 0.10078317770894918, 0.17655349652476993, 0.2020804830849856, 0.21972015663181377, 0.14820756451635386, 0.15134825203562918, 0.20422425513124576, 0.2178992135341037, 9.999999999998899e-05, 0.004419577536056929, 0.04614251507095091, 0.03257639526994538, 0.04444682155597168, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02989087113161981, 0.09086224617314675, 0.07407543656645688, 0.07900272884867932, 0.032341941448128075, 0.0815099522892544, 0.038747458553372804, 0.10912521522915408, 0.06664350806293218, 0.05575531867352168, 0.05819275578585348, 0.032360795575969714, 0.12565252260813287, 0.06083435794486214, 0.06563690602896333, 0.07847549174906943, 0.12722927550935004, 0.12089301212502801, 0.12691222806249258, 0.039505282583523704, 0.09525314100826743, 0.1317815415936655, 0.12627359109731096, 0.14058561220748578, 0.054979127461302624, 0.07648050686123875, 0.07806331452935189, 0.4886976463881343, 0.5370291696649303, 0.5204216559397822, 0.5764915455301935, 0.4893426260011925, 0.5417469652231275, 0.5159297309749542, 0.537338871541675, 0.5313992158586365, 0.10829290518804735, 0.10251143618808511, 0.11137674907541417, 0.10281695116926826, 0.12596021896886356, 0.11201675367037167, 0.13267351434381502, 0.13120902196286188, 0.1091016014802797, 0.34940025863354185, 0.21415785372135387, 0.18797523425755946, 0.19344781447118087, 0.30773898351645523, 0.25705445350832246, 0.24670449422834073, 0.2051386787124706, 0.26896604533936896, 0.3589596643345626, 0.36679614024001295, 0.31325018121261805, 0.3588556386172034, 0.4043865250242882, 0.4507972387821466, 0.3840175321309295, 0.45453359507973234, 0.43102924038707713, 0.254544262576066, 0.2884694462273899, 0.24515132693462383, 0.2171915940594803, 0.2856420918608935, 0.27324310228149074, 0.31813634277915204, 0.33561292741208637, 0.19280665930882324, 0.2109653131921957, 0.212036228010277, 0.21086093220192292, 0.19290160608792162, 0.20544910450843978, 0.2011823084206864, 0.2199160504576846, 0.20243440632535326, 0.2040933735908459, 0.2385582594176765, 0.21646053742642157, 0.19632788924966638, 0.19094998391203555, 0.2405214000451691, 0.6386579530706349, 0.2439736178424884, 0.1929357318075956, 0.21259996585475127, 0.15562182177270856, 0.1614780857348873, 0.8161693349810039, 0.1564866025961228, 0.1982009600712632, 0.19621189669554173, 0.14118071359260653, 0.7977916638202609, 0.2020299628331571, 0.5442029050188573, 0.2094803062608176, 0.1685606167137399, 0.16727099106685495, 0.20695554307988318, 0.669264887681049, 0.2104488123164716, 0.67983829165854, 0.7879021157261776, 0.19309704884576717, 0.1808230193159247, 0.18317050674929103, 0.20039812146008218, 0.18670075092526783, 0.20969695373613706, 0.1936880189701291, 0.19662169558466602, 0.20324440561723334, 0.08820528472625588, 0.12722859333673842, 0.09581746555598092, 0.08491247470609975, 0.09361169000222125, 0.09046743406336188, 0.08720053292898611, 0.09353046757106098, 0.11878284565667696]}, "mutation_prompt": null}
{"id": "79e31099-36c1-44b0-a63c-620d963c3614", "solution": "import numpy as np\nfrom sklearn.ensemble import RandomForestRegressor\n\nclass HybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Reduced to integrate surrogate model\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.8\n        self.initial_crossover_rate = 0.85\n        self.iterations = self.budget // self.population_size\n        self.surrogate_model = RandomForestRegressor(n_estimators=10)\n        self.training_data = []\n        self.training_scores = []\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.6 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.6 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n                self.training_data.append(self.particles[i])\n                self.training_scores.append(score)\n\n            if len(self.training_data) >= 5 * self.dim:  # Train surrogate model after initial data\n                self.surrogate_model.fit(self.training_data, self.training_scores)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                if len(self.training_data) >= 5 * self.dim:\n                    surrogate_score = self.surrogate_model.predict([trial])[0]\n                    if surrogate_score < self.best_personal_scores[i]:\n                        score = func(trial)\n                        evaluations += 1\n                        if score < self.best_personal_scores[i]:\n                            self.particles[i] = trial\n                            self.best_personal_scores[i] = score\n                            self.best_personal_positions[i] = trial\n                            if score < self.best_global_score:\n                                self.best_global_score = score\n                                self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "HybridSwarmOptimizer", "description": "A hybrid swarm optimizer incorporating random forest surrogate model for enhanced convergence via informed sampling.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "f2db6f43-09ad-460e-8966-a9ec96d8d483", "metadata": {}, "mutation_prompt": null}
{"id": "71db053d-6e03-4933-acec-a6b86978b3a2", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.85\n        self.initial_crossover_rate = 0.9\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1\n        self.velocity_decay = 0.98  # New parameter for velocity decay\n        self.elite_size = 5  # Consider top particles\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n        self.elite_crossover_rate = 0.75 + 0.25 * (1 - evals / self.budget)  # New elite crossover dynamic\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = (0.5 - 0.3 * (evaluations / self.budget)) * self.velocity_decay\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            elite_indices = np.argsort(self.best_personal_scores)[:self.elite_size]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                if i in elite_indices:\n                    crossover_rate = self.elite_crossover_rate\n                else:\n                    crossover_rate = self.crossover_rate\n                \n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.6, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizer", "description": "A novel swarm optimizer with dynamic velocity adjustment and adaptive crossover for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.29539061070842626, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "f2db6f43-09ad-460e-8966-a9ec96d8d483", "metadata": {"aucs": [0.7991067336919965, 0.769694925909748, 0.7496372367732608, 0.747747913024116, 0.7761829030558856, 0.7964935344493309, 0.7428822820925218, 0.7960606902507793, 0.7235108232059235, 0.5349519613303305, 0.5296546819988803, 0.5107884628409513, 0.4913849188338387, 0.5498776370873883, 0.5606464051203858, 0.5305944163826115, 0.5305294383481352, 0.5503336184069985, 0.1515702919445665, 0.20975591327123733, 0.13999506358224312, 0.1362432017219375, 0.19366680336018116, 0.14499695379845723, 0.1564602885515456, 0.1606365005634831, 0.14190124584142194, 0.13892867259189812, 0.11459826889697833, 0.1463384267110197, 0.13931765475175362, 0.13841147217222038, 0.2925616677901628, 0.13566294252114164, 0.19446250642698604, 0.11419430376287942, 0.9729077937181505, 0.9578386359578197, 0.9675707320110798, 0.9647450170865742, 0.9571572471427587, 0.9657423617484092, 0.9571947387368981, 0.9777506836150158, 0.9680894025437108, 0.558369443705756, 0.47311127338913506, 0.5051754769506612, 0.1472606689687418, 0.4843555147075106, 0.37044620409460005, 0.4807290796776017, 0.4623203157831456, 0.47762770401292, 0.6710658596629874, 0.16971049959632933, 0.35964940648313926, 0.2084762893031994, 0.8417239404491043, 0.21569842908206915, 0.2340437744038406, 0.22092341204430166, 0.7578996116639167, 0.20282719330491195, 0.18076012454855284, 0.14730305747583283, 0.19130860227676194, 0.175228164442775, 0.20732982715698178, 0.170607635081923, 0.1779766021257666, 0.22634982627237432, 0.17800918763533047, 0.11717721275608095, 0.19527115487663949, 0.1913551881780735, 0.22418458593941815, 0.2020035067354652, 0.2113023943283664, 0.16213892014300524, 0.21195455216984072, 9.999999999998899e-05, 0.029122492521931442, 0.04565416011389167, 0.021556394741440665, 0.0019996352371135506, 0.07595465133401935, 9.999999999998899e-05, 9.999999999998899e-05, 0.03133628279534639, 0.054615149478831504, 0.08511956435325596, 0.013911544577539847, 0.04939538212682859, 0.08483157991096901, 0.05932019626444396, 0.05712377903873889, 0.0362552298944151, 0.09170198471418534, 0.0868624268283209, 0.004326613475164387, 0.04096109981098239, 0.09812364272761165, 0.06861010773384768, 0.13052808125370574, 0.08284803416277553, 0.13518935262593001, 0.11055326185558623, 0.27947147795711347, 0.0402704929585741, 0.23819781907713622, 0.11838515866277544, 0.1119941121496073, 0.10718041040115645, 0.24724806705532487, 0.07953595194860641, 0.15579322230329817, 0.49624789159595684, 0.47864842815101616, 0.5050009616237271, 0.5192495676034, 0.5460918313971024, 0.5523397135529051, 0.5557621892320288, 0.5145117526899234, 0.5044249049273388, 0.1418269823359113, 0.07358169386327196, 0.09271547770107791, 0.12223124247493433, 0.10091651881105679, 0.08248923258929752, 0.1032053497405977, 0.1418319640094, 0.1452454075802807, 0.16462582336460196, 0.2329555613938965, 0.13854344210253622, 0.19188233140474753, 0.28299874717146745, 0.3482978937418242, 0.18642675451183388, 0.29365559894035764, 0.2060547895580508, 0.3325448432711374, 0.34036419810561525, 0.35757161239484425, 0.30684044250380804, 0.40695890074986474, 0.43368277296202085, 0.4409288413317506, 0.46492955749477527, 0.4684166673954204, 0.2155134488883499, 0.2380294649041741, 0.35987591046110656, 0.1918364129178638, 0.2692725636150495, 0.20534016109126663, 0.4320787105391687, 0.2517624543226257, 0.2049403559039924, 0.21721623285027347, 0.1609323152013783, 0.2126778367779143, 0.20484663953884008, 0.19405087481162842, 0.21090530661305207, 0.2008363690984023, 0.22325670567323141, 0.22961050008009365, 0.19718353978867842, 0.18769219409624405, 0.20784764927738597, 0.23821720060726181, 0.20285166060121684, 0.5865430015501438, 0.20176780761682678, 0.21271387422250354, 0.5389685689288646, 0.17019250496313165, 0.16282287843743137, 0.8518308933274703, 0.7341758684233464, 0.19873277814807044, 0.1973241369713633, 0.14144862277557657, 0.16874107814551043, 0.16136614739878918, 0.4751887608611778, 0.2103687404144332, 0.6031074951615295, 0.16785461969230397, 0.11253744380785624, 0.19032183761624488, 0.20959423871414928, 0.6025913053893632, 0.7208100455583266, 0.19259767155406127, 0.19147074109235684, 0.19278113744428937, 0.19524425180503835, 0.18425652564512518, 0.18339438875498737, 0.19424274166378286, 0.18783923560533977, 0.17980578560504634, 0.10530657491916995, 0.11051915265012635, 0.09081000397759331, 0.06843129273288118, 0.08893869866802073, 0.0901423242199122, 0.10114113329902341, 0.090302082591462, 0.09264175358933224]}, "mutation_prompt": null}
{"id": "f21eb3e5-2217-478d-bbb2-ede59d58dfea", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Adjusted population size for exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.initial_scale_factor = 0.85  # Subtle adjustment for convergence\n        self.initial_crossover_rate = 0.9  # Increased crossover rate\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.1  # More sensitive threshold for diversity\n\n    def dynamic_parameters(self, evals):\n        self.scale_factor = self.initial_scale_factor * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n        self.crossover_rate = self.initial_crossover_rate * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            self.dynamic_parameters(evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.5 - 0.3 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.6, mutant, edge_mutation)\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizer", "description": "An enhanced swarm-based optimization algorithm with adaptive dynamic exploration and exploitation balancing for improved convergence efficiency.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2db6f43-09ad-460e-8966-a9ec96d8d483", "metadata": {"aucs": [0.7873735211004558, 0.7510879262362643, 0.7585180256460895, 0.7389902116523035, 0.7718647416762775, 0.775657991913916, 0.7762066639937368, 0.7736269432763563, 0.7407061985694982, 0.5199919318828887, 0.5909571019641116, 0.42913800273252534, 0.5115694475062527, 0.5728858525784097, 0.5429193123339109, 0.5576507171646499, 0.5129179624492375, 0.4551982025499207, 0.4070324454073826, 0.10704237581849652, 0.33884337298460065, 0.3348705007770105, 0.1464789622260969, 0.36623447809152965, 0.1451036092508191, 0.16274649973831878, 0.19473865017913394, 0.1256120128060707, 0.1324618465679943, 0.11483727015280765, 0.13774530079705383, 0.12440650146664445, 0.13841421724876313, 0.12941168385003798, 0.13758661437061415, 0.15985527765323526, 0.9448254247051189, 0.9769951147930914, 0.9692622293498611, 0.9747494753764656, 0.9675827278034648, 0.9768295538746795, 0.956662700172372, 0.9678719561930156, 0.9576433014212594, 0.4794968100271628, 0.5107458147858144, 0.500864557931393, 0.5153058292321011, 0.5046565123968861, 0.17690563831533745, 0.5382418591921018, 0.4600887849156867, 0.483607817371674, 0.2220407957649202, 0.699915644321186, 0.359144107993973, 0.20868405516292954, 0.8146689495882524, 0.7720675197471134, 0.21923615993886703, 0.20447533814376762, 0.23119630147560033, 0.19793546206182078, 0.17197361635666186, 0.14273126254911528, 0.18564899907222232, 0.1735675625321772, 0.16748504001114128, 0.17090651389992906, 0.1469530188739997, 0.18589080994879636, 0.19295915190904045, 0.10078317770894918, 0.17655349652476993, 0.2020804830849856, 0.21972015663181377, 0.14820756451635386, 0.15134825203562918, 0.20422425513124576, 0.2178992135341037, 9.999999999998899e-05, 0.004419577536056929, 0.04614251507095091, 0.03257639526994538, 0.04444682155597168, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02989087113161981, 0.09086224617314675, 0.07407543656645688, 0.07900272884867932, 0.032341941448128075, 0.0815099522892544, 0.038747458553372804, 0.10912521522915408, 0.06664350806293218, 0.05575531867352168, 0.05819275578585348, 0.032360795575969714, 0.12565252260813287, 0.06083435794486214, 0.06563690602896333, 0.07847549174906943, 0.12722927550935004, 0.12089301212502801, 0.12691222806249258, 0.039505282583523704, 0.09525314100826743, 0.1317815415936655, 0.12627359109731096, 0.14058561220748578, 0.054979127461302624, 0.07648050686123875, 0.07806331452935189, 0.4886976463881343, 0.5370291696649303, 0.5204216559397822, 0.5764915455301935, 0.4893426260011925, 0.5417469652231275, 0.5159297309749542, 0.537338871541675, 0.5313992158586365, 0.10829290518804735, 0.10251143618808511, 0.11137674907541417, 0.10281695116926826, 0.12596021896886356, 0.11201675367037167, 0.13267351434381502, 0.13120902196286188, 0.1091016014802797, 0.34940025863354185, 0.21415785372135387, 0.18797523425755946, 0.19344781447118087, 0.30773898351645523, 0.25705445350832246, 0.24670449422834073, 0.2051386787124706, 0.26896604533936896, 0.3589596643345626, 0.36679614024001295, 0.31325018121261805, 0.3588556386172034, 0.4043865250242882, 0.4507972387821466, 0.3840175321309295, 0.45453359507973234, 0.43102924038707713, 0.254544262576066, 0.2884694462273899, 0.24515132693462383, 0.2171915940594803, 0.2856420918608935, 0.27324310228149074, 0.31813634277915204, 0.33561292741208637, 0.19280665930882324, 0.2109653131921957, 0.212036228010277, 0.21086093220192292, 0.19290160608792162, 0.20544910450843978, 0.2011823084206864, 0.2199160504576846, 0.20243440632535326, 0.2040933735908459, 0.2385582594176765, 0.21646053742642157, 0.19632788924966638, 0.19094998391203555, 0.2405214000451691, 0.6386579530706349, 0.2439736178424884, 0.1929357318075956, 0.21259996585475127, 0.15562182177270856, 0.1614780857348873, 0.8161693349810039, 0.1564866025961228, 0.1982009600712632, 0.19621189669554173, 0.14118071359260653, 0.7977916638202609, 0.2020299628331571, 0.5442029050188573, 0.2094803062608176, 0.1685606167137399, 0.16727099106685495, 0.20695554307988318, 0.669264887681049, 0.2104488123164716, 0.67983829165854, 0.7879021157261776, 0.19309704884576717, 0.1808230193159247, 0.18317050674929103, 0.20039812146008218, 0.18670075092526783, 0.20969695373613706, 0.1936880189701291, 0.19662169558466602, 0.20324440561723334, 0.08820528472625588, 0.12722859333673842, 0.09581746555598092, 0.08491247470609975, 0.09361169000222125, 0.09046743406336188, 0.08720053292898611, 0.09353046757106098, 0.11878284565667696]}, "mutation_prompt": null}
{"id": "210e57c9-9aef-49ed-a5d1-09cbe9a383a4", "solution": "import numpy as np\n\nclass HybridEvolutionaryOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Simplified factor for mutation\n        self.crossover_rate = 0.9\n        self.iterations = self.budget // self.population_size\n        self.diversity_threshold = 0.05  # Increased sensitivity for diversity\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                inertia = 0.7 - 0.4 * (evaluations / self.budget)  # Changed inertia range\n                r1, r2 = np.random.uniform(size=self.dim), np.random.uniform(size=self.dim)\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            current_diversity = self.compute_diversity()\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                if current_diversity < self.diversity_threshold:\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.7, mutant, edge_mutation)  # Adjusted mutation probability\n                \n                trial = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                        trial[j] = mutant[j]\n                score = func(trial)\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.particles[i] = trial\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = trial\n                    if score < self.best_global_score:\n                        self.best_global_score = score\n                        self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "HybridEvolutionaryOptimizer", "description": "A hybrid evolutionary optimizer integrating adaptive differential mutation with swarm intelligence for enhanced convergence in black box optimization.", "configspace": "", "generation": 88, "fitness": 0.2521992063474497, "feedback": "The algorithm HybridEvolutionaryOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "f2db6f43-09ad-460e-8966-a9ec96d8d483", "metadata": {"aucs": [0.6348294017361042, 0.5968927632030371, 0.6356219859559689, 0.6797286669811167, 0.6273362275788066, 0.608013888029203, 0.6275484098492019, 0.5936125977952746, 0.6070880343171126, 0.3039711156555923, 0.3031731037301323, 0.3457396518731606, 0.17398237550538942, 0.22988055636012839, 0.2532590487861027, 0.2961948587469586, 0.2781714525617991, 0.1934388235629756, 0.09897822281020596, 0.11699635500671524, 0.12151276182373072, 0.18966707179868125, 0.11052991861236483, 0.10626469858601917, 0.17725740771916387, 0.14378064042613592, 0.09810892430867157, 0.10257094369369169, 0.1025918583318437, 0.1056131513232309, 0.11683189245141112, 0.116649867467992, 0.1254094554067111, 0.124127258917059, 0.10575441322215196, 0.08178969476445674, 0.9762522083998655, 0.9677037883362227, 0.9665521180671494, 0.9769244096109835, 0.9647400401153308, 0.97729998983919, 0.9677428410792516, 0.9671139112184411, 0.9692422789180757, 0.3888622047022131, 0.33135993202234426, 0.3370491866831171, 0.3364865398226765, 0.3448071593782418, 0.3496520336859672, 0.32491221666493675, 0.3578795345258603, 0.3484612746982243, 0.581243339112743, 0.5359881028022726, 0.5125732894108423, 0.19033226027562566, 0.3132016908026478, 0.4542478836439061, 0.5570278262121038, 0.2136379107684816, 0.36898422623326554, 0.14440167181144825, 0.19853402017189536, 0.14599568013868303, 0.10431515890911103, 0.1914415672047176, 0.13019527291278488, 0.1536403136597324, 0.16743462998709002, 0.2145818018333986, 0.27260173372054497, 0.12630076092179277, 0.10284945591790273, 0.21936790754356994, 0.1595294532640379, 0.16752741538204696, 0.1869543762742042, 0.17695347509679127, 0.11811881569826477, 0.004156639589688482, 0.003037712050683705, 9.999999999998899e-05, 0.02938247319688303, 0.05792999892584216, 9.999999999998899e-05, 0.002436252103143466, 9.999999999998899e-05, 0.014659632560492741, 0.1453324568180171, 0.0918505169652164, 0.09602168951552481, 0.030527831524289062, 0.09815699898088948, 0.01703561642113205, 0.05372184744022057, 0.04865866523211826, 0.0840065903028473, 0.046546937523764376, 0.020634450823845296, 0.052779799586052056, 0.10947285973520515, 0.05833163733567437, 0.04860828431342101, 0.05269317002147378, 0.12452653704505046, 0.07774686996007263, 0.12557765298727297, 0.042971272863293386, 0.06590298958546248, 0.13426809216508828, 0.05681629546508393, 0.15276330509402614, 0.045699541258211296, 0.06518376145461713, 0.07849277041824387, 0.46022545166617057, 0.46519090580723976, 0.4478735225406857, 0.43427514042866755, 0.44248531742701025, 0.5055722124220076, 0.43853906861641767, 0.4257315732499476, 0.42067474114724224, 0.11813718185112831, 0.10923596567392124, 0.10318576525022038, 0.10874846916136627, 0.11834815677667687, 0.09975606084997857, 0.10033426086014696, 0.07099124378834354, 0.11583929890433087, 0.29515670233998603, 0.2222792465097888, 0.2060575176862982, 0.21076242071580853, 0.20254313155206827, 0.15183623759646014, 0.2327104804716713, 0.20648642335361334, 0.19192083440881413, 0.25596960075141384, 0.2912791123541686, 0.32535176500687235, 0.30644255603381143, 0.3245430537366881, 0.31925092680584355, 0.3763963012023509, 0.32294832259764217, 0.2604009226623448, 0.19752044919461886, 0.1820317894232708, 0.3022844268897177, 0.2042884144359185, 0.245816614482269, 0.27416237997378834, 0.2663540122046758, 0.22793386409442773, 0.2740731795007928, 0.2064308807763191, 0.21020079749869625, 0.1907704934479686, 0.1905161390901241, 0.21027249515937874, 0.21150585810878209, 0.19397610934475196, 0.22184623398819514, 0.19839658891827872, 0.18146706518928646, 0.20741245331940528, 0.41911820217155726, 0.2050686450885496, 0.3686644233584794, 0.4265479973355131, 0.3213193552439414, 0.20818314642553604, 0.20307791790355612, 0.16414038639012363, 0.7807556093851014, 0.20166029913750605, 0.6992664719791831, 0.1966086492046656, 0.12256148564190239, 0.14099778896377624, 0.16746993117426223, 0.18085441409927916, 0.36506828580028594, 0.20561753384920123, 0.16626788041250706, 0.6670012133002557, 0.1505479922079228, 0.162729428471991, 0.2181847892686981, 0.10367717289132483, 0.20786151209526482, 0.20790445453618744, 0.17739741676890952, 0.17961713423698145, 0.21493505707671734, 0.18239594702659645, 0.19562639129578696, 0.19439959431738685, 0.18026940529889257, 0.20333385410112637, 0.07894331698429524, 0.0816704137151626, 0.07924717997736785, 0.07915573388943609, 0.07826259844529881, 0.09551049023736846, 0.10370659839371399, 0.10704628923535187, 0.06744567082521857]}, "mutation_prompt": null}
{"id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Adjusted population size for efficiency\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Fixed scale factor for consistency\n        self.crossover_rate = 0.85  # Reduced crossover rate\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15  # Dynamic threshold based on diversity measure\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.2 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV2", "description": "A modified swarm optimization with adaptive diversity management and enhanced parameter tuning for improved convergence speed.", "configspace": "", "generation": 89, "fitness": 0.3298954224497103, "feedback": "The algorithm EnhancedSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "f2db6f43-09ad-460e-8966-a9ec96d8d483", "metadata": {"aucs": [0.8762743937486778, 0.8673829656899147, 0.8782881677431872, 0.8581318282924161, 0.8605200732474104, 0.8704777471747678, 0.8669501535914438, 0.8767913976636248, 0.8697271807471996, 0.7292592142782701, 0.6958860554492716, 0.6862661905742402, 0.7096497551220675, 0.7167364303086643, 0.7381799447205526, 0.6943872628972643, 0.7088893327988407, 0.720371945202172, 0.3482948532021707, 0.15349288652780446, 0.5051223420989501, 0.15907635784631602, 0.5070164809046678, 0.5280492563109339, 0.447443175757282, 0.26325781945678906, 0.3898003605139132, 0.1388205895773239, 0.1467129287993708, 0.14141217358013514, 0.13389562611085915, 0.1156575963635158, 0.1627314511994138, 0.16363926862956035, 0.14527747050295692, 0.1589943207702187, 0.981855484622502, 0.9795881701807362, 0.9748156162543172, 0.9792088726802245, 0.9798193702692622, 0.9742668333733502, 0.98140298251034, 0.9800328698541079, 0.9808580820685565, 0.7112806484615446, 0.6000664272177662, 0.7307347984989904, 0.55210153228452, 0.33804871219618804, 0.19747862555160034, 0.5365519153146263, 0.6723982565749891, 0.6393792066251385, 0.22584340034636685, 0.15781436012425798, 0.2265530861449211, 0.2188287847075855, 0.21597035463092584, 0.8428236758470273, 0.8089726098878465, 0.24128420105806636, 0.3995593438679347, 0.2606170066166147, 0.23403238541779725, 0.2812271903547767, 0.22271865255321, 0.2067103996056967, 0.17447785651177272, 0.2232835619792518, 0.18667330168152307, 0.20106938831754673, 0.2134313419697863, 0.12985846619541241, 0.2216158000745594, 0.13262726627682464, 0.23546448823381283, 0.13350769987844346, 0.2537378399053595, 0.25746632532602454, 0.2545912574950835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07826185666345442, 0.03842796887265354, 0.00954189234284153, 0.0016162389967913082, 9.999999999998899e-05, 0.0649678482172128, 0.12183228050334549, 0.05150865374764069, 0.1419288485191178, 0.08158563968775401, 0.046950876493785265, 0.03310871631851242, 0.09279807604728407, 0.0684269337962935, 0.08628777550082034, 0.08491712185139344, 0.06281625175589267, 0.2170775971647243, 0.07312672777825269, 0.07446200812423576, 0.0764443909580863, 0.09527675853290207, 0.14173340112962363, 0.08275516461664212, 0.09846662918237381, 0.06791304111850005, 0.042796141020220446, 0.19568566690772315, 0.16752478765476297, 0.2659323932089819, 0.055267141019859856, 0.04892446069501999, 0.14667803387140232, 0.5198636877279188, 0.5219048086962947, 0.511545939221538, 0.5112223206059087, 0.5340323763669241, 0.5563244343353202, 0.5742717285964551, 0.5647306395570708, 0.5536905361127811, 0.12241076564682174, 0.11494734577112031, 0.15273562711565158, 0.1074108133720807, 0.10804483168519141, 0.09735763809088294, 0.12139787980916805, 0.1396057656870029, 0.10937161739736967, 0.2678544577086429, 0.24955233264257082, 0.16540011921814313, 0.3431233683573399, 0.44517819615215115, 0.23138748587235236, 0.27726190959484787, 0.27343225505877666, 0.2004636853906162, 0.2545678207548052, 0.3419246339245494, 0.31485807500722895, 0.20726594080029037, 0.310990550555139, 0.31910469952571974, 0.22800629302817454, 0.43738972624716477, 0.272219777406865, 0.22146828796140194, 0.32118420889092203, 0.22990515740344208, 0.3046479143364662, 0.31049314466937616, 0.24985121338727723, 0.19605035496554446, 0.1942166044641298, 0.31216131996166563, 0.19635170010466285, 0.21716336094419408, 0.25721860315265654, 0.22690595076019338, 0.19566595945495568, 0.22292694899091126, 0.21560579489066467, 0.20816422400674783, 0.2174779711753957, 0.20598666448328262, 0.20297489130983914, 0.21699828568699642, 0.21578567323590325, 0.1903859017234858, 0.22032744189409625, 0.17705823682144983, 0.20301479107422515, 0.19500159798981753, 0.16206365824024693, 0.16835604233037316, 0.9100399329875795, 0.9016202320026829, 0.16222687767946664, 0.9119944374182469, 0.16785206685794496, 0.17787332323642513, 0.16725373503374308, 0.893422122778117, 0.45465575473074893, 0.8778521529472461, 0.6641187459079781, 0.21169237502874905, 0.20955283424003968, 0.7957405213060387, 0.16867668469839248, 0.8312943130294401, 0.19467361755248092, 0.19208686446620704, 0.18341450133484727, 0.18749797016410408, 0.18427915326384414, 0.17912732946542198, 0.19749822318214105, 0.18483766558637915, 0.1895540741357239, 0.09161246566133086, 0.09583784803259443, 0.08760405648611158, 0.09673271305585673, 0.0917121373233627, 0.10948415130475642, 0.10061135216891415, 0.08131304113139393, 0.08845121834045477]}, "mutation_prompt": null}
{"id": "a4477e4f-5fe0-4807-9c60-17390b474ec6", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8\n        self.crossover_rate = 0.85\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def local_search(self, particle):\n        noise = np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(particle + noise, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.5 - 0.3 * (evaluations / self.budget)\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    if np.random.rand() < 0.1:  # Incorporating local search\n                        trial = self.local_search(trial)\n\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV3", "description": "Integrated a hybrid strategy combining adaptive inertia with local search and refined mutation for enhanced convergence.", "configspace": "", "generation": 90, "fitness": 0.3123552079572985, "feedback": "The algorithm EnhancedSwarmOptimizerV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.8240519727622041, 0.8419774471926826, 0.8254983932429891, 0.831936669270978, 0.8181584343108081, 0.8477693198347451, 0.83989899884785, 0.8448836099984636, 0.8342499948628357, 0.6417888671919558, 0.6569605896403257, 0.6336644767294779, 0.6158356597744007, 0.6230662190407407, 0.6645625713363243, 0.6351655912299855, 0.6443163449577675, 0.6059056270288302, 0.5474348762604488, 0.134197585044892, 0.15869580209597334, 0.16265375276431937, 0.5593575796384844, 0.2460784209542476, 0.1370161794202326, 0.5342668098902719, 0.1335010200162131, 0.16165356697943511, 0.13602923632071906, 0.14029838018992724, 0.12461649667526709, 0.15127789534977398, 0.15352261925926158, 0.19187061476343925, 0.149229101896873, 0.12779555453135394, 0.9884494082848561, 0.9796220202648653, 0.9787066372561558, 0.9796035802898435, 0.9808110543743637, 0.9801086597812302, 0.9780712109551595, 0.9808404798178368, 0.9812570900506409, 0.6402921728962372, 0.43217248120586294, 0.4017072068887747, 0.6214757581035673, 0.5904629642777239, 0.6186270551150654, 0.664413638772992, 0.6466669117036501, 0.6680732223130683, 0.3921048703514237, 0.22405767510965624, 0.22431929903139536, 0.19478241262295193, 0.2089878417937161, 0.279237949551867, 0.230057215326527, 0.2169065102228649, 0.36062380591784426, 0.20543940136002503, 0.35482410173832457, 0.322390608762513, 0.18949877836312246, 0.2298374500514918, 0.19616787282269366, 0.213561373326843, 0.19565613992806896, 0.206203255747749, 0.22572554100203623, 0.2404339147169784, 0.12921573779765116, 0.2936149565890922, 0.13023424561822194, 0.253068857723337, 0.1294201566952612, 0.2389321842013078, 0.22417502903815334, 9.999999999998899e-05, 0.07108296534858272, 0.04353079864053111, 0.040540729359691774, 9.999999999998899e-05, 0.03331682018284843, 0.007057045482982693, 9.999999999998899e-05, 0.018125851611558774, 0.06669014310558141, 0.07651766821015904, 0.11671654583273872, 0.0795603824211143, 0.03107528625306677, 0.0442734180507961, 0.08110248677883924, 0.07730876953789101, 0.0831642529461235, 0.04499490942101547, 0.029453569656558987, 0.0446317771525806, 0.08016212170433323, 0.07242651563246638, 0.07493046517177049, 0.09464778270916052, 0.09061817478930356, 0.09280372629633638, 0.07107122073396366, 0.042436658756126455, 0.11013523047687124, 0.0586149843086472, 0.09389954538248035, 0.25716262809178914, 0.054804567744697996, 0.04901616004124976, 0.07900253209192176, 0.6227052335428845, 0.5168134174310746, 0.5477846659815264, 0.5189016792264909, 0.511729798561199, 0.5107204399952823, 0.5227233937746927, 0.5469700619697626, 0.5204591850585915, 0.06627489993227431, 0.13996575244741094, 0.09608780867117162, 0.0870453265052824, 0.1384288900883155, 0.14038209370880816, 0.13033107945765365, 0.08586173773415684, 0.11533632945849437, 0.26029627500293906, 0.1865276899452002, 0.1577792560965563, 0.16459089116432457, 0.3633850668136335, 0.19871169327623817, 0.21649464565346366, 0.19953038305428072, 0.17589594656557328, 0.5063773336731947, 0.46872300535110045, 0.28415726362862437, 0.3363550239655335, 0.5610377848129329, 0.32454630277331487, 0.46675843384126103, 0.355430098685502, 0.530456205656849, 0.33775363896015065, 0.337878335093052, 0.22455057620160823, 0.16089224368854993, 0.28079697514680724, 0.2540627847704806, 0.1943555929893288, 0.23752016152751199, 0.3482796791657783, 0.19851848619021295, 0.20946325603456517, 0.22527784289490405, 0.19782342239063577, 0.1957318796718931, 0.24282465856907298, 0.2020980751952578, 0.24223167020197567, 0.20482311168428713, 0.20750417186040715, 0.2490341983470975, 0.21691495015224205, 0.18868525398828406, 0.1920985149159019, 0.19674225568918924, 0.1848820051602802, 0.23950790627087004, 0.19174821474503345, 0.16209523299604478, 0.35968249338893354, 0.8325470852440283, 0.8908746011181341, 0.2085254949062484, 0.8618405379435151, 0.1496982670317487, 0.1690217811686271, 0.16741767866099233, 0.8302361319871351, 0.1551109142625242, 0.4935926917537218, 0.2043141557028132, 0.21124638823126018, 0.2092287772200524, 0.7933577411941131, 0.16773988111374816, 0.16646902438549516, 0.18269253346032732, 0.19948735217874647, 0.21844244220993614, 0.19589169108419768, 0.19680521187524558, 0.20280187477723954, 0.19324791825901422, 0.19916909538257632, 0.19824989390716774, 0.08443042890829278, 0.14969359620051803, 0.1466659485480437, 0.11716991203144156, 0.09738964249175375, 0.11392924729157838, 0.10540271173368587, 0.10348659218146372, 0.08199424194385696]}, "mutation_prompt": null}
{"id": "0d155f6c-1788-41d9-840d-b082e0dbe574", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Adjusted population size for efficiency\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Fixed scale factor for consistency\n        self.crossover_rate = 0.85  # Reduced crossover rate\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15  # Dynamic threshold based on diversity measure\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.2 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV2", "description": "A modified swarm optimization with adaptive diversity management and enhanced parameter tuning for improved convergence speed.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.8762743937486778, 0.8673829656899147, 0.8782881677431872, 0.8581318282924161, 0.8605200732474104, 0.8704777471747678, 0.8669501535914438, 0.8767913976636248, 0.8697271807471996, 0.7292592142782701, 0.6958860554492716, 0.6862661905742402, 0.7096497551220675, 0.7167364303086643, 0.7381799447205526, 0.6943872628972643, 0.7088893327988407, 0.720371945202172, 0.3482948532021707, 0.15349288652780446, 0.5051223420989501, 0.15907635784631602, 0.5070164809046678, 0.5280492563109339, 0.447443175757282, 0.26325781945678906, 0.3898003605139132, 0.1388205895773239, 0.1467129287993708, 0.14141217358013514, 0.13389562611085915, 0.1156575963635158, 0.1627314511994138, 0.16363926862956035, 0.14527747050295692, 0.1589943207702187, 0.981855484622502, 0.9795881701807362, 0.9748156162543172, 0.9792088726802245, 0.9798193702692622, 0.9742668333733502, 0.98140298251034, 0.9800328698541079, 0.9808580820685565, 0.7112806484615446, 0.6000664272177662, 0.7307347984989904, 0.55210153228452, 0.33804871219618804, 0.19747862555160034, 0.5365519153146263, 0.6723982565749891, 0.6393792066251385, 0.22584340034636685, 0.15781436012425798, 0.2265530861449211, 0.2188287847075855, 0.21597035463092584, 0.8428236758470273, 0.8089726098878465, 0.24128420105806636, 0.3995593438679347, 0.2606170066166147, 0.23403238541779725, 0.2812271903547767, 0.22271865255321, 0.2067103996056967, 0.17447785651177272, 0.2232835619792518, 0.18667330168152307, 0.20106938831754673, 0.2134313419697863, 0.12985846619541241, 0.2216158000745594, 0.13262726627682464, 0.23546448823381283, 0.13350769987844346, 0.2537378399053595, 0.25746632532602454, 0.2545912574950835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07826185666345442, 0.03842796887265354, 0.00954189234284153, 0.0016162389967913082, 9.999999999998899e-05, 0.0649678482172128, 0.12183228050334549, 0.05150865374764069, 0.1419288485191178, 0.08158563968775401, 0.046950876493785265, 0.03310871631851242, 0.09279807604728407, 0.0684269337962935, 0.08628777550082034, 0.08491712185139344, 0.06281625175589267, 0.2170775971647243, 0.07312672777825269, 0.07446200812423576, 0.0764443909580863, 0.09527675853290207, 0.14173340112962363, 0.08275516461664212, 0.09846662918237381, 0.06791304111850005, 0.042796141020220446, 0.19568566690772315, 0.16752478765476297, 0.2659323932089819, 0.055267141019859856, 0.04892446069501999, 0.14667803387140232, 0.5198636877279188, 0.5219048086962947, 0.511545939221538, 0.5112223206059087, 0.5340323763669241, 0.5563244343353202, 0.5742717285964551, 0.5647306395570708, 0.5536905361127811, 0.12241076564682174, 0.11494734577112031, 0.15273562711565158, 0.1074108133720807, 0.10804483168519141, 0.09735763809088294, 0.12139787980916805, 0.1396057656870029, 0.10937161739736967, 0.2678544577086429, 0.24955233264257082, 0.16540011921814313, 0.3431233683573399, 0.44517819615215115, 0.23138748587235236, 0.27726190959484787, 0.27343225505877666, 0.2004636853906162, 0.2545678207548052, 0.3419246339245494, 0.31485807500722895, 0.20726594080029037, 0.310990550555139, 0.31910469952571974, 0.22800629302817454, 0.43738972624716477, 0.272219777406865, 0.22146828796140194, 0.32118420889092203, 0.22990515740344208, 0.3046479143364662, 0.31049314466937616, 0.24985121338727723, 0.19605035496554446, 0.1942166044641298, 0.31216131996166563, 0.19635170010466285, 0.21716336094419408, 0.25721860315265654, 0.22690595076019338, 0.19566595945495568, 0.22292694899091126, 0.21560579489066467, 0.20816422400674783, 0.2174779711753957, 0.20598666448328262, 0.20297489130983914, 0.21699828568699642, 0.21578567323590325, 0.1903859017234858, 0.22032744189409625, 0.17705823682144983, 0.20301479107422515, 0.19500159798981753, 0.16206365824024693, 0.16835604233037316, 0.9100399329875795, 0.9016202320026829, 0.16222687767946664, 0.9119944374182469, 0.16785206685794496, 0.17787332323642513, 0.16725373503374308, 0.893422122778117, 0.45465575473074893, 0.8778521529472461, 0.6641187459079781, 0.21169237502874905, 0.20955283424003968, 0.7957405213060387, 0.16867668469839248, 0.8312943130294401, 0.19467361755248092, 0.19208686446620704, 0.18341450133484727, 0.18749797016410408, 0.18427915326384414, 0.17912732946542198, 0.19749822318214105, 0.18483766558637915, 0.1895540741357239, 0.09161246566133086, 0.09583784803259443, 0.08760405648611158, 0.09673271305585673, 0.0917121373233627, 0.10948415130475642, 0.10061135216891415, 0.08131304113139393, 0.08845121834045477]}, "mutation_prompt": null}
{"id": "c845f78b-9161-4312-aafb-b553af83c50f", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Adjusted population size for efficiency\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Fixed scale factor for consistency\n        self.crossover_rate = 0.85  # Reduced crossover rate\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15  # Dynamic threshold based on diversity measure\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.2 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV2", "description": "A modified swarm optimization with adaptive diversity management and enhanced parameter tuning for improved convergence speed.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.8762743937486778, 0.8673829656899147, 0.8782881677431872, 0.8581318282924161, 0.8605200732474104, 0.8704777471747678, 0.8669501535914438, 0.8767913976636248, 0.8697271807471996, 0.7292592142782701, 0.6958860554492716, 0.6862661905742402, 0.7096497551220675, 0.7167364303086643, 0.7381799447205526, 0.6943872628972643, 0.7088893327988407, 0.720371945202172, 0.3482948532021707, 0.15349288652780446, 0.5051223420989501, 0.15907635784631602, 0.5070164809046678, 0.5280492563109339, 0.447443175757282, 0.26325781945678906, 0.3898003605139132, 0.1388205895773239, 0.1467129287993708, 0.14141217358013514, 0.13389562611085915, 0.1156575963635158, 0.1627314511994138, 0.16363926862956035, 0.14527747050295692, 0.1589943207702187, 0.981855484622502, 0.9795881701807362, 0.9748156162543172, 0.9792088726802245, 0.9798193702692622, 0.9742668333733502, 0.98140298251034, 0.9800328698541079, 0.9808580820685565, 0.7112806484615446, 0.6000664272177662, 0.7307347984989904, 0.55210153228452, 0.33804871219618804, 0.19747862555160034, 0.5365519153146263, 0.6723982565749891, 0.6393792066251385, 0.22584340034636685, 0.15781436012425798, 0.2265530861449211, 0.2188287847075855, 0.21597035463092584, 0.8428236758470273, 0.8089726098878465, 0.24128420105806636, 0.3995593438679347, 0.2606170066166147, 0.23403238541779725, 0.2812271903547767, 0.22271865255321, 0.2067103996056967, 0.17447785651177272, 0.2232835619792518, 0.18667330168152307, 0.20106938831754673, 0.2134313419697863, 0.12985846619541241, 0.2216158000745594, 0.13262726627682464, 0.23546448823381283, 0.13350769987844346, 0.2537378399053595, 0.25746632532602454, 0.2545912574950835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07826185666345442, 0.03842796887265354, 0.00954189234284153, 0.0016162389967913082, 9.999999999998899e-05, 0.0649678482172128, 0.12183228050334549, 0.05150865374764069, 0.1419288485191178, 0.08158563968775401, 0.046950876493785265, 0.03310871631851242, 0.09279807604728407, 0.0684269337962935, 0.08628777550082034, 0.08491712185139344, 0.06281625175589267, 0.2170775971647243, 0.07312672777825269, 0.07446200812423576, 0.0764443909580863, 0.09527675853290207, 0.14173340112962363, 0.08275516461664212, 0.09846662918237381, 0.06791304111850005, 0.042796141020220446, 0.19568566690772315, 0.16752478765476297, 0.2659323932089819, 0.055267141019859856, 0.04892446069501999, 0.14667803387140232, 0.5198636877279188, 0.5219048086962947, 0.511545939221538, 0.5112223206059087, 0.5340323763669241, 0.5563244343353202, 0.5742717285964551, 0.5647306395570708, 0.5536905361127811, 0.12241076564682174, 0.11494734577112031, 0.15273562711565158, 0.1074108133720807, 0.10804483168519141, 0.09735763809088294, 0.12139787980916805, 0.1396057656870029, 0.10937161739736967, 0.2678544577086429, 0.24955233264257082, 0.16540011921814313, 0.3431233683573399, 0.44517819615215115, 0.23138748587235236, 0.27726190959484787, 0.27343225505877666, 0.2004636853906162, 0.2545678207548052, 0.3419246339245494, 0.31485807500722895, 0.20726594080029037, 0.310990550555139, 0.31910469952571974, 0.22800629302817454, 0.43738972624716477, 0.272219777406865, 0.22146828796140194, 0.32118420889092203, 0.22990515740344208, 0.3046479143364662, 0.31049314466937616, 0.24985121338727723, 0.19605035496554446, 0.1942166044641298, 0.31216131996166563, 0.19635170010466285, 0.21716336094419408, 0.25721860315265654, 0.22690595076019338, 0.19566595945495568, 0.22292694899091126, 0.21560579489066467, 0.20816422400674783, 0.2174779711753957, 0.20598666448328262, 0.20297489130983914, 0.21699828568699642, 0.21578567323590325, 0.1903859017234858, 0.22032744189409625, 0.17705823682144983, 0.20301479107422515, 0.19500159798981753, 0.16206365824024693, 0.16835604233037316, 0.9100399329875795, 0.9016202320026829, 0.16222687767946664, 0.9119944374182469, 0.16785206685794496, 0.17787332323642513, 0.16725373503374308, 0.893422122778117, 0.45465575473074893, 0.8778521529472461, 0.6641187459079781, 0.21169237502874905, 0.20955283424003968, 0.7957405213060387, 0.16867668469839248, 0.8312943130294401, 0.19467361755248092, 0.19208686446620704, 0.18341450133484727, 0.18749797016410408, 0.18427915326384414, 0.17912732946542198, 0.19749822318214105, 0.18483766558637915, 0.1895540741357239, 0.09161246566133086, 0.09583784803259443, 0.08760405648611158, 0.09673271305585673, 0.0917121373233627, 0.10948415130475642, 0.10061135216891415, 0.08131304113139393, 0.08845121834045477]}, "mutation_prompt": null}
{"id": "61ec5870-7712-40fd-8a4d-c22e493d13d2", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Adjusted population size for efficiency\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Fixed scale factor for consistency\n        self.crossover_rate = 0.85  # Reduced crossover rate\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15  # Dynamic threshold based on diversity measure\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.2 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV2", "description": "A modified swarm optimization with adaptive diversity management and enhanced parameter tuning for improved convergence speed.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.8762743937486778, 0.8673829656899147, 0.8782881677431872, 0.8581318282924161, 0.8605200732474104, 0.8704777471747678, 0.8669501535914438, 0.8767913976636248, 0.8697271807471996, 0.7292592142782701, 0.6958860554492716, 0.6862661905742402, 0.7096497551220675, 0.7167364303086643, 0.7381799447205526, 0.6943872628972643, 0.7088893327988407, 0.720371945202172, 0.3482948532021707, 0.15349288652780446, 0.5051223420989501, 0.15907635784631602, 0.5070164809046678, 0.5280492563109339, 0.447443175757282, 0.26325781945678906, 0.3898003605139132, 0.1388205895773239, 0.1467129287993708, 0.14141217358013514, 0.13389562611085915, 0.1156575963635158, 0.1627314511994138, 0.16363926862956035, 0.14527747050295692, 0.1589943207702187, 0.981855484622502, 0.9795881701807362, 0.9748156162543172, 0.9792088726802245, 0.9798193702692622, 0.9742668333733502, 0.98140298251034, 0.9800328698541079, 0.9808580820685565, 0.7112806484615446, 0.6000664272177662, 0.7307347984989904, 0.55210153228452, 0.33804871219618804, 0.19747862555160034, 0.5365519153146263, 0.6723982565749891, 0.6393792066251385, 0.22584340034636685, 0.15781436012425798, 0.2265530861449211, 0.2188287847075855, 0.21597035463092584, 0.8428236758470273, 0.8089726098878465, 0.24128420105806636, 0.3995593438679347, 0.2606170066166147, 0.23403238541779725, 0.2812271903547767, 0.22271865255321, 0.2067103996056967, 0.17447785651177272, 0.2232835619792518, 0.18667330168152307, 0.20106938831754673, 0.2134313419697863, 0.12985846619541241, 0.2216158000745594, 0.13262726627682464, 0.23546448823381283, 0.13350769987844346, 0.2537378399053595, 0.25746632532602454, 0.2545912574950835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07826185666345442, 0.03842796887265354, 0.00954189234284153, 0.0016162389967913082, 9.999999999998899e-05, 0.0649678482172128, 0.12183228050334549, 0.05150865374764069, 0.1419288485191178, 0.08158563968775401, 0.046950876493785265, 0.03310871631851242, 0.09279807604728407, 0.0684269337962935, 0.08628777550082034, 0.08491712185139344, 0.06281625175589267, 0.2170775971647243, 0.07312672777825269, 0.07446200812423576, 0.0764443909580863, 0.09527675853290207, 0.14173340112962363, 0.08275516461664212, 0.09846662918237381, 0.06791304111850005, 0.042796141020220446, 0.19568566690772315, 0.16752478765476297, 0.2659323932089819, 0.055267141019859856, 0.04892446069501999, 0.14667803387140232, 0.5198636877279188, 0.5219048086962947, 0.511545939221538, 0.5112223206059087, 0.5340323763669241, 0.5563244343353202, 0.5742717285964551, 0.5647306395570708, 0.5536905361127811, 0.12241076564682174, 0.11494734577112031, 0.15273562711565158, 0.1074108133720807, 0.10804483168519141, 0.09735763809088294, 0.12139787980916805, 0.1396057656870029, 0.10937161739736967, 0.2678544577086429, 0.24955233264257082, 0.16540011921814313, 0.3431233683573399, 0.44517819615215115, 0.23138748587235236, 0.27726190959484787, 0.27343225505877666, 0.2004636853906162, 0.2545678207548052, 0.3419246339245494, 0.31485807500722895, 0.20726594080029037, 0.310990550555139, 0.31910469952571974, 0.22800629302817454, 0.43738972624716477, 0.272219777406865, 0.22146828796140194, 0.32118420889092203, 0.22990515740344208, 0.3046479143364662, 0.31049314466937616, 0.24985121338727723, 0.19605035496554446, 0.1942166044641298, 0.31216131996166563, 0.19635170010466285, 0.21716336094419408, 0.25721860315265654, 0.22690595076019338, 0.19566595945495568, 0.22292694899091126, 0.21560579489066467, 0.20816422400674783, 0.2174779711753957, 0.20598666448328262, 0.20297489130983914, 0.21699828568699642, 0.21578567323590325, 0.1903859017234858, 0.22032744189409625, 0.17705823682144983, 0.20301479107422515, 0.19500159798981753, 0.16206365824024693, 0.16835604233037316, 0.9100399329875795, 0.9016202320026829, 0.16222687767946664, 0.9119944374182469, 0.16785206685794496, 0.17787332323642513, 0.16725373503374308, 0.893422122778117, 0.45465575473074893, 0.8778521529472461, 0.6641187459079781, 0.21169237502874905, 0.20955283424003968, 0.7957405213060387, 0.16867668469839248, 0.8312943130294401, 0.19467361755248092, 0.19208686446620704, 0.18341450133484727, 0.18749797016410408, 0.18427915326384414, 0.17912732946542198, 0.19749822318214105, 0.18483766558637915, 0.1895540741357239, 0.09161246566133086, 0.09583784803259443, 0.08760405648611158, 0.09673271305585673, 0.0917121373233627, 0.10948415130475642, 0.10061135216891415, 0.08131304113139393, 0.08845121834045477]}, "mutation_prompt": null}
{"id": "b78b6a46-98f5-4ce7-bac5-e7b959afefe8", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Adjusted population size for efficiency\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Fixed scale factor for consistency\n        self.crossover_rate = 0.85  # Reduced crossover rate\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15  # Dynamic threshold based on diversity measure\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.2 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV2", "description": "A modified swarm optimization with adaptive diversity management and enhanced parameter tuning for improved convergence speed.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.8762743937486778, 0.8673829656899147, 0.8782881677431872, 0.8581318282924161, 0.8605200732474104, 0.8704777471747678, 0.8669501535914438, 0.8767913976636248, 0.8697271807471996, 0.7292592142782701, 0.6958860554492716, 0.6862661905742402, 0.7096497551220675, 0.7167364303086643, 0.7381799447205526, 0.6943872628972643, 0.7088893327988407, 0.720371945202172, 0.3482948532021707, 0.15349288652780446, 0.5051223420989501, 0.15907635784631602, 0.5070164809046678, 0.5280492563109339, 0.447443175757282, 0.26325781945678906, 0.3898003605139132, 0.1388205895773239, 0.1467129287993708, 0.14141217358013514, 0.13389562611085915, 0.1156575963635158, 0.1627314511994138, 0.16363926862956035, 0.14527747050295692, 0.1589943207702187, 0.981855484622502, 0.9795881701807362, 0.9748156162543172, 0.9792088726802245, 0.9798193702692622, 0.9742668333733502, 0.98140298251034, 0.9800328698541079, 0.9808580820685565, 0.7112806484615446, 0.6000664272177662, 0.7307347984989904, 0.55210153228452, 0.33804871219618804, 0.19747862555160034, 0.5365519153146263, 0.6723982565749891, 0.6393792066251385, 0.22584340034636685, 0.15781436012425798, 0.2265530861449211, 0.2188287847075855, 0.21597035463092584, 0.8428236758470273, 0.8089726098878465, 0.24128420105806636, 0.3995593438679347, 0.2606170066166147, 0.23403238541779725, 0.2812271903547767, 0.22271865255321, 0.2067103996056967, 0.17447785651177272, 0.2232835619792518, 0.18667330168152307, 0.20106938831754673, 0.2134313419697863, 0.12985846619541241, 0.2216158000745594, 0.13262726627682464, 0.23546448823381283, 0.13350769987844346, 0.2537378399053595, 0.25746632532602454, 0.2545912574950835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07826185666345442, 0.03842796887265354, 0.00954189234284153, 0.0016162389967913082, 9.999999999998899e-05, 0.0649678482172128, 0.12183228050334549, 0.05150865374764069, 0.1419288485191178, 0.08158563968775401, 0.046950876493785265, 0.03310871631851242, 0.09279807604728407, 0.0684269337962935, 0.08628777550082034, 0.08491712185139344, 0.06281625175589267, 0.2170775971647243, 0.07312672777825269, 0.07446200812423576, 0.0764443909580863, 0.09527675853290207, 0.14173340112962363, 0.08275516461664212, 0.09846662918237381, 0.06791304111850005, 0.042796141020220446, 0.19568566690772315, 0.16752478765476297, 0.2659323932089819, 0.055267141019859856, 0.04892446069501999, 0.14667803387140232, 0.5198636877279188, 0.5219048086962947, 0.511545939221538, 0.5112223206059087, 0.5340323763669241, 0.5563244343353202, 0.5742717285964551, 0.5647306395570708, 0.5536905361127811, 0.12241076564682174, 0.11494734577112031, 0.15273562711565158, 0.1074108133720807, 0.10804483168519141, 0.09735763809088294, 0.12139787980916805, 0.1396057656870029, 0.10937161739736967, 0.2678544577086429, 0.24955233264257082, 0.16540011921814313, 0.3431233683573399, 0.44517819615215115, 0.23138748587235236, 0.27726190959484787, 0.27343225505877666, 0.2004636853906162, 0.2545678207548052, 0.3419246339245494, 0.31485807500722895, 0.20726594080029037, 0.310990550555139, 0.31910469952571974, 0.22800629302817454, 0.43738972624716477, 0.272219777406865, 0.22146828796140194, 0.32118420889092203, 0.22990515740344208, 0.3046479143364662, 0.31049314466937616, 0.24985121338727723, 0.19605035496554446, 0.1942166044641298, 0.31216131996166563, 0.19635170010466285, 0.21716336094419408, 0.25721860315265654, 0.22690595076019338, 0.19566595945495568, 0.22292694899091126, 0.21560579489066467, 0.20816422400674783, 0.2174779711753957, 0.20598666448328262, 0.20297489130983914, 0.21699828568699642, 0.21578567323590325, 0.1903859017234858, 0.22032744189409625, 0.17705823682144983, 0.20301479107422515, 0.19500159798981753, 0.16206365824024693, 0.16835604233037316, 0.9100399329875795, 0.9016202320026829, 0.16222687767946664, 0.9119944374182469, 0.16785206685794496, 0.17787332323642513, 0.16725373503374308, 0.893422122778117, 0.45465575473074893, 0.8778521529472461, 0.6641187459079781, 0.21169237502874905, 0.20955283424003968, 0.7957405213060387, 0.16867668469839248, 0.8312943130294401, 0.19467361755248092, 0.19208686446620704, 0.18341450133484727, 0.18749797016410408, 0.18427915326384414, 0.17912732946542198, 0.19749822318214105, 0.18483766558637915, 0.1895540741357239, 0.09161246566133086, 0.09583784803259443, 0.08760405648611158, 0.09673271305585673, 0.0917121373233627, 0.10948415130475642, 0.10061135216891415, 0.08131304113139393, 0.08845121834045477]}, "mutation_prompt": null}
{"id": "00c670f7-7a88-41c3-b6fb-aa427628b2ce", "solution": "import numpy as np\n\nclass ImprovedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Slight increase in population for higher diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Expanded velocity range\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.9  # Slightly increased scale factor for more exploration\n        self.crossover_rate = 0.8  # Modified crossover rate for diversification\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.1  # Adjusted threshold for diversity sensitivity\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.7 + 0.3 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.9 - 0.4 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.uniform(size=(3, self.dim))\n                inertia = 0.5 - 0.3 * (evaluations / self.budget)  # Adjusted inertia\n                cognitive = 1.5 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.5 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                attraction = 0.5 * r3 * (np.mean(self.particles, axis=0) - self.particles[i])  # New swarm attraction strategy\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social + attraction\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.6, mutant, edge_mutation)  # Modified mutation strategy\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "ImprovedSwarmOptimizer", "description": "Integrating a multi-strategy adaptive velocity update mechanism and swarm attraction strategy to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 95, "fitness": 0.27355078344647876, "feedback": "The algorithm ImprovedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.717487677409153, 0.7201207884775456, 0.7328818869065712, 0.7105131322031244, 0.7195238458672228, 0.7365729031042569, 0.7557044380238673, 0.7544570072788392, 0.7414922519198294, 0.3994517211931162, 0.495858207021294, 0.4649955884523599, 0.39702056232178384, 0.43868881990666864, 0.4316413298810381, 0.4119940006173306, 0.49787534631164476, 0.4683059823990573, 0.1412897629937363, 0.17190987208528863, 0.15651576428326697, 0.10115976803227988, 0.11994919068534204, 0.1349620964956424, 0.16054800457594698, 0.14318191280544634, 0.35264302021586313, 0.12640745021263755, 0.1133539645201519, 0.09931712410810889, 0.10757880247078155, 0.09825825487611473, 0.11620529533502344, 0.13281957882941808, 0.08898620465552654, 0.12476477509340433, 0.9794959103199755, 0.9779573933964075, 0.9841420981390397, 0.9761454271773424, 0.984789693577979, 0.9790806214432918, 0.973464308034672, 0.9847377335070151, 0.9791885442451269, 0.43836770725741747, 0.4336548168574498, 0.33125102055098976, 0.3913533088644482, 0.3969399661719093, 0.39585705636851587, 0.40895279389389205, 0.39167266496755015, 0.3496111702351794, 0.34080898317657704, 0.2097457939376105, 0.35517109161733984, 0.1671533857582297, 0.2605664810671585, 0.2652458115470965, 0.6553241820008066, 0.3515847772023778, 0.2025100289417261, 0.14488794586260156, 0.16166676397422652, 0.17436996514393832, 0.19086136909538975, 0.20783587507693768, 0.17008067822695017, 0.14540575529245758, 0.18665533881644536, 0.17165450979450925, 0.18707522481753336, 0.19610326947484624, 0.2897127762611089, 0.17402663987741762, 0.181743067505291, 0.16634644077858174, 0.12288069812284552, 0.1756969573941014, 0.176121581840323, 0.07830326711132451, 0.024356302260946316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015442134201628654, 9.999999999998899e-05, 0.10320786478579269, 0.0584077583344097, 0.13796733807419936, 0.03622440652641579, 0.036476510879282276, 0.09069467817971921, 0.07795605545584972, 0.06106593804645177, 0.13795353034267077, 0.14408624289513405, 0.030129514912548117, 0.09493180595611861, 0.0692532674920252, 0.05793403255953222, 0.05642881824316914, 0.052570927900529196, 0.08078118594613404, 0.07231183428663113, 0.07554349782684089, 0.12743640829522174, 0.18569315784735607, 0.11799203706369776, 0.04305643610602272, 0.08790483468075583, 0.07566402538133699, 0.10454015408741413, 0.05441088377646519, 0.4681902863626497, 0.5083863031515807, 0.47882963080129326, 0.5004892308404776, 0.46205590962468446, 0.47599685597466, 0.4969404780377503, 0.49411661659471307, 0.4881314411402605, 0.11440782349869094, 0.1015108379580072, 0.10295152499507498, 0.11797302809350041, 0.11326157968689421, 0.09091329195824349, 0.09998972562872332, 0.11692351475485485, 0.11185864359026587, 0.19520652730130084, 0.24833013864182407, 0.18844468412032167, 0.1565310917852898, 0.17239713712536264, 0.1499512986869369, 0.18338584101754873, 0.1858533002153011, 0.23594447174379884, 0.33298774495143, 0.28045706680834503, 0.36089257046366585, 0.39866069271397364, 0.41568665310135566, 0.35701434563590473, 0.4474464578204076, 0.42549042530524006, 0.4400775674872942, 0.30663798586053204, 0.3111424659693893, 0.26383149061104827, 0.2035543134850165, 0.24065952659966905, 0.1744267015457973, 0.12413264898079146, 0.23567526941707195, 0.23834357494919223, 0.22366551880328456, 0.20187074912941683, 0.21792126308689475, 0.20839894788493452, 0.1976765271861426, 0.20908092159354108, 0.20195531711739545, 0.21557618197192885, 0.1975867082572711, 0.21553057606973347, 0.21070642339707524, 0.2302196647041307, 0.19390453606250246, 0.2004510184706716, 0.2074389942725302, 0.2108965445279526, 0.21287179315459748, 0.19337042895468592, 0.18833126738706374, 0.1882256722002208, 0.8210159631815755, 0.8164376042795403, 0.4088112413263181, 0.7810632142524039, 0.21037424779277158, 0.15061796075009393, 0.1775190620962327, 0.529632326369363, 0.20568613986096596, 0.6645087575596724, 0.19109207914161286, 0.20401455494485266, 0.20418439137051914, 0.13107576360477746, 0.16639991997646153, 0.3833213431628222, 0.17383211223490036, 0.17791609598082925, 0.1877238323116851, 0.1804323814823411, 0.1947844376908796, 0.1738848115205217, 0.2032913343304883, 0.17940021560854724, 0.1811430499900062, 0.08646354910833831, 0.11444385430054949, 0.08254253242233078, 0.08062283981521301, 0.09177813748463082, 0.09203782271294081, 0.08471902074884652, 0.09472638034055092, 0.07194358956225566]}, "mutation_prompt": null}
{"id": "77b9b673-86ef-4bd6-ac57-b22742415122", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Adjusted population size for efficiency\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Fixed scale factor for consistency\n        self.crossover_rate = 0.85  # Reduced crossover rate\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15  # Dynamic threshold based on diversity measure\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.2 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV2", "description": "A modified swarm optimization with adaptive diversity management and enhanced parameter tuning for improved convergence speed.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.8762743937486778, 0.8673829656899147, 0.8782881677431872, 0.8581318282924161, 0.8605200732474104, 0.8704777471747678, 0.8669501535914438, 0.8767913976636248, 0.8697271807471996, 0.7292592142782701, 0.6958860554492716, 0.6862661905742402, 0.7096497551220675, 0.7167364303086643, 0.7381799447205526, 0.6943872628972643, 0.7088893327988407, 0.720371945202172, 0.3482948532021707, 0.15349288652780446, 0.5051223420989501, 0.15907635784631602, 0.5070164809046678, 0.5280492563109339, 0.447443175757282, 0.26325781945678906, 0.3898003605139132, 0.1388205895773239, 0.1467129287993708, 0.14141217358013514, 0.13389562611085915, 0.1156575963635158, 0.1627314511994138, 0.16363926862956035, 0.14527747050295692, 0.1589943207702187, 0.981855484622502, 0.9795881701807362, 0.9748156162543172, 0.9792088726802245, 0.9798193702692622, 0.9742668333733502, 0.98140298251034, 0.9800328698541079, 0.9808580820685565, 0.7112806484615446, 0.6000664272177662, 0.7307347984989904, 0.55210153228452, 0.33804871219618804, 0.19747862555160034, 0.5365519153146263, 0.6723982565749891, 0.6393792066251385, 0.22584340034636685, 0.15781436012425798, 0.2265530861449211, 0.2188287847075855, 0.21597035463092584, 0.8428236758470273, 0.8089726098878465, 0.24128420105806636, 0.3995593438679347, 0.2606170066166147, 0.23403238541779725, 0.2812271903547767, 0.22271865255321, 0.2067103996056967, 0.17447785651177272, 0.2232835619792518, 0.18667330168152307, 0.20106938831754673, 0.2134313419697863, 0.12985846619541241, 0.2216158000745594, 0.13262726627682464, 0.23546448823381283, 0.13350769987844346, 0.2537378399053595, 0.25746632532602454, 0.2545912574950835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07826185666345442, 0.03842796887265354, 0.00954189234284153, 0.0016162389967913082, 9.999999999998899e-05, 0.0649678482172128, 0.12183228050334549, 0.05150865374764069, 0.1419288485191178, 0.08158563968775401, 0.046950876493785265, 0.03310871631851242, 0.09279807604728407, 0.0684269337962935, 0.08628777550082034, 0.08491712185139344, 0.06281625175589267, 0.2170775971647243, 0.07312672777825269, 0.07446200812423576, 0.0764443909580863, 0.09527675853290207, 0.14173340112962363, 0.08275516461664212, 0.09846662918237381, 0.06791304111850005, 0.042796141020220446, 0.19568566690772315, 0.16752478765476297, 0.2659323932089819, 0.055267141019859856, 0.04892446069501999, 0.14667803387140232, 0.5198636877279188, 0.5219048086962947, 0.511545939221538, 0.5112223206059087, 0.5340323763669241, 0.5563244343353202, 0.5742717285964551, 0.5647306395570708, 0.5536905361127811, 0.12241076564682174, 0.11494734577112031, 0.15273562711565158, 0.1074108133720807, 0.10804483168519141, 0.09735763809088294, 0.12139787980916805, 0.1396057656870029, 0.10937161739736967, 0.2678544577086429, 0.24955233264257082, 0.16540011921814313, 0.3431233683573399, 0.44517819615215115, 0.23138748587235236, 0.27726190959484787, 0.27343225505877666, 0.2004636853906162, 0.2545678207548052, 0.3419246339245494, 0.31485807500722895, 0.20726594080029037, 0.310990550555139, 0.31910469952571974, 0.22800629302817454, 0.43738972624716477, 0.272219777406865, 0.22146828796140194, 0.32118420889092203, 0.22990515740344208, 0.3046479143364662, 0.31049314466937616, 0.24985121338727723, 0.19605035496554446, 0.1942166044641298, 0.31216131996166563, 0.19635170010466285, 0.21716336094419408, 0.25721860315265654, 0.22690595076019338, 0.19566595945495568, 0.22292694899091126, 0.21560579489066467, 0.20816422400674783, 0.2174779711753957, 0.20598666448328262, 0.20297489130983914, 0.21699828568699642, 0.21578567323590325, 0.1903859017234858, 0.22032744189409625, 0.17705823682144983, 0.20301479107422515, 0.19500159798981753, 0.16206365824024693, 0.16835604233037316, 0.9100399329875795, 0.9016202320026829, 0.16222687767946664, 0.9119944374182469, 0.16785206685794496, 0.17787332323642513, 0.16725373503374308, 0.893422122778117, 0.45465575473074893, 0.8778521529472461, 0.6641187459079781, 0.21169237502874905, 0.20955283424003968, 0.7957405213060387, 0.16867668469839248, 0.8312943130294401, 0.19467361755248092, 0.19208686446620704, 0.18341450133484727, 0.18749797016410408, 0.18427915326384414, 0.17912732946542198, 0.19749822318214105, 0.18483766558637915, 0.1895540741357239, 0.09161246566133086, 0.09583784803259443, 0.08760405648611158, 0.09673271305585673, 0.0917121373233627, 0.10948415130475642, 0.10061135216891415, 0.08131304113139393, 0.08845121834045477]}, "mutation_prompt": null}
{"id": "4fc4a5f1-fb6a-4098-99c5-1ed37b2ae1e5", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Adjusted population size for efficiency\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Fixed scale factor for consistency\n        self.crossover_rate = 0.85  # Reduced crossover rate\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15  # Dynamic threshold based on diversity measure\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.2 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV2", "description": "A modified swarm optimization with adaptive diversity management and enhanced parameter tuning for improved convergence speed.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.8762743937486778, 0.8673829656899147, 0.8782881677431872, 0.8581318282924161, 0.8605200732474104, 0.8704777471747678, 0.8669501535914438, 0.8767913976636248, 0.8697271807471996, 0.7292592142782701, 0.6958860554492716, 0.6862661905742402, 0.7096497551220675, 0.7167364303086643, 0.7381799447205526, 0.6943872628972643, 0.7088893327988407, 0.720371945202172, 0.3482948532021707, 0.15349288652780446, 0.5051223420989501, 0.15907635784631602, 0.5070164809046678, 0.5280492563109339, 0.447443175757282, 0.26325781945678906, 0.3898003605139132, 0.1388205895773239, 0.1467129287993708, 0.14141217358013514, 0.13389562611085915, 0.1156575963635158, 0.1627314511994138, 0.16363926862956035, 0.14527747050295692, 0.1589943207702187, 0.981855484622502, 0.9795881701807362, 0.9748156162543172, 0.9792088726802245, 0.9798193702692622, 0.9742668333733502, 0.98140298251034, 0.9800328698541079, 0.9808580820685565, 0.7112806484615446, 0.6000664272177662, 0.7307347984989904, 0.55210153228452, 0.33804871219618804, 0.19747862555160034, 0.5365519153146263, 0.6723982565749891, 0.6393792066251385, 0.22584340034636685, 0.15781436012425798, 0.2265530861449211, 0.2188287847075855, 0.21597035463092584, 0.8428236758470273, 0.8089726098878465, 0.24128420105806636, 0.3995593438679347, 0.2606170066166147, 0.23403238541779725, 0.2812271903547767, 0.22271865255321, 0.2067103996056967, 0.17447785651177272, 0.2232835619792518, 0.18667330168152307, 0.20106938831754673, 0.2134313419697863, 0.12985846619541241, 0.2216158000745594, 0.13262726627682464, 0.23546448823381283, 0.13350769987844346, 0.2537378399053595, 0.25746632532602454, 0.2545912574950835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07826185666345442, 0.03842796887265354, 0.00954189234284153, 0.0016162389967913082, 9.999999999998899e-05, 0.0649678482172128, 0.12183228050334549, 0.05150865374764069, 0.1419288485191178, 0.08158563968775401, 0.046950876493785265, 0.03310871631851242, 0.09279807604728407, 0.0684269337962935, 0.08628777550082034, 0.08491712185139344, 0.06281625175589267, 0.2170775971647243, 0.07312672777825269, 0.07446200812423576, 0.0764443909580863, 0.09527675853290207, 0.14173340112962363, 0.08275516461664212, 0.09846662918237381, 0.06791304111850005, 0.042796141020220446, 0.19568566690772315, 0.16752478765476297, 0.2659323932089819, 0.055267141019859856, 0.04892446069501999, 0.14667803387140232, 0.5198636877279188, 0.5219048086962947, 0.511545939221538, 0.5112223206059087, 0.5340323763669241, 0.5563244343353202, 0.5742717285964551, 0.5647306395570708, 0.5536905361127811, 0.12241076564682174, 0.11494734577112031, 0.15273562711565158, 0.1074108133720807, 0.10804483168519141, 0.09735763809088294, 0.12139787980916805, 0.1396057656870029, 0.10937161739736967, 0.2678544577086429, 0.24955233264257082, 0.16540011921814313, 0.3431233683573399, 0.44517819615215115, 0.23138748587235236, 0.27726190959484787, 0.27343225505877666, 0.2004636853906162, 0.2545678207548052, 0.3419246339245494, 0.31485807500722895, 0.20726594080029037, 0.310990550555139, 0.31910469952571974, 0.22800629302817454, 0.43738972624716477, 0.272219777406865, 0.22146828796140194, 0.32118420889092203, 0.22990515740344208, 0.3046479143364662, 0.31049314466937616, 0.24985121338727723, 0.19605035496554446, 0.1942166044641298, 0.31216131996166563, 0.19635170010466285, 0.21716336094419408, 0.25721860315265654, 0.22690595076019338, 0.19566595945495568, 0.22292694899091126, 0.21560579489066467, 0.20816422400674783, 0.2174779711753957, 0.20598666448328262, 0.20297489130983914, 0.21699828568699642, 0.21578567323590325, 0.1903859017234858, 0.22032744189409625, 0.17705823682144983, 0.20301479107422515, 0.19500159798981753, 0.16206365824024693, 0.16835604233037316, 0.9100399329875795, 0.9016202320026829, 0.16222687767946664, 0.9119944374182469, 0.16785206685794496, 0.17787332323642513, 0.16725373503374308, 0.893422122778117, 0.45465575473074893, 0.8778521529472461, 0.6641187459079781, 0.21169237502874905, 0.20955283424003968, 0.7957405213060387, 0.16867668469839248, 0.8312943130294401, 0.19467361755248092, 0.19208686446620704, 0.18341450133484727, 0.18749797016410408, 0.18427915326384414, 0.17912732946542198, 0.19749822318214105, 0.18483766558637915, 0.1895540741357239, 0.09161246566133086, 0.09583784803259443, 0.08760405648611158, 0.09673271305585673, 0.0917121373233627, 0.10948415130475642, 0.10061135216891415, 0.08131304113139393, 0.08845121834045477]}, "mutation_prompt": null}
{"id": "f0dfa317-d65e-4c32-8aee-d8ba90bf78f4", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Adjusted population size for efficiency\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Fixed scale factor for consistency\n        self.crossover_rate = 0.85  # Reduced crossover rate\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15  # Dynamic threshold based on diversity measure\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.2 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV2", "description": "A modified swarm optimization with adaptive diversity management and enhanced parameter tuning for improved convergence speed.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.8762743937486778, 0.8673829656899147, 0.8782881677431872, 0.8581318282924161, 0.8605200732474104, 0.8704777471747678, 0.8669501535914438, 0.8767913976636248, 0.8697271807471996, 0.7292592142782701, 0.6958860554492716, 0.6862661905742402, 0.7096497551220675, 0.7167364303086643, 0.7381799447205526, 0.6943872628972643, 0.7088893327988407, 0.720371945202172, 0.3482948532021707, 0.15349288652780446, 0.5051223420989501, 0.15907635784631602, 0.5070164809046678, 0.5280492563109339, 0.447443175757282, 0.26325781945678906, 0.3898003605139132, 0.1388205895773239, 0.1467129287993708, 0.14141217358013514, 0.13389562611085915, 0.1156575963635158, 0.1627314511994138, 0.16363926862956035, 0.14527747050295692, 0.1589943207702187, 0.981855484622502, 0.9795881701807362, 0.9748156162543172, 0.9792088726802245, 0.9798193702692622, 0.9742668333733502, 0.98140298251034, 0.9800328698541079, 0.9808580820685565, 0.7112806484615446, 0.6000664272177662, 0.7307347984989904, 0.55210153228452, 0.33804871219618804, 0.19747862555160034, 0.5365519153146263, 0.6723982565749891, 0.6393792066251385, 0.22584340034636685, 0.15781436012425798, 0.2265530861449211, 0.2188287847075855, 0.21597035463092584, 0.8428236758470273, 0.8089726098878465, 0.24128420105806636, 0.3995593438679347, 0.2606170066166147, 0.23403238541779725, 0.2812271903547767, 0.22271865255321, 0.2067103996056967, 0.17447785651177272, 0.2232835619792518, 0.18667330168152307, 0.20106938831754673, 0.2134313419697863, 0.12985846619541241, 0.2216158000745594, 0.13262726627682464, 0.23546448823381283, 0.13350769987844346, 0.2537378399053595, 0.25746632532602454, 0.2545912574950835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07826185666345442, 0.03842796887265354, 0.00954189234284153, 0.0016162389967913082, 9.999999999998899e-05, 0.0649678482172128, 0.12183228050334549, 0.05150865374764069, 0.1419288485191178, 0.08158563968775401, 0.046950876493785265, 0.03310871631851242, 0.09279807604728407, 0.0684269337962935, 0.08628777550082034, 0.08491712185139344, 0.06281625175589267, 0.2170775971647243, 0.07312672777825269, 0.07446200812423576, 0.0764443909580863, 0.09527675853290207, 0.14173340112962363, 0.08275516461664212, 0.09846662918237381, 0.06791304111850005, 0.042796141020220446, 0.19568566690772315, 0.16752478765476297, 0.2659323932089819, 0.055267141019859856, 0.04892446069501999, 0.14667803387140232, 0.5198636877279188, 0.5219048086962947, 0.511545939221538, 0.5112223206059087, 0.5340323763669241, 0.5563244343353202, 0.5742717285964551, 0.5647306395570708, 0.5536905361127811, 0.12241076564682174, 0.11494734577112031, 0.15273562711565158, 0.1074108133720807, 0.10804483168519141, 0.09735763809088294, 0.12139787980916805, 0.1396057656870029, 0.10937161739736967, 0.2678544577086429, 0.24955233264257082, 0.16540011921814313, 0.3431233683573399, 0.44517819615215115, 0.23138748587235236, 0.27726190959484787, 0.27343225505877666, 0.2004636853906162, 0.2545678207548052, 0.3419246339245494, 0.31485807500722895, 0.20726594080029037, 0.310990550555139, 0.31910469952571974, 0.22800629302817454, 0.43738972624716477, 0.272219777406865, 0.22146828796140194, 0.32118420889092203, 0.22990515740344208, 0.3046479143364662, 0.31049314466937616, 0.24985121338727723, 0.19605035496554446, 0.1942166044641298, 0.31216131996166563, 0.19635170010466285, 0.21716336094419408, 0.25721860315265654, 0.22690595076019338, 0.19566595945495568, 0.22292694899091126, 0.21560579489066467, 0.20816422400674783, 0.2174779711753957, 0.20598666448328262, 0.20297489130983914, 0.21699828568699642, 0.21578567323590325, 0.1903859017234858, 0.22032744189409625, 0.17705823682144983, 0.20301479107422515, 0.19500159798981753, 0.16206365824024693, 0.16835604233037316, 0.9100399329875795, 0.9016202320026829, 0.16222687767946664, 0.9119944374182469, 0.16785206685794496, 0.17787332323642513, 0.16725373503374308, 0.893422122778117, 0.45465575473074893, 0.8778521529472461, 0.6641187459079781, 0.21169237502874905, 0.20955283424003968, 0.7957405213060387, 0.16867668469839248, 0.8312943130294401, 0.19467361755248092, 0.19208686446620704, 0.18341450133484727, 0.18749797016410408, 0.18427915326384414, 0.17912732946542198, 0.19749822318214105, 0.18483766558637915, 0.1895540741357239, 0.09161246566133086, 0.09583784803259443, 0.08760405648611158, 0.09673271305585673, 0.0917121373233627, 0.10948415130475642, 0.10061135216891415, 0.08131304113139393, 0.08845121834045477]}, "mutation_prompt": null}
{"id": "b3f30905-e2be-4fac-95f8-8c4df2b8a8ce", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Adjusted population size for efficiency\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.best_personal_positions = np.copy(self.particles)\n        self.best_personal_scores = np.full(self.population_size, np.inf)\n        self.best_global_position = None\n        self.best_global_score = np.inf\n        self.scale_factor = 0.8  # Fixed scale factor for consistency\n        self.crossover_rate = 0.85  # Reduced crossover rate\n        self.iterations = self.budget // self.population_size\n        self.dynamic_threshold = 0.15  # Dynamic threshold based on diversity measure\n\n    def adaptive_parameters(self, diversity):\n        self.scale_factor = 0.8 + 0.2 * (1 - diversity / self.dynamic_threshold)\n        self.crossover_rate = 0.85 - 0.2 * (diversity / self.dynamic_threshold)\n\n    def compute_diversity(self):\n        pairwise_differences = np.sum((self.particles[:, np.newaxis] - self.particles[np.newaxis, :]) ** 2, axis=2)\n        return np.mean(np.sqrt(pairwise_differences))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_diversity = self.compute_diversity()\n            self.adaptive_parameters(current_diversity)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(size=self.dim)\n                r2 = np.random.uniform(size=self.dim)\n                inertia = 0.4 - 0.2 * (evaluations / self.budget)  # Adjusted inertia adaptation\n                cognitive = 1.3 * r1 * (self.best_personal_positions[i] - self.particles[i])\n                social = 1.3 * r2 * (self.best_global_position - self.particles[i]) if self.best_global_position is not None else 0\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.best_personal_scores[i]:\n                    self.best_personal_scores[i] = score\n                    self.best_personal_positions[i] = self.particles[i]\n                if score < self.best_global_score:\n                    self.best_global_score = score\n                    self.best_global_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + self.scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    edge_mutation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.where(np.random.rand(self.dim) < 0.5, mutant, edge_mutation)\n\n                    trial = np.copy(self.particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate or j == np.random.randint(self.dim):\n                            trial[j] = mutant[j]\n                    score = func(trial)\n                    evaluations += 1\n                    if score < self.best_personal_scores[i]:\n                        self.particles[i] = trial\n                        self.best_personal_scores[i] = score\n                        self.best_personal_positions[i] = trial\n                        if score < self.best_global_score:\n                            self.best_global_score = score\n                            self.best_global_position = trial\n\n        return self.best_global_position, self.best_global_score", "name": "EnhancedSwarmOptimizerV2", "description": "A modified swarm optimization with adaptive diversity management and enhanced parameter tuning for improved convergence speed.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b8802295-59c7-43dd-a268-cdfc5f6143d3", "metadata": {"aucs": [0.8762743937486778, 0.8673829656899147, 0.8782881677431872, 0.8581318282924161, 0.8605200732474104, 0.8704777471747678, 0.8669501535914438, 0.8767913976636248, 0.8697271807471996, 0.7292592142782701, 0.6958860554492716, 0.6862661905742402, 0.7096497551220675, 0.7167364303086643, 0.7381799447205526, 0.6943872628972643, 0.7088893327988407, 0.720371945202172, 0.3482948532021707, 0.15349288652780446, 0.5051223420989501, 0.15907635784631602, 0.5070164809046678, 0.5280492563109339, 0.447443175757282, 0.26325781945678906, 0.3898003605139132, 0.1388205895773239, 0.1467129287993708, 0.14141217358013514, 0.13389562611085915, 0.1156575963635158, 0.1627314511994138, 0.16363926862956035, 0.14527747050295692, 0.1589943207702187, 0.981855484622502, 0.9795881701807362, 0.9748156162543172, 0.9792088726802245, 0.9798193702692622, 0.9742668333733502, 0.98140298251034, 0.9800328698541079, 0.9808580820685565, 0.7112806484615446, 0.6000664272177662, 0.7307347984989904, 0.55210153228452, 0.33804871219618804, 0.19747862555160034, 0.5365519153146263, 0.6723982565749891, 0.6393792066251385, 0.22584340034636685, 0.15781436012425798, 0.2265530861449211, 0.2188287847075855, 0.21597035463092584, 0.8428236758470273, 0.8089726098878465, 0.24128420105806636, 0.3995593438679347, 0.2606170066166147, 0.23403238541779725, 0.2812271903547767, 0.22271865255321, 0.2067103996056967, 0.17447785651177272, 0.2232835619792518, 0.18667330168152307, 0.20106938831754673, 0.2134313419697863, 0.12985846619541241, 0.2216158000745594, 0.13262726627682464, 0.23546448823381283, 0.13350769987844346, 0.2537378399053595, 0.25746632532602454, 0.2545912574950835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07826185666345442, 0.03842796887265354, 0.00954189234284153, 0.0016162389967913082, 9.999999999998899e-05, 0.0649678482172128, 0.12183228050334549, 0.05150865374764069, 0.1419288485191178, 0.08158563968775401, 0.046950876493785265, 0.03310871631851242, 0.09279807604728407, 0.0684269337962935, 0.08628777550082034, 0.08491712185139344, 0.06281625175589267, 0.2170775971647243, 0.07312672777825269, 0.07446200812423576, 0.0764443909580863, 0.09527675853290207, 0.14173340112962363, 0.08275516461664212, 0.09846662918237381, 0.06791304111850005, 0.042796141020220446, 0.19568566690772315, 0.16752478765476297, 0.2659323932089819, 0.055267141019859856, 0.04892446069501999, 0.14667803387140232, 0.5198636877279188, 0.5219048086962947, 0.511545939221538, 0.5112223206059087, 0.5340323763669241, 0.5563244343353202, 0.5742717285964551, 0.5647306395570708, 0.5536905361127811, 0.12241076564682174, 0.11494734577112031, 0.15273562711565158, 0.1074108133720807, 0.10804483168519141, 0.09735763809088294, 0.12139787980916805, 0.1396057656870029, 0.10937161739736967, 0.2678544577086429, 0.24955233264257082, 0.16540011921814313, 0.3431233683573399, 0.44517819615215115, 0.23138748587235236, 0.27726190959484787, 0.27343225505877666, 0.2004636853906162, 0.2545678207548052, 0.3419246339245494, 0.31485807500722895, 0.20726594080029037, 0.310990550555139, 0.31910469952571974, 0.22800629302817454, 0.43738972624716477, 0.272219777406865, 0.22146828796140194, 0.32118420889092203, 0.22990515740344208, 0.3046479143364662, 0.31049314466937616, 0.24985121338727723, 0.19605035496554446, 0.1942166044641298, 0.31216131996166563, 0.19635170010466285, 0.21716336094419408, 0.25721860315265654, 0.22690595076019338, 0.19566595945495568, 0.22292694899091126, 0.21560579489066467, 0.20816422400674783, 0.2174779711753957, 0.20598666448328262, 0.20297489130983914, 0.21699828568699642, 0.21578567323590325, 0.1903859017234858, 0.22032744189409625, 0.17705823682144983, 0.20301479107422515, 0.19500159798981753, 0.16206365824024693, 0.16835604233037316, 0.9100399329875795, 0.9016202320026829, 0.16222687767946664, 0.9119944374182469, 0.16785206685794496, 0.17787332323642513, 0.16725373503374308, 0.893422122778117, 0.45465575473074893, 0.8778521529472461, 0.6641187459079781, 0.21169237502874905, 0.20955283424003968, 0.7957405213060387, 0.16867668469839248, 0.8312943130294401, 0.19467361755248092, 0.19208686446620704, 0.18341450133484727, 0.18749797016410408, 0.18427915326384414, 0.17912732946542198, 0.19749822318214105, 0.18483766558637915, 0.1895540741357239, 0.09161246566133086, 0.09583784803259443, 0.08760405648611158, 0.09673271305585673, 0.0917121373233627, 0.10948415130475642, 0.10061135216891415, 0.08131304113139393, 0.08845121834045477]}, "mutation_prompt": null}
