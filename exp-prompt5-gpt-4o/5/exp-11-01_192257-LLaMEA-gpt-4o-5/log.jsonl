{"id": "e9d99c8e-92f0-4e81-9682-8811ebf84876", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / 10\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Adaptive Random Sampling with Local Search that balances exploration and exploitation based on feedback from evaluated solutions.", "configspace": "", "generation": 0, "fitness": 0.1768973655787423, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3421937269162143, 0.3335060931404473, 0.3207155317229389, 0.3065995845330628, 0.3343185543553604, 0.315254977145659, 0.2977296024252394, 0.31337199221151846, 0.32315032324011483, 0.0015499546630959316, 0.020222745644837614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015788823539580887, 9.999999999998899e-05, 0.06074324740566461, 0.0903670515477184, 0.08505308802899636, 0.09307938665983106, 0.07703355822426294, 0.1002329525888519, 0.10311293964601576, 0.08892496070883882, 0.09274892928578993, 0.1011841133470831, 0.0768182180414333, 0.07918795392385258, 0.09060531209827682, 0.05761954034972838, 0.06806801824531938, 0.08833067945994622, 0.10505612243144191, 0.07188839241306888, 0.954670413000935, 0.953404699868996, 0.9349225876626759, 0.9493667478216468, 0.9441209523472963, 0.9347734251633665, 0.953492461532374, 0.9612390513882814, 0.9624757692095594, 0.2055434574266567, 0.19780344478152634, 0.18664673615443206, 0.19218161442318082, 0.20357675824267318, 0.20611198924639873, 0.2031062627594984, 0.21558780749593565, 0.18756410182399774, 0.23537353848086828, 0.2092872159055903, 0.2619217233248985, 0.2796648720150984, 0.24685053620048225, 0.2426479057689086, 0.22386229653746037, 0.23145384533629698, 0.2406906004228987, 0.11169242213361286, 0.12422077486366101, 0.12581401242354495, 0.07369391976943773, 0.1304387731743838, 0.12397874624694427, 0.12033662989129956, 0.12571418801879608, 0.1302244710856295, 0.1258625718644364, 0.11877909545626175, 0.12209495774235479, 0.11634114164821219, 0.11569932780682046, 0.1240649158375261, 0.11642610150956112, 0.10982020826976058, 0.11915082907427732, 9.999999999998899e-05, 9.999999999998899e-05, 0.005156285396483162, 0.004608733579043123, 9.999999999998899e-05, 9.999999999998899e-05, 0.013428548446602684, 9.999999999998899e-05, 9.999999999998899e-05, 0.11425653801808944, 0.12551288117852621, 0.12819296273339065, 0.08491437806426672, 0.09786827530613684, 0.06199975875947272, 0.13739508541419543, 0.05378906563854724, 0.10448947103543782, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06427214812170445, 0.05614552128909711, 0.05934431294312981, 0.046994663691863225, 0.05559824338845831, 0.04692522648950859, 0.04947363379933034, 0.045180843982099206, 0.06462147596008494, 0.33014361615465027, 0.3027306240804656, 0.32056716698464716, 0.3293951718468444, 0.32683172236106717, 0.31853161797488627, 0.3278419362794518, 0.31378145419586767, 0.32427030677496105, 0.09860746249163255, 0.092327371591571, 0.09219198780839721, 0.08523668634620607, 0.10405307486966997, 0.10748822773818278, 0.10824576489318605, 0.07940494615820459, 0.07644462004876895, 0.15598951119806392, 0.1719585184880541, 0.18769757218291816, 0.17098430916309004, 0.2256477839152008, 0.13944841901553973, 0.16712131811331488, 0.17331095212234926, 0.16865013569680454, 0.2509888048873612, 0.22967862415481954, 0.17222292770668723, 0.22298932990367526, 0.24809026597868533, 0.22812835406504117, 0.2106237671685276, 0.22421517524665113, 0.17902686880528051, 0.18908685629205257, 0.18949699168815182, 0.15556779549551125, 0.17944731586710472, 0.18157518215996837, 0.1088897515849514, 0.1475780272078857, 0.15246860542795293, 0.16863389292627784, 0.19996133171390373, 0.21337239063357727, 0.2046449169698169, 0.2150531336800232, 0.20145773908329567, 0.20719339165361228, 0.21459733644349832, 0.18022071020646557, 0.21738950673721502, 0.17579142782163049, 0.182882144838577, 0.17542442531554403, 0.1883710510599984, 0.1922307111477206, 0.16562183613532067, 0.18311107179280917, 0.1808107636785934, 0.17856680950199366, 0.18232757552570256, 0.1354507410600867, 0.10396661509614458, 0.17164417738622706, 0.11184426529841496, 0.06154296356924693, 0.10804993512178918, 0.11392012923647177, 0.1668673495657622, 0.40910750206425295, 0.11265567458922321, 0.08278809806016874, 0.16917040576805975, 0.2052779734290323, 0.18821781994142062, 0.16890875209298628, 0.16638593379334832, 0.31140553558148676, 0.18598771411132908, 0.19552006417231504, 0.17705998279747093, 0.19233917710934523, 0.19536693471165456, 0.1773683639429151, 0.19439448924685654, 0.18663424888765257, 0.1822099964310936, 0.09302789782856002, 0.09793769461293655, 0.07330140063167978, 0.0813905655702909, 0.081109769917739, 0.10737295121838064, 0.09697559666555988, 0.0896090233163448, 0.08896380484410416]}, "mutation_prompt": null}
{"id": "6a93e171-7f5e-4c9e-855a-c1943388e382", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / 10\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Adaptive Random Sampling with Local Search that balances exploration and exploitation based on feedback from evaluated solutions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e9d99c8e-92f0-4e81-9682-8811ebf84876", "metadata": {"aucs": [0.3421937269162143, 0.3335060931404473, 0.3207155317229389, 0.3065995845330628, 0.3343185543553604, 0.315254977145659, 0.2977296024252394, 0.31337199221151846, 0.32315032324011483, 0.0015499546630959316, 0.020222745644837614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015788823539580887, 9.999999999998899e-05, 0.06074324740566461, 0.0903670515477184, 0.08505308802899636, 0.09307938665983106, 0.07703355822426294, 0.1002329525888519, 0.10311293964601576, 0.08892496070883882, 0.09274892928578993, 0.1011841133470831, 0.0768182180414333, 0.07918795392385258, 0.09060531209827682, 0.05761954034972838, 0.06806801824531938, 0.08833067945994622, 0.10505612243144191, 0.07188839241306888, 0.954670413000935, 0.953404699868996, 0.9349225876626759, 0.9493667478216468, 0.9441209523472963, 0.9347734251633665, 0.953492461532374, 0.9612390513882814, 0.9624757692095594, 0.2055434574266567, 0.19780344478152634, 0.18664673615443206, 0.19218161442318082, 0.20357675824267318, 0.20611198924639873, 0.2031062627594984, 0.21558780749593565, 0.18756410182399774, 0.23537353848086828, 0.2092872159055903, 0.2619217233248985, 0.2796648720150984, 0.24685053620048225, 0.2426479057689086, 0.22386229653746037, 0.23145384533629698, 0.2406906004228987, 0.11169242213361286, 0.12422077486366101, 0.12581401242354495, 0.07369391976943773, 0.1304387731743838, 0.12397874624694427, 0.12033662989129956, 0.12571418801879608, 0.1302244710856295, 0.1258625718644364, 0.11877909545626175, 0.12209495774235479, 0.11634114164821219, 0.11569932780682046, 0.1240649158375261, 0.11642610150956112, 0.10982020826976058, 0.11915082907427732, 9.999999999998899e-05, 9.999999999998899e-05, 0.005156285396483162, 0.004608733579043123, 9.999999999998899e-05, 9.999999999998899e-05, 0.013428548446602684, 9.999999999998899e-05, 9.999999999998899e-05, 0.11425653801808944, 0.12551288117852621, 0.12819296273339065, 0.08491437806426672, 0.09786827530613684, 0.06199975875947272, 0.13739508541419543, 0.05378906563854724, 0.10448947103543782, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06427214812170445, 0.05614552128909711, 0.05934431294312981, 0.046994663691863225, 0.05559824338845831, 0.04692522648950859, 0.04947363379933034, 0.045180843982099206, 0.06462147596008494, 0.33014361615465027, 0.3027306240804656, 0.32056716698464716, 0.3293951718468444, 0.32683172236106717, 0.31853161797488627, 0.3278419362794518, 0.31378145419586767, 0.32427030677496105, 0.09860746249163255, 0.092327371591571, 0.09219198780839721, 0.08523668634620607, 0.10405307486966997, 0.10748822773818278, 0.10824576489318605, 0.07940494615820459, 0.07644462004876895, 0.15598951119806392, 0.1719585184880541, 0.18769757218291816, 0.17098430916309004, 0.2256477839152008, 0.13944841901553973, 0.16712131811331488, 0.17331095212234926, 0.16865013569680454, 0.2509888048873612, 0.22967862415481954, 0.17222292770668723, 0.22298932990367526, 0.24809026597868533, 0.22812835406504117, 0.2106237671685276, 0.22421517524665113, 0.17902686880528051, 0.18908685629205257, 0.18949699168815182, 0.15556779549551125, 0.17944731586710472, 0.18157518215996837, 0.1088897515849514, 0.1475780272078857, 0.15246860542795293, 0.16863389292627784, 0.19996133171390373, 0.21337239063357727, 0.2046449169698169, 0.2150531336800232, 0.20145773908329567, 0.20719339165361228, 0.21459733644349832, 0.18022071020646557, 0.21738950673721502, 0.17579142782163049, 0.182882144838577, 0.17542442531554403, 0.1883710510599984, 0.1922307111477206, 0.16562183613532067, 0.18311107179280917, 0.1808107636785934, 0.17856680950199366, 0.18232757552570256, 0.1354507410600867, 0.10396661509614458, 0.17164417738622706, 0.11184426529841496, 0.06154296356924693, 0.10804993512178918, 0.11392012923647177, 0.1668673495657622, 0.40910750206425295, 0.11265567458922321, 0.08278809806016874, 0.16917040576805975, 0.2052779734290323, 0.18821781994142062, 0.16890875209298628, 0.16638593379334832, 0.31140553558148676, 0.18598771411132908, 0.19552006417231504, 0.17705998279747093, 0.19233917710934523, 0.19536693471165456, 0.1773683639429151, 0.19439448924685654, 0.18663424888765257, 0.1822099964310936, 0.09302789782856002, 0.09793769461293655, 0.07330140063167978, 0.0813905655702909, 0.081109769917739, 0.10737295121838064, 0.09697559666555988, 0.0896090233163448, 0.08896380484410416]}, "mutation_prompt": null}
{"id": "a2075762-49de-4012-9df1-657af4447a36", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / 10\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Adaptive Random Sampling with Local Search that balances exploration and exploitation based on feedback from evaluated solutions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e9d99c8e-92f0-4e81-9682-8811ebf84876", "metadata": {"aucs": [0.3421937269162143, 0.3335060931404473, 0.3207155317229389, 0.3065995845330628, 0.3343185543553604, 0.315254977145659, 0.2977296024252394, 0.31337199221151846, 0.32315032324011483, 0.0015499546630959316, 0.020222745644837614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015788823539580887, 9.999999999998899e-05, 0.06074324740566461, 0.0903670515477184, 0.08505308802899636, 0.09307938665983106, 0.07703355822426294, 0.1002329525888519, 0.10311293964601576, 0.08892496070883882, 0.09274892928578993, 0.1011841133470831, 0.0768182180414333, 0.07918795392385258, 0.09060531209827682, 0.05761954034972838, 0.06806801824531938, 0.08833067945994622, 0.10505612243144191, 0.07188839241306888, 0.954670413000935, 0.953404699868996, 0.9349225876626759, 0.9493667478216468, 0.9441209523472963, 0.9347734251633665, 0.953492461532374, 0.9612390513882814, 0.9624757692095594, 0.2055434574266567, 0.19780344478152634, 0.18664673615443206, 0.19218161442318082, 0.20357675824267318, 0.20611198924639873, 0.2031062627594984, 0.21558780749593565, 0.18756410182399774, 0.23537353848086828, 0.2092872159055903, 0.2619217233248985, 0.2796648720150984, 0.24685053620048225, 0.2426479057689086, 0.22386229653746037, 0.23145384533629698, 0.2406906004228987, 0.11169242213361286, 0.12422077486366101, 0.12581401242354495, 0.07369391976943773, 0.1304387731743838, 0.12397874624694427, 0.12033662989129956, 0.12571418801879608, 0.1302244710856295, 0.1258625718644364, 0.11877909545626175, 0.12209495774235479, 0.11634114164821219, 0.11569932780682046, 0.1240649158375261, 0.11642610150956112, 0.10982020826976058, 0.11915082907427732, 9.999999999998899e-05, 9.999999999998899e-05, 0.005156285396483162, 0.004608733579043123, 9.999999999998899e-05, 9.999999999998899e-05, 0.013428548446602684, 9.999999999998899e-05, 9.999999999998899e-05, 0.11425653801808944, 0.12551288117852621, 0.12819296273339065, 0.08491437806426672, 0.09786827530613684, 0.06199975875947272, 0.13739508541419543, 0.05378906563854724, 0.10448947103543782, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06427214812170445, 0.05614552128909711, 0.05934431294312981, 0.046994663691863225, 0.05559824338845831, 0.04692522648950859, 0.04947363379933034, 0.045180843982099206, 0.06462147596008494, 0.33014361615465027, 0.3027306240804656, 0.32056716698464716, 0.3293951718468444, 0.32683172236106717, 0.31853161797488627, 0.3278419362794518, 0.31378145419586767, 0.32427030677496105, 0.09860746249163255, 0.092327371591571, 0.09219198780839721, 0.08523668634620607, 0.10405307486966997, 0.10748822773818278, 0.10824576489318605, 0.07940494615820459, 0.07644462004876895, 0.15598951119806392, 0.1719585184880541, 0.18769757218291816, 0.17098430916309004, 0.2256477839152008, 0.13944841901553973, 0.16712131811331488, 0.17331095212234926, 0.16865013569680454, 0.2509888048873612, 0.22967862415481954, 0.17222292770668723, 0.22298932990367526, 0.24809026597868533, 0.22812835406504117, 0.2106237671685276, 0.22421517524665113, 0.17902686880528051, 0.18908685629205257, 0.18949699168815182, 0.15556779549551125, 0.17944731586710472, 0.18157518215996837, 0.1088897515849514, 0.1475780272078857, 0.15246860542795293, 0.16863389292627784, 0.19996133171390373, 0.21337239063357727, 0.2046449169698169, 0.2150531336800232, 0.20145773908329567, 0.20719339165361228, 0.21459733644349832, 0.18022071020646557, 0.21738950673721502, 0.17579142782163049, 0.182882144838577, 0.17542442531554403, 0.1883710510599984, 0.1922307111477206, 0.16562183613532067, 0.18311107179280917, 0.1808107636785934, 0.17856680950199366, 0.18232757552570256, 0.1354507410600867, 0.10396661509614458, 0.17164417738622706, 0.11184426529841496, 0.06154296356924693, 0.10804993512178918, 0.11392012923647177, 0.1668673495657622, 0.40910750206425295, 0.11265567458922321, 0.08278809806016874, 0.16917040576805975, 0.2052779734290323, 0.18821781994142062, 0.16890875209298628, 0.16638593379334832, 0.31140553558148676, 0.18598771411132908, 0.19552006417231504, 0.17705998279747093, 0.19233917710934523, 0.19536693471165456, 0.1773683639429151, 0.19439448924685654, 0.18663424888765257, 0.1822099964310936, 0.09302789782856002, 0.09793769461293655, 0.07330140063167978, 0.0813905655702909, 0.081109769917739, 0.10737295121838064, 0.09697559666555988, 0.0896090233163448, 0.08896380484410416]}, "mutation_prompt": null}
{"id": "05a74857-fd4c-49b0-b0b5-eeafa15c6c68", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / 10\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Adaptive Random Sampling with Local Search that balances exploration and exploitation based on feedback from evaluated solutions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e9d99c8e-92f0-4e81-9682-8811ebf84876", "metadata": {"aucs": [0.3421937269162143, 0.3335060931404473, 0.3207155317229389, 0.3065995845330628, 0.3343185543553604, 0.315254977145659, 0.2977296024252394, 0.31337199221151846, 0.32315032324011483, 0.0015499546630959316, 0.020222745644837614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015788823539580887, 9.999999999998899e-05, 0.06074324740566461, 0.0903670515477184, 0.08505308802899636, 0.09307938665983106, 0.07703355822426294, 0.1002329525888519, 0.10311293964601576, 0.08892496070883882, 0.09274892928578993, 0.1011841133470831, 0.0768182180414333, 0.07918795392385258, 0.09060531209827682, 0.05761954034972838, 0.06806801824531938, 0.08833067945994622, 0.10505612243144191, 0.07188839241306888, 0.954670413000935, 0.953404699868996, 0.9349225876626759, 0.9493667478216468, 0.9441209523472963, 0.9347734251633665, 0.953492461532374, 0.9612390513882814, 0.9624757692095594, 0.2055434574266567, 0.19780344478152634, 0.18664673615443206, 0.19218161442318082, 0.20357675824267318, 0.20611198924639873, 0.2031062627594984, 0.21558780749593565, 0.18756410182399774, 0.23537353848086828, 0.2092872159055903, 0.2619217233248985, 0.2796648720150984, 0.24685053620048225, 0.2426479057689086, 0.22386229653746037, 0.23145384533629698, 0.2406906004228987, 0.11169242213361286, 0.12422077486366101, 0.12581401242354495, 0.07369391976943773, 0.1304387731743838, 0.12397874624694427, 0.12033662989129956, 0.12571418801879608, 0.1302244710856295, 0.1258625718644364, 0.11877909545626175, 0.12209495774235479, 0.11634114164821219, 0.11569932780682046, 0.1240649158375261, 0.11642610150956112, 0.10982020826976058, 0.11915082907427732, 9.999999999998899e-05, 9.999999999998899e-05, 0.005156285396483162, 0.004608733579043123, 9.999999999998899e-05, 9.999999999998899e-05, 0.013428548446602684, 9.999999999998899e-05, 9.999999999998899e-05, 0.11425653801808944, 0.12551288117852621, 0.12819296273339065, 0.08491437806426672, 0.09786827530613684, 0.06199975875947272, 0.13739508541419543, 0.05378906563854724, 0.10448947103543782, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06427214812170445, 0.05614552128909711, 0.05934431294312981, 0.046994663691863225, 0.05559824338845831, 0.04692522648950859, 0.04947363379933034, 0.045180843982099206, 0.06462147596008494, 0.33014361615465027, 0.3027306240804656, 0.32056716698464716, 0.3293951718468444, 0.32683172236106717, 0.31853161797488627, 0.3278419362794518, 0.31378145419586767, 0.32427030677496105, 0.09860746249163255, 0.092327371591571, 0.09219198780839721, 0.08523668634620607, 0.10405307486966997, 0.10748822773818278, 0.10824576489318605, 0.07940494615820459, 0.07644462004876895, 0.15598951119806392, 0.1719585184880541, 0.18769757218291816, 0.17098430916309004, 0.2256477839152008, 0.13944841901553973, 0.16712131811331488, 0.17331095212234926, 0.16865013569680454, 0.2509888048873612, 0.22967862415481954, 0.17222292770668723, 0.22298932990367526, 0.24809026597868533, 0.22812835406504117, 0.2106237671685276, 0.22421517524665113, 0.17902686880528051, 0.18908685629205257, 0.18949699168815182, 0.15556779549551125, 0.17944731586710472, 0.18157518215996837, 0.1088897515849514, 0.1475780272078857, 0.15246860542795293, 0.16863389292627784, 0.19996133171390373, 0.21337239063357727, 0.2046449169698169, 0.2150531336800232, 0.20145773908329567, 0.20719339165361228, 0.21459733644349832, 0.18022071020646557, 0.21738950673721502, 0.17579142782163049, 0.182882144838577, 0.17542442531554403, 0.1883710510599984, 0.1922307111477206, 0.16562183613532067, 0.18311107179280917, 0.1808107636785934, 0.17856680950199366, 0.18232757552570256, 0.1354507410600867, 0.10396661509614458, 0.17164417738622706, 0.11184426529841496, 0.06154296356924693, 0.10804993512178918, 0.11392012923647177, 0.1668673495657622, 0.40910750206425295, 0.11265567458922321, 0.08278809806016874, 0.16917040576805975, 0.2052779734290323, 0.18821781994142062, 0.16890875209298628, 0.16638593379334832, 0.31140553558148676, 0.18598771411132908, 0.19552006417231504, 0.17705998279747093, 0.19233917710934523, 0.19536693471165456, 0.1773683639429151, 0.19439448924685654, 0.18663424888765257, 0.1822099964310936, 0.09302789782856002, 0.09793769461293655, 0.07330140063167978, 0.0813905655702909, 0.081109769917739, 0.10737295121838064, 0.09697559666555988, 0.0896090233163448, 0.08896380484410416]}, "mutation_prompt": null}
{"id": "b4bdf46c-838b-4248-9a13-a4c579fd3739", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 12)  # Increased candidates\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / 8  # Wider range\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.6 * success_rate))  # Increased sensitivity", "name": "AdaptiveRandomLocalSearch", "description": "Enhanced Adaptive Random Local Search by increasing candidate exploration and adaptive sensitivity.", "configspace": "", "generation": 4, "fitness": 0.17312011017741483, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "e9d99c8e-92f0-4e81-9682-8811ebf84876", "metadata": {"aucs": [0.3020760203388553, 0.3330798746216561, 0.3319510631613263, 0.29049685903987843, 0.317016594718903, 0.31292639214038775, 0.27148718096726143, 0.3503313323324905, 0.34724261856239336, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08558921009446696, 0.08732343761860628, 0.09097157338269812, 0.08122800736980518, 0.0840412108026718, 0.08874140049809887, 0.09455253017087617, 0.09874334088242753, 0.09316186152516459, 0.0677407333951704, 0.07802390006255833, 0.08039785801360244, 0.06755195872346087, 0.08318969483908167, 0.07840920356690262, 0.08181686345527417, 0.07391039997472804, 0.08778271628468215, 0.9639168991243047, 0.9524479791220294, 0.9415107309987057, 0.9504812053441627, 0.9345425527298243, 0.9538569889164089, 0.9535967379533881, 0.9608922686073001, 0.9622168422143168, 0.18482580254248904, 0.18051969835658654, 0.20183106416840801, 0.18195980482819973, 0.18166269788145373, 0.16340775959011222, 0.2038742440156629, 0.17832447290694087, 0.21100510034571573, 0.24154308651647038, 0.2517486392725514, 0.2307575249941629, 0.22601480055894807, 0.20735118021045795, 0.22100179564508893, 0.21684361959318388, 0.23245852932534283, 0.21763045865344666, 0.11187240106247043, 0.12149024890613214, 0.10680517541924606, 0.07129442968766597, 0.08687670449544571, 0.10429267854240243, 0.11113984513586872, 0.11269338550545926, 0.11586645634836168, 0.15092270126485186, 0.107662683871252, 0.11474596821327998, 0.13360954004375214, 0.11477395067276397, 0.11832272031741309, 0.11662347719864352, 0.09804960832511078, 0.13617914238398443, 9.999999999998899e-05, 9.999999999998899e-05, 0.003449526064783326, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035498040188294944, 0.1071728582092959, 0.11391543661885406, 0.1317901132731264, 0.0910339621582067, 0.07599491344261278, 0.055798849718111554, 0.08909885926291061, 0.052227221454348216, 0.1453688684174409, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03848848918531966, 0.03937484612818465, 0.038724296933878355, 0.05814197777407937, 0.036809487947873865, 0.05360394333042007, 0.04170734408038157, 0.04187141845239617, 0.0395045348431724, 0.2897640145711563, 0.30147781138634067, 0.3081356830158668, 0.3244579076345494, 0.3388124448883526, 0.29395142206232905, 0.301934139593797, 0.30822151284523747, 0.3147307721493042, 0.09184140440714383, 0.08373725051610059, 0.07156059411769333, 0.06726353422918185, 0.10853749019968395, 0.0796806397624723, 0.09976444140624319, 0.07745431711017448, 0.07649452777071597, 0.13160101127655144, 0.16500879845726535, 0.184759252313212, 0.1720063883108809, 0.19654488816088078, 0.16323974133502783, 0.1708255071558148, 0.14690143957572255, 0.1397450652792298, 0.2394107005972168, 0.21736973370628687, 0.1866153271118629, 0.23327640375985925, 0.22434413791946095, 0.22223981713513086, 0.2322007211127799, 0.22666372429853687, 0.21686710370269424, 0.18876226773021976, 0.1754239285440331, 0.12877158002470745, 0.15543087164530767, 0.17027243369188472, 0.15806849634133635, 0.16397557402979057, 0.14361364600873416, 0.1329057626104735, 0.18985243918830919, 0.2095493186617141, 0.20047802090295674, 0.22574948625628644, 0.2000233066329341, 0.2270999277856406, 0.2280773322238605, 0.2119327746303632, 0.20914870227565363, 0.1762425383209535, 0.17258873206131342, 0.177834981326776, 0.17578887266384535, 0.17789296455896075, 0.1735106913417187, 0.17762910188359804, 0.17305892525138356, 0.19255991466284728, 0.17749378375259817, 0.1314145488583377, 0.10363917704442682, 0.1724886554734517, 0.0652218823617331, 0.06121632226964868, 0.10806351501373812, 0.12344508402967747, 0.1669263643979464, 0.37750622382703314, 0.11201961434897845, 0.08205899245648562, 0.19362206827593864, 0.20416826150667788, 0.19638991908970693, 0.16732255211680858, 0.16595832703735613, 0.3824850755922422, 0.1769414715188986, 0.18825947292631073, 0.18596999088122157, 0.17650521803167518, 0.17503236725326676, 0.19043729245858698, 0.1922451341754733, 0.17412852599272788, 0.18924396083279982, 0.07478221462051227, 0.09884421862437487, 0.09773336191598914, 0.12257414349696594, 0.08597476250262048, 0.09278226426644431, 0.0978992173335288, 0.08390628861980354, 0.08425883945036983]}, "mutation_prompt": null}
{"id": "9266ac29-36a4-4241-bf03-9a7c37b7fb80", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / 10\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Adaptive Random Sampling with Local Search that balances exploration and exploitation based on feedback from evaluated solutions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e9d99c8e-92f0-4e81-9682-8811ebf84876", "metadata": {"aucs": [0.3421937269162143, 0.3335060931404473, 0.3207155317229389, 0.3065995845330628, 0.3343185543553604, 0.315254977145659, 0.2977296024252394, 0.31337199221151846, 0.32315032324011483, 0.0015499546630959316, 0.020222745644837614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015788823539580887, 9.999999999998899e-05, 0.06074324740566461, 0.0903670515477184, 0.08505308802899636, 0.09307938665983106, 0.07703355822426294, 0.1002329525888519, 0.10311293964601576, 0.08892496070883882, 0.09274892928578993, 0.1011841133470831, 0.0768182180414333, 0.07918795392385258, 0.09060531209827682, 0.05761954034972838, 0.06806801824531938, 0.08833067945994622, 0.10505612243144191, 0.07188839241306888, 0.954670413000935, 0.953404699868996, 0.9349225876626759, 0.9493667478216468, 0.9441209523472963, 0.9347734251633665, 0.953492461532374, 0.9612390513882814, 0.9624757692095594, 0.2055434574266567, 0.19780344478152634, 0.18664673615443206, 0.19218161442318082, 0.20357675824267318, 0.20611198924639873, 0.2031062627594984, 0.21558780749593565, 0.18756410182399774, 0.23537353848086828, 0.2092872159055903, 0.2619217233248985, 0.2796648720150984, 0.24685053620048225, 0.2426479057689086, 0.22386229653746037, 0.23145384533629698, 0.2406906004228987, 0.11169242213361286, 0.12422077486366101, 0.12581401242354495, 0.07369391976943773, 0.1304387731743838, 0.12397874624694427, 0.12033662989129956, 0.12571418801879608, 0.1302244710856295, 0.1258625718644364, 0.11877909545626175, 0.12209495774235479, 0.11634114164821219, 0.11569932780682046, 0.1240649158375261, 0.11642610150956112, 0.10982020826976058, 0.11915082907427732, 9.999999999998899e-05, 9.999999999998899e-05, 0.005156285396483162, 0.004608733579043123, 9.999999999998899e-05, 9.999999999998899e-05, 0.013428548446602684, 9.999999999998899e-05, 9.999999999998899e-05, 0.11425653801808944, 0.12551288117852621, 0.12819296273339065, 0.08491437806426672, 0.09786827530613684, 0.06199975875947272, 0.13739508541419543, 0.05378906563854724, 0.10448947103543782, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06427214812170445, 0.05614552128909711, 0.05934431294312981, 0.046994663691863225, 0.05559824338845831, 0.04692522648950859, 0.04947363379933034, 0.045180843982099206, 0.06462147596008494, 0.33014361615465027, 0.3027306240804656, 0.32056716698464716, 0.3293951718468444, 0.32683172236106717, 0.31853161797488627, 0.3278419362794518, 0.31378145419586767, 0.32427030677496105, 0.09860746249163255, 0.092327371591571, 0.09219198780839721, 0.08523668634620607, 0.10405307486966997, 0.10748822773818278, 0.10824576489318605, 0.07940494615820459, 0.07644462004876895, 0.15598951119806392, 0.1719585184880541, 0.18769757218291816, 0.17098430916309004, 0.2256477839152008, 0.13944841901553973, 0.16712131811331488, 0.17331095212234926, 0.16865013569680454, 0.2509888048873612, 0.22967862415481954, 0.17222292770668723, 0.22298932990367526, 0.24809026597868533, 0.22812835406504117, 0.2106237671685276, 0.22421517524665113, 0.17902686880528051, 0.18908685629205257, 0.18949699168815182, 0.15556779549551125, 0.17944731586710472, 0.18157518215996837, 0.1088897515849514, 0.1475780272078857, 0.15246860542795293, 0.16863389292627784, 0.19996133171390373, 0.21337239063357727, 0.2046449169698169, 0.2150531336800232, 0.20145773908329567, 0.20719339165361228, 0.21459733644349832, 0.18022071020646557, 0.21738950673721502, 0.17579142782163049, 0.182882144838577, 0.17542442531554403, 0.1883710510599984, 0.1922307111477206, 0.16562183613532067, 0.18311107179280917, 0.1808107636785934, 0.17856680950199366, 0.18232757552570256, 0.1354507410600867, 0.10396661509614458, 0.17164417738622706, 0.11184426529841496, 0.06154296356924693, 0.10804993512178918, 0.11392012923647177, 0.1668673495657622, 0.40910750206425295, 0.11265567458922321, 0.08278809806016874, 0.16917040576805975, 0.2052779734290323, 0.18821781994142062, 0.16890875209298628, 0.16638593379334832, 0.31140553558148676, 0.18598771411132908, 0.19552006417231504, 0.17705998279747093, 0.19233917710934523, 0.19536693471165456, 0.1773683639429151, 0.19439448924685654, 0.18663424888765257, 0.1822099964310936, 0.09302789782856002, 0.09793769461293655, 0.07330140063167978, 0.0813905655702909, 0.081109769917739, 0.10737295121838064, 0.09697559666555988, 0.0896090233163448, 0.08896380484410416]}, "mutation_prompt": null}
{"id": "a9dbc37c-0db4-479d-8f5f-7ea12d3529ed", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Adjusting perturbation_radius calculation with adaptation_factor\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / (10 * adaptation_factor)  \n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Improved adaptation mechanism by dynamically adjusting the perturbation radius based on recent improvement trends.", "configspace": "", "generation": 6, "fitness": 0.17895773057980244, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "e9d99c8e-92f0-4e81-9682-8811ebf84876", "metadata": {"aucs": [0.31626175628304276, 0.3394307615442922, 0.37625179381518425, 0.2997948854650059, 0.2974946659434152, 0.3217905795009335, 0.3109622352347534, 0.31930566375950786, 0.30921872906154557, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08313799879231898, 0.07872806098824892, 0.07143042781552267, 0.09612892936543271, 0.0982971345291539, 0.09748539927693689, 0.07925806675115588, 0.12090967633308902, 0.09184776143723705, 0.08949490875906263, 0.09239435213136893, 0.08535346070885785, 0.0708894163978212, 0.07761652762562044, 0.07812547329918595, 0.08234426030827613, 0.07602797417798934, 0.09263449241912003, 0.9748492188101529, 0.9821770270198861, 0.9593212127232, 0.9689766016013585, 0.953118093644495, 0.9536415650541689, 0.9699113583270716, 0.9684810960429319, 0.9789013596447823, 0.20562282351210115, 0.2336945103604796, 0.22233662097180817, 0.20636632507810837, 0.2126044824908908, 0.2228366488666783, 0.20541647590571, 0.20697170866809877, 0.21055562226320546, 0.23356380575800528, 0.26855161168553643, 0.24538906581007625, 0.2694084905634557, 0.2211906069439269, 0.2778322624485897, 0.3047554688015762, 0.25180610231682365, 0.2638861730113926, 0.11244824964064848, 0.13419446416212355, 0.11198970724509127, 0.10669482920518603, 0.13827291761527394, 0.11797830591744263, 0.10987805637297732, 0.13438127969248415, 0.1202744758669052, 0.1208600473252136, 0.10892254643188337, 0.11655870515785738, 0.10572815876827613, 0.14942245169842572, 0.12911469739880033, 0.12106642400762724, 0.13136035395809742, 0.13227225982057966, 9.999999999998899e-05, 0.0018870646996907992, 9.999999999998899e-05, 0.00496387996236658, 9.999999999998899e-05, 0.03754824917039401, 9.999999999998899e-05, 9.999999999998899e-05, 0.008922982297785542, 0.16470384553807493, 0.08407954316082178, 0.18593163272150182, 0.08456221434905287, 0.06495350671922606, 0.048608604189921745, 0.14019356584266973, 0.07635794545147656, 0.12043219835001617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05201188341636176, 0.03364175167797345, 0.043485776555915456, 0.04996359293217867, 0.04938456034211358, 0.045043299694197625, 0.04667954818252962, 0.0841653860183118, 0.052645919182729095, 0.3163742672697183, 0.3213506829471582, 0.3180576716097401, 0.3077714262021014, 0.3393539123464657, 0.29887052216834176, 0.3201791332546915, 0.3430402458193298, 0.3212100403786504, 0.09308146828982411, 0.09557276394736514, 0.10838107046605705, 0.11892585737896899, 0.07626524201536555, 0.10567695723685955, 0.09366267577935028, 0.09041238218959624, 0.0858426560359169, 0.17900365681771668, 0.1821739815607949, 0.16725542868251797, 0.17846996528296055, 0.18088705436867336, 0.18875932682811913, 0.09889851721357157, 0.13729301316928944, 0.19087849217565922, 0.2294104517241774, 0.25161144739928176, 0.22106314421004458, 0.23546712171568163, 0.2313872441979783, 0.19962278290944824, 0.22692495145466673, 0.24909328087309424, 0.19050332415530336, 0.1709740731821081, 0.190289457218341, 0.11388162470069074, 0.1768966832452501, 0.18683166144587915, 0.12313189742817299, 0.18072935021184844, 0.1096950752896173, 0.1231718024894799, 0.21455073796427404, 0.22022458585430238, 0.19423995071178501, 0.18220018546886685, 0.23492781656944817, 0.1864391700784418, 0.22639605591935097, 0.17249909363854765, 0.20507800997107573, 0.18464189076117787, 0.1679739532085478, 0.18552979561938732, 0.17344575585925137, 0.1874160539304367, 0.1716498212831078, 0.16955960522002222, 0.18728857147054312, 0.17987450863584287, 0.18004827063853768, 0.13288796587241614, 0.09747158410722023, 0.17213886212060114, 0.11217087436923134, 0.09887886706653193, 0.10834283329879546, 0.11414071853470631, 0.16734949315388803, 0.37163875170031346, 0.11209164094524116, 0.0823351794443219, 0.1694898248917308, 0.19751044123795714, 0.19807258045956821, 0.16766373043159932, 0.16849260201866545, 0.3480588356616815, 0.1918009260319672, 0.1813516162443869, 0.19162160714362453, 0.1778660686039648, 0.18199999491898355, 0.17852771061297912, 0.18689269751004622, 0.1910901877139729, 0.18072148644789066, 0.10783314378149478, 0.08902531561032223, 0.079614937962594, 0.07865194898279004, 0.07000192158931895, 0.08596228310697696, 0.10026209610237946, 0.07992535690525182, 0.08200149177630922]}, "mutation_prompt": null}
{"id": "ffeaa146-40b4-44b4-9018-b7601e11d7d8", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Adjusting perturbation_radius calculation with adaptation_factor\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / (10 * adaptation_factor)  \n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Improved adaptation mechanism by dynamically adjusting the perturbation radius based on recent improvement trends.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a9dbc37c-0db4-479d-8f5f-7ea12d3529ed", "metadata": {"aucs": [0.31626175628304276, 0.3394307615442922, 0.37625179381518425, 0.2997948854650059, 0.2974946659434152, 0.3217905795009335, 0.3109622352347534, 0.31930566375950786, 0.30921872906154557, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08313799879231898, 0.07872806098824892, 0.07143042781552267, 0.09612892936543271, 0.0982971345291539, 0.09748539927693689, 0.07925806675115588, 0.12090967633308902, 0.09184776143723705, 0.08949490875906263, 0.09239435213136893, 0.08535346070885785, 0.0708894163978212, 0.07761652762562044, 0.07812547329918595, 0.08234426030827613, 0.07602797417798934, 0.09263449241912003, 0.9748492188101529, 0.9821770270198861, 0.9593212127232, 0.9689766016013585, 0.953118093644495, 0.9536415650541689, 0.9699113583270716, 0.9684810960429319, 0.9789013596447823, 0.20562282351210115, 0.2336945103604796, 0.22233662097180817, 0.20636632507810837, 0.2126044824908908, 0.2228366488666783, 0.20541647590571, 0.20697170866809877, 0.21055562226320546, 0.23356380575800528, 0.26855161168553643, 0.24538906581007625, 0.2694084905634557, 0.2211906069439269, 0.2778322624485897, 0.3047554688015762, 0.25180610231682365, 0.2638861730113926, 0.11244824964064848, 0.13419446416212355, 0.11198970724509127, 0.10669482920518603, 0.13827291761527394, 0.11797830591744263, 0.10987805637297732, 0.13438127969248415, 0.1202744758669052, 0.1208600473252136, 0.10892254643188337, 0.11655870515785738, 0.10572815876827613, 0.14942245169842572, 0.12911469739880033, 0.12106642400762724, 0.13136035395809742, 0.13227225982057966, 9.999999999998899e-05, 0.0018870646996907992, 9.999999999998899e-05, 0.00496387996236658, 9.999999999998899e-05, 0.03754824917039401, 9.999999999998899e-05, 9.999999999998899e-05, 0.008922982297785542, 0.16470384553807493, 0.08407954316082178, 0.18593163272150182, 0.08456221434905287, 0.06495350671922606, 0.048608604189921745, 0.14019356584266973, 0.07635794545147656, 0.12043219835001617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05201188341636176, 0.03364175167797345, 0.043485776555915456, 0.04996359293217867, 0.04938456034211358, 0.045043299694197625, 0.04667954818252962, 0.0841653860183118, 0.052645919182729095, 0.3163742672697183, 0.3213506829471582, 0.3180576716097401, 0.3077714262021014, 0.3393539123464657, 0.29887052216834176, 0.3201791332546915, 0.3430402458193298, 0.3212100403786504, 0.09308146828982411, 0.09557276394736514, 0.10838107046605705, 0.11892585737896899, 0.07626524201536555, 0.10567695723685955, 0.09366267577935028, 0.09041238218959624, 0.0858426560359169, 0.17900365681771668, 0.1821739815607949, 0.16725542868251797, 0.17846996528296055, 0.18088705436867336, 0.18875932682811913, 0.09889851721357157, 0.13729301316928944, 0.19087849217565922, 0.2294104517241774, 0.25161144739928176, 0.22106314421004458, 0.23546712171568163, 0.2313872441979783, 0.19962278290944824, 0.22692495145466673, 0.24909328087309424, 0.19050332415530336, 0.1709740731821081, 0.190289457218341, 0.11388162470069074, 0.1768966832452501, 0.18683166144587915, 0.12313189742817299, 0.18072935021184844, 0.1096950752896173, 0.1231718024894799, 0.21455073796427404, 0.22022458585430238, 0.19423995071178501, 0.18220018546886685, 0.23492781656944817, 0.1864391700784418, 0.22639605591935097, 0.17249909363854765, 0.20507800997107573, 0.18464189076117787, 0.1679739532085478, 0.18552979561938732, 0.17344575585925137, 0.1874160539304367, 0.1716498212831078, 0.16955960522002222, 0.18728857147054312, 0.17987450863584287, 0.18004827063853768, 0.13288796587241614, 0.09747158410722023, 0.17213886212060114, 0.11217087436923134, 0.09887886706653193, 0.10834283329879546, 0.11414071853470631, 0.16734949315388803, 0.37163875170031346, 0.11209164094524116, 0.0823351794443219, 0.1694898248917308, 0.19751044123795714, 0.19807258045956821, 0.16766373043159932, 0.16849260201866545, 0.3480588356616815, 0.1918009260319672, 0.1813516162443869, 0.19162160714362453, 0.1778660686039648, 0.18199999491898355, 0.17852771061297912, 0.18689269751004622, 0.1910901877139729, 0.18072148644789066, 0.10783314378149478, 0.08902531561032223, 0.079614937962594, 0.07865194898279004, 0.07000192158931895, 0.08596228310697696, 0.10026209610237946, 0.07992535690525182, 0.08200149177630922]}, "mutation_prompt": null}
{"id": "3c7928ad-b2d0-4111-9fad-7c0ce8a52aa7", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Adjusting perturbation_radius calculation with adaptation_factor\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / (10 * adaptation_factor)  \n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Improved adaptation mechanism by dynamically adjusting the perturbation radius based on recent improvement trends.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a9dbc37c-0db4-479d-8f5f-7ea12d3529ed", "metadata": {"aucs": [0.31626175628304276, 0.3394307615442922, 0.37625179381518425, 0.2997948854650059, 0.2974946659434152, 0.3217905795009335, 0.3109622352347534, 0.31930566375950786, 0.30921872906154557, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08313799879231898, 0.07872806098824892, 0.07143042781552267, 0.09612892936543271, 0.0982971345291539, 0.09748539927693689, 0.07925806675115588, 0.12090967633308902, 0.09184776143723705, 0.08949490875906263, 0.09239435213136893, 0.08535346070885785, 0.0708894163978212, 0.07761652762562044, 0.07812547329918595, 0.08234426030827613, 0.07602797417798934, 0.09263449241912003, 0.9748492188101529, 0.9821770270198861, 0.9593212127232, 0.9689766016013585, 0.953118093644495, 0.9536415650541689, 0.9699113583270716, 0.9684810960429319, 0.9789013596447823, 0.20562282351210115, 0.2336945103604796, 0.22233662097180817, 0.20636632507810837, 0.2126044824908908, 0.2228366488666783, 0.20541647590571, 0.20697170866809877, 0.21055562226320546, 0.23356380575800528, 0.26855161168553643, 0.24538906581007625, 0.2694084905634557, 0.2211906069439269, 0.2778322624485897, 0.3047554688015762, 0.25180610231682365, 0.2638861730113926, 0.11244824964064848, 0.13419446416212355, 0.11198970724509127, 0.10669482920518603, 0.13827291761527394, 0.11797830591744263, 0.10987805637297732, 0.13438127969248415, 0.1202744758669052, 0.1208600473252136, 0.10892254643188337, 0.11655870515785738, 0.10572815876827613, 0.14942245169842572, 0.12911469739880033, 0.12106642400762724, 0.13136035395809742, 0.13227225982057966, 9.999999999998899e-05, 0.0018870646996907992, 9.999999999998899e-05, 0.00496387996236658, 9.999999999998899e-05, 0.03754824917039401, 9.999999999998899e-05, 9.999999999998899e-05, 0.008922982297785542, 0.16470384553807493, 0.08407954316082178, 0.18593163272150182, 0.08456221434905287, 0.06495350671922606, 0.048608604189921745, 0.14019356584266973, 0.07635794545147656, 0.12043219835001617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05201188341636176, 0.03364175167797345, 0.043485776555915456, 0.04996359293217867, 0.04938456034211358, 0.045043299694197625, 0.04667954818252962, 0.0841653860183118, 0.052645919182729095, 0.3163742672697183, 0.3213506829471582, 0.3180576716097401, 0.3077714262021014, 0.3393539123464657, 0.29887052216834176, 0.3201791332546915, 0.3430402458193298, 0.3212100403786504, 0.09308146828982411, 0.09557276394736514, 0.10838107046605705, 0.11892585737896899, 0.07626524201536555, 0.10567695723685955, 0.09366267577935028, 0.09041238218959624, 0.0858426560359169, 0.17900365681771668, 0.1821739815607949, 0.16725542868251797, 0.17846996528296055, 0.18088705436867336, 0.18875932682811913, 0.09889851721357157, 0.13729301316928944, 0.19087849217565922, 0.2294104517241774, 0.25161144739928176, 0.22106314421004458, 0.23546712171568163, 0.2313872441979783, 0.19962278290944824, 0.22692495145466673, 0.24909328087309424, 0.19050332415530336, 0.1709740731821081, 0.190289457218341, 0.11388162470069074, 0.1768966832452501, 0.18683166144587915, 0.12313189742817299, 0.18072935021184844, 0.1096950752896173, 0.1231718024894799, 0.21455073796427404, 0.22022458585430238, 0.19423995071178501, 0.18220018546886685, 0.23492781656944817, 0.1864391700784418, 0.22639605591935097, 0.17249909363854765, 0.20507800997107573, 0.18464189076117787, 0.1679739532085478, 0.18552979561938732, 0.17344575585925137, 0.1874160539304367, 0.1716498212831078, 0.16955960522002222, 0.18728857147054312, 0.17987450863584287, 0.18004827063853768, 0.13288796587241614, 0.09747158410722023, 0.17213886212060114, 0.11217087436923134, 0.09887886706653193, 0.10834283329879546, 0.11414071853470631, 0.16734949315388803, 0.37163875170031346, 0.11209164094524116, 0.0823351794443219, 0.1694898248917308, 0.19751044123795714, 0.19807258045956821, 0.16766373043159932, 0.16849260201866545, 0.3480588356616815, 0.1918009260319672, 0.1813516162443869, 0.19162160714362453, 0.1778660686039648, 0.18199999491898355, 0.17852771061297912, 0.18689269751004622, 0.1910901877139729, 0.18072148644789066, 0.10783314378149478, 0.08902531561032223, 0.079614937962594, 0.07865194898279004, 0.07000192158931895, 0.08596228310697696, 0.10026209610237946, 0.07992535690525182, 0.08200149177630922]}, "mutation_prompt": null}
{"id": "27a4fd03-776e-44d8-9574-8c6f9d883a91", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Adjusting perturbation_radius calculation with adaptation_factor\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / (10 * adaptation_factor)  \n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Improved adaptation mechanism by dynamically adjusting the perturbation radius based on recent improvement trends.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a9dbc37c-0db4-479d-8f5f-7ea12d3529ed", "metadata": {"aucs": [0.31626175628304276, 0.3394307615442922, 0.37625179381518425, 0.2997948854650059, 0.2974946659434152, 0.3217905795009335, 0.3109622352347534, 0.31930566375950786, 0.30921872906154557, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08313799879231898, 0.07872806098824892, 0.07143042781552267, 0.09612892936543271, 0.0982971345291539, 0.09748539927693689, 0.07925806675115588, 0.12090967633308902, 0.09184776143723705, 0.08949490875906263, 0.09239435213136893, 0.08535346070885785, 0.0708894163978212, 0.07761652762562044, 0.07812547329918595, 0.08234426030827613, 0.07602797417798934, 0.09263449241912003, 0.9748492188101529, 0.9821770270198861, 0.9593212127232, 0.9689766016013585, 0.953118093644495, 0.9536415650541689, 0.9699113583270716, 0.9684810960429319, 0.9789013596447823, 0.20562282351210115, 0.2336945103604796, 0.22233662097180817, 0.20636632507810837, 0.2126044824908908, 0.2228366488666783, 0.20541647590571, 0.20697170866809877, 0.21055562226320546, 0.23356380575800528, 0.26855161168553643, 0.24538906581007625, 0.2694084905634557, 0.2211906069439269, 0.2778322624485897, 0.3047554688015762, 0.25180610231682365, 0.2638861730113926, 0.11244824964064848, 0.13419446416212355, 0.11198970724509127, 0.10669482920518603, 0.13827291761527394, 0.11797830591744263, 0.10987805637297732, 0.13438127969248415, 0.1202744758669052, 0.1208600473252136, 0.10892254643188337, 0.11655870515785738, 0.10572815876827613, 0.14942245169842572, 0.12911469739880033, 0.12106642400762724, 0.13136035395809742, 0.13227225982057966, 9.999999999998899e-05, 0.0018870646996907992, 9.999999999998899e-05, 0.00496387996236658, 9.999999999998899e-05, 0.03754824917039401, 9.999999999998899e-05, 9.999999999998899e-05, 0.008922982297785542, 0.16470384553807493, 0.08407954316082178, 0.18593163272150182, 0.08456221434905287, 0.06495350671922606, 0.048608604189921745, 0.14019356584266973, 0.07635794545147656, 0.12043219835001617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05201188341636176, 0.03364175167797345, 0.043485776555915456, 0.04996359293217867, 0.04938456034211358, 0.045043299694197625, 0.04667954818252962, 0.0841653860183118, 0.052645919182729095, 0.3163742672697183, 0.3213506829471582, 0.3180576716097401, 0.3077714262021014, 0.3393539123464657, 0.29887052216834176, 0.3201791332546915, 0.3430402458193298, 0.3212100403786504, 0.09308146828982411, 0.09557276394736514, 0.10838107046605705, 0.11892585737896899, 0.07626524201536555, 0.10567695723685955, 0.09366267577935028, 0.09041238218959624, 0.0858426560359169, 0.17900365681771668, 0.1821739815607949, 0.16725542868251797, 0.17846996528296055, 0.18088705436867336, 0.18875932682811913, 0.09889851721357157, 0.13729301316928944, 0.19087849217565922, 0.2294104517241774, 0.25161144739928176, 0.22106314421004458, 0.23546712171568163, 0.2313872441979783, 0.19962278290944824, 0.22692495145466673, 0.24909328087309424, 0.19050332415530336, 0.1709740731821081, 0.190289457218341, 0.11388162470069074, 0.1768966832452501, 0.18683166144587915, 0.12313189742817299, 0.18072935021184844, 0.1096950752896173, 0.1231718024894799, 0.21455073796427404, 0.22022458585430238, 0.19423995071178501, 0.18220018546886685, 0.23492781656944817, 0.1864391700784418, 0.22639605591935097, 0.17249909363854765, 0.20507800997107573, 0.18464189076117787, 0.1679739532085478, 0.18552979561938732, 0.17344575585925137, 0.1874160539304367, 0.1716498212831078, 0.16955960522002222, 0.18728857147054312, 0.17987450863584287, 0.18004827063853768, 0.13288796587241614, 0.09747158410722023, 0.17213886212060114, 0.11217087436923134, 0.09887886706653193, 0.10834283329879546, 0.11414071853470631, 0.16734949315388803, 0.37163875170031346, 0.11209164094524116, 0.0823351794443219, 0.1694898248917308, 0.19751044123795714, 0.19807258045956821, 0.16766373043159932, 0.16849260201866545, 0.3480588356616815, 0.1918009260319672, 0.1813516162443869, 0.19162160714362453, 0.1778660686039648, 0.18199999491898355, 0.17852771061297912, 0.18689269751004622, 0.1910901877139729, 0.18072148644789066, 0.10783314378149478, 0.08902531561032223, 0.079614937962594, 0.07865194898279004, 0.07000192158931895, 0.08596228310697696, 0.10026209610237946, 0.07992535690525182, 0.08200149177630922]}, "mutation_prompt": null}
{"id": "1573c90e-37dd-414b-91cd-09b100b72f90", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Adjusting perturbation_radius calculation with adaptation_factor\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / (10 * adaptation_factor)  \n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Improved adaptation mechanism by dynamically adjusting the perturbation radius based on recent improvement trends.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a9dbc37c-0db4-479d-8f5f-7ea12d3529ed", "metadata": {"aucs": [0.31626175628304276, 0.3394307615442922, 0.37625179381518425, 0.2997948854650059, 0.2974946659434152, 0.3217905795009335, 0.3109622352347534, 0.31930566375950786, 0.30921872906154557, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08313799879231898, 0.07872806098824892, 0.07143042781552267, 0.09612892936543271, 0.0982971345291539, 0.09748539927693689, 0.07925806675115588, 0.12090967633308902, 0.09184776143723705, 0.08949490875906263, 0.09239435213136893, 0.08535346070885785, 0.0708894163978212, 0.07761652762562044, 0.07812547329918595, 0.08234426030827613, 0.07602797417798934, 0.09263449241912003, 0.9748492188101529, 0.9821770270198861, 0.9593212127232, 0.9689766016013585, 0.953118093644495, 0.9536415650541689, 0.9699113583270716, 0.9684810960429319, 0.9789013596447823, 0.20562282351210115, 0.2336945103604796, 0.22233662097180817, 0.20636632507810837, 0.2126044824908908, 0.2228366488666783, 0.20541647590571, 0.20697170866809877, 0.21055562226320546, 0.23356380575800528, 0.26855161168553643, 0.24538906581007625, 0.2694084905634557, 0.2211906069439269, 0.2778322624485897, 0.3047554688015762, 0.25180610231682365, 0.2638861730113926, 0.11244824964064848, 0.13419446416212355, 0.11198970724509127, 0.10669482920518603, 0.13827291761527394, 0.11797830591744263, 0.10987805637297732, 0.13438127969248415, 0.1202744758669052, 0.1208600473252136, 0.10892254643188337, 0.11655870515785738, 0.10572815876827613, 0.14942245169842572, 0.12911469739880033, 0.12106642400762724, 0.13136035395809742, 0.13227225982057966, 9.999999999998899e-05, 0.0018870646996907992, 9.999999999998899e-05, 0.00496387996236658, 9.999999999998899e-05, 0.03754824917039401, 9.999999999998899e-05, 9.999999999998899e-05, 0.008922982297785542, 0.16470384553807493, 0.08407954316082178, 0.18593163272150182, 0.08456221434905287, 0.06495350671922606, 0.048608604189921745, 0.14019356584266973, 0.07635794545147656, 0.12043219835001617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05201188341636176, 0.03364175167797345, 0.043485776555915456, 0.04996359293217867, 0.04938456034211358, 0.045043299694197625, 0.04667954818252962, 0.0841653860183118, 0.052645919182729095, 0.3163742672697183, 0.3213506829471582, 0.3180576716097401, 0.3077714262021014, 0.3393539123464657, 0.29887052216834176, 0.3201791332546915, 0.3430402458193298, 0.3212100403786504, 0.09308146828982411, 0.09557276394736514, 0.10838107046605705, 0.11892585737896899, 0.07626524201536555, 0.10567695723685955, 0.09366267577935028, 0.09041238218959624, 0.0858426560359169, 0.17900365681771668, 0.1821739815607949, 0.16725542868251797, 0.17846996528296055, 0.18088705436867336, 0.18875932682811913, 0.09889851721357157, 0.13729301316928944, 0.19087849217565922, 0.2294104517241774, 0.25161144739928176, 0.22106314421004458, 0.23546712171568163, 0.2313872441979783, 0.19962278290944824, 0.22692495145466673, 0.24909328087309424, 0.19050332415530336, 0.1709740731821081, 0.190289457218341, 0.11388162470069074, 0.1768966832452501, 0.18683166144587915, 0.12313189742817299, 0.18072935021184844, 0.1096950752896173, 0.1231718024894799, 0.21455073796427404, 0.22022458585430238, 0.19423995071178501, 0.18220018546886685, 0.23492781656944817, 0.1864391700784418, 0.22639605591935097, 0.17249909363854765, 0.20507800997107573, 0.18464189076117787, 0.1679739532085478, 0.18552979561938732, 0.17344575585925137, 0.1874160539304367, 0.1716498212831078, 0.16955960522002222, 0.18728857147054312, 0.17987450863584287, 0.18004827063853768, 0.13288796587241614, 0.09747158410722023, 0.17213886212060114, 0.11217087436923134, 0.09887886706653193, 0.10834283329879546, 0.11414071853470631, 0.16734949315388803, 0.37163875170031346, 0.11209164094524116, 0.0823351794443219, 0.1694898248917308, 0.19751044123795714, 0.19807258045956821, 0.16766373043159932, 0.16849260201866545, 0.3480588356616815, 0.1918009260319672, 0.1813516162443869, 0.19162160714362453, 0.1778660686039648, 0.18199999491898355, 0.17852771061297912, 0.18689269751004622, 0.1910901877139729, 0.18072148644789066, 0.10783314378149478, 0.08902531561032223, 0.079614937962594, 0.07865194898279004, 0.07000192158931895, 0.08596228310697696, 0.10026209610237946, 0.07992535690525182, 0.08200149177630922]}, "mutation_prompt": null}
{"id": "acd7649b-6cc1-49dd-b6a9-ccf250571875", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Modified perturbation_radius calculation incorporating Lvy flight\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / (10 * adaptation_factor * np.random.standard_cauchy())\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhanced candidate generation by diversifying the perturbation radius using elements of Lvy flight.", "configspace": "", "generation": 11, "fitness": 0.2203593232528539, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "a9dbc37c-0db4-479d-8f5f-7ea12d3529ed", "metadata": {"aucs": [0.5627104818775952, 0.5778025859367301, 0.5400094671771563, 0.5573933239857629, 0.5927689268020572, 0.580813016614643, 0.5375852487493261, 0.5805317845753913, 0.5473005086038956, 0.08863560884640176, 0.004204524524597741, 9.999999999998899e-05, 0.025681588049691118, 0.03157699200326369, 9.999999999998899e-05, 0.01704285657663529, 0.012670582391891339, 9.999999999998899e-05, 0.08784372249781935, 0.08723664940729181, 0.05649059321919159, 0.08214296991659953, 0.15415430298491706, 0.1099440267611812, 0.12180725389668223, 0.11497483576724521, 0.11688913385998134, 0.0862500398568462, 0.038434475083462316, 0.04644648914068117, 0.10955846695960825, 0.050961794516602876, 0.08965003486496825, 0.054489197082923435, 0.05625682198246973, 0.06878525450317774, 0.9801466870285854, 0.9611420881381662, 0.9834717635833305, 0.9818518402595411, 0.9554120531482071, 0.9795791651823741, 0.9978132025626999, 0.9729736538120638, 0.9858174349930483, 0.3722623525300829, 0.38364966150912694, 0.35126377319155966, 0.379899882182658, 0.3964434412593135, 0.36467272623263103, 0.3600505591760864, 0.36997915253872893, 0.3232462701158092, 0.22487817206252136, 0.19920459163470827, 0.2204343390771485, 0.3524004877638065, 0.2750209915209121, 0.21380036329295093, 0.2236375902352319, 0.3314434476901157, 0.2297173127765162, 0.12950739810135636, 0.1700255822613903, 0.12185475302141624, 0.22397900343195865, 0.14012564001318428, 0.13157315174221584, 0.1952977998244081, 0.16041434088277584, 0.15143708855046334, 0.14205787682622906, 0.13039619637480915, 0.1308540546617344, 0.168176588469799, 0.12867367525647022, 0.1975237284147533, 0.1554847633356249, 0.15253964553250665, 0.14774809953097445, 9.999999999998899e-05, 0.0021088799128190505, 9.999999999998899e-05, 0.10185146416806035, 0.0642478911582417, 0.025302676590114204, 0.0007852940124415397, 9.999999999998899e-05, 9.999999999998899e-05, 0.07171270987109324, 0.06074101365082385, 0.057903036369430616, 0.12158925339448035, 0.035750400092014245, 0.03460249234631596, 0.11946806065367022, 0.05765220765733503, 0.09209309251713071, 0.021187540467145993, 0.031007741343533013, 0.030958809803460108, 0.025601938216942788, 0.08270470781689232, 0.04104278428959496, 0.0853677545786139, 0.08367293945978294, 0.023776246685376812, 0.1096043298743119, 0.10235047277623832, 0.13483312445746465, 0.03825420430859827, 0.1388472655027403, 0.07828179110263866, 0.13508965756575564, 0.1865997798249145, 0.18179512264723297, 0.48460970773854506, 0.449713453836573, 0.41645059307637633, 0.4427250691214182, 0.4824909295932126, 0.4720677247930072, 0.45384496961138643, 0.46139639759226114, 0.48522906581722236, 0.08116639864120101, 0.11638431479429168, 0.11947610669803221, 0.08955070976185109, 0.12304331526063506, 0.11348924803182814, 0.14723585878009493, 0.10197054427631591, 0.07354863061890449, 0.20355042812201019, 0.2025935727287278, 0.28691584894416233, 0.19535955389598691, 0.1865047385230869, 0.15754453446777716, 0.18756023782750686, 0.19106145502510186, 0.25961887372237735, 0.23660794685370146, 0.18374239383649893, 0.1437234228390607, 0.3486887894924191, 0.31209165507182013, 0.2048884635394277, 0.23655817114684186, 0.2710588558078494, 0.17035137971642522, 0.21969134459837836, 0.12778967782848072, 0.12523617467283255, 0.2060158056979391, 0.1936995209705048, 0.1449791051993714, 0.21377096583202992, 0.17035788668934349, 0.13088063401795957, 0.2016738913516929, 0.2030015394645277, 0.21022094654000278, 0.2051803584975832, 0.19711613497381897, 0.2904236531113732, 0.22126951222623636, 0.21745325137607407, 0.20063107503781952, 0.1860264718470961, 0.18168645195922728, 0.18528304581825694, 0.2327846595565224, 0.1935624285854306, 0.18651331818017647, 0.18146082184646262, 0.21222892831518558, 0.19649262328731332, 0.18970036095744391, 0.13766846737024274, 0.1745715241985788, 0.5682668102729126, 0.17348199683862187, 0.13351697964544673, 0.13734497963498593, 0.17464953537710792, 0.7835680340839212, 0.12687127681873678, 0.4031937294204566, 0.12771293976590714, 0.21061481320318276, 0.21197167525400795, 0.21231878135188065, 0.21442438995751467, 0.16630727733237927, 0.12833852583999417, 0.23301776334057533, 0.19108359227102334, 0.19772622859434907, 0.19731506956311595, 0.1977469865714666, 0.2205343892323377, 0.21070336867467931, 0.1896843893025162, 0.2171286077026715, 0.1009475771478221, 0.09283740520750616, 0.09086017232339294, 0.07686501007725743, 0.07998263880686862, 0.10257830341289942, 0.08956711841545695, 0.10846156728737877, 0.08339731841433862]}, "mutation_prompt": null}
{"id": "23d4bd43-e0ca-4c69-874c-a65635ff425c", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Modified perturbation_radius calculation incorporating Lvy flight\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / (10 * adaptation_factor * np.random.standard_cauchy())\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhanced candidate generation by diversifying the perturbation radius using elements of Lvy flight.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "acd7649b-6cc1-49dd-b6a9-ccf250571875", "metadata": {"aucs": [0.5627104818775952, 0.5778025859367301, 0.5400094671771563, 0.5573933239857629, 0.5927689268020572, 0.580813016614643, 0.5375852487493261, 0.5805317845753913, 0.5473005086038956, 0.08863560884640176, 0.004204524524597741, 9.999999999998899e-05, 0.025681588049691118, 0.03157699200326369, 9.999999999998899e-05, 0.01704285657663529, 0.012670582391891339, 9.999999999998899e-05, 0.08784372249781935, 0.08723664940729181, 0.05649059321919159, 0.08214296991659953, 0.15415430298491706, 0.1099440267611812, 0.12180725389668223, 0.11497483576724521, 0.11688913385998134, 0.0862500398568462, 0.038434475083462316, 0.04644648914068117, 0.10955846695960825, 0.050961794516602876, 0.08965003486496825, 0.054489197082923435, 0.05625682198246973, 0.06878525450317774, 0.9801466870285854, 0.9611420881381662, 0.9834717635833305, 0.9818518402595411, 0.9554120531482071, 0.9795791651823741, 0.9978132025626999, 0.9729736538120638, 0.9858174349930483, 0.3722623525300829, 0.38364966150912694, 0.35126377319155966, 0.379899882182658, 0.3964434412593135, 0.36467272623263103, 0.3600505591760864, 0.36997915253872893, 0.3232462701158092, 0.22487817206252136, 0.19920459163470827, 0.2204343390771485, 0.3524004877638065, 0.2750209915209121, 0.21380036329295093, 0.2236375902352319, 0.3314434476901157, 0.2297173127765162, 0.12950739810135636, 0.1700255822613903, 0.12185475302141624, 0.22397900343195865, 0.14012564001318428, 0.13157315174221584, 0.1952977998244081, 0.16041434088277584, 0.15143708855046334, 0.14205787682622906, 0.13039619637480915, 0.1308540546617344, 0.168176588469799, 0.12867367525647022, 0.1975237284147533, 0.1554847633356249, 0.15253964553250665, 0.14774809953097445, 9.999999999998899e-05, 0.0021088799128190505, 9.999999999998899e-05, 0.10185146416806035, 0.0642478911582417, 0.025302676590114204, 0.0007852940124415397, 9.999999999998899e-05, 9.999999999998899e-05, 0.07171270987109324, 0.06074101365082385, 0.057903036369430616, 0.12158925339448035, 0.035750400092014245, 0.03460249234631596, 0.11946806065367022, 0.05765220765733503, 0.09209309251713071, 0.021187540467145993, 0.031007741343533013, 0.030958809803460108, 0.025601938216942788, 0.08270470781689232, 0.04104278428959496, 0.0853677545786139, 0.08367293945978294, 0.023776246685376812, 0.1096043298743119, 0.10235047277623832, 0.13483312445746465, 0.03825420430859827, 0.1388472655027403, 0.07828179110263866, 0.13508965756575564, 0.1865997798249145, 0.18179512264723297, 0.48460970773854506, 0.449713453836573, 0.41645059307637633, 0.4427250691214182, 0.4824909295932126, 0.4720677247930072, 0.45384496961138643, 0.46139639759226114, 0.48522906581722236, 0.08116639864120101, 0.11638431479429168, 0.11947610669803221, 0.08955070976185109, 0.12304331526063506, 0.11348924803182814, 0.14723585878009493, 0.10197054427631591, 0.07354863061890449, 0.20355042812201019, 0.2025935727287278, 0.28691584894416233, 0.19535955389598691, 0.1865047385230869, 0.15754453446777716, 0.18756023782750686, 0.19106145502510186, 0.25961887372237735, 0.23660794685370146, 0.18374239383649893, 0.1437234228390607, 0.3486887894924191, 0.31209165507182013, 0.2048884635394277, 0.23655817114684186, 0.2710588558078494, 0.17035137971642522, 0.21969134459837836, 0.12778967782848072, 0.12523617467283255, 0.2060158056979391, 0.1936995209705048, 0.1449791051993714, 0.21377096583202992, 0.17035788668934349, 0.13088063401795957, 0.2016738913516929, 0.2030015394645277, 0.21022094654000278, 0.2051803584975832, 0.19711613497381897, 0.2904236531113732, 0.22126951222623636, 0.21745325137607407, 0.20063107503781952, 0.1860264718470961, 0.18168645195922728, 0.18528304581825694, 0.2327846595565224, 0.1935624285854306, 0.18651331818017647, 0.18146082184646262, 0.21222892831518558, 0.19649262328731332, 0.18970036095744391, 0.13766846737024274, 0.1745715241985788, 0.5682668102729126, 0.17348199683862187, 0.13351697964544673, 0.13734497963498593, 0.17464953537710792, 0.7835680340839212, 0.12687127681873678, 0.4031937294204566, 0.12771293976590714, 0.21061481320318276, 0.21197167525400795, 0.21231878135188065, 0.21442438995751467, 0.16630727733237927, 0.12833852583999417, 0.23301776334057533, 0.19108359227102334, 0.19772622859434907, 0.19731506956311595, 0.1977469865714666, 0.2205343892323377, 0.21070336867467931, 0.1896843893025162, 0.2171286077026715, 0.1009475771478221, 0.09283740520750616, 0.09086017232339294, 0.07686501007725743, 0.07998263880686862, 0.10257830341289942, 0.08956711841545695, 0.10846156728737877, 0.08339731841433862]}, "mutation_prompt": null}
{"id": "46c1938c-9331-44a2-ac74-a359dea10602", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n            else:\n                # Stochastically return to a previous solution if no improvement\n                best_solution = self.history[np.random.randint(len(self.history))][0]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Modified perturbation_radius calculation incorporating Lvy flight\n        perturbation_radius = adaptation_factor * (self.upper_bound - self.lower_bound) / (10 * adaptation_factor * np.random.standard_cauchy())\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce stochastic return to previous solutions if no improvement is detected to enhance exploration.", "configspace": "", "generation": 13, "fitness": 0.1524141344905365, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "acd7649b-6cc1-49dd-b6a9-ccf250571875", "metadata": {"aucs": [0.30622950751713984, 0.3092941003711914, 0.297781627452404, 0.3221761243883009, 0.2957065733692351, 0.3519892134812942, 0.31536845482047793, 0.29398936483699867, 0.2800222716514851, 0.0030967056545599947, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05569054455216138, 0.0855516382696937, 0.034889608742366574, 0.0679581329257879, 0.05156257897169403, 0.05952883105912732, 0.09058485560902751, 0.05745369078010265, 0.06596674487316523, 0.0985689320188865, 0.03504684041932482, 0.02393312665408409, 0.046023145826355916, 0.01816365002200726, 0.045937436968182754, 0.041784405944467085, 0.023696075329973754, 0.03879442066864558, 0.8764359434279025, 0.8527901090005778, 0.875853283047274, 0.9337996333388511, 0.938348907016399, 0.7938165519826996, 0.9978132025626999, 0.9655392954605799, 0.9018692451379562, 0.13597865640398143, 0.13239838858663966, 0.2098397241147555, 0.2042081189838053, 0.14800528433857396, 0.10464623579711918, 0.2353201932886031, 0.11803183875853396, 0.04458845008678358, 0.1624450289037659, 0.0980856945954307, 0.18563581991557565, 0.18922159735158972, 0.1523880704685162, 0.1610902476577767, 0.1883244319352695, 0.13189768492408693, 0.19056460636523087, 0.09073039611475264, 0.05309534313902109, 0.11526783363900339, 0.09980598586306622, 0.10379479868274633, 0.02561177953792737, 0.12189756835879162, 0.05955070210031954, 0.08687218118971396, 0.0919080272056001, 0.05203044743731866, 0.025562074953912495, 0.11504415636775589, 0.0726120537595234, 0.1299239234706827, 0.09364179277721907, 0.04546198338491081, 0.14062549506499689, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04206258835537413, 0.042958462934514, 0.06991433298904481, 0.07908893351097701, 0.00932387132860879, 0.02236623709321317, 0.11437866519382045, 0.026109052848142578, 0.04254629863164994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024707269121452935, 0.022229593151767757, 9.999999999998899e-05, 0.03844289011229807, 0.06057262590901902, 9.999999999998899e-05, 0.027795815465299523, 0.023960624225612626, 0.03562963950118514, 0.31224246589989013, 0.2681480042245704, 0.28342190559962566, 0.22724447830654004, 0.2836089723056554, 0.24798716293505563, 0.20937008859200412, 0.27337747590855477, 0.2722166916973707, 0.10594631487217288, 0.06410776569664556, 0.06732816474395786, 0.05710654545462113, 0.058775785875938125, 0.046152128825587946, 0.08327667183032172, 0.057593348054929105, 0.042150818634398846, 0.14565816675110932, 0.1768551814467879, 0.16823350923728708, 0.16315341441611342, 0.15299024506017866, 0.17172825517638124, 0.1704337390301538, 0.1512073033592335, 0.16325467045911268, 0.210433057307428, 0.14749260299873146, 0.11888483854318421, 0.204890398618655, 0.19787156363840297, 0.17251329915895297, 0.177948142640594, 0.16204791404083885, 0.11875856827832709, 0.195191618403721, 0.09968986289256665, 0.11247272525458829, 0.17598930786865474, 0.14314597937654872, 0.12706469211911353, 0.164715828558194, 0.1559299137099469, 0.17826922877938867, 0.19426217869729345, 0.14442826596158287, 0.15876728581992572, 0.21257085248254837, 0.14932190340190377, 0.1612347483843658, 0.1849970118607296, 0.1985192796219919, 0.1597649132123119, 0.16888421077544025, 0.15931915142381659, 0.1760618980085099, 0.1716672756318829, 0.20136345544792966, 0.1614681858273369, 0.16964531314584363, 0.16429296975099716, 0.19670586938163892, 0.17794085890504518, 0.13759498019211025, 0.14979739957177862, 0.16459894703567313, 0.1631747961989768, 0.42074215827624395, 0.13429302428457668, 0.11505570815882549, 0.15067462626405248, 0.4935416354457096, 0.10615908444463007, 0.12005801567109575, 0.16104002762726288, 0.1668984183172988, 0.20385736698048806, 0.2110570818221864, 0.13369634529524987, 0.12067959592452349, 0.202701012658267, 0.17916155807435274, 0.20967764035917547, 0.2025058801034194, 0.20283239954389876, 0.18065973229017873, 0.194479576289722, 0.1783428556737373, 0.20160586673939862, 0.058604824623855856, 0.05658748407722192, 0.07794892654636354, 0.05980573648016341, 0.05648561590641854, 0.055939997979673306, 0.08383675620925346, 0.05624618581258167, 0.058969054706030644]}, "mutation_prompt": null}
{"id": "da06cc03-8229-4c44-ad02-5773a213c7d9", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Modified perturbation_radius calculation incorporating adaptive scaling\n        adaptive_scale = 1.0 - (evals / self.budget)  # Adaptive scaling based on iteration\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (10 * adaptation_factor * np.random.standard_cauchy())\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce adaptive scaling of the perturbation radius based on iteration count to balance exploration and exploitation.", "configspace": "", "generation": 14, "fitness": 0.2274748521004718, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "acd7649b-6cc1-49dd-b6a9-ccf250571875", "metadata": {"aucs": [0.5945959860083352, 0.6069650334375776, 0.5978019781747457, 0.5995810865746267, 0.6014144861938313, 0.5720425612063529, 0.6034673265289885, 0.595620783270326, 0.6040860530343837, 0.08021988344902731, 9.999999999998899e-05, 9.999999999998899e-05, 0.054021659844034176, 0.03103196178653911, 9.999999999998899e-05, 0.04700323789357119, 0.008420141883949017, 9.999999999998899e-05, 0.08462226313560695, 0.09595476120307667, 0.06252578174927925, 0.15040317901249067, 0.10821630072022237, 0.10506000418519379, 0.12618351231574432, 0.13937443142641426, 0.1550221402259846, 0.08128921087660224, 0.02688914217240912, 0.05753316786882967, 0.08658233891553224, 0.05382459357699676, 0.052606861377215486, 0.04598876095021365, 0.05541511907047092, 0.07132697335385108, 0.9800829414087862, 0.95932600035317, 0.9834687242677346, 0.9818392384695925, 0.9553680299119692, 0.9795763345972014, 0.9978130169024523, 0.9725335306934358, 0.9858179158605553, 0.38606391732234024, 0.3709000299871583, 0.35752327331767264, 0.400166475745403, 0.4274169317427815, 0.42265581986267453, 0.4044212670592485, 0.4026706111098818, 0.39350158190945217, 0.22487969012280662, 0.16810747916233504, 0.2076686807858451, 0.6428004399578804, 0.21164574294362404, 0.2209349906864052, 0.5187881036635538, 0.5742744781370315, 0.30278665533147153, 0.15051689548459357, 0.17458565253708724, 0.12463122575081598, 0.22680421440866072, 0.16015545196443914, 0.13294460978763167, 0.17431411847852507, 0.131016979218893, 0.15845089540107526, 0.1504452894197168, 0.16039365950078588, 0.1320313156801678, 0.17807676254849647, 0.12856048666615827, 0.20459095485595236, 0.16329908040016905, 0.16108692992313978, 0.23774184634612827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06990161127264494, 0.07855657545058725, 9.999999999998899e-05, 0.00021287818263138192, 0.0007800258162695695, 0.05465582743714781, 0.06694696558059188, 0.05216178892668122, 0.06217288462126269, 0.12114134638359575, 0.03884244074150467, 0.033391711481654984, 0.12206270087844584, 0.052275140309030244, 0.08546170225679683, 0.03295733181659799, 0.046622586809865085, 0.06427007210230362, 0.04219476792005794, 0.12589105470256456, 0.10013203498054757, 0.09542838548106392, 0.08609258565804434, 0.06539545627987586, 0.11366486150674904, 0.046456926168339296, 0.09738644550730713, 0.04540730276465765, 0.09182590307024274, 0.05805824049078112, 0.17925468561899383, 0.13282200325751214, 0.18670546899561413, 0.5022928019916293, 0.4691217451384647, 0.47898519237837267, 0.44589724200908043, 0.43402113046638735, 0.4520624405017345, 0.4472466082213392, 0.4495073171326899, 0.5192212346653517, 0.1250540010521194, 0.12485332496414125, 0.09938325513844848, 0.10429229217592617, 0.07687367273252788, 0.09302258298803212, 0.1468593569682607, 0.1048830933545305, 0.14666454271109464, 0.19476976418995728, 0.23599119900748478, 0.35262142151168285, 0.1434684912965668, 0.1829816004514785, 0.27218098530137325, 0.17441968676002018, 0.2674100774507153, 0.23991755658035685, 0.15692060936880448, 0.340418660071628, 0.12931406630075815, 0.27052362695097076, 0.28539460512080095, 0.2598756244478022, 0.21477946061389575, 0.33993773579382736, 0.28110438192743814, 0.14658461635636855, 0.24765495719752473, 0.13804353686978976, 0.20771020559995168, 0.19572996559801137, 0.14254437623253924, 0.16397395713952467, 0.21256978740282284, 0.1243251707557329, 0.2051140159101945, 0.24475563644173948, 0.21026961312826298, 0.23950605493647648, 0.24071500356007125, 0.1936484077516839, 0.22733704726038717, 0.20893513691285326, 0.19544609996378515, 0.18060557658498566, 0.2506516117797306, 0.17792816268633238, 0.2328805747072238, 0.19356197230771133, 0.20840425283178277, 0.20109996442868705, 0.24521477990023677, 0.1976097762140555, 0.1897146898589187, 0.13767466807934614, 0.17544512612477114, 0.6274201289586809, 0.17564259869121468, 0.10503868056637822, 0.1687548135913527, 0.20124697266219238, 0.15439020758134192, 0.12687935214708246, 0.11259974829069475, 0.12789665637426606, 0.21032222441499826, 0.21233167131682262, 0.21257868296690474, 0.2145273115908165, 0.16607239216679115, 0.12831789096479929, 0.19641307072896375, 0.2239362918897948, 0.20770593378680946, 0.21125065934280518, 0.20726005487461985, 0.19008595067659229, 0.20358335419668605, 0.22111369886901577, 0.24617005049228224, 0.10151837833755817, 0.06927155292110565, 0.09747275626824647, 0.09221295869246637, 0.06869591398349018, 0.11787912483249874, 0.08989626795214611, 0.06149562377899043, 0.0989622439590292]}, "mutation_prompt": null}
{"id": "315a36fd-c81d-427d-adf4-32aab9e72306", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), 10)\n        # Modified perturbation_radius calculation incorporating adaptive scaling\n        adaptive_scale = 1.0 - (evals / self.budget)  # Adaptive scaling based on iteration\n        # Modify perturbation_radius to include Gaussian component\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        # Use past history to adaptively adjust the exploration range\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            # Calculate success rate in recent history\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce non-uniform mutation scaling by incorporating a Gaussian perturbation component for enhanced local exploration.", "configspace": "", "generation": 15, "fitness": 0.23749677172545097, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "da06cc03-8229-4c44-ad02-5773a213c7d9", "metadata": {"aucs": [0.6610913848348212, 0.5967456985961352, 0.6309558526173642, 0.6411048846363493, 0.5635539922578003, 0.6135230568446941, 0.6477223453536719, 0.5507928460652203, 0.619341166331163, 0.00012381209459377818, 0.0240641830839744, 9.999999999998899e-05, 0.01763858584510347, 0.03706588051201054, 9.999999999998899e-05, 0.036586922806802646, 0.015694139942872276, 9.999999999998899e-05, 0.13140320259656268, 0.07286264260632647, 0.08781779962526493, 0.07352615571348764, 0.13718056230363795, 0.09481128336693911, 0.11020123901867607, 0.11024237732722175, 0.16988582232145344, 0.07084119388085142, 0.07041495243764351, 0.047475626605239074, 0.043824243574385746, 0.06623438739287779, 0.09877938220198867, 0.06190364113666513, 0.08602229649033633, 0.045961902170929214, 0.9887259295900834, 0.9821935657991699, 0.9780980172654852, 0.9730664636252646, 0.9542201175816887, 0.9910128831347813, 0.9786564622718312, 0.9806123006870109, 0.9792504164529893, 0.4354841895892836, 0.41313384524065655, 0.40057070841945797, 0.4694058831036354, 0.43831252684418964, 0.3866988458550854, 0.4308374517806539, 0.42290602918507336, 0.40605332289163665, 0.16869121215769722, 0.1961284512232534, 0.22496850487052777, 0.2764273230299308, 0.21321911055687726, 0.20949451119256612, 0.23891617995714232, 0.48110514172044283, 0.23084324879513263, 0.14005675110922, 0.13441003313634414, 0.2079255596376023, 0.19376064931851222, 0.18093911267051055, 0.17330662085700044, 0.13107494515920548, 0.18661939034125696, 0.15221820352959092, 0.1871938274701762, 0.16153528157653452, 0.16025317578253306, 0.1844772087626031, 0.24538192798364133, 0.1573647072316311, 0.2153665337396744, 0.13054380352091977, 0.1955405537030731, 0.05616825997063313, 9.999999999998899e-05, 0.0018310947113292508, 0.07014569343979693, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008581747292213393, 9.999999999998899e-05, 0.02570009801339912, 0.029730693494770866, 0.05204939629518701, 0.16456087446416334, 0.12471847398254055, 0.025402112473036698, 0.06404737337369315, 0.14740904579448322, 0.0629344653613172, 0.1232578070379563, 0.09967735179766624, 0.014023220735058017, 0.019287744863081047, 0.058293495055515065, 0.0598383929036288, 0.05045406745779113, 0.05146322034914208, 0.08096715987012726, 0.06116160103004875, 0.06945394184056408, 0.14997002728829134, 0.05889344346099301, 0.12472026184965412, 0.09695082945653188, 0.06282758545808409, 0.1959413022538865, 0.10042025922393771, 0.10024528297829971, 0.4904511947433564, 0.46856732261749545, 0.4767283766420415, 0.49820176204920286, 0.4881910283077524, 0.4826200799806195, 0.49313932882259637, 0.46658789469740414, 0.4917002982616977, 0.14360722207593568, 0.1438079033278704, 0.10454011683070297, 0.052184690657945065, 0.08350934102876528, 0.0622982390107667, 0.07281746761948127, 0.07278606292023637, 0.06446909289713654, 0.3582663930177703, 0.24710596851197242, 0.2307375196528728, 0.2536375110281084, 0.19539362810774086, 0.19280407354176754, 0.2485007254993633, 0.2136416821745878, 0.18866471592973544, 0.3534067726397524, 0.3359066744141258, 0.13189816256589204, 0.23069766415179616, 0.22898176231837064, 0.27577863667900415, 0.3252194705553947, 0.33734275017358073, 0.2161022142900827, 0.23435029818766484, 0.15765505672795477, 0.21768336291425527, 0.20424341911823884, 0.2367749097306544, 0.13985818206717104, 0.19306562310539588, 0.1188900088795739, 0.16944049108610326, 0.18429196011269855, 0.2078688375913026, 0.192522517490474, 0.2260034759941305, 0.18438072387641102, 0.23064404320450704, 0.20954528492179048, 0.22925668223961237, 0.17331371986524868, 0.19188493865844336, 0.22555059812416178, 0.2019872887811579, 0.20128191728676614, 0.208538106976504, 0.20089196860848313, 0.18888665811427097, 0.20137496092631624, 0.17109772207960483, 0.18966041547142953, 0.1368792935575509, 0.8752887441848956, 0.17318172114626762, 0.18905487681165034, 0.12239098314650232, 0.13737969028592756, 0.11545437298088013, 0.7821872021791705, 0.7246582850198104, 0.11348513610416722, 0.5371025954026994, 0.1573664821170776, 0.21143099981851599, 0.21171437588807618, 0.5951456172468074, 0.16784463349539014, 0.47680932537153065, 0.22628621254048087, 0.18682390117697378, 0.2072743415797198, 0.21185380226946182, 0.2038720621869069, 0.21252460013267105, 0.22489066064405205, 0.19456513991894409, 0.2482164840211296, 0.10015701509547348, 0.08738962668078476, 0.07695968933307817, 0.13327884764826958, 0.0592367852538086, 0.08606079269494271, 0.09037578665048607, 0.11272422914309155, 0.0717043191284944]}, "mutation_prompt": null}
{"id": "1ce769f4-6b38-4e26-8708-9786533818f0", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget)  # Adaptive scaling based on iteration\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce adaptive candidate scaling using a dynamic number based on past improvement trend to balance exploration and exploitation.", "configspace": "", "generation": 16, "fitness": 0.2397120124432059, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "315a36fd-c81d-427d-adf4-32aab9e72306", "metadata": {"aucs": [0.6212443996617821, 0.6173801339219325, 0.667451672216973, 0.6130824194736096, 0.6578982379624237, 0.622791285569131, 0.6481075187826566, 0.646347808515702, 0.6081527375721391, 0.043464886454952056, 0.019717563117128134, 9.999999999998899e-05, 0.10763398866169305, 9.999999999998899e-05, 9.999999999998899e-05, 0.04931364138123395, 0.00011672573203691528, 9.999999999998899e-05, 0.08722179879816361, 0.0843706665119136, 0.0703657959647177, 0.09690843393939252, 0.09856002746965309, 0.14485038771077174, 0.05837640605989114, 0.15527923370927077, 0.08242966080503333, 0.08502892782360338, 0.07370916222147639, 0.047812176604470236, 0.08635644004302445, 0.09209859794107511, 0.04438819209278444, 0.09210219413175325, 0.07126185205016389, 0.061735727173223176, 0.9629483884222283, 0.9828490137739687, 0.9801835727809269, 0.9743616080733303, 0.9758945222117769, 0.9869431448874777, 0.9774195372547042, 0.9942057453616668, 0.9701522998447009, 0.41975952125443683, 0.40460280921734937, 0.38439772408856643, 0.42564185986762904, 0.436856162892435, 0.42942982508422123, 0.4130787712265508, 0.3798236799601673, 0.40208315292847363, 0.20775960544896654, 0.17708544029737272, 0.7674847347408122, 0.37131108194742124, 0.1882388184082664, 0.2802569101501844, 0.36011054131699616, 0.3756240883454418, 0.17824210971567123, 0.15504175272949683, 0.2287244142420204, 0.19425817039694837, 0.13476497043201285, 0.2283206419967706, 0.1338874114449713, 0.12021063386856368, 0.20715984203061766, 0.1315276729542615, 0.17898079562029545, 0.12617681162641514, 0.12783368924856475, 0.20427444089253277, 0.130065225308706, 0.17078892913084287, 0.13030158491846977, 0.1396478427442347, 0.18063224302805625, 9.999999999998899e-05, 0.04038452168329765, 0.01082890336044906, 0.022119801281626494, 0.11209263516537105, 0.059021213309120135, 9.999999999998899e-05, 9.999999999998899e-05, 0.07938625768579355, 0.06438697119199843, 0.08899222281585284, 0.1606609090873451, 0.14912385406452378, 0.04770342130633676, 0.053594130243457716, 0.17703765070892608, 0.046142507012286504, 0.10799164343151535, 0.03131449502843775, 0.03173398334214439, 0.05422007428874909, 0.08411192021205227, 0.05799994284493992, 0.07714229287611174, 0.07959765090204729, 0.10365408500025097, 0.08346159147642718, 0.07790982673632585, 0.15921222385448397, 0.1151194930206515, 0.11264836550488255, 0.19844174896872802, 0.11709606701544928, 0.11695819861777657, 0.12176949077301402, 0.1920920920899406, 0.47804587249537656, 0.47305723886199935, 0.4526623400664005, 0.4740392877734184, 0.4638689077346697, 0.46254035114553005, 0.48760569284954747, 0.49804807288104713, 0.4805991123868172, 0.09623421334594773, 0.08065272259022038, 0.1589915509093489, 0.08807148943227716, 0.0867055203554632, 0.08900080609758165, 0.0986696041531091, 0.1182619822106784, 0.15333848527509397, 0.18725583430227477, 0.19428100487645317, 0.3842049842906754, 0.1872685088371867, 0.2119460758719045, 0.17592532513179726, 0.3191667230735258, 0.1922234855395616, 0.1584356897434478, 0.29724512744254294, 0.23961572085107596, 0.2318148974722093, 0.21553811103175846, 0.3564281559214718, 0.14475060157117736, 0.24588562860425123, 0.3247143909701382, 0.31092485706040174, 0.24065725919499636, 0.21569640509886234, 0.07071035083582378, 0.13766779147921882, 0.1835021335189736, 0.14444004352604867, 0.1629372772021932, 0.23422143716643207, 0.23638330239603267, 0.20429696496070393, 0.1680257400828421, 0.191146289459442, 0.21733722713523262, 0.2921285409422276, 0.275695962633824, 0.20695463268188863, 0.23122434817983595, 0.20554469391105235, 0.20043816706974538, 0.1736907188446457, 0.24984943374991886, 0.17248285338531877, 0.21728845560697618, 0.20592408085106473, 0.22854922173849568, 0.17379573286592875, 0.18558530210380964, 0.16945439833145737, 0.13767240769033073, 0.8636773256063537, 0.14962430676249527, 0.1800104659654731, 0.9279162556965689, 0.13760488101968116, 0.21150609638952578, 0.15486102322899065, 0.12851652618401932, 0.1627354558972891, 0.6576274693468449, 0.15583139313463834, 0.21496790523646359, 0.2116991281992846, 0.21506114965080347, 0.16580768481758845, 0.39696158678802484, 0.2119047151986374, 0.1897464587332015, 0.20948183355343686, 0.23004984571634512, 0.1885168850136314, 0.20293052837095416, 0.21016118103522252, 0.19549202617166206, 0.19600379562559433, 0.12066572995839975, 0.10703695091150844, 0.08415549504047193, 0.07344970607539003, 0.12727508873720794, 0.09913511584829282, 0.05965563178547395, 0.08395520234237863, 0.08289967080130667]}, "mutation_prompt": null}
{"id": "47409814-fc51-4093-b428-186c2696f3c5", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget)  # Adaptive scaling based on iteration\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce adaptive candidate scaling using a dynamic number based on past improvement trend to balance exploration and exploitation.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1ce769f4-6b38-4e26-8708-9786533818f0", "metadata": {"aucs": [0.6212443996617821, 0.6173801339219325, 0.667451672216973, 0.6130824194736096, 0.6578982379624237, 0.622791285569131, 0.6481075187826566, 0.646347808515702, 0.6081527375721391, 0.043464886454952056, 0.019717563117128134, 9.999999999998899e-05, 0.10763398866169305, 9.999999999998899e-05, 9.999999999998899e-05, 0.04931364138123395, 0.00011672573203691528, 9.999999999998899e-05, 0.08722179879816361, 0.0843706665119136, 0.0703657959647177, 0.09690843393939252, 0.09856002746965309, 0.14485038771077174, 0.05837640605989114, 0.15527923370927077, 0.08242966080503333, 0.08502892782360338, 0.07370916222147639, 0.047812176604470236, 0.08635644004302445, 0.09209859794107511, 0.04438819209278444, 0.09210219413175325, 0.07126185205016389, 0.061735727173223176, 0.9629483884222283, 0.9828490137739687, 0.9801835727809269, 0.9743616080733303, 0.9758945222117769, 0.9869431448874777, 0.9774195372547042, 0.9942057453616668, 0.9701522998447009, 0.41975952125443683, 0.40460280921734937, 0.38439772408856643, 0.42564185986762904, 0.436856162892435, 0.42942982508422123, 0.4130787712265508, 0.3798236799601673, 0.40208315292847363, 0.20775960544896654, 0.17708544029737272, 0.7674847347408122, 0.37131108194742124, 0.1882388184082664, 0.2802569101501844, 0.36011054131699616, 0.3756240883454418, 0.17824210971567123, 0.15504175272949683, 0.2287244142420204, 0.19425817039694837, 0.13476497043201285, 0.2283206419967706, 0.1338874114449713, 0.12021063386856368, 0.20715984203061766, 0.1315276729542615, 0.17898079562029545, 0.12617681162641514, 0.12783368924856475, 0.20427444089253277, 0.130065225308706, 0.17078892913084287, 0.13030158491846977, 0.1396478427442347, 0.18063224302805625, 9.999999999998899e-05, 0.04038452168329765, 0.01082890336044906, 0.022119801281626494, 0.11209263516537105, 0.059021213309120135, 9.999999999998899e-05, 9.999999999998899e-05, 0.07938625768579355, 0.06438697119199843, 0.08899222281585284, 0.1606609090873451, 0.14912385406452378, 0.04770342130633676, 0.053594130243457716, 0.17703765070892608, 0.046142507012286504, 0.10799164343151535, 0.03131449502843775, 0.03173398334214439, 0.05422007428874909, 0.08411192021205227, 0.05799994284493992, 0.07714229287611174, 0.07959765090204729, 0.10365408500025097, 0.08346159147642718, 0.07790982673632585, 0.15921222385448397, 0.1151194930206515, 0.11264836550488255, 0.19844174896872802, 0.11709606701544928, 0.11695819861777657, 0.12176949077301402, 0.1920920920899406, 0.47804587249537656, 0.47305723886199935, 0.4526623400664005, 0.4740392877734184, 0.4638689077346697, 0.46254035114553005, 0.48760569284954747, 0.49804807288104713, 0.4805991123868172, 0.09623421334594773, 0.08065272259022038, 0.1589915509093489, 0.08807148943227716, 0.0867055203554632, 0.08900080609758165, 0.0986696041531091, 0.1182619822106784, 0.15333848527509397, 0.18725583430227477, 0.19428100487645317, 0.3842049842906754, 0.1872685088371867, 0.2119460758719045, 0.17592532513179726, 0.3191667230735258, 0.1922234855395616, 0.1584356897434478, 0.29724512744254294, 0.23961572085107596, 0.2318148974722093, 0.21553811103175846, 0.3564281559214718, 0.14475060157117736, 0.24588562860425123, 0.3247143909701382, 0.31092485706040174, 0.24065725919499636, 0.21569640509886234, 0.07071035083582378, 0.13766779147921882, 0.1835021335189736, 0.14444004352604867, 0.1629372772021932, 0.23422143716643207, 0.23638330239603267, 0.20429696496070393, 0.1680257400828421, 0.191146289459442, 0.21733722713523262, 0.2921285409422276, 0.275695962633824, 0.20695463268188863, 0.23122434817983595, 0.20554469391105235, 0.20043816706974538, 0.1736907188446457, 0.24984943374991886, 0.17248285338531877, 0.21728845560697618, 0.20592408085106473, 0.22854922173849568, 0.17379573286592875, 0.18558530210380964, 0.16945439833145737, 0.13767240769033073, 0.8636773256063537, 0.14962430676249527, 0.1800104659654731, 0.9279162556965689, 0.13760488101968116, 0.21150609638952578, 0.15486102322899065, 0.12851652618401932, 0.1627354558972891, 0.6576274693468449, 0.15583139313463834, 0.21496790523646359, 0.2116991281992846, 0.21506114965080347, 0.16580768481758845, 0.39696158678802484, 0.2119047151986374, 0.1897464587332015, 0.20948183355343686, 0.23004984571634512, 0.1885168850136314, 0.20293052837095416, 0.21016118103522252, 0.19549202617166206, 0.19600379562559433, 0.12066572995839975, 0.10703695091150844, 0.08415549504047193, 0.07344970607539003, 0.12727508873720794, 0.09913511584829282, 0.05965563178547395, 0.08395520234237863, 0.08289967080130667]}, "mutation_prompt": null}
{"id": "463cf8c6-5e46-4fcc-bfd9-9a240a734cbc", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget)  # Adaptive scaling based on iteration\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce adaptive candidate scaling using a dynamic number based on past improvement trend to balance exploration and exploitation.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1ce769f4-6b38-4e26-8708-9786533818f0", "metadata": {"aucs": [0.6212443996617821, 0.6173801339219325, 0.667451672216973, 0.6130824194736096, 0.6578982379624237, 0.622791285569131, 0.6481075187826566, 0.646347808515702, 0.6081527375721391, 0.043464886454952056, 0.019717563117128134, 9.999999999998899e-05, 0.10763398866169305, 9.999999999998899e-05, 9.999999999998899e-05, 0.04931364138123395, 0.00011672573203691528, 9.999999999998899e-05, 0.08722179879816361, 0.0843706665119136, 0.0703657959647177, 0.09690843393939252, 0.09856002746965309, 0.14485038771077174, 0.05837640605989114, 0.15527923370927077, 0.08242966080503333, 0.08502892782360338, 0.07370916222147639, 0.047812176604470236, 0.08635644004302445, 0.09209859794107511, 0.04438819209278444, 0.09210219413175325, 0.07126185205016389, 0.061735727173223176, 0.9629483884222283, 0.9828490137739687, 0.9801835727809269, 0.9743616080733303, 0.9758945222117769, 0.9869431448874777, 0.9774195372547042, 0.9942057453616668, 0.9701522998447009, 0.41975952125443683, 0.40460280921734937, 0.38439772408856643, 0.42564185986762904, 0.436856162892435, 0.42942982508422123, 0.4130787712265508, 0.3798236799601673, 0.40208315292847363, 0.20775960544896654, 0.17708544029737272, 0.7674847347408122, 0.37131108194742124, 0.1882388184082664, 0.2802569101501844, 0.36011054131699616, 0.3756240883454418, 0.17824210971567123, 0.15504175272949683, 0.2287244142420204, 0.19425817039694837, 0.13476497043201285, 0.2283206419967706, 0.1338874114449713, 0.12021063386856368, 0.20715984203061766, 0.1315276729542615, 0.17898079562029545, 0.12617681162641514, 0.12783368924856475, 0.20427444089253277, 0.130065225308706, 0.17078892913084287, 0.13030158491846977, 0.1396478427442347, 0.18063224302805625, 9.999999999998899e-05, 0.04038452168329765, 0.01082890336044906, 0.022119801281626494, 0.11209263516537105, 0.059021213309120135, 9.999999999998899e-05, 9.999999999998899e-05, 0.07938625768579355, 0.06438697119199843, 0.08899222281585284, 0.1606609090873451, 0.14912385406452378, 0.04770342130633676, 0.053594130243457716, 0.17703765070892608, 0.046142507012286504, 0.10799164343151535, 0.03131449502843775, 0.03173398334214439, 0.05422007428874909, 0.08411192021205227, 0.05799994284493992, 0.07714229287611174, 0.07959765090204729, 0.10365408500025097, 0.08346159147642718, 0.07790982673632585, 0.15921222385448397, 0.1151194930206515, 0.11264836550488255, 0.19844174896872802, 0.11709606701544928, 0.11695819861777657, 0.12176949077301402, 0.1920920920899406, 0.47804587249537656, 0.47305723886199935, 0.4526623400664005, 0.4740392877734184, 0.4638689077346697, 0.46254035114553005, 0.48760569284954747, 0.49804807288104713, 0.4805991123868172, 0.09623421334594773, 0.08065272259022038, 0.1589915509093489, 0.08807148943227716, 0.0867055203554632, 0.08900080609758165, 0.0986696041531091, 0.1182619822106784, 0.15333848527509397, 0.18725583430227477, 0.19428100487645317, 0.3842049842906754, 0.1872685088371867, 0.2119460758719045, 0.17592532513179726, 0.3191667230735258, 0.1922234855395616, 0.1584356897434478, 0.29724512744254294, 0.23961572085107596, 0.2318148974722093, 0.21553811103175846, 0.3564281559214718, 0.14475060157117736, 0.24588562860425123, 0.3247143909701382, 0.31092485706040174, 0.24065725919499636, 0.21569640509886234, 0.07071035083582378, 0.13766779147921882, 0.1835021335189736, 0.14444004352604867, 0.1629372772021932, 0.23422143716643207, 0.23638330239603267, 0.20429696496070393, 0.1680257400828421, 0.191146289459442, 0.21733722713523262, 0.2921285409422276, 0.275695962633824, 0.20695463268188863, 0.23122434817983595, 0.20554469391105235, 0.20043816706974538, 0.1736907188446457, 0.24984943374991886, 0.17248285338531877, 0.21728845560697618, 0.20592408085106473, 0.22854922173849568, 0.17379573286592875, 0.18558530210380964, 0.16945439833145737, 0.13767240769033073, 0.8636773256063537, 0.14962430676249527, 0.1800104659654731, 0.9279162556965689, 0.13760488101968116, 0.21150609638952578, 0.15486102322899065, 0.12851652618401932, 0.1627354558972891, 0.6576274693468449, 0.15583139313463834, 0.21496790523646359, 0.2116991281992846, 0.21506114965080347, 0.16580768481758845, 0.39696158678802484, 0.2119047151986374, 0.1897464587332015, 0.20948183355343686, 0.23004984571634512, 0.1885168850136314, 0.20293052837095416, 0.21016118103522252, 0.19549202617166206, 0.19600379562559433, 0.12066572995839975, 0.10703695091150844, 0.08415549504047193, 0.07344970607539003, 0.12727508873720794, 0.09913511584829282, 0.05965563178547395, 0.08395520234237863, 0.08289967080130667]}, "mutation_prompt": null}
{"id": "bb6c75e5-0ada-44cc-a091-f5bb061f8f07", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(15 - 5 * self.calculate_adaptation())))  # Increased candidate pool size\n        adaptive_scale = 1.0 - (evals / self.budget)  # Adaptive scaling based on iteration\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-20:]  # Broadened historical scope\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a more aggressive exploration phase early on and adjust adaptation factor calculation to consider broader historical data.", "configspace": "", "generation": 19, "fitness": 0.23390314184159172, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "1ce769f4-6b38-4e26-8708-9786533818f0", "metadata": {"aucs": [0.6693561969331179, 0.5846379819662495, 0.6009668522274709, 0.65728460865636, 0.5884849970374623, 0.6256196446532047, 0.6486996774527214, 0.5904940226677821, 0.6476057359678056, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005272936569312825, 0.05806149095900126, 9.999999999998899e-05, 0.06254586984643351, 9.999999999998899e-05, 9.999999999998899e-05, 0.10018835632345058, 0.09384027763169434, 0.12786515898904494, 0.13209681852199406, 0.07445157820616255, 0.11008103105621647, 0.13340543050322828, 0.09346700387140228, 0.11382982620178705, 0.0998559625918759, 0.12032279008446589, 0.06969343033338404, 0.06272856721615538, 0.0930690650094892, 0.06207574485655509, 0.05206104737483763, 0.07374458488320457, 0.058775078650746715, 0.9875143923101708, 0.9512394486952992, 0.9721260683232096, 0.9814184675952718, 0.9751592317832014, 0.9903937047745547, 0.9857497490625551, 0.9670586632397343, 0.9826339428929728, 0.44655038253222734, 0.39321953039007274, 0.39963532377188793, 0.43094661887994024, 0.3971414067949628, 0.39751836655033945, 0.4196486076359851, 0.3978447136295936, 0.40334585793696986, 0.20857630033412622, 0.21823436722206846, 0.22595533589170014, 0.5745152700838578, 0.21019230800706168, 0.2450248565256845, 0.3871495645953469, 0.23374307868376876, 0.21161341644268206, 0.12786736240180074, 0.20818021763686412, 0.23077603295895477, 0.213026004244535, 0.13168953240882197, 0.16563926687978203, 0.16254519367643794, 0.1863886596469213, 0.1436034728418586, 0.18928799905332105, 0.1293630902682309, 0.28851337251614984, 0.20210585848912033, 0.13047975586947413, 0.14117669157486512, 0.19383415614986665, 0.34183992032444344, 0.15303193416156646, 9.999999999998899e-05, 0.0011413390071498553, 0.04679451098905707, 0.14707483820725287, 0.012324251015594201, 0.031074719842860588, 0.0008580939954101474, 9.999999999998899e-05, 9.999999999998899e-05, 0.09642187977492689, 0.08648091791141377, 0.10528644847460478, 0.12472539664130522, 0.008152802172222584, 0.04192611444410943, 0.16941578549202096, 0.055656533639108274, 0.09195901547241703, 0.1620500725820666, 0.027029390234470374, 0.09727410854544782, 0.07345187748554216, 0.10683226979088212, 0.029257190122825016, 0.04056854844957414, 0.06543371251934227, 0.05779278274127486, 0.05043890766520942, 0.05658071772023343, 0.044366879775280754, 0.05193327828144079, 0.14402911073024638, 0.09498895397796225, 0.15175030754552554, 0.09536349086799367, 0.10505528891271498, 0.4888159165855147, 0.4615608779940993, 0.46886283303032716, 0.46710414317029114, 0.4468672798673953, 0.4514309876757603, 0.4888824373560937, 0.4744326976388379, 0.4624232999832024, 0.16407199139037543, 0.09128580795898722, 0.10140085509579333, 0.14331744350468945, 0.07273750504394316, 0.07331104412438183, 0.12085025900834989, 0.05800272931728867, 0.08816082512629597, 0.32866193151271683, 0.21967643056155028, 0.2042216820376348, 0.3384381800617866, 0.1670443275435709, 0.21823827593987766, 0.2985412262152082, 0.2024838857674971, 0.15988418816721062, 0.3469042179673141, 0.17981976578958914, 0.2303718633696883, 0.2515468871950105, 0.3193063366716007, 0.20216967477788061, 0.32360000190772265, 0.19445135797838076, 0.1796752875986276, 0.2015707812164772, 0.25334833675576396, 0.09671057404178596, 0.20653162065694564, 0.21847752112559682, 0.17508502951019056, 0.22343313716638624, 0.17032762159647552, 0.13231803082432747, 0.1610907917170078, 0.1968822392175943, 0.23964792607965657, 0.2691677762449489, 0.18362274977321358, 0.20135848200447548, 0.20954434408571287, 0.20286023273938592, 0.18491601570546845, 0.19616059847706246, 0.1923723509264189, 0.1863429640072617, 0.21073421332599507, 0.1817139267912694, 0.1852914936547806, 0.18841819085771017, 0.2042926284929586, 0.1959382687424689, 0.1889618255343305, 0.13670914933161216, 0.8266596835693895, 0.17327044707426797, 0.15398457797885434, 0.17945762227841056, 0.21415934777741652, 0.1611995335771801, 0.16145724761957025, 0.638649278698461, 0.11314865605881241, 0.11321080983932752, 0.15590433726382347, 0.21239511282056533, 0.21261171064960527, 0.7031459383078111, 0.16724116317661464, 0.414213138020776, 0.20246137528738917, 0.18682204338461195, 0.20549244747082807, 0.197324879583482, 0.21061592575468602, 0.21251167686923222, 0.1961320629772193, 0.20275125734790944, 0.2170859471819231, 0.08744925782393309, 0.12906170094345215, 0.07167591345521618, 0.1111730682917279, 0.07290475667047935, 0.09819264889791957, 0.06275425639375276, 0.08517307208450453, 0.07193566915852245]}, "mutation_prompt": null}
{"id": "5f7eba3a-1ae5-4d84-89d9-d9b3d39f7130", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget)  # Adaptive scaling based on iteration\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= np.sin((np.pi / self.budget) * evals)  # Line changed for sinusoidal factor\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance exploration by dynamically adjusting the perturbation radius using a decaying sinusoidal factor.", "configspace": "", "generation": 20, "fitness": 0.2354204736460673, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "1ce769f4-6b38-4e26-8708-9786533818f0", "metadata": {"aucs": [0.6944341487295712, 0.6999128566501747, 0.6526805570569723, 0.7031649684451194, 0.7083311129326365, 0.6441762565953044, 0.6581780211015245, 0.6627830087785109, 0.6317924139383129, 0.01279034012249436, 9.999999999998899e-05, 9.999999999998899e-05, 0.06925386572407966, 0.04960702379644244, 9.999999999998899e-05, 0.01294227640867085, 0.046283915852125546, 9.999999999998899e-05, 0.10176649057526632, 0.1245873989106916, 0.034272862265292914, 0.07731310102770061, 0.08017364779048786, 0.07472651147381426, 0.05148375562650742, 0.08502114833059438, 0.06988203032545859, 0.09341375156572229, 0.043575546385415276, 0.046768552189713986, 0.12309777269876321, 0.04464991402486396, 0.0643161613038239, 0.0665800191758843, 0.03608616529222797, 0.10429083182285181, 0.9288474266586098, 0.9525563251492907, 0.927743505691226, 0.9324882750987563, 0.9334871560243008, 0.9272894129415791, 0.8890694889506077, 0.9069309574057606, 0.8980993387592711, 0.5022128882054668, 0.43932374771144644, 0.4059530888221189, 0.45669879251057544, 0.4409502957699727, 0.4812375771786134, 0.4403265834195367, 0.44073174705765594, 0.395023759519626, 0.19102658883038326, 0.18045063684225693, 0.20579593447428857, 0.5297779333944157, 0.2590473904632088, 0.2854152619732795, 0.6047726162552902, 0.2102282324545366, 0.25792336677433336, 0.13192406605613838, 0.17954305945682358, 0.14454144096767174, 0.16212226352480774, 0.193680869695679, 0.13458086722068296, 0.12880977130686566, 0.1262091756246948, 0.13595922432649388, 0.20531705890891383, 0.26058494306895064, 0.13531185152617453, 0.21408280446436168, 0.20334678083747026, 0.15449381681142316, 0.22659824728308464, 0.17524801420567915, 0.15479084467423398, 0.059543365128801096, 9.999999999998899e-05, 9.999999999998899e-05, 0.008350170149875158, 0.01345077285462215, 0.00012063799977435341, 0.0017939667451906116, 9.999999999998899e-05, 0.02563656812267312, 0.05259552752551666, 0.10826910227640052, 0.1910702921386056, 0.10587025775829029, 0.01665317101588626, 0.04042147334879842, 0.22762279355126414, 0.04346842576628185, 0.10858204499155688, 0.08788504344866965, 0.03441117072559541, 0.10401050610036178, 0.13496616256278826, 0.09577143434996793, 0.1015299345286228, 0.12481436926271072, 0.13776117286074407, 0.06719673362617473, 0.14430052647348368, 0.1898277950904238, 0.09638530013920221, 0.20758842697854119, 0.2396380063317104, 0.0789303987076384, 0.13787476753870764, 0.08762758750777444, 0.10556096868722142, 0.5051598987210719, 0.4812460540515944, 0.5310062261716331, 0.5418713953704211, 0.4956646033825335, 0.4604361940301862, 0.477491772127247, 0.48502241947625613, 0.4791002018915833, 0.056180172076733315, 0.06544808774505473, 0.0937636422878757, 0.07311474661261042, 0.07026954104097893, 0.06399856528558956, 0.07763117671918773, 0.08616275049972011, 0.10289991394331899, 0.12579577563431865, 0.3445032862394539, 0.16986342845226243, 0.17341643317259992, 0.3374811659820284, 0.16270568680967445, 0.11454740189203616, 0.20214740519812502, 0.23672708355537242, 0.3022909469049251, 0.17106332624015197, 0.13767215412498301, 0.3037522460330082, 0.2292091984470258, 0.16006402798506902, 0.2043043183195461, 0.31381360693377336, 0.23791214742694033, 0.22112064061946068, 0.21010810833741211, 0.13064527657830172, 0.17153566086860883, 0.1585377504529233, 0.12029164093093148, 0.18800609281546699, 0.09789243299343886, 0.14426685936139805, 0.20179202943382202, 0.1844955433423896, 0.20433212601360684, 0.18917718888042512, 0.19848387580629423, 0.17948775210597068, 0.22876308879973517, 0.17779929912082426, 0.2163002367471739, 0.17773715898193587, 0.18158659038607916, 0.16842149469468404, 0.16700548256642433, 0.18100461015575908, 0.17065086881775227, 0.1713117095646166, 0.17374134791150442, 0.16417332805018336, 0.15952309907376716, 0.13571906898625907, 0.9110525512100619, 0.17188491453997246, 0.17918544491754218, 0.8410914009815795, 0.12837017478702362, 0.18347887561560894, 0.6490349045592807, 0.8352214361985763, 0.16189278688132103, 0.08078847689562985, 0.2100060391737052, 0.2073629724818712, 0.209378586326328, 0.1570810963068645, 0.15966719459232737, 0.1608139490999143, 0.22677486423238735, 0.19844627471786613, 0.2237110276786619, 0.21973287100882288, 0.19863261573883795, 0.25431628833160913, 0.24934853913685862, 0.23711410900277596, 0.195871980639042, 0.05904345194549765, 0.0724118869660908, 0.06506236139529376, 0.09171676116568883, 0.08202604911307876, 0.06829104867182045, 0.06432940264269293, 0.05803914495415141, 0.05287673295226125]}, "mutation_prompt": null}
{"id": "11ab36f5-617a-4994-a68e-5c8ca1db8d18", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget)  # Adaptive scaling based on iteration\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Introduce orthogonal perturbations\n        base_perturbation = np.random.normal(0, perturbation_radius, self.dim)\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim) + \n                    np.random.normal(0, perturbation_radius, self.dim) * (base_perturbation if i % 2 == 0 else -base_perturbation),\n                    self.lower_bound, self.upper_bound)\n            for i in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance candidate diversity using orthogonal perturbations for improved exploration.  ", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "1ce769f4-6b38-4e26-8708-9786533818f0", "metadata": {}, "mutation_prompt": null}
{"id": "107f09a8-1d83-45d3-abcf-83b14539f52f", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget)  # Adaptive scaling based on iteration\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce adaptive candidate scaling using a dynamic number based on past improvement trend to balance exploration and exploitation.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1ce769f4-6b38-4e26-8708-9786533818f0", "metadata": {"aucs": [0.6212443996617821, 0.6173801339219325, 0.667451672216973, 0.6130824194736096, 0.6578982379624237, 0.622791285569131, 0.6481075187826566, 0.646347808515702, 0.6081527375721391, 0.043464886454952056, 0.019717563117128134, 9.999999999998899e-05, 0.10763398866169305, 9.999999999998899e-05, 9.999999999998899e-05, 0.04931364138123395, 0.00011672573203691528, 9.999999999998899e-05, 0.08722179879816361, 0.0843706665119136, 0.0703657959647177, 0.09690843393939252, 0.09856002746965309, 0.14485038771077174, 0.05837640605989114, 0.15527923370927077, 0.08242966080503333, 0.08502892782360338, 0.07370916222147639, 0.047812176604470236, 0.08635644004302445, 0.09209859794107511, 0.04438819209278444, 0.09210219413175325, 0.07126185205016389, 0.061735727173223176, 0.9629483884222283, 0.9828490137739687, 0.9801835727809269, 0.9743616080733303, 0.9758945222117769, 0.9869431448874777, 0.9774195372547042, 0.9942057453616668, 0.9701522998447009, 0.41975952125443683, 0.40460280921734937, 0.38439772408856643, 0.42564185986762904, 0.436856162892435, 0.42942982508422123, 0.4130787712265508, 0.3798236799601673, 0.40208315292847363, 0.20775960544896654, 0.17708544029737272, 0.7674847347408122, 0.37131108194742124, 0.1882388184082664, 0.2802569101501844, 0.36011054131699616, 0.3756240883454418, 0.17824210971567123, 0.15504175272949683, 0.2287244142420204, 0.19425817039694837, 0.13476497043201285, 0.2283206419967706, 0.1338874114449713, 0.12021063386856368, 0.20715984203061766, 0.1315276729542615, 0.17898079562029545, 0.12617681162641514, 0.12783368924856475, 0.20427444089253277, 0.130065225308706, 0.17078892913084287, 0.13030158491846977, 0.1396478427442347, 0.18063224302805625, 9.999999999998899e-05, 0.04038452168329765, 0.01082890336044906, 0.022119801281626494, 0.11209263516537105, 0.059021213309120135, 9.999999999998899e-05, 9.999999999998899e-05, 0.07938625768579355, 0.06438697119199843, 0.08899222281585284, 0.1606609090873451, 0.14912385406452378, 0.04770342130633676, 0.053594130243457716, 0.17703765070892608, 0.046142507012286504, 0.10799164343151535, 0.03131449502843775, 0.03173398334214439, 0.05422007428874909, 0.08411192021205227, 0.05799994284493992, 0.07714229287611174, 0.07959765090204729, 0.10365408500025097, 0.08346159147642718, 0.07790982673632585, 0.15921222385448397, 0.1151194930206515, 0.11264836550488255, 0.19844174896872802, 0.11709606701544928, 0.11695819861777657, 0.12176949077301402, 0.1920920920899406, 0.47804587249537656, 0.47305723886199935, 0.4526623400664005, 0.4740392877734184, 0.4638689077346697, 0.46254035114553005, 0.48760569284954747, 0.49804807288104713, 0.4805991123868172, 0.09623421334594773, 0.08065272259022038, 0.1589915509093489, 0.08807148943227716, 0.0867055203554632, 0.08900080609758165, 0.0986696041531091, 0.1182619822106784, 0.15333848527509397, 0.18725583430227477, 0.19428100487645317, 0.3842049842906754, 0.1872685088371867, 0.2119460758719045, 0.17592532513179726, 0.3191667230735258, 0.1922234855395616, 0.1584356897434478, 0.29724512744254294, 0.23961572085107596, 0.2318148974722093, 0.21553811103175846, 0.3564281559214718, 0.14475060157117736, 0.24588562860425123, 0.3247143909701382, 0.31092485706040174, 0.24065725919499636, 0.21569640509886234, 0.07071035083582378, 0.13766779147921882, 0.1835021335189736, 0.14444004352604867, 0.1629372772021932, 0.23422143716643207, 0.23638330239603267, 0.20429696496070393, 0.1680257400828421, 0.191146289459442, 0.21733722713523262, 0.2921285409422276, 0.275695962633824, 0.20695463268188863, 0.23122434817983595, 0.20554469391105235, 0.20043816706974538, 0.1736907188446457, 0.24984943374991886, 0.17248285338531877, 0.21728845560697618, 0.20592408085106473, 0.22854922173849568, 0.17379573286592875, 0.18558530210380964, 0.16945439833145737, 0.13767240769033073, 0.8636773256063537, 0.14962430676249527, 0.1800104659654731, 0.9279162556965689, 0.13760488101968116, 0.21150609638952578, 0.15486102322899065, 0.12851652618401932, 0.1627354558972891, 0.6576274693468449, 0.15583139313463834, 0.21496790523646359, 0.2116991281992846, 0.21506114965080347, 0.16580768481758845, 0.39696158678802484, 0.2119047151986374, 0.1897464587332015, 0.20948183355343686, 0.23004984571634512, 0.1885168850136314, 0.20293052837095416, 0.21016118103522252, 0.19549202617166206, 0.19600379562559433, 0.12066572995839975, 0.10703695091150844, 0.08415549504047193, 0.07344970607539003, 0.12727508873720794, 0.09913511584829282, 0.05965563178547395, 0.08395520234237863, 0.08289967080130667]}, "mutation_prompt": null}
{"id": "dc46444e-44d8-435d-a496-082748626d1b", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 23, "fitness": 0.2438259949802994, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "1ce769f4-6b38-4e26-8708-9786533818f0", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "c8228c4b-9b49-4c58-bc8d-7c981d90203e", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "d1943809-52d7-40a9-b1c2-78e5461b9b62", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "1ba5c23f-869e-42b1-a1a5-9a74121a17ae", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "7058ea37-31d7-4381-8787-6646949d46d9", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "02e20b7a-33b4-4d64-8648-9de4eb55069a", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (\n            self.upper_bound - self.lower_bound) * np.random.uniform(0.8, 1.2)  # Stochastic scaling\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce stochastic scaling to perturbation radius for diverse exploration.", "configspace": "", "generation": 28, "fitness": 0.17818414261231028, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.3758256199107891, 0.4171241572146821, 0.37559608247518483, 0.3521832607850348, 0.4134489184394865, 0.4200723015030403, 0.38587307735363174, 0.4364238216489067, 0.39843265801652283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0905394937106132, 0.10801886537082805, 0.0893365280384727, 0.10559981272842611, 0.11108424886769785, 0.10704149119832507, 0.07384897697238613, 0.09264841703984039, 0.12416568107462622, 0.0388451741206578, 0.07804984429916562, 0.07705716520655426, 0.08939854848966455, 0.13703520389840596, 0.08432856771301611, 0.0679320202196585, 0.08278277274141221, 0.09783944312962867, 0.9935864932662196, 0.9908362319595667, 0.9961484958917384, 0.9920131165637583, 0.9968808099724381, 0.9937043379107073, 0.9969776146901362, 0.9970326290219665, 0.9972204477089093, 0.2502667776367108, 0.21303611064242, 0.23401302453854422, 0.2583977898105544, 0.20835036966819853, 0.2251260702124157, 0.19348810694778262, 0.2539385312460267, 0.19467970181242467, 0.17959047504597625, 0.1961497819356729, 0.1858454239201066, 0.1806136662177401, 0.20274247780039378, 0.19909219421287427, 0.21825500837625056, 0.16969871246746682, 0.16645285424706668, 0.1175713201031402, 0.062033154602187834, 0.12747159446721867, 0.11302170239462972, 9.999999999998899e-05, 0.11858316453549544, 0.11721517220099065, 0.011736090236973196, 0.11580332284347261, 0.08830092222283326, 0.09021181344856832, 0.10141729724020754, 0.14880640826405012, 0.11541212739699114, 0.12854661902747888, 0.1862506345001178, 9.999999999998899e-05, 0.13803196360068049, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04013395357831506, 0.07695445969863124, 0.05939522075565018, 0.002630317832367335, 0.05929907359869924, 0.04484960341069455, 0.047224528235874086, 0.04627651450052139, 0.012275855565578975, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053022145757800176, 0.07805433894853764, 0.08837662733559859, 0.05098584271730122, 0.08323502136102656, 0.08912135311155722, 0.09627008996058217, 0.04924916647373889, 0.06965750987232244, 0.37051832399867624, 0.3149808546803974, 0.3629799378054145, 0.3433561010122227, 0.32584243641295996, 0.34887593938257966, 0.3388187530258242, 0.33831486576580316, 0.3659667084428283, 0.07968311996314348, 0.05635355768899586, 0.12739649153748778, 0.08880156364539182, 0.0829935619444071, 0.10037272547557219, 0.06585733476632827, 0.06632697047480374, 0.07958516950651773, 0.20371250341768732, 0.15322002510654542, 0.14095803662841844, 0.15306783324794382, 0.13873803145525965, 0.12939232992686533, 0.1388550691036633, 0.146701087059808, 0.18613558267147012, 0.22950798723170907, 0.25189869365051176, 0.2751876335058884, 0.250985974970919, 0.18850768326340872, 0.21540859686634395, 0.24243454464929515, 0.22984840314368293, 0.2800846500371712, 0.19205790164278425, 0.1685857872863249, 0.17514249697262163, 0.11532096546615445, 0.1585466705695877, 0.12804140761566563, 0.1644607271489491, 0.15778147487677818, 0.18291051340343478, 0.15709506100923132, 0.1625801604461441, 0.18101383620797185, 0.19700892172537565, 0.1507163148320455, 0.20276028087741937, 0.17607082008230668, 0.17052665952916302, 0.17571258814608426, 0.16353955697541478, 0.14876612490681818, 0.15763835108981417, 0.1608338949665742, 0.1557750978812541, 0.1681999276353554, 0.1669679417628659, 0.1789029242600897, 0.15604381643383347, 0.14873493818248895, 0.1927456110547383, 0.16102274137763017, 0.18010771992039676, 0.12325652473859505, 0.12905502232271104, 0.13735198427147643, 0.10987568987408558, 0.19061461548409653, 0.20065213105622248, 0.31941537855666324, 0.20458718584162283, 0.19843765078409592, 0.224446694935017, 0.3397333782404429, 0.20649644062220096, 0.2079009816546229, 0.3563375902415339, 0.16667789845477, 0.18162826322156644, 0.17557344643188733, 0.1710048571559455, 0.19554431305849973, 0.18667170769359098, 0.20179179112686674, 0.18536257748423257, 0.17637718378418865, 0.07150610889185505, 0.07321466856777337, 0.06189544136263725, 0.062185259092066736, 0.06229195634137541, 0.07753514986513166, 0.05359657899496195, 0.07058166903704388, 0.05390001362942021]}, "mutation_prompt": null}
{"id": "1a9c13cd-61cf-48fc-bca8-a445b8c98d0f", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "2db9c32f-80d6-4ea0-9a0e-95114cbfc321", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "ea80a48c-d109-4879-95a6-029dc9a0886b", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.05)\n        )  # Reduced normal perturbation\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a dynamic perturbation strategy that adapts based on current evaluation progress for enhanced exploration-exploitation balance.", "configspace": "", "generation": 31, "fitness": 0.23872633286221448, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.6313663744195037, 0.651805136375344, 0.6342689815769792, 0.6448274748443619, 0.6550119856797972, 0.7075896993724768, 0.6653495671346183, 0.6415229727763498, 0.7217672864839682, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10780068551803101, 9.999999999998899e-05, 9.999999999998899e-05, 0.07399465769965285, 9.999999999998899e-05, 9.999999999998899e-05, 0.09371846274255735, 0.0536835086372881, 0.09340623839984696, 0.04528621267919297, 0.07222529413844425, 0.094290243079862, 0.11823686384071208, 0.11847403067023421, 0.09427891929559717, 0.072466282405377, 0.05253254731109758, 0.018207444482683743, 0.0879210469442121, 0.11819537879265629, 0.09385596312521571, 0.09209329709349945, 0.0520643378078679, 0.058462557132368365, 0.96196597350236, 0.982852128578664, 0.9846226440641804, 0.9595526858681669, 0.9796909380162566, 0.986921885238912, 0.9782884147539559, 0.9942054254526629, 0.9700860797469505, 0.5096989280772348, 0.481167675852749, 0.3946993576152842, 0.4768149465835462, 0.4579763088701829, 0.4277361468126959, 0.4263585628764365, 0.47721351655028776, 0.3759488259749041, 0.20808043392742415, 0.1745990106363453, 0.3385414989259552, 0.21543466180607174, 0.18363399520446588, 0.3133123509481991, 0.4036610799185997, 0.2988796117676811, 0.1725871934709461, 0.13450266271013367, 0.1714625480151799, 0.1479037384932972, 0.16413955532011137, 0.18529107893918784, 0.13566543653228258, 0.12199430132566125, 0.13143796753151127, 0.13181077127104035, 0.15142008834769605, 0.12445977965110211, 0.12683657548517058, 0.20540163486623375, 0.17524935716023538, 0.1305937249661776, 0.16095874684248834, 0.17127670468714873, 0.263297330357248, 9.999999999998899e-05, 9.999999999998899e-05, 0.024483418587506467, 9.999999999998899e-05, 9.999999999998899e-05, 0.1270176933168745, 9.999999999998899e-05, 9.999999999998899e-05, 0.02911384130030914, 0.0486216923931031, 0.06551162570171476, 0.13105762169628454, 0.1251899575178168, 0.07653463870205601, 0.03057158840045504, 0.11698685901573713, 0.037482697691244904, 0.10304330218520241, 0.05061182146007959, 0.042218685391139266, 0.08661778227687045, 0.24419213416789443, 0.07822473310379996, 0.06558011967235688, 0.108409478092371, 0.13587295227255802, 0.15646461495378694, 0.10591390241369047, 0.24689636702239115, 0.1557386589435399, 0.2469733847228599, 0.21244502944202504, 0.036208193415012246, 0.0835184992333654, 0.10132398161397904, 0.1526974669554616, 0.4713827452183684, 0.48833012903787754, 0.5043772027625171, 0.4939822566046964, 0.4908142706411476, 0.46677635204757173, 0.4514468492944662, 0.4672700547237466, 0.45569357736946325, 0.11906549695976387, 0.11740382014189654, 0.10999462966753604, 0.05917715014318803, 0.07435270874324851, 0.08469927279322598, 0.06949242192129168, 0.1184086095747523, 0.08684328628091131, 0.45121066725057, 0.14895027647175396, 0.22723373611747388, 0.3305298090472293, 0.15963270463115986, 0.38348086489358435, 0.20856481454952347, 0.2013205333184107, 0.21031096754988887, 0.2680588869009334, 0.18669283330180741, 0.187727477160623, 0.250833915300546, 0.18191475533299883, 0.187248988830218, 0.2051131240495716, 0.2748347513696231, 0.25278391005591283, 0.3302092431255511, 0.27940700104695937, 0.25009966468473777, 0.2963876546426363, 0.16128137828400213, 0.209486263078984, 0.18081534044204794, 0.22303842649958572, 0.19411367440465388, 0.17099858104690735, 0.19427955462282043, 0.18971164238244587, 0.20063659041595427, 0.18661870638628586, 0.2581269392038553, 0.18993301476834845, 0.24033766788947097, 0.19464806390788925, 0.19548197150123747, 0.16800047396869688, 0.19020856094395278, 0.1791168044385164, 0.19384651573740097, 0.1917923714845451, 0.2006014463243001, 0.17995936896933706, 0.18149494717880477, 0.16938747953970212, 0.13749363319609997, 0.7838717801750247, 0.14960682171092343, 0.18001772945063932, 0.9455064262368389, 0.14065382845784802, 0.1494915097745536, 0.15487605179431596, 0.24621540812421028, 0.11327879659911555, 0.5520324997593686, 0.1562381694594165, 0.21488002672601547, 0.2114514211205627, 0.21520726304339977, 0.2039516474407167, 0.3367962602873543, 0.2301850497431528, 0.18919085765945687, 0.1995892422580754, 0.20008596103222187, 0.20801614560798776, 0.2322733561536512, 0.21477910274150647, 0.21933008956904065, 0.21701385430111786, 0.09515528506196513, 0.05920081491261986, 0.07016464950254975, 0.06270210614863447, 0.13617433134185408, 0.09429391411957677, 0.08480349441023538, 0.07726686656506354, 0.07736183111177508]}, "mutation_prompt": null}
{"id": "3e33808b-3bb4-4de6-9bdc-aee9a5e676aa", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        sinusoidal_factor = 1 + 0.1 * np.sin(2 * np.pi * evals / self.budget)  # Sinusoidal perturbation factor\n        perturbation_radius *= sinusoidal_factor  # Apply sinusoidal factor\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a sinusoidal perturbation factor to improve exploration diversity and escape local minima.", "configspace": "", "generation": 32, "fitness": 0.23720852363443434, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.6913268159311228, 0.6842271199173668, 0.7061114288289001, 0.6784140468481341, 0.6573904853006491, 0.6661617109359125, 0.6640590402805949, 0.6937745912116919, 0.6722631635528111, 0.017976151795763284, 9.999999999998899e-05, 9.999999999998899e-05, 0.0933398400884844, 9.999999999998899e-05, 9.999999999998899e-05, 0.059980123647433214, 9.999999999998899e-05, 9.999999999998899e-05, 0.08737534416035164, 0.0860692747568228, 0.061832930500768435, 0.07220020878016853, 0.0986881821197314, 0.09450691414660273, 0.06264326038255408, 0.10774912563999983, 0.08409831677323654, 0.0772192054631674, 0.05929564495387096, 0.05039986909899563, 0.07396611019339727, 0.07968724742672262, 0.0667820988299338, 0.10325260681815085, 0.08582964101319734, 0.05448487094538412, 0.9610346497444576, 0.9828384771060799, 0.9794273523210777, 0.9598039155881233, 0.9796987383802201, 0.9869238920094668, 0.9782626015704716, 0.9942055402348575, 0.9700949566155971, 0.45261644325507244, 0.4742288196167036, 0.4026654140947423, 0.46806490606491136, 0.4821205356617905, 0.4795609890108897, 0.4169283854253104, 0.4690320533851696, 0.4176156377607917, 0.32052002115633893, 0.19572332334312137, 0.23025491301479384, 0.3867260447140549, 0.25000163317083945, 0.21315255521059673, 0.30601743028365813, 0.23065308458761735, 0.20599047401517945, 0.13461440845930717, 0.21861540798063417, 0.16477377765240853, 0.13659832222848, 0.19002636132543782, 0.13562063269114188, 0.11882207548654, 0.19542888793231195, 0.13484599579949896, 0.16532531443434217, 0.12598538468454767, 0.12974600062554986, 0.25215205885656355, 0.1343293033621794, 0.1302331247649594, 0.17918020138643764, 0.160230442613167, 0.15215862230736255, 0.021820513900193905, 0.03285761231810813, 9.999999999998899e-05, 0.004808429832471095, 0.027920531284444605, 0.020734316084170534, 9.999999999998899e-05, 9.999999999998899e-05, 0.03804604601709505, 0.043557217883772315, 0.081307653604197, 0.15405626773551429, 0.12462687488297475, 0.07799649507136763, 0.03236389994541766, 0.11635456606323447, 0.0356812535852401, 0.10699607171632908, 0.050390902461765696, 0.037595184736886056, 0.052322855886479336, 0.19583969844580662, 0.08501470933374966, 0.0765852445998495, 0.09936009519609723, 0.12370352254741901, 0.11443382065093433, 0.09892998493995397, 0.13124324288213884, 0.19812845263631884, 0.15831193846856717, 0.21535994271051717, 0.02075602448555569, 0.10674804860082299, 0.13244226528861835, 0.23595483615092516, 0.48621130473924945, 0.49853679337222234, 0.5188981424587877, 0.4697660677886132, 0.5120661016144963, 0.4747478406565502, 0.48344071125232513, 0.44296256905642317, 0.4394664632473204, 0.08448802780805598, 0.0936293945154053, 0.08942815917947788, 0.09416790555802468, 0.11166128245243256, 0.08461966285016531, 0.09486973146356736, 0.058164902541947616, 0.13559889135770775, 0.17808584599875998, 0.23431737177496537, 0.24351255209128586, 0.3626971070338997, 0.16564315047521394, 0.16232110475715922, 0.22048065206334233, 0.13629864504674238, 0.2219355763183778, 0.2836522639868787, 0.3536031591531166, 0.16222014237834415, 0.23732663055285108, 0.309010275452555, 0.1739292771489036, 0.1797892774928188, 0.29337955117406533, 0.18836206486339147, 0.1745316547673359, 0.27197027872627355, 0.125039187214376, 0.1499907752070585, 0.1583108934774753, 0.09466858971747805, 0.1855530866308681, 0.24085356317480822, 0.2521110140792645, 0.20072233810614815, 0.21761044990834422, 0.21477996553392564, 0.21729100796631928, 0.21036289571610856, 0.17452191194165456, 0.22729976870271051, 0.21126886469568185, 0.23928231947288836, 0.2015127981676339, 0.17393381790112528, 0.1944022400802048, 0.18000025739068148, 0.19161599009779806, 0.19209643094959383, 0.22964101224977262, 0.21154846614863476, 0.18577592788193165, 0.1694589357665891, 0.137703336362747, 0.2583620426390474, 0.4225934383839848, 0.18004175466700056, 0.9421167504249848, 0.1376989205049225, 0.25893455369418905, 0.15489340736427581, 0.30157328772351144, 0.18356926173862853, 0.5811796562980915, 0.15587971871837036, 0.21503768006152113, 0.2115302527236157, 0.21513857636149725, 0.2039482429852748, 0.318238317943461, 0.18976776484842572, 0.20309035944807574, 0.23625346711083306, 0.20567433556805403, 0.25035139027192066, 0.24606564728817448, 0.22413695294605007, 0.21259284337868334, 0.23070180098449466, 0.1047768709429252, 0.10574568022867148, 0.07451484691450583, 0.10105197612626327, 0.08452882069437984, 0.09672479942095469, 0.0761502840467152, 0.06712464014665187, 0.0768033845071241]}, "mutation_prompt": null}
{"id": "7372bcdd-5177-4704-bb0c-856b67c57fb9", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Adjusted candidate count scaling for better exploration\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 4 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            5 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.2)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Integrate a dynamic perturbation scale adjustment with local fitness landscape exploration to enhance convergence stability.", "configspace": "", "generation": 33, "fitness": 0.227558047697973, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.6073578655128622, 0.5916119100023134, 0.6171424568793626, 0.6135265452018422, 0.5870263965742106, 0.6228415812428933, 0.5602554814700449, 0.5947725249195401, 0.6249908561309045, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1236386845117935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014014261234882586, 9.999999999998899e-05, 0.0648788218666203, 0.07022242517806776, 0.08445200297321609, 0.05381771446469663, 0.0930488180179525, 0.07540155029932993, 0.08631642016261953, 0.12675009561900474, 0.11002350390536175, 0.051561357213695924, 0.06132425646263273, 0.14037003103442236, 0.07368264492277898, 0.08509581562009139, 0.06541348065413566, 0.06017543485007959, 0.08648921863025061, 0.045911526427539484, 0.9763615461462876, 0.9902706379944806, 0.9844903391219861, 0.9964357057969907, 0.9886570851300183, 0.9807776446673592, 0.980895029147019, 0.9854753616886178, 0.9930834790921846, 0.3866764434826775, 0.36293813771202965, 0.4452520230191218, 0.4202154193413442, 0.4031312901049606, 0.39289931773782905, 0.3688631391637025, 0.40458492366866305, 0.4066300680860009, 0.26864068000021857, 0.15875970986933574, 0.22435289094463984, 0.19277120226811828, 0.214941141772105, 0.28342113577609795, 0.39871368418793085, 0.3603680342875558, 0.19708990024739892, 0.14343129078714012, 0.1315072286301454, 0.17197240857344043, 0.1332639590575132, 0.1715585235875282, 0.133094931813606, 0.13240460567932077, 0.19250173249085534, 0.1422622462642099, 0.1313998108324358, 0.13450627150441374, 0.13925807293791748, 0.16544816079726932, 0.14698954098995842, 0.1600951584209762, 0.2367536747259663, 0.1102075516997636, 0.12955899725679298, 0.04173992860410036, 9.999999999998899e-05, 0.008462107744569791, 0.0001212080734170895, 9.999999999998899e-05, 0.03572154588369836, 9.999999999998899e-05, 9.999999999998899e-05, 0.0398092328427061, 0.0783487900097336, 0.08734828656312044, 0.05416882076585716, 0.06736964095134479, 0.03908716863912176, 0.019968201350291537, 0.06685312568269852, 0.017920766199216454, 0.05546930921403148, 0.02806487078455744, 0.020105869661847686, 0.04259037059103499, 0.10140234477093313, 0.06700276940474592, 0.0636345531623187, 0.10250561051995666, 0.039014045682494, 0.07262039364918471, 0.16642356784146173, 0.11029796319354535, 0.06554501514975797, 0.052157955677684886, 0.08735142928084572, 0.08196201942993775, 0.09314797047392365, 0.06690304063658181, 0.18101228286486748, 0.42713323098333045, 0.46548014203124044, 0.49196771116463756, 0.4536172124785792, 0.48204619596285214, 0.4323800452719069, 0.46942688943797384, 0.4510952865258355, 0.41322037288793767, 0.112960779246293, 0.07590055412300734, 0.08950942254318361, 0.15729845452729874, 0.1484060200552303, 0.09453933076790055, 0.10967980964830926, 0.09056639598970373, 0.13501187215694754, 0.15312245091350773, 0.28492497412058515, 0.27608923514504835, 0.20996546285213946, 0.2082363959593595, 0.3800264169653631, 0.22798952616950507, 0.2018712366676897, 0.24825591743625897, 0.19804504549956425, 0.33826165623663795, 0.16660299286720326, 0.29385051005488805, 0.31642868740409813, 0.17775079293006113, 0.2971505914760798, 0.22460220213807103, 0.25844518501437186, 0.22745548416780026, 0.11531552857064087, 0.10909897996280127, 0.1883288426046693, 0.21596012612053284, 0.21769313710669647, 0.19426718988006508, 0.15738469514309872, 0.19723797357417483, 0.21176751131837956, 0.1779944711892133, 0.18654091910158455, 0.19881003477354475, 0.20216184410344218, 0.18506107953969442, 0.21611316906541467, 0.20562417537453737, 0.18238823735498177, 0.17805808578404225, 0.18199378532532906, 0.17973211880608164, 0.19630963031989945, 0.18739369372580994, 0.19165587225355862, 0.18206307027663993, 0.17886053996293283, 0.1834433511201734, 0.18425934637276165, 0.1885737459954231, 0.9340259059430268, 0.16537851605035925, 0.1885419443674745, 0.1492744224752579, 0.17203954745283878, 0.2120391474316462, 0.16610828203717587, 0.6804090736010461, 0.20093346897032727, 0.11427220886040146, 0.4031705859726117, 0.47994191806461617, 0.2134862185340498, 0.15804908332426004, 0.4191636373585059, 0.32424344505712466, 0.22621044070425977, 0.2168368228877292, 0.19382892953641573, 0.19962791575312644, 0.19697573872669027, 0.2281875899395055, 0.18783677293929457, 0.1945463468376597, 0.1912879971692384, 0.06463931717330584, 0.11769298249331572, 0.09312065672367786, 0.06747999979573649, 0.09562981391546399, 0.1391211176402799, 0.08656737686122395, 0.09314901863010783, 0.0876752263126298]}, "mutation_prompt": null}
{"id": "1738208f-b422-48d1-8d8f-334e01ab329a", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "c16417e6-7f62-465f-b674-54103d534013", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n        self.momentum = np.zeros(dim)  # Initialize momentum\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        self.momentum = 0.9 * self.momentum + np.random.normal(0, perturbation_radius, self.dim)  # Update momentum\n        candidates = [\n            np.clip(current_best + self.momentum,\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Integrate adaptive momentum to smooth perturbation dynamics for improved convergence.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {}, "mutation_prompt": null}
{"id": "6cbbe453-9f42-4a92-ae00-44fc72096a20", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance the exploration-exploitation balance by adjusting the candidate count dynamically based on the evaluation budget and performance history.", "configspace": "", "generation": 36, "fitness": 0.2438259949802994, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "386d39ac-7a66-4bfa-a599-5df473c2e785", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "5ad92e93-228d-4053-941a-592c88616a55", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        dimension_scale = np.sqrt(self.dim)  # Add dimension-based scaling\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius / dimension_scale, perturbation_radius / dimension_scale, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce adaptive perturbation based on dimension to improve exploration in high-dimensional spaces.", "configspace": "", "generation": 38, "fitness": 0.24374148622907066, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.24.", "error": "", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.6944563179276662, 0.655572825138668, 0.7230091009709843, 0.7432534367132448, 0.7252924704645979, 0.7483215398670331, 0.709735973764017, 0.7343022788036906, 0.7348297278208591, 9.999999999998899e-05, 9.999999999998899e-05, 0.0413310112233618, 0.00031031433656225627, 9.999999999998899e-05, 9.999999999998899e-05, 0.009858004938994469, 9.999999999998899e-05, 9.999999999998899e-05, 0.1283111962813317, 0.06313042802608326, 0.06941960849001516, 0.09320210392133488, 0.12964767530440424, 0.05473222687441526, 0.09688954673094163, 0.07595723581605451, 0.06689082837279148, 0.06963034951608438, 0.07374113180923392, 0.040505352585169185, 0.059826787739312604, 0.06489901780260976, 0.07821000537263756, 0.05279220452653077, 0.054096849147028614, 0.04350657943815006, 0.9919879432476916, 0.9682535469158524, 0.9770103804786684, 0.9658516388038355, 0.9670821205918355, 0.9797048166872526, 0.9737747542848509, 0.9884046678810148, 0.9431384181738297, 0.5141303980774006, 0.47636328657794313, 0.5259873295344237, 0.5056994048132528, 0.48815081528484794, 0.4743299566729129, 0.5429874445787752, 0.5062895444594234, 0.5200736257727038, 0.23160225818613167, 0.1647690684127492, 0.2289789685842636, 0.28065713740706255, 0.21105635005036238, 0.1958850447914875, 0.31313136093883354, 0.6131699367328296, 0.21172974541547585, 0.21763140253806645, 0.22259320403547123, 0.18327571468700843, 0.18380268005719314, 0.20244021545427804, 0.12032332945968405, 0.20106119860641558, 0.21021408581338807, 0.18257394507593072, 0.19006636507967078, 0.17703091098483859, 0.12527729659477482, 0.21446774479890685, 0.19394214571185153, 0.1377776383516086, 0.36524619184922025, 0.1312816930794667, 0.1626118731801096, 9.999999999998899e-05, 0.01016912066263953, 0.09806631074225947, 0.04585843438251469, 0.11799828935226453, 0.03259263277063307, 9.999999999998899e-05, 0.003193652980291173, 0.01187952572564388, 0.02874288425127325, 0.07872752477198441, 0.14347788035484266, 0.10261980928564718, 0.021558013005269827, 0.02077778243422923, 0.10316109877106905, 0.05738565185379796, 0.06642066678588321, 0.23376610615562343, 0.03961005574700083, 0.03758651709880856, 0.1850560275028762, 0.09715895537561847, 0.07840253244810569, 0.09352642401356204, 0.18914100574630588, 0.08832774237312391, 0.122160156466956, 0.14092005039581257, 0.058611954674825606, 0.046225280887840614, 0.2496679371288445, 0.08123629474967187, 0.1186858906041871, 0.10273020843835168, 0.10434611909165037, 0.47038058086245893, 0.502767810368377, 0.48083275067782416, 0.5176264806885337, 0.5198904547876001, 0.49010706107825375, 0.5037041840112575, 0.47898483196979236, 0.4910268867310914, 0.10262068379690481, 0.11924534400642894, 0.12002319174110909, 0.06445927837023224, 0.11751901803123344, 0.07060377677817575, 0.0888857011940749, 0.06829151122513755, 0.09022802019091192, 0.1922785515864721, 0.2616722488760689, 0.19230556617823413, 0.2232518006595654, 0.1732731169056313, 0.19193785674699138, 0.17973795727794728, 0.1755205051293275, 0.2555747887829032, 0.2900751684704719, 0.17618405308158558, 0.17100661511759896, 0.3425364649630859, 0.19399630168752968, 0.19652133467722643, 0.19942701442807842, 0.18339915882510216, 0.27534404240968013, 0.2052926845838282, 0.19578354809305487, 0.05760935805139922, 0.17604134149362294, 0.19805331966101747, 0.0951991552499154, 0.1892555224627741, 0.19744523875590525, 0.09868379278341022, 0.1956707535470983, 0.2512683132980321, 0.1907808364178103, 0.24882182514156204, 0.19280886243944584, 0.18268331974827745, 0.185803775369198, 0.23507611801546713, 0.22114394840767082, 0.17272160722910124, 0.18962597789355484, 0.19823003686298002, 0.20699020887084008, 0.19327033924945614, 0.2073745676790013, 0.19936104867207294, 0.20149409645852678, 0.18892869376763344, 0.9503203303732243, 0.13698436579332263, 0.15838178114563106, 0.36865644792486496, 0.13438400069743217, 0.19218041078731696, 0.1702230450229696, 0.13064686681082316, 0.1895171403135819, 0.7507743841189006, 0.14770948454013055, 0.5273554615821981, 0.11428964852916379, 0.2142575312162046, 0.21140631298714918, 0.5485807626312678, 0.16674869612836773, 0.3802035151133847, 0.2580939897087562, 0.2009399210264159, 0.21217103794149905, 0.28154589058290846, 0.2434459223838209, 0.20677829863020736, 0.21333703662165016, 0.23456916017278262, 0.26705819107209816, 0.1588150414681353, 0.0799625318681576, 0.06227078844104217, 0.05855249058128498, 0.09498660304934003, 0.07495502416033994, 0.07434434590486727, 0.08239637341618367, 0.07659152475146835]}, "mutation_prompt": null}
{"id": "928ae191-2c65-47e8-b8da-aafa77caa590", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "6db21567-50ce-4a2f-b219-832fd186438f", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "4d303eee-378a-444d-939d-2edf59abb749", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance adaptive scaling by incorporating a logarithmic factor to improve convergence in later stages.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.7145767098994027, 0.6391338553468945, 0.7240396224691843, 0.6705331957328952, 0.6404209900844916, 0.6528853213722623, 0.684360120799631, 0.6773793748516193, 0.6341538479553387, 0.01738857750740186, 9.999999999998899e-05, 9.999999999998899e-05, 0.09764303965850574, 9.999999999998899e-05, 9.999999999998899e-05, 0.05834603505676683, 9.999999999998899e-05, 9.999999999998899e-05, 0.08746667186274648, 0.1125291017122052, 0.05907637446433889, 0.08342156397794875, 0.09871834310400829, 0.09433368654105212, 0.05739516350951013, 0.11273961752380346, 0.09659731923675186, 0.09098265329925803, 0.0499275149150471, 0.04001141856638091, 0.07844246195106064, 0.1111917938847029, 0.05694816403320113, 0.10603106002091933, 0.11597728641551841, 0.056753567847202424, 0.9609828049000058, 0.9828364462068503, 0.9793683646442655, 0.9596777992881023, 0.9796970686802646, 0.986920384598956, 0.978246007938951, 0.9942053643730091, 0.9700883877754435, 0.48912933655626833, 0.4168868944111327, 0.34819227718487833, 0.4655525701516624, 0.4813521954497031, 0.46647608201648016, 0.506160354391777, 0.4342433921448281, 0.41342446917074627, 0.20575996227681403, 0.21105438362980422, 0.2302743725674452, 0.9075424265298363, 0.3786619478033334, 0.21283937441166778, 0.32499892393484886, 0.390632390743321, 0.2321814211264266, 0.13179175728425163, 0.2204136001748781, 0.15219752340053705, 0.1332820822701387, 0.24404309554518622, 0.1354353382687401, 0.11918957627770177, 0.20580023841345085, 0.13131369307376828, 0.15985571810877086, 0.12581950007075915, 0.1269433891004974, 0.23103894038478134, 0.13491519379510553, 0.13031986403666618, 0.15410741150611051, 0.15912777942460166, 0.13225238106538095, 9.999999999998899e-05, 9.999999999998899e-05, 0.012389769183403732, 9.999999999998899e-05, 0.05600677994275616, 0.013589376660245955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05488571842516199, 0.06897300551586283, 0.1532269515456265, 0.1252070780224701, 0.07741719655315826, 0.011135266330955296, 0.1531300941278121, 0.03670056581207315, 0.0784966501840243, 0.054187864249035766, 0.037935815877076506, 0.08053812111420267, 0.2185169738820295, 0.07861672828682476, 0.12221307008688131, 0.08483351729784205, 0.15059963825979872, 0.15705886124455315, 0.09185658320353873, 0.14165591927719323, 0.20522839569452445, 0.15564768778654126, 0.23544337066241572, 0.030684529612753586, 0.10657707211621259, 0.10995965511056416, 0.23870967536875565, 0.4814354223504447, 0.46339123054993714, 0.47005296701070043, 0.4734862450552064, 0.4519761988211469, 0.4949601556323282, 0.5088098223854335, 0.53872935248098, 0.47698706914027966, 0.1585398038219128, 0.11788635819138893, 0.08917280108621728, 0.09396842162952856, 0.12610731230891947, 0.08454455216070222, 0.09475197201573082, 0.13074029809412457, 0.11108717855529571, 0.1812820266106513, 0.23109864231334953, 0.252925816825169, 0.35401957112101234, 0.14238011674293483, 0.16030483143425922, 0.21398619937959573, 0.18102399802734992, 0.20635873198863508, 0.3547675019694623, 0.3506015935806137, 0.16847500805168947, 0.17448325073745818, 0.2182757404890624, 0.1837340619409601, 0.21045275104325223, 0.34425116137445344, 0.20919561100044815, 0.22039767097585572, 0.26723147236834055, 0.2690177493005145, 0.15393438322690312, 0.14947142807727265, 0.0948159958855842, 0.18660305314776926, 0.20635271043067105, 0.13427656182287306, 0.19073714339597247, 0.21806903331759087, 0.1859326442184901, 0.24376229756486978, 0.18591416886690337, 0.2026054618400569, 0.2106500231067553, 0.1827411597878721, 0.2018414344773114, 0.2016163729623841, 0.1837236253027047, 0.1940339193606575, 0.17259910056342542, 0.18427544074568647, 0.19207452395735813, 0.22859533182467318, 0.189604223726479, 0.18538786122568807, 0.16946119919296687, 0.1376986736515211, 0.9144817555393521, 0.4111841467921248, 0.18001664954611007, 0.9410847270943221, 0.14071056032569162, 0.1884374757188172, 0.1549021619883093, 0.12840331691056595, 0.11313868526041937, 0.6851429774193725, 0.15625692990755247, 0.21504545527039964, 0.21181967813651703, 0.21513570648961755, 0.20401365894579626, 0.29724656248729997, 0.2062189509927982, 0.2195009006189993, 0.1986692780863305, 0.19368838543668498, 0.25361738515082355, 0.22633811418962535, 0.20896036488454106, 0.18616887445666475, 0.2134275769787659, 0.1456646160141174, 0.11688483873458222, 0.08392047279066028, 0.13429702916533004, 0.09491217517597084, 0.11267920139196408, 0.07602009275340571, 0.07459701470787783, 0.11890188599498575]}, "mutation_prompt": null}
{"id": "ba4a914c-f879-46b5-985c-18a4abd5c9a3", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Add quadratic decay based on remaining budget\n        perturbation_radius *= (1.0 - (evals / self.budget) ** 2)\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a quadratic decay factor for perturbation radius to enhance exploration-exploitation balance.", "configspace": "", "generation": 42, "fitness": 0.24490060364395383, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "dc46444e-44d8-435d-a496-082748626d1b", "metadata": {"aucs": [0.704308755730582, 0.6479358500512299, 0.7208529121602334, 0.6730267177357605, 0.6430743530065781, 0.6735328232937214, 0.6602934511207621, 0.6759076188113919, 0.6351281620825253, 0.017378288903844297, 9.999999999998899e-05, 9.999999999998899e-05, 0.09545406923351074, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201156504538686, 9.999999999998899e-05, 9.999999999998899e-05, 0.10496957671231144, 0.11323557226774195, 0.07362845903473791, 0.07974994280290726, 0.1242418086445346, 0.09436524026626225, 0.07403662774399022, 0.11276153874950956, 0.07179946551574501, 0.09055202339299462, 0.0697078177924022, 0.08700619071318283, 0.07723893359971412, 0.07339881587450747, 0.08828603981952532, 0.10598448555428153, 0.11587920492793058, 0.0453062637217041, 0.9609810473728208, 0.9828364095800035, 0.9793672928396712, 0.9596713733094194, 0.9796970682761779, 0.9869203321028397, 0.9782457507451717, 0.9942053643768053, 0.9700881059212568, 0.5092289903530298, 0.42554321009381846, 0.4578133544912304, 0.468319802192112, 0.4380507203196704, 0.4681944462114971, 0.5061326510698265, 0.431398742145224, 0.40279444815638743, 0.23252252540132323, 0.19094611617880486, 0.2302743725674452, 0.9075424265298363, 0.33672539909805455, 0.20941328969885276, 0.349521878813316, 0.21698547775832777, 0.20645693791951125, 0.13182906236340586, 0.21989676993594687, 0.17051991432460523, 0.134509360613553, 0.2346042974133552, 0.1354835472220306, 0.11916158680830302, 0.2028322135956917, 0.13131901585820382, 0.16031930050749232, 0.12606777731565966, 0.12694642293416658, 0.23109206475777577, 0.1349117644624943, 0.13032062690361768, 0.19128978318472123, 0.15910834994300782, 0.1322471820248673, 9.999999999998899e-05, 0.0006433422625284901, 9.999999999998899e-05, 0.0007241598307040631, 0.04914423460294837, 0.010461574180833821, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012680351489084973, 0.056208359545026565, 0.07408282782268039, 0.15328530709458077, 0.12698222727556097, 0.0803396125409015, 0.01288657349116129, 0.15724358245052994, 0.03496694098273345, 0.07624663819222455, 0.044610474939351996, 0.037051377277168784, 0.059751810869926314, 0.23386136351896603, 0.07942855234480617, 0.1325284967098107, 0.09019837554498522, 0.15049215858360598, 0.16184465804574233, 0.09259178959356029, 0.14007572585907635, 0.20433988457458718, 0.15442489129169024, 0.23606986097673166, 0.03181389296723536, 0.10680646829733942, 0.10987989661408704, 0.23914362497717034, 0.48428069769523485, 0.4625273863084498, 0.4766283759036899, 0.47711062374661584, 0.4653834237574024, 0.45909001031796515, 0.5050378263469317, 0.535108246716071, 0.43573600047217775, 0.15926721426961543, 0.11785897548092872, 0.08925515114615212, 0.07599701598574904, 0.12616059576950034, 0.08464729744770338, 0.09473498740181874, 0.09503347857202571, 0.10636954507190788, 0.1816929596485405, 0.250000754054187, 0.25199393707367523, 0.36323197064782486, 0.17292513010226818, 0.16104236128950467, 0.20590776878385209, 0.1586753262886934, 0.21075454776908786, 0.3541335895469463, 0.21338565699025402, 0.30987080301197034, 0.21914894008936958, 0.2157339914200994, 0.18509735019833629, 0.2619612304974036, 0.3112781289075257, 0.19271829948968744, 0.22592650385827073, 0.27011375422403594, 0.2628632603009856, 0.15000679912392967, 0.2065344182546166, 0.09451363630663978, 0.19407868291071428, 0.20412576533073612, 0.15257297488416877, 0.2927604314746264, 0.20634537940193887, 0.21269009129055505, 0.22039705703644763, 0.17374760920710508, 0.23518757727143302, 0.1916919272931462, 0.1823638823524567, 0.22167446574077432, 0.20160181499398033, 0.18372142606362662, 0.189413489602397, 0.17260164846567683, 0.18563603834652165, 0.19206968606091346, 0.22855791880495535, 0.1896239496722204, 0.18538790591982002, 0.17810197180463416, 0.13770076575670553, 0.9131698993599588, 0.14964533254120072, 0.18001780319949723, 0.9411564532775718, 0.13769994371296745, 0.18874730929447292, 0.26782072862498696, 0.12843560686359468, 0.20881356716032085, 0.7050261145873942, 0.156286305063987, 0.21504628284082317, 0.2118177531405041, 0.21513598180102889, 0.20401399858593772, 0.33239280123281145, 0.20673461143249394, 0.22896086674832716, 0.21862123024460112, 0.20754263072608214, 0.2382076791857769, 0.20506593564274422, 0.21090285418270227, 0.1966952247896122, 0.27803163083939997, 0.12335894314478879, 0.10162007772383874, 0.0848759952222834, 0.1340325321421013, 0.09466453436207645, 0.11262988001035668, 0.07865281274813318, 0.08036889279641624, 0.11676187748402933]}, "mutation_prompt": null}
{"id": "6add872b-40e2-4306-a09c-bb1e24b1533a", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Add quadratic decay based on remaining budget\n        perturbation_radius *= (1.0 - (evals / self.budget) ** 2)\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a quadratic decay factor for perturbation radius to enhance exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba4a914c-f879-46b5-985c-18a4abd5c9a3", "metadata": {"aucs": [0.704308755730582, 0.6479358500512299, 0.7208529121602334, 0.6730267177357605, 0.6430743530065781, 0.6735328232937214, 0.6602934511207621, 0.6759076188113919, 0.6351281620825253, 0.017378288903844297, 9.999999999998899e-05, 9.999999999998899e-05, 0.09545406923351074, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201156504538686, 9.999999999998899e-05, 9.999999999998899e-05, 0.10496957671231144, 0.11323557226774195, 0.07362845903473791, 0.07974994280290726, 0.1242418086445346, 0.09436524026626225, 0.07403662774399022, 0.11276153874950956, 0.07179946551574501, 0.09055202339299462, 0.0697078177924022, 0.08700619071318283, 0.07723893359971412, 0.07339881587450747, 0.08828603981952532, 0.10598448555428153, 0.11587920492793058, 0.0453062637217041, 0.9609810473728208, 0.9828364095800035, 0.9793672928396712, 0.9596713733094194, 0.9796970682761779, 0.9869203321028397, 0.9782457507451717, 0.9942053643768053, 0.9700881059212568, 0.5092289903530298, 0.42554321009381846, 0.4578133544912304, 0.468319802192112, 0.4380507203196704, 0.4681944462114971, 0.5061326510698265, 0.431398742145224, 0.40279444815638743, 0.23252252540132323, 0.19094611617880486, 0.2302743725674452, 0.9075424265298363, 0.33672539909805455, 0.20941328969885276, 0.349521878813316, 0.21698547775832777, 0.20645693791951125, 0.13182906236340586, 0.21989676993594687, 0.17051991432460523, 0.134509360613553, 0.2346042974133552, 0.1354835472220306, 0.11916158680830302, 0.2028322135956917, 0.13131901585820382, 0.16031930050749232, 0.12606777731565966, 0.12694642293416658, 0.23109206475777577, 0.1349117644624943, 0.13032062690361768, 0.19128978318472123, 0.15910834994300782, 0.1322471820248673, 9.999999999998899e-05, 0.0006433422625284901, 9.999999999998899e-05, 0.0007241598307040631, 0.04914423460294837, 0.010461574180833821, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012680351489084973, 0.056208359545026565, 0.07408282782268039, 0.15328530709458077, 0.12698222727556097, 0.0803396125409015, 0.01288657349116129, 0.15724358245052994, 0.03496694098273345, 0.07624663819222455, 0.044610474939351996, 0.037051377277168784, 0.059751810869926314, 0.23386136351896603, 0.07942855234480617, 0.1325284967098107, 0.09019837554498522, 0.15049215858360598, 0.16184465804574233, 0.09259178959356029, 0.14007572585907635, 0.20433988457458718, 0.15442489129169024, 0.23606986097673166, 0.03181389296723536, 0.10680646829733942, 0.10987989661408704, 0.23914362497717034, 0.48428069769523485, 0.4625273863084498, 0.4766283759036899, 0.47711062374661584, 0.4653834237574024, 0.45909001031796515, 0.5050378263469317, 0.535108246716071, 0.43573600047217775, 0.15926721426961543, 0.11785897548092872, 0.08925515114615212, 0.07599701598574904, 0.12616059576950034, 0.08464729744770338, 0.09473498740181874, 0.09503347857202571, 0.10636954507190788, 0.1816929596485405, 0.250000754054187, 0.25199393707367523, 0.36323197064782486, 0.17292513010226818, 0.16104236128950467, 0.20590776878385209, 0.1586753262886934, 0.21075454776908786, 0.3541335895469463, 0.21338565699025402, 0.30987080301197034, 0.21914894008936958, 0.2157339914200994, 0.18509735019833629, 0.2619612304974036, 0.3112781289075257, 0.19271829948968744, 0.22592650385827073, 0.27011375422403594, 0.2628632603009856, 0.15000679912392967, 0.2065344182546166, 0.09451363630663978, 0.19407868291071428, 0.20412576533073612, 0.15257297488416877, 0.2927604314746264, 0.20634537940193887, 0.21269009129055505, 0.22039705703644763, 0.17374760920710508, 0.23518757727143302, 0.1916919272931462, 0.1823638823524567, 0.22167446574077432, 0.20160181499398033, 0.18372142606362662, 0.189413489602397, 0.17260164846567683, 0.18563603834652165, 0.19206968606091346, 0.22855791880495535, 0.1896239496722204, 0.18538790591982002, 0.17810197180463416, 0.13770076575670553, 0.9131698993599588, 0.14964533254120072, 0.18001780319949723, 0.9411564532775718, 0.13769994371296745, 0.18874730929447292, 0.26782072862498696, 0.12843560686359468, 0.20881356716032085, 0.7050261145873942, 0.156286305063987, 0.21504628284082317, 0.2118177531405041, 0.21513598180102889, 0.20401399858593772, 0.33239280123281145, 0.20673461143249394, 0.22896086674832716, 0.21862123024460112, 0.20754263072608214, 0.2382076791857769, 0.20506593564274422, 0.21090285418270227, 0.1966952247896122, 0.27803163083939997, 0.12335894314478879, 0.10162007772383874, 0.0848759952222834, 0.1340325321421013, 0.09466453436207645, 0.11262988001035668, 0.07865281274813318, 0.08036889279641624, 0.11676187748402933]}, "mutation_prompt": null}
{"id": "f9fa51a0-1083-4246-b68c-bb96d979aae8", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Add quadratic decay based on remaining budget\n        perturbation_radius *= (1.0 - (evals / self.budget) ** 2)\n        # Adjust perturbation radius based on variance in candidate performance\n        if len(candidate_values) > 1:\n            perturbation_radius *= max(0.1, np.std(candidate_values) / (np.mean(candidate_values) + 1e-8))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Extend the dynamic adaptation of perturbation radius to consider variance in candidate performance for improved local search.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'candidate_values' is not defined\").", "error": "NameError(\"name 'candidate_values' is not defined\")", "parent_id": "ba4a914c-f879-46b5-985c-18a4abd5c9a3", "metadata": {}, "mutation_prompt": null}
{"id": "714f8387-077d-438e-90d7-bdbbb25245ad", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= (1.0 - (evals / self.budget) ** 2)\n        variance_factor = np.var([val for _, val in self.history[-10:]]) if len(self.history) > 10 else 1.0  # New line\n        perturbation_radius *= (1.0 + variance_factor)  # Modified line\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce adaptive mutation based on the variance of recent improvements to enhance convergence.", "configspace": "", "generation": 45, "fitness": 0.23166400534612577, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "ba4a914c-f879-46b5-985c-18a4abd5c9a3", "metadata": {"aucs": [0.7078577572076228, 0.7287637892338981, 0.6570048464809763, 0.6964572365162907, 0.6582612639384369, 0.6350711520364571, 0.6798273479082158, 0.7672007016438911, 0.6516991501412979, 0.0004073118801543041, 9.999999999998899e-05, 0.00010324092533842144, 0.04386303414776471, 9.999999999998899e-05, 9.999999999998899e-05, 0.038777303469733626, 9.999999999998899e-05, 0.01732695788015004, 0.11450617691448783, 0.07732516143851975, 0.10179306113427389, 0.1074607082804998, 0.10124678985688584, 0.06309200525689795, 0.08953611032778352, 0.0790989617364658, 0.09750926869333709, 0.05550880797047231, 0.07152771703890815, 0.041864098266544136, 0.05186920073622081, 0.10923161749345855, 0.04873217814525377, 0.10001595713362876, 0.07847157039321806, 0.0896039143638222, 0.9926006213706425, 0.9926579001850004, 0.9930420398874519, 0.9925261061994205, 0.9893546977201414, 0.99329764483365, 0.9936199527941145, 0.9813267432559931, 0.9906656503224712, 0.3995990183368724, 0.44391945234271535, 0.33246613848576567, 0.43897753289541386, 0.4512286171165282, 0.43290412456252114, 0.38494909009357514, 0.4787123403058522, 0.45907725422971946, 0.2785964122511456, 0.3466728096845809, 0.22769770273999346, 0.1761370277007065, 0.19422500823471944, 0.356430282718989, 0.23450279084711734, 0.2994314078450079, 0.21955941605599638, 0.20827296621977576, 0.14023853062564162, 0.12610239000383938, 0.13893383328305386, 0.1995557228719328, 0.13904746730787498, 0.17515036097286263, 0.17394951618076504, 0.1722437324699262, 0.1701898957650686, 0.12596929151225522, 0.1490107536048748, 0.16563435977624763, 0.17882268469788798, 0.15385183485750809, 0.1662176374331702, 0.26265527788476384, 0.16238166460427528, 9.999999999998899e-05, 9.999999999998899e-05, 0.023083698433984834, 0.010495332242402178, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03487921474468825, 0.07027885586111549, 0.08321348167493725, 0.12322102239313992, 0.05067704423324615, 0.01972258371314184, 0.08738418790647207, 0.01598862140924595, 0.042795052137730605, 0.054098404833690106, 0.009091257951438947, 0.0014550267692067242, 0.07861476226204578, 0.0703028242671846, 0.03447808224120941, 0.09689361291867393, 0.05252096827941111, 0.05180686338809759, 0.1352165446215562, 0.05316748889321865, 0.14764653978897535, 0.11561768718603505, 0.09716179700797178, 0.02696682499557157, 0.09467232298614803, 0.0852503875452505, 0.0833197900722662, 0.4953558601875526, 0.45689664213351966, 0.49344481982475885, 0.49487336801202786, 0.4792749782635448, 0.48251697861028164, 0.4712993755070016, 0.4757141299809138, 0.5296036334870651, 0.10937528060206536, 0.08516513050000463, 0.07845659371484948, 0.09824635940695337, 0.06550416021874794, 0.11948173473650625, 0.1251863838307372, 0.09848648719386277, 0.16269031919597132, 0.147522045522249, 0.16302028649965783, 0.36982703451556387, 0.12811413777648872, 0.18990678018885254, 0.2576294756309554, 0.301502161364656, 0.2226122282506835, 0.27840114722500386, 0.2703592374791359, 0.31666927985932647, 0.21558871647457656, 0.25635835323166534, 0.26259658522217866, 0.20259653105058817, 0.19069950168361594, 0.21930809425208386, 0.24438979664590021, 0.22474167979608506, 0.17452132921289554, 0.19743616413858378, 0.20583505399060809, 0.18162048224872906, 0.22910541560397946, 0.3162708402432757, 0.2939924038000806, 0.21081295177408854, 0.18352592217829444, 0.21880446303819268, 0.20225206858666867, 0.21160368799015583, 0.19998615806769726, 0.22891292753049175, 0.1868409438736105, 0.17803706363470662, 0.1949901621882596, 0.18298805039025134, 0.16255838897992803, 0.16888432829914402, 0.1877098618778481, 0.1909236680296995, 0.21007013961667942, 0.17751650048072498, 0.18361113444078692, 0.18103326412427856, 0.34767913697369357, 0.9037114250735311, 0.13713579659380137, 0.20207138944907577, 0.1797279136286184, 0.17596572828893908, 0.13704021353363172, 0.943134286337024, 0.1687606119618038, 0.21491871023844156, 0.10036584503152612, 0.12847095723478474, 0.15714131887729255, 0.25419575412320494, 0.12788283737473682, 0.2140331153957865, 0.1126828059347037, 0.20715777689229165, 0.24864458645862364, 0.1905221054888886, 0.20102294849057212, 0.20093482659329154, 0.20605817607737342, 0.1983836717226687, 0.2085565110961578, 0.19061251280905755, 0.20138514867194657, 0.06833246726792808, 0.09662367523996163, 0.0972459994522471, 0.0720975654794489, 0.10517856101679446, 0.07536302230669556, 0.06139401490139296, 0.08643601886736019, 0.080758655027788]}, "mutation_prompt": null}
{"id": "ed2e1ce5-885a-411a-9bd2-28b9a3de00ee", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Add quadratic decay based on remaining budget\n        perturbation_radius *= (1.0 - (evals / self.budget) ** 2)\n        # Implement asymmetric perturbation\n        asymmetry_factor = np.sign(np.random.uniform(-1, 1, self.dim))\n        candidates = [\n            np.clip(current_best + asymmetry_factor * np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance candidate generation by incorporating asymmetric perturbations to improve convergence rate.", "configspace": "", "generation": 46, "fitness": 0.23684957221869674, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "ba4a914c-f879-46b5-985c-18a4abd5c9a3", "metadata": {"aucs": [0.6637514297177262, 0.6419677396863523, 0.6724407206490575, 0.669200083815241, 0.6611095843908537, 0.6804934388920557, 0.6782905413730529, 0.6817707124435931, 0.6647204662854197, 0.0248778222280851, 9.999999999998899e-05, 9.999999999998899e-05, 0.020757289714615546, 0.0005805847008828469, 9.999999999998899e-05, 0.021521457815569578, 9.999999999998899e-05, 9.999999999998899e-05, 0.10027334336085603, 0.06515513158198083, 0.05724343859130965, 0.13410149677259142, 0.07968190561051391, 0.07952686796858233, 0.07139871220075744, 0.10653077962805724, 0.07344863758150966, 0.07028872334710956, 0.07266081468592944, 0.05407109688559519, 0.0852134232203503, 0.07386744107184728, 0.061859665765508165, 0.10721299205664325, 0.09562603777252987, 0.055122970842482744, 0.984364710995296, 0.9773440303638544, 0.9934515887859152, 0.975887757779839, 0.9897449032693104, 0.9817118200550574, 0.9505673268214254, 0.9733566063971382, 0.9885223038435901, 0.45048100745390207, 0.3991864004363872, 0.3543739085021185, 0.5014400952347425, 0.4978773561107458, 0.51849856697059, 0.4525903109074184, 0.33850472818489075, 0.4634905365544292, 0.3525948274368359, 0.18798208092792024, 0.19522061170198435, 0.9090206505310702, 0.38625650800064093, 0.2846413764401363, 0.4202349157999683, 0.36275226449179554, 0.24517315408360296, 0.1306848462285779, 0.1662496962104879, 0.17945127686175133, 0.17737190724299767, 0.29384410488341695, 0.13368449007423444, 0.18287341831593773, 0.13363966850632802, 0.1282833011671337, 0.1837565417087228, 0.13318380907108163, 0.3347864081841404, 0.17761432948296552, 0.2010724882807533, 0.1690421928678032, 0.13327462437179605, 0.1378952600208997, 0.13312249795173448, 0.02151454632938543, 0.07213613915083539, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004089657886412468, 0.0019737818733992496, 0.0581638381589632, 0.05894084658728038, 0.03952285512437648, 0.08900477730444434, 0.10920931476175377, 0.04975450593843267, 0.11818382934390426, 0.07382301338472808, 0.06947396421705743, 0.11262287053627229, 0.04925726259618646, 0.033587875975243375, 0.0711479796077592, 0.07914086830854172, 0.13865637518377427, 0.07511841194905644, 0.052642287504198415, 0.08643020734077711, 0.06757869174655207, 0.17051255190044556, 0.08234259867519866, 0.0784509194863735, 0.23806995312985968, 0.04138368725806085, 0.18566516076501938, 0.21406753794467348, 0.0979701169793088, 0.11503251909624668, 0.518709951932583, 0.5313578560402226, 0.4670284061610279, 0.5052426519131707, 0.5876840947920413, 0.5028683775748763, 0.46644493254135344, 0.4861083838773298, 0.47025070119161205, 0.08685725820903312, 0.09316816578354792, 0.08064938088676776, 0.07620009244356785, 0.11565500134534301, 0.08832612555133268, 0.0812113861902195, 0.09332027412134503, 0.09939788555158424, 0.1585212516464688, 0.19147241496159462, 0.16669366881460468, 0.14422951205800272, 0.19991280807629286, 0.21038925670818176, 0.4046848041421165, 0.3490330586980749, 0.2690548386170324, 0.23065064368462562, 0.19986371256524638, 0.1690331734135374, 0.31657132993129267, 0.3606726150921007, 0.1614022428338634, 0.25390651410796705, 0.23967094623834417, 0.1896625390653569, 0.16444593612348413, 0.29697994497276625, 0.1299009401623018, 0.22669994846648467, 0.19377802985915216, 0.13555304598732765, 0.16168213883290905, 0.11201147106864195, 0.1771435999974026, 0.17775773697643704, 0.22431750812595008, 0.2202791424989352, 0.20005804102180713, 0.1699504930085497, 0.16970674129009333, 0.2249103526740991, 0.20500666073376128, 0.27395185329352323, 0.182929764587766, 0.16929689023215966, 0.181158739339096, 0.17179929950388528, 0.21164459963718418, 0.1906657275507614, 0.17747558011281217, 0.2154357075735429, 0.19256075767926384, 0.1600527435319451, 0.137685020319539, 0.17461510614320908, 0.17417510931152624, 0.15510730374053328, 0.8194034935045895, 0.17055901802754192, 0.15657805566637473, 0.16445867316558926, 0.46660006000669874, 0.11320912583819387, 0.12730989619288535, 0.15795095033902107, 0.21382780982257765, 0.12853921764774223, 0.5890850603976243, 0.18141646021366964, 0.14245867668684076, 0.21367300477119866, 0.19566988588360346, 0.2079596077857533, 0.20231945219360403, 0.19728926987946438, 0.22451304178184373, 0.2032689604339819, 0.23600025908011324, 0.18793328386518127, 0.08529337188659569, 0.09053925518446171, 0.0986972867106759, 0.06082242300853813, 0.07164818132653095, 0.10559215528109211, 0.0899244157753003, 0.1147645416966927, 0.07500569995122675]}, "mutation_prompt": null}
{"id": "fb767c21-2050-4ba9-86c7-ca1e525b526c", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Added dynamic candidate count based on past performance\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)  # Enhanced adaptive scaling\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Add quadratic decay based on remaining budget\n        perturbation_radius *= (1.0 - (evals / self.budget) ** 2)\n        # Introduce a non-linear temperature schedule\n        perturbation_radius *= np.exp(-0.01 * evals)  # New line for non-linear schedule\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0  # Start with maximum exploration\n        else:\n            recent_history = self.history[-10:]  # Look at the last 10 evaluations\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a non-linear temperature schedule to adaptively regulate candidate exploration.", "configspace": "", "generation": 47, "fitness": 0.1831667263860248, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.22.", "error": "", "parent_id": "ba4a914c-f879-46b5-985c-18a4abd5c9a3", "metadata": {"aucs": [0.9670154962737367, 0.9667587256177257, 0.9652998169822398, 0.9629166290815914, 0.9598785555140578, 0.9655331753054761, 0.9658698853037532, 0.9611956855960995, 0.9603013971263792, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0926729688655461, 0.046553009496061115, 0.020122722226476042, 0.033006777869276305, 0.03383846516393185, 0.05342394294349673, 0.05357588064782248, 0.028100556233234042, 0.029313932770346773, 0.09141114434893838, 0.05338654337534954, 9.999999999998899e-05, 0.06527212267584459, 0.08161003049887272, 0.04299275238539868, 0.07344901407335569, 0.02069301478108243, 0.03379746446724041, 0.9811671056985485, 0.11968250824939619, 0.08445632578578477, 0.17535645056433657, 0.141424815779999, 0.2082239601614042, 0.10979146745289758, 0.2186540962639053, 0.1094100692784643, 0.47980690792092917, 0.08697320575230838, 9.999999999998899e-05, 0.2109061517120493, 0.23441337739132573, 0.13537754524667767, 0.1581204812406415, 0.1434653984131894, 0.16104946704902845, 0.13478918450737998, 0.06044381962337719, 0.049620202858752016, 0.1793774170124871, 0.17413710191510923, 0.149791135425147, 0.1807713546831865, 0.033012918714812045, 0.1283065526845466, 0.13642050133858175, 0.16483359157633004, 0.15151672070241073, 0.13183304823302355, 0.142608459220548, 9.999999999998899e-05, 0.21707551064388686, 0.15757956610362212, 0.13245512957936334, 0.16383534398502597, 0.13698256390276242, 0.12450202386682396, 0.16532212436662508, 0.15631782102827674, 0.1385691872004141, 0.3055439103320372, 0.13159751868175917, 0.1345911729988768, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03453815420979767, 0.07373015231605529, 0.08693176922749812, 0.0633166769167639, 0.04848478196830597, 9.999999999998899e-05, 0.11799093182644882, 0.020845568670183057, 0.06373098265778043, 0.10380633298575181, 0.046904317348166136, 0.10357366202161589, 0.1411184703188204, 0.10999511994637412, 0.15534728873607806, 0.18895496853441096, 0.13861141475736982, 0.19491420980951224, 0.08153803285532557, 0.054265182640736764, 0.12923675758565256, 0.13266107332402188, 0.052413042644395724, 0.17011934106256832, 0.0867839359718926, 0.05200758701745034, 0.12186349489392412, 0.4984899531720345, 0.4826418344527035, 0.6409816580557712, 0.40248856559823176, 0.40203719025761864, 0.44907676291720255, 0.5556329906188241, 0.4532091531904716, 0.4316545556740645, 0.06369153294512764, 0.08722528906802585, 0.06110549589136194, 0.05044251717525461, 0.07194355113999862, 0.07424365651653075, 0.04954946411555794, 0.08480770001969173, 0.040658371426078754, 0.1878865431319141, 0.13187536097471197, 0.19785443342193898, 0.3203756983298647, 0.12701776120436625, 0.14743648038863377, 0.1521753840770822, 0.19540715152350852, 0.2819615849558158, 0.1525699329026986, 0.1424330520297925, 0.11643541652965828, 0.16076910067208283, 0.13948701413966114, 0.1412418329537355, 0.1769159571588791, 0.1575440582067209, 0.1634980786529795, 0.04821605605934087, 0.19537487777566354, 0.05536120398874955, 0.114802105172634, 0.08126539641643682, 0.1375291736742572, 0.19611418502249356, 0.0433570179583499, 0.046816722032035574, 0.2762131593456001, 0.14452157299623303, 0.2354385805024759, 0.15494090190475085, 0.2155885586098033, 0.2644347758411125, 0.2253383615902027, 0.16842145835856592, 0.136244486169668, 0.1815854135227255, 0.16823859483322745, 0.17701669675274445, 0.17277624482348708, 0.19486479972077753, 0.23083748695025308, 0.19367189561692488, 0.17988235137952602, 0.19336051236483986, 0.16950215556183845, 0.13750536508436761, 0.6028779837258761, 0.14970904599832813, 0.17994057032041488, 0.9757810664722425, 0.13776117740344984, 0.11542638273357242, 0.1552704799971103, 0.6937613758932303, 0.11239084980140046, 0.4356495672560985, 0.15317338301826733, 0.21409724287333542, 0.21096288300667976, 0.21538418290950723, 0.09462902598971379, 0.16312452628963492, 0.2100841726152729, 0.18789936617267744, 0.21375843707248554, 0.22633794200915314, 0.18831555512584042, 0.20097636511455397, 0.2542348051743766, 0.23315567644459623, 0.29100638739831797, 0.09308249760877318, 0.0599757644414165, 0.06513711327984895, 0.06872980016590047, 0.04802707100819603, 0.06903777847817238, 0.056066453703820796, 0.0696698641362895, 0.04260673720883146]}, "mutation_prompt": null}
{"id": "7936441f-1850-45e7-96c8-457ea42981e3", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce dynamic perturbation decay using cosine annealing to improve convergence efficiency.", "configspace": "", "generation": 48, "fitness": 0.24521108672518502, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "ba4a914c-f879-46b5-985c-18a4abd5c9a3", "metadata": {"aucs": [0.7201978321848431, 0.6521918806377339, 0.6708640821643159, 0.682234554307164, 0.6557329392284907, 0.6790124181558769, 0.6806354152812836, 0.6996458758771653, 0.6481265217945416, 0.022676885124609525, 9.999999999998899e-05, 9.999999999998899e-05, 0.10597414785804848, 9.999999999998899e-05, 9.999999999998899e-05, 0.1130686868650631, 9.999999999998899e-05, 9.999999999998899e-05, 0.08739857286340225, 0.08011377278948317, 0.059101888390480584, 0.06701428097453532, 0.09874070730789897, 0.0943571191542778, 0.08430539923172242, 0.11277255559829702, 0.09346575812597435, 0.09067455377387046, 0.057179699103506065, 0.07467063837970345, 0.08356433685597608, 0.07282474620582802, 0.08610301351193206, 0.10599565188369875, 0.11578577258020162, 0.05509907650966783, 0.960978482454653, 0.9828363558776129, 0.9793657390873736, 0.9596622045422997, 0.9796970677816866, 0.9869202551413274, 0.9782453740018389, 0.9942053643824704, 0.9700876932269037, 0.47680481057339386, 0.42799471404272027, 0.4507411277361585, 0.5210248216008015, 0.44756565216066213, 0.4099638208397962, 0.4981544533945509, 0.48008456049839077, 0.4166778142775893, 0.21649768725500007, 0.16660067926351474, 0.39932804881807993, 0.9081118588002596, 0.3844630223265495, 0.21302288533546265, 0.250959232931524, 0.226067044581868, 0.2049595339404986, 0.1449921871723494, 0.21988631740412345, 0.15924582827482792, 0.1401854134200894, 0.23451635528699222, 0.13539103672728126, 0.11919381441468946, 0.20602306421410965, 0.13372769872933699, 0.17164398697103356, 0.1260722355369528, 0.12697967940165145, 0.23120843785106204, 0.1349147086851593, 0.1303147737846344, 0.19985780363495664, 0.15924601930028037, 0.13223865957552483, 9.999999999998899e-05, 9.999999999998899e-05, 0.004645562038243067, 0.0005502677066371309, 0.048944370735772624, 0.012907707142525204, 9.999999999998899e-05, 9.999999999998899e-05, 0.00538798479365854, 0.0620631096868659, 0.0801178180811859, 0.1539398082227823, 0.1236692785158029, 0.08157157137437276, 0.019157857366547293, 0.1597557944529171, 0.035224557996813566, 0.08116682101269213, 0.0571497436631887, 0.03409061988774065, 0.06739065644318254, 0.21598281850257517, 0.07946106243003215, 0.16541607737149477, 0.08531017873546676, 0.1526189018275158, 0.16170239323963798, 0.09201296533934433, 0.14134152108683284, 0.21012677929511359, 0.160108401520501, 0.23616854551938027, 0.019057621738629682, 0.10613582194493831, 0.11013042341432244, 0.2274428597100836, 0.4899343997451119, 0.4648669675741056, 0.4785398050186359, 0.4905500297464811, 0.4923674579892563, 0.4907934443529598, 0.4842591790938511, 0.5432796322503906, 0.45215264412503386, 0.15961374685276297, 0.11835781956346003, 0.08925815701410122, 0.0835218577875414, 0.12624523625714534, 0.09902595388671065, 0.13993906785344656, 0.05600330322298852, 0.10646179837484637, 0.1822586630138927, 0.2654103061819034, 0.25299119307400453, 0.35720158899130694, 0.17029537906830516, 0.1600154044630221, 0.2119998521288866, 0.16768207458986384, 0.1916547792597617, 0.35417665442253843, 0.2552993690447807, 0.23333967611216144, 0.19384940835508324, 0.215960546293529, 0.23600918481842148, 0.20664176946750556, 0.3561621884086581, 0.18415510215455866, 0.22898286526753897, 0.26797261223006685, 0.31052666106830773, 0.13805334042274064, 0.18720367927391623, 0.09471918259404288, 0.1905598899382357, 0.20598069897011917, 0.1340801690388096, 0.29682546908790763, 0.21681973171391078, 0.18638866449246627, 0.23895310474149645, 0.19188466035137652, 0.18871106671923954, 0.22007603524098618, 0.19253240208979583, 0.20456249990212205, 0.20160715014519437, 0.18376729781040468, 0.19099257122108726, 0.17261352648269945, 0.2117662228333692, 0.19209658806028762, 0.22851995509541378, 0.18967485165174847, 0.18538652267292333, 0.1694613264276268, 0.1377025832122164, 0.8774093452496902, 0.14964538320297438, 0.18001916742202706, 0.9450813218104284, 0.13769995971920856, 0.18861062323310684, 0.15490315906765262, 0.12843243011591343, 0.11312292776798549, 0.6421722564052114, 0.15627645976136884, 0.21504690071852717, 0.21181258455224394, 0.2151361097494655, 0.20400255157070402, 0.3503190812919653, 0.2253228450578868, 0.24277764248545985, 0.22179007806480666, 0.21873225798761597, 0.23429339186175702, 0.21722837856422328, 0.19264610113947578, 0.2638518097101282, 0.2537829923384566, 0.12051708542091744, 0.10183850358391633, 0.08215123755929743, 0.13157972541554008, 0.09465520151203766, 0.11289034649131446, 0.06203266703178867, 0.07861054216493035, 0.08457168652444413]}, "mutation_prompt": null}
{"id": "558ef638-ee39-4bde-b515-91f825a0b002", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce dynamic perturbation decay using cosine annealing to improve convergence efficiency.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7936441f-1850-45e7-96c8-457ea42981e3", "metadata": {"aucs": [0.7201978321848431, 0.6521918806377339, 0.6708640821643159, 0.682234554307164, 0.6557329392284907, 0.6790124181558769, 0.6806354152812836, 0.6996458758771653, 0.6481265217945416, 0.022676885124609525, 9.999999999998899e-05, 9.999999999998899e-05, 0.10597414785804848, 9.999999999998899e-05, 9.999999999998899e-05, 0.1130686868650631, 9.999999999998899e-05, 9.999999999998899e-05, 0.08739857286340225, 0.08011377278948317, 0.059101888390480584, 0.06701428097453532, 0.09874070730789897, 0.0943571191542778, 0.08430539923172242, 0.11277255559829702, 0.09346575812597435, 0.09067455377387046, 0.057179699103506065, 0.07467063837970345, 0.08356433685597608, 0.07282474620582802, 0.08610301351193206, 0.10599565188369875, 0.11578577258020162, 0.05509907650966783, 0.960978482454653, 0.9828363558776129, 0.9793657390873736, 0.9596622045422997, 0.9796970677816866, 0.9869202551413274, 0.9782453740018389, 0.9942053643824704, 0.9700876932269037, 0.47680481057339386, 0.42799471404272027, 0.4507411277361585, 0.5210248216008015, 0.44756565216066213, 0.4099638208397962, 0.4981544533945509, 0.48008456049839077, 0.4166778142775893, 0.21649768725500007, 0.16660067926351474, 0.39932804881807993, 0.9081118588002596, 0.3844630223265495, 0.21302288533546265, 0.250959232931524, 0.226067044581868, 0.2049595339404986, 0.1449921871723494, 0.21988631740412345, 0.15924582827482792, 0.1401854134200894, 0.23451635528699222, 0.13539103672728126, 0.11919381441468946, 0.20602306421410965, 0.13372769872933699, 0.17164398697103356, 0.1260722355369528, 0.12697967940165145, 0.23120843785106204, 0.1349147086851593, 0.1303147737846344, 0.19985780363495664, 0.15924601930028037, 0.13223865957552483, 9.999999999998899e-05, 9.999999999998899e-05, 0.004645562038243067, 0.0005502677066371309, 0.048944370735772624, 0.012907707142525204, 9.999999999998899e-05, 9.999999999998899e-05, 0.00538798479365854, 0.0620631096868659, 0.0801178180811859, 0.1539398082227823, 0.1236692785158029, 0.08157157137437276, 0.019157857366547293, 0.1597557944529171, 0.035224557996813566, 0.08116682101269213, 0.0571497436631887, 0.03409061988774065, 0.06739065644318254, 0.21598281850257517, 0.07946106243003215, 0.16541607737149477, 0.08531017873546676, 0.1526189018275158, 0.16170239323963798, 0.09201296533934433, 0.14134152108683284, 0.21012677929511359, 0.160108401520501, 0.23616854551938027, 0.019057621738629682, 0.10613582194493831, 0.11013042341432244, 0.2274428597100836, 0.4899343997451119, 0.4648669675741056, 0.4785398050186359, 0.4905500297464811, 0.4923674579892563, 0.4907934443529598, 0.4842591790938511, 0.5432796322503906, 0.45215264412503386, 0.15961374685276297, 0.11835781956346003, 0.08925815701410122, 0.0835218577875414, 0.12624523625714534, 0.09902595388671065, 0.13993906785344656, 0.05600330322298852, 0.10646179837484637, 0.1822586630138927, 0.2654103061819034, 0.25299119307400453, 0.35720158899130694, 0.17029537906830516, 0.1600154044630221, 0.2119998521288866, 0.16768207458986384, 0.1916547792597617, 0.35417665442253843, 0.2552993690447807, 0.23333967611216144, 0.19384940835508324, 0.215960546293529, 0.23600918481842148, 0.20664176946750556, 0.3561621884086581, 0.18415510215455866, 0.22898286526753897, 0.26797261223006685, 0.31052666106830773, 0.13805334042274064, 0.18720367927391623, 0.09471918259404288, 0.1905598899382357, 0.20598069897011917, 0.1340801690388096, 0.29682546908790763, 0.21681973171391078, 0.18638866449246627, 0.23895310474149645, 0.19188466035137652, 0.18871106671923954, 0.22007603524098618, 0.19253240208979583, 0.20456249990212205, 0.20160715014519437, 0.18376729781040468, 0.19099257122108726, 0.17261352648269945, 0.2117662228333692, 0.19209658806028762, 0.22851995509541378, 0.18967485165174847, 0.18538652267292333, 0.1694613264276268, 0.1377025832122164, 0.8774093452496902, 0.14964538320297438, 0.18001916742202706, 0.9450813218104284, 0.13769995971920856, 0.18861062323310684, 0.15490315906765262, 0.12843243011591343, 0.11312292776798549, 0.6421722564052114, 0.15627645976136884, 0.21504690071852717, 0.21181258455224394, 0.2151361097494655, 0.20400255157070402, 0.3503190812919653, 0.2253228450578868, 0.24277764248545985, 0.22179007806480666, 0.21873225798761597, 0.23429339186175702, 0.21722837856422328, 0.19264610113947578, 0.2638518097101282, 0.2537829923384566, 0.12051708542091744, 0.10183850358391633, 0.08215123755929743, 0.13157972541554008, 0.09465520151203766, 0.11289034649131446, 0.06203266703178867, 0.07861054216493035, 0.08457168652444413]}, "mutation_prompt": null}
{"id": "783fe4d5-3f3e-46a2-be1f-c3bc89a29be2", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) * (\n            1.0 / (1.0 + np.abs(np.random.standard_cauchy())) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Incorporate variance reduction in perturbation generation to boost convergence stability and solution precision.", "configspace": "", "generation": 50, "fitness": 0.21380981587350142, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "7936441f-1850-45e7-96c8-457ea42981e3", "metadata": {"aucs": [0.5286013047607441, 0.513436767282132, 0.5454482652950086, 0.5457027001893247, 0.5550842404017455, 0.529199760466412, 0.49318070515354606, 0.5330005569402368, 0.5268406248634256, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006825564293833519, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10226241405455982, 0.07803735427949776, 0.10257363392962793, 0.10643642153997912, 0.11295197021564107, 0.06987362808384767, 0.12106780591571242, 0.0905450644896455, 0.13858888101027755, 0.08265827968616701, 0.09907338843125202, 0.04886887085372815, 0.0725336121530159, 0.0795776443982239, 0.08768096969202888, 0.09320485156203306, 0.11673108629069062, 0.11209199896811883, 0.9810685177515085, 0.9848175410790903, 0.9895150108175198, 0.9820639110327901, 0.9914473334469933, 0.9934949333999824, 0.9935105796322985, 0.9946620877991419, 0.9834565338271196, 0.3069562943947599, 0.23270706377617878, 0.31814205083201963, 0.32574219742994504, 0.2621873694028528, 0.27578237241481474, 0.3527967960188829, 0.3997810136835015, 0.33969395690086057, 0.32456834414090885, 0.22269926511672022, 0.3328738423718336, 0.274927533678341, 0.21912955184041127, 0.21524367040809045, 0.2148306794101622, 0.3734123596848403, 0.2658188906076231, 0.12642226957376967, 0.12574889249000276, 0.128532609853786, 0.13659597457549422, 0.12808226840635029, 0.1501338833555621, 0.11986084430519461, 0.1585500832253216, 0.23918254910827974, 0.13550866327998556, 0.18493043021105382, 0.15058288827471, 0.16127538396961605, 0.1483229544055612, 0.15124178487711948, 0.12627961320731718, 0.16750138303028328, 0.14731401123106758, 0.050610482739193, 9.999999999998899e-05, 9.999999999998899e-05, 0.005648214491779213, 0.005198968559578687, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009026049496962951, 0.0008078363417786116, 0.053170089060677106, 0.0855318863650516, 0.0961230463829088, 0.07949459395616687, 0.05285094754216246, 0.053077844044928546, 0.08708549775470398, 0.013822129191189525, 0.06538702814408803, 0.0013044529910797298, 0.041795415839660954, 0.05086931469088107, 0.04969873118845536, 0.0171436493503343, 0.001981783964442596, 0.020300652178469658, 0.0040004389670266205, 0.0018506238928294172, 0.10104282407076537, 0.09566723096672647, 0.11701660274885473, 0.1515875301743883, 0.1418390105875429, 0.04988620051141046, 0.09452349943169791, 0.11308810113874801, 0.14086584368029686, 0.42510482647250725, 0.4474111999688444, 0.4069267645233018, 0.4083837575251983, 0.4327046775365464, 0.3966833278382975, 0.47842131848614156, 0.4024847137929628, 0.4086008393874586, 0.11593422254854613, 0.08469262846492742, 0.10268350260271564, 0.08956113849554936, 0.08484163022833913, 0.08201818299487218, 0.10919981537959411, 0.12640064878993107, 0.10056970377843244, 0.19380183603090306, 0.157452318447297, 0.1807903142824716, 0.1996771946454471, 0.37550435913941593, 0.1781124919990834, 0.23823786371493172, 0.2521417102481751, 0.16977152059286094, 0.2901709244241907, 0.21974187361539843, 0.24715360295578948, 0.2623644833816633, 0.31924162359687724, 0.3031920390177938, 0.3291479808743323, 0.20417543834630303, 0.21042108963774264, 0.22914854685187158, 0.1936646107524902, 0.14250453177786404, 0.239035993124745, 0.15832685804413504, 0.1770582769143979, 0.23961938747695855, 0.17932491272953388, 0.16971014915897464, 0.18551184530712894, 0.20428273342035286, 0.20574721922462613, 0.19690705969629418, 0.17213897360205987, 0.16936586563727163, 0.17787048341176692, 0.19718213706991772, 0.2226969563359137, 0.17337601860566043, 0.19384070352395855, 0.1870174943361439, 0.1787391639342263, 0.20513808131578848, 0.19672812178297883, 0.18289256146453037, 0.2054621016250634, 0.20896405930683637, 0.14747385925935685, 0.6537945254895445, 0.366129177640399, 0.1441761417990105, 0.16401967622404567, 0.14648915621413794, 0.1682208367292174, 0.16946340860377418, 0.1544648374580031, 0.17047744378968688, 0.20786801254546294, 0.16747846622818818, 0.20991173084039483, 0.2732429810736001, 0.12672389694419495, 0.2744176215671019, 0.16618424334595783, 0.4776609426050151, 0.21501009035371021, 0.18623084822691915, 0.18206105074628398, 0.2260743241165667, 0.2099661238138404, 0.2049378104418702, 0.18889170166229408, 0.2201483747160361, 0.2242440294540805, 0.07548180368180946, 0.0913844959258302, 0.08637041543338941, 0.08407846067946934, 0.07938370189037491, 0.0760362037102108, 0.07871398952103303, 0.08314604723961472, 0.08173975913192122]}, "mutation_prompt": null}
{"id": "e8128bcc-b391-4032-87d4-572b858f86f8", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        perturbation_radius = adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce dynamic perturbation decay using cosine annealing to improve convergence efficiency.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7936441f-1850-45e7-96c8-457ea42981e3", "metadata": {"aucs": [0.7201978321848431, 0.6521918806377339, 0.6708640821643159, 0.682234554307164, 0.6557329392284907, 0.6790124181558769, 0.6806354152812836, 0.6996458758771653, 0.6481265217945416, 0.022676885124609525, 9.999999999998899e-05, 9.999999999998899e-05, 0.10597414785804848, 9.999999999998899e-05, 9.999999999998899e-05, 0.1130686868650631, 9.999999999998899e-05, 9.999999999998899e-05, 0.08739857286340225, 0.08011377278948317, 0.059101888390480584, 0.06701428097453532, 0.09874070730789897, 0.0943571191542778, 0.08430539923172242, 0.11277255559829702, 0.09346575812597435, 0.09067455377387046, 0.057179699103506065, 0.07467063837970345, 0.08356433685597608, 0.07282474620582802, 0.08610301351193206, 0.10599565188369875, 0.11578577258020162, 0.05509907650966783, 0.960978482454653, 0.9828363558776129, 0.9793657390873736, 0.9596622045422997, 0.9796970677816866, 0.9869202551413274, 0.9782453740018389, 0.9942053643824704, 0.9700876932269037, 0.47680481057339386, 0.42799471404272027, 0.4507411277361585, 0.5210248216008015, 0.44756565216066213, 0.4099638208397962, 0.4981544533945509, 0.48008456049839077, 0.4166778142775893, 0.21649768725500007, 0.16660067926351474, 0.39932804881807993, 0.9081118588002596, 0.3844630223265495, 0.21302288533546265, 0.250959232931524, 0.226067044581868, 0.2049595339404986, 0.1449921871723494, 0.21988631740412345, 0.15924582827482792, 0.1401854134200894, 0.23451635528699222, 0.13539103672728126, 0.11919381441468946, 0.20602306421410965, 0.13372769872933699, 0.17164398697103356, 0.1260722355369528, 0.12697967940165145, 0.23120843785106204, 0.1349147086851593, 0.1303147737846344, 0.19985780363495664, 0.15924601930028037, 0.13223865957552483, 9.999999999998899e-05, 9.999999999998899e-05, 0.004645562038243067, 0.0005502677066371309, 0.048944370735772624, 0.012907707142525204, 9.999999999998899e-05, 9.999999999998899e-05, 0.00538798479365854, 0.0620631096868659, 0.0801178180811859, 0.1539398082227823, 0.1236692785158029, 0.08157157137437276, 0.019157857366547293, 0.1597557944529171, 0.035224557996813566, 0.08116682101269213, 0.0571497436631887, 0.03409061988774065, 0.06739065644318254, 0.21598281850257517, 0.07946106243003215, 0.16541607737149477, 0.08531017873546676, 0.1526189018275158, 0.16170239323963798, 0.09201296533934433, 0.14134152108683284, 0.21012677929511359, 0.160108401520501, 0.23616854551938027, 0.019057621738629682, 0.10613582194493831, 0.11013042341432244, 0.2274428597100836, 0.4899343997451119, 0.4648669675741056, 0.4785398050186359, 0.4905500297464811, 0.4923674579892563, 0.4907934443529598, 0.4842591790938511, 0.5432796322503906, 0.45215264412503386, 0.15961374685276297, 0.11835781956346003, 0.08925815701410122, 0.0835218577875414, 0.12624523625714534, 0.09902595388671065, 0.13993906785344656, 0.05600330322298852, 0.10646179837484637, 0.1822586630138927, 0.2654103061819034, 0.25299119307400453, 0.35720158899130694, 0.17029537906830516, 0.1600154044630221, 0.2119998521288866, 0.16768207458986384, 0.1916547792597617, 0.35417665442253843, 0.2552993690447807, 0.23333967611216144, 0.19384940835508324, 0.215960546293529, 0.23600918481842148, 0.20664176946750556, 0.3561621884086581, 0.18415510215455866, 0.22898286526753897, 0.26797261223006685, 0.31052666106830773, 0.13805334042274064, 0.18720367927391623, 0.09471918259404288, 0.1905598899382357, 0.20598069897011917, 0.1340801690388096, 0.29682546908790763, 0.21681973171391078, 0.18638866449246627, 0.23895310474149645, 0.19188466035137652, 0.18871106671923954, 0.22007603524098618, 0.19253240208979583, 0.20456249990212205, 0.20160715014519437, 0.18376729781040468, 0.19099257122108726, 0.17261352648269945, 0.2117662228333692, 0.19209658806028762, 0.22851995509541378, 0.18967485165174847, 0.18538652267292333, 0.1694613264276268, 0.1377025832122164, 0.8774093452496902, 0.14964538320297438, 0.18001916742202706, 0.9450813218104284, 0.13769995971920856, 0.18861062323310684, 0.15490315906765262, 0.12843243011591343, 0.11312292776798549, 0.6421722564052114, 0.15627645976136884, 0.21504690071852717, 0.21181258455224394, 0.2151361097494655, 0.20400255157070402, 0.3503190812919653, 0.2253228450578868, 0.24277764248545985, 0.22179007806480666, 0.21873225798761597, 0.23429339186175702, 0.21722837856422328, 0.19264610113947578, 0.2638518097101282, 0.2537829923384566, 0.12051708542091744, 0.10183850358391633, 0.08215123755929743, 0.13157972541554008, 0.09465520151203766, 0.11289034649131446, 0.06203266703178867, 0.07861054216493035, 0.08457168652444413]}, "mutation_prompt": null}
{"id": "b5aa20fa-efb1-4450-90e3-a7cb7b8644c3", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget  # Introduced adaptive learning rate\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce an adaptive learning rate based on evaluation progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.24797130118934538, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "7936441f-1850-45e7-96c8-457ea42981e3", "metadata": {"aucs": [0.6859176338236574, 0.7531935814119854, 0.7005487770133259, 0.713009147783566, 0.7172012803667704, 0.693325905341789, 0.7869260353927944, 0.713580302788196, 0.6880799640793143, 0.018918703428808303, 9.999999999998899e-05, 9.999999999998899e-05, 0.09388525657127045, 9.999999999998899e-05, 9.999999999998899e-05, 0.047459070977771245, 9.999999999998899e-05, 9.999999999998899e-05, 0.08779743137524532, 0.08609363997040387, 0.1284415191770586, 0.08786737604143402, 0.1280211584746388, 0.07314489792854661, 0.07216022284668344, 0.11910178016354311, 0.07430304726290415, 0.07530483974988433, 0.04602551986441428, 0.04572265958595778, 0.06710484025283436, 0.0821410158336574, 0.09413841538867507, 0.08564961580224151, 0.07201689149108259, 0.07003911211142766, 0.960904572543334, 0.9828331719625271, 0.9846160025387711, 0.9595259921456072, 0.979694715964495, 0.9869148976233232, 0.9782211534745356, 0.9942050911319325, 0.9700775641115388, 0.46293595102942187, 0.4537680709993186, 0.4759798704257888, 0.48378245900026007, 0.5153532517962078, 0.4922549352626112, 0.4876743047093539, 0.5134894602212589, 0.4347931340366735, 0.1592200137520875, 0.15197036417786092, 0.7889827539163949, 0.3894537110845183, 0.1923597274736638, 0.28243435839898967, 0.3265376231054953, 0.225505509102766, 0.17049767562437124, 0.14971681363433398, 0.20957613731672953, 0.18021788827897778, 0.14920355777879923, 0.200072138699964, 0.13306398220808258, 0.1189867283788888, 0.22013604821299582, 0.1341922933084183, 0.18268090717267704, 0.12490215827163464, 0.12678152363000805, 0.25539265676429157, 0.13650893837264444, 0.22331755217507043, 0.16963099723424058, 0.1669321805220072, 0.13213021387262291, 0.0003828573865828355, 0.03769515584015193, 0.00016437813239444932, 0.0008848923496372896, 0.020793724519173162, 0.12682954032431548, 9.999999999998899e-05, 0.00016653233596131134, 0.011884944641972095, 0.05828551067343268, 0.08470556213423919, 0.15491351707176348, 0.11077256877634778, 0.07044415578932417, 0.010789238558413072, 0.1639480232655789, 0.04762025550326565, 0.08947295756790008, 0.05398832552043753, 0.042286078007033434, 0.10220200300698312, 0.21249451155400556, 0.07434555641305973, 0.1729227704754459, 0.11202890909283836, 0.10108385757817828, 0.15438128729526013, 0.0911399210423629, 0.14301541148005492, 0.21278202124110812, 0.09722118448499062, 0.23359680194753651, 0.0398465953494439, 0.09592394207969623, 0.10773824583687142, 0.22251743534976998, 0.5046663318702491, 0.4833839046817707, 0.522190202578074, 0.49784752271247223, 0.5180784553620286, 0.4894341366473808, 0.49999320187155605, 0.501117729392335, 0.5116574868822552, 0.08331127474515665, 0.11840347125732842, 0.10569849931722819, 0.18746379515828138, 0.12627159482947503, 0.08474409900193003, 0.09483638795373495, 0.06620334737216349, 0.13155505506236298, 0.17962295707510167, 0.22765008828094857, 0.2548930711073151, 0.192223368753337, 0.16595734987590882, 0.1520234965009637, 0.189599380874786, 0.3563711369413818, 0.2013406415590181, 0.2881742314632365, 0.24457515841388433, 0.15755939667558028, 0.33300317095588716, 0.22205666021850012, 0.17288953256437867, 0.19116596702812605, 0.23293285238395312, 0.2845043647542488, 0.19282218923285332, 0.2132120615257027, 0.07695999331917391, 0.12251018889570364, 0.1667652778029537, 0.12432910934506691, 0.2202938530778491, 0.249146553170025, 0.221389860583026, 0.19372370398566696, 0.2487939292909941, 0.23979504631939497, 0.24532829776648446, 0.25432624447324415, 0.19472830837434318, 0.24219881005146227, 0.26189719245243037, 0.18448051547770639, 0.17468878914101627, 0.18395568376934512, 0.17488007567091501, 0.17882141951123653, 0.19775323318389426, 0.19207684437663652, 0.22959348726832562, 0.1794379847130647, 0.19267635549346596, 0.16946310962496902, 0.1377075278610882, 0.8931085489049351, 0.1496448581999582, 0.18003469851315657, 0.9494809609981056, 0.137700865877581, 0.11539478923582702, 0.1549314195631103, 0.2349096576293287, 0.11320992648273964, 0.8162344498419565, 0.15624668868285552, 0.21506084752350574, 0.21184400020219019, 0.21514465076694422, 0.40964428940172926, 0.4045920155758719, 0.2135005473894397, 0.19231303955633416, 0.22708156508993327, 0.21994334267773308, 0.2335916789274458, 0.22861718934565456, 0.19866634654075754, 0.20373793242846439, 0.2351299485074123, 0.1304156092701242, 0.1308073736605584, 0.07850448827271661, 0.09096848875607066, 0.07132160943942778, 0.11282617441143483, 0.06666231360353436, 0.05834872767030119, 0.09050967970018431]}, "mutation_prompt": null}
{"id": "6199be9b-5e48-4cf6-bcd4-d42686dbdc05", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget  # Introduced adaptive learning rate\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce an adaptive learning rate based on evaluation progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b5aa20fa-efb1-4450-90e3-a7cb7b8644c3", "metadata": {"aucs": [0.6859176338236574, 0.7531935814119854, 0.7005487770133259, 0.713009147783566, 0.7172012803667704, 0.693325905341789, 0.7869260353927944, 0.713580302788196, 0.6880799640793143, 0.018918703428808303, 9.999999999998899e-05, 9.999999999998899e-05, 0.09388525657127045, 9.999999999998899e-05, 9.999999999998899e-05, 0.047459070977771245, 9.999999999998899e-05, 9.999999999998899e-05, 0.08779743137524532, 0.08609363997040387, 0.1284415191770586, 0.08786737604143402, 0.1280211584746388, 0.07314489792854661, 0.07216022284668344, 0.11910178016354311, 0.07430304726290415, 0.07530483974988433, 0.04602551986441428, 0.04572265958595778, 0.06710484025283436, 0.0821410158336574, 0.09413841538867507, 0.08564961580224151, 0.07201689149108259, 0.07003911211142766, 0.960904572543334, 0.9828331719625271, 0.9846160025387711, 0.9595259921456072, 0.979694715964495, 0.9869148976233232, 0.9782211534745356, 0.9942050911319325, 0.9700775641115388, 0.46293595102942187, 0.4537680709993186, 0.4759798704257888, 0.48378245900026007, 0.5153532517962078, 0.4922549352626112, 0.4876743047093539, 0.5134894602212589, 0.4347931340366735, 0.1592200137520875, 0.15197036417786092, 0.7889827539163949, 0.3894537110845183, 0.1923597274736638, 0.28243435839898967, 0.3265376231054953, 0.225505509102766, 0.17049767562437124, 0.14971681363433398, 0.20957613731672953, 0.18021788827897778, 0.14920355777879923, 0.200072138699964, 0.13306398220808258, 0.1189867283788888, 0.22013604821299582, 0.1341922933084183, 0.18268090717267704, 0.12490215827163464, 0.12678152363000805, 0.25539265676429157, 0.13650893837264444, 0.22331755217507043, 0.16963099723424058, 0.1669321805220072, 0.13213021387262291, 0.0003828573865828355, 0.03769515584015193, 0.00016437813239444932, 0.0008848923496372896, 0.020793724519173162, 0.12682954032431548, 9.999999999998899e-05, 0.00016653233596131134, 0.011884944641972095, 0.05828551067343268, 0.08470556213423919, 0.15491351707176348, 0.11077256877634778, 0.07044415578932417, 0.010789238558413072, 0.1639480232655789, 0.04762025550326565, 0.08947295756790008, 0.05398832552043753, 0.042286078007033434, 0.10220200300698312, 0.21249451155400556, 0.07434555641305973, 0.1729227704754459, 0.11202890909283836, 0.10108385757817828, 0.15438128729526013, 0.0911399210423629, 0.14301541148005492, 0.21278202124110812, 0.09722118448499062, 0.23359680194753651, 0.0398465953494439, 0.09592394207969623, 0.10773824583687142, 0.22251743534976998, 0.5046663318702491, 0.4833839046817707, 0.522190202578074, 0.49784752271247223, 0.5180784553620286, 0.4894341366473808, 0.49999320187155605, 0.501117729392335, 0.5116574868822552, 0.08331127474515665, 0.11840347125732842, 0.10569849931722819, 0.18746379515828138, 0.12627159482947503, 0.08474409900193003, 0.09483638795373495, 0.06620334737216349, 0.13155505506236298, 0.17962295707510167, 0.22765008828094857, 0.2548930711073151, 0.192223368753337, 0.16595734987590882, 0.1520234965009637, 0.189599380874786, 0.3563711369413818, 0.2013406415590181, 0.2881742314632365, 0.24457515841388433, 0.15755939667558028, 0.33300317095588716, 0.22205666021850012, 0.17288953256437867, 0.19116596702812605, 0.23293285238395312, 0.2845043647542488, 0.19282218923285332, 0.2132120615257027, 0.07695999331917391, 0.12251018889570364, 0.1667652778029537, 0.12432910934506691, 0.2202938530778491, 0.249146553170025, 0.221389860583026, 0.19372370398566696, 0.2487939292909941, 0.23979504631939497, 0.24532829776648446, 0.25432624447324415, 0.19472830837434318, 0.24219881005146227, 0.26189719245243037, 0.18448051547770639, 0.17468878914101627, 0.18395568376934512, 0.17488007567091501, 0.17882141951123653, 0.19775323318389426, 0.19207684437663652, 0.22959348726832562, 0.1794379847130647, 0.19267635549346596, 0.16946310962496902, 0.1377075278610882, 0.8931085489049351, 0.1496448581999582, 0.18003469851315657, 0.9494809609981056, 0.137700865877581, 0.11539478923582702, 0.1549314195631103, 0.2349096576293287, 0.11320992648273964, 0.8162344498419565, 0.15624668868285552, 0.21506084752350574, 0.21184400020219019, 0.21514465076694422, 0.40964428940172926, 0.4045920155758719, 0.2135005473894397, 0.19231303955633416, 0.22708156508993327, 0.21994334267773308, 0.2335916789274458, 0.22861718934565456, 0.19866634654075754, 0.20373793242846439, 0.2351299485074123, 0.1304156092701242, 0.1308073736605584, 0.07850448827271661, 0.09096848875607066, 0.07132160943942778, 0.11282617441143483, 0.06666231360353436, 0.05834872767030119, 0.09050967970018431]}, "mutation_prompt": null}
{"id": "bc5f5b36-b6c0-4e30-9bc1-307f54b937d6", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget  # Introduced adaptive learning rate\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        # Incorporating Lvy flight for perturbation\n        levy_flight = np.random.standard_cauchy(size=self.dim) * perturbation_radius\n        candidates = [\n            np.clip(current_best + levy_flight, self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance exploration by incorporating a Lvy flight perturbation for candidate generation.", "configspace": "", "generation": 54, "fitness": 0.17843099721176878, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "b5aa20fa-efb1-4450-90e3-a7cb7b8644c3", "metadata": {"aucs": [0.41825651320482304, 0.4395500079575311, 0.4405386865561377, 0.4367012731494797, 0.4807617332926577, 0.41793410810576326, 0.44767922813463024, 0.4631701674779293, 0.5261830900301028, 9.999999999998899e-05, 0.0034338444193071638, 9.999999999998899e-05, 0.004596359108987258, 9.999999999998899e-05, 9.999999999998899e-05, 0.017610517716389995, 0.0009591468480907306, 9.999999999998899e-05, 0.07022197120746354, 0.10355323975392638, 0.07423489213772105, 0.09492301116564272, 0.07058894181079944, 0.08842158556584667, 0.08226304393071093, 0.09012000716592827, 0.07054732077752035, 0.06963345548837119, 0.0713816691854472, 0.09802255639530577, 0.062396529078281304, 0.11788219606185923, 0.09939282485421463, 0.06061774142539322, 0.0645457305908762, 0.05000775733111329, 0.9483486543127029, 0.9683675082686286, 0.94420189466966, 0.9484731030864075, 0.9548307551557726, 0.9948902528238318, 0.9801217416859174, 0.983983676720237, 0.9576167303430559, 0.2509925128809366, 0.21131747131388123, 0.2606007077006126, 0.22133068487841479, 0.2550080646157379, 0.23076710135574086, 0.20499140834886842, 0.2448058153967908, 0.18819274956716203, 0.21228815765279552, 0.10035148338756683, 0.13561565206339132, 0.23886490853089448, 0.1935667392850171, 0.19083131290342292, 0.21217363722824356, 0.14498208416361535, 0.13298351208783066, 0.177794057992413, 0.13313804705257082, 0.11777477467987196, 0.12765254101855428, 0.12495461951232867, 0.17611966673035517, 0.09109986214912225, 0.18933782559607015, 0.07404514363772596, 0.1253017392233654, 0.11877426821888237, 0.09393597607698212, 0.13607182535108042, 0.08775990092430619, 0.16116827900163155, 0.12855514111474786, 0.20892660713783007, 0.12479082003356545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008421672480668496, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01113090853276355, 0.007608821742280947, 0.027572449252096343, 0.016361077134247393, 0.05816030849412468, 0.03692996847818664, 0.011103439706741658, 0.03081689673609911, 0.03995673985810333, 0.03774706466657096, 0.008064835468414855, 0.004081886143439073, 0.010897336323362983, 0.011012955653525003, 0.027040208684306677, 0.0035913635933848553, 0.014057718355372506, 0.00922670012051674, 0.006631035585267231, 0.09707932354441962, 0.06605279859628221, 0.06594501666302299, 0.03550593135421354, 0.05242724898303608, 0.0731406404574384, 0.06117285764477587, 0.10965975999783473, 0.11022321003812052, 0.3787553741436651, 0.3726324792498312, 0.33373691642756553, 0.37698118020813887, 0.39215130511278995, 0.3847849516295031, 0.3816457957550581, 0.36313949055770456, 0.41257806049878665, 0.06936760924692831, 0.04152559385816712, 0.08851218429155339, 0.0724102984793159, 0.054692037144113415, 0.0747188004491336, 0.07164037018411673, 0.06707169680218794, 0.05139800509239345, 0.1378175323523534, 0.1842614681755823, 0.1657615969893177, 0.1986343303225775, 0.15149030326977386, 0.13133059716573026, 0.18923469755765043, 0.1613192057573427, 0.1180747807915532, 0.29685705439386123, 0.23260579889960487, 0.17220708465720203, 0.20269860858577227, 0.22399123498002205, 0.19733637407639693, 0.1601859953567637, 0.21479201087308908, 0.17602462860327228, 0.17012795441442252, 0.11076364560669427, 0.10848996708586855, 0.09528045361018322, 0.09289125476329918, 0.1282803723925936, 0.1329476141362428, 0.13093410362404556, 0.149969926894841, 0.1800945693654672, 0.1374360344987926, 0.18401146927081224, 0.2084664514956147, 0.15737891041504048, 0.16611081536666783, 0.20941874806495442, 0.16019604328714154, 0.16243676648404526, 0.19730881701282588, 0.16400240057841475, 0.18973794970651414, 0.20239534606649212, 0.1668185642317458, 0.17714667712629817, 0.1827468218657189, 0.16848947077859444, 0.17227212214862897, 0.18375876750013231, 0.16444385918961002, 0.15114203601052745, 0.16260120709785097, 0.1341135647607462, 0.5004267191466903, 0.11297897957739789, 0.12320595515324606, 0.18580231965447347, 0.1492721282084991, 0.11162090747154685, 0.15037210621866504, 0.20025973006989517, 0.24364063826827242, 0.22402776641397837, 0.15380688126191766, 0.3167875487535664, 0.20742522042820388, 0.16652661128804824, 0.18704163573424804, 0.18411478060374553, 0.1882532523951882, 0.17307751256208448, 0.17500914651091248, 0.16450261092655805, 0.18402626652259002, 0.1838411203820498, 0.05200810079330698, 0.05192569947680514, 0.0781314453604588, 0.0650512773602473, 0.06296914960558953, 0.06034046221066347, 0.0999169347708192, 0.047280822971387915, 0.04380427598853853]}, "mutation_prompt": null}
{"id": "408eeede-50f6-4965-932f-049649df8f85", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        # Change: Adjust candidate pool size based on success rate\n        num_candidates = min(self.budget - len(self.history), max(5, int(5 + 10 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget  # Introduced adaptive learning rate\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce dynamic candidate pool size based on success rate to better adjust between exploration and exploitation.", "configspace": "", "generation": 55, "fitness": 0.24162209386882136, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "b5aa20fa-efb1-4450-90e3-a7cb7b8644c3", "metadata": {"aucs": [0.7159521210236297, 0.7224652533736807, 0.6805831169017413, 0.6475084710972305, 0.6983914314641225, 0.6798417992864074, 0.7109372129241054, 0.6747969296668099, 0.7442352212647033, 0.008315856834636204, 0.0014442623681157896, 9.999999999998899e-05, 0.08009344853188727, 0.06948000650527542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1232947078241845, 0.07109031527862264, 0.06936576791812477, 0.11375501390234188, 0.09323069804325546, 0.04330918558469765, 0.09383546314755387, 0.09985548410657197, 0.0937664299473896, 0.11177799329952354, 0.045883517820945574, 0.032896641783416114, 0.04825411712995864, 0.07889656827628733, 0.04047883021459597, 0.08757421673700427, 0.0931153348688013, 0.0580434011605947, 0.9851065137485586, 0.956890320936252, 0.9789159489815876, 0.9637532762917318, 0.9535601706035732, 0.9864632418812398, 0.9729113823261551, 0.9766243383799642, 0.9791340572240674, 0.43839025728973935, 0.4407840088426488, 0.4270329218050941, 0.4823098848827636, 0.40391460417445924, 0.508445080154295, 0.4445181687462396, 0.4345678191986071, 0.4067093297511215, 0.19756137324067236, 0.1658656946735555, 0.6805532285726879, 0.8506678734209588, 0.21948716212065467, 0.2104933491473009, 0.23806042175019193, 0.2017921227942321, 0.42594176563997843, 0.2021035319866502, 0.17815367861241915, 0.19244257273099707, 0.1885769304246575, 0.17126926042198798, 0.1416311982420857, 0.13140756532959108, 0.12486150424951414, 0.13327311391789642, 0.194079634850718, 0.16644051531737314, 0.17040249427502385, 0.1308965469992872, 0.21211054120851347, 0.15362990465365334, 0.20020521118569712, 0.17509468381225957, 0.12881506223514694, 9.999999999998899e-05, 9.999999999998899e-05, 0.05636705882895443, 0.01773246679720264, 0.0035104127946573582, 0.014375692407752272, 0.0004863179578012966, 9.999999999998899e-05, 0.012105062382005038, 0.05043825331050411, 0.053753528751360524, 0.13853700878898723, 0.1336668869673895, 0.04798875740453845, 0.03473526462493659, 0.14438857281461948, 0.046151672320198456, 0.06566174062131813, 0.1400108809816335, 0.030458304957578508, 0.09941133698655125, 0.13827130978656665, 0.15889004093429981, 0.08256096056276963, 0.10108155635687488, 0.144459986338333, 0.13181828962760633, 0.130681312170847, 0.09963359185346599, 0.15626402038754927, 0.06649634707929797, 0.1243850791736062, 0.10365802348661568, 0.06688841692300995, 0.058468218924767834, 0.2084310890644301, 0.5005882820552531, 0.49017925781608884, 0.493219240719297, 0.4603055709967513, 0.5021108472156042, 0.49584616769549017, 0.47884976388675127, 0.49962207087125166, 0.49833158874024586, 0.0951738180004379, 0.08278827690470392, 0.06586353917156029, 0.08359016647670925, 0.12392828920429788, 0.09380709006313026, 0.16539601524960212, 0.07011882230313926, 0.06678164457834102, 0.19405352542719134, 0.19490591213029662, 0.2785143467624257, 0.22955397368122865, 0.1841217437899456, 0.1970531662612015, 0.1833601366768044, 0.1908114502343098, 0.2782819469445317, 0.3112877066505553, 0.2538062369199918, 0.2282449984724999, 0.2696624301333731, 0.2360205543711369, 0.1849202358749189, 0.2940987315828947, 0.2718552502429149, 0.1332128287888361, 0.23526441656993313, 0.2805998243904614, 0.34811022107185696, 0.25637462145960555, 0.21953180463641042, 0.1448046694846813, 0.20163279828585912, 0.1162867677630196, 0.16827358461768294, 0.20364556450061078, 0.19418831495874722, 0.20988795902466062, 0.17591885436898358, 0.1905525373517798, 0.20386304999014204, 0.2113099655507633, 0.22989229926683197, 0.18463060998721625, 0.18701726634220905, 0.18453600458906994, 0.18846341641074937, 0.22249622204291486, 0.18879702310206226, 0.18339367073595114, 0.21212152898636172, 0.2001540698938311, 0.18888329091103173, 0.18923772692116625, 0.1373826507867143, 0.9336487396921271, 0.14887602660969823, 0.17904612926724894, 0.1316631275499276, 0.10874691037873885, 0.11536629561482026, 0.15493740764233555, 0.563107822650365, 0.11358991645418337, 0.6562483447631002, 0.15625816931740188, 0.1051221258956031, 0.21290233753797816, 0.489758064540321, 0.16867337696566498, 0.20823476943198582, 0.21638337244497519, 0.214268036394473, 0.21179194589317407, 0.22807781526035276, 0.21873411745545068, 0.1889031056664343, 0.24340869027665502, 0.22728795939487623, 0.21301988449279963, 0.08554339373980435, 0.09430290309156553, 0.09447046361113465, 0.13423459595797227, 0.058502553496406096, 0.13277675465770444, 0.14189117373964488, 0.09999926440792972, 0.08219577279149248]}, "mutation_prompt": null}
{"id": "cdd5ae29-0553-47e1-8fa9-fbb5fecce1ff", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget  # Introduced adaptive learning rate\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce an adaptive learning rate based on evaluation progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b5aa20fa-efb1-4450-90e3-a7cb7b8644c3", "metadata": {"aucs": [0.6859176338236574, 0.7531935814119854, 0.7005487770133259, 0.713009147783566, 0.7172012803667704, 0.693325905341789, 0.7869260353927944, 0.713580302788196, 0.6880799640793143, 0.018918703428808303, 9.999999999998899e-05, 9.999999999998899e-05, 0.09388525657127045, 9.999999999998899e-05, 9.999999999998899e-05, 0.047459070977771245, 9.999999999998899e-05, 9.999999999998899e-05, 0.08779743137524532, 0.08609363997040387, 0.1284415191770586, 0.08786737604143402, 0.1280211584746388, 0.07314489792854661, 0.07216022284668344, 0.11910178016354311, 0.07430304726290415, 0.07530483974988433, 0.04602551986441428, 0.04572265958595778, 0.06710484025283436, 0.0821410158336574, 0.09413841538867507, 0.08564961580224151, 0.07201689149108259, 0.07003911211142766, 0.960904572543334, 0.9828331719625271, 0.9846160025387711, 0.9595259921456072, 0.979694715964495, 0.9869148976233232, 0.9782211534745356, 0.9942050911319325, 0.9700775641115388, 0.46293595102942187, 0.4537680709993186, 0.4759798704257888, 0.48378245900026007, 0.5153532517962078, 0.4922549352626112, 0.4876743047093539, 0.5134894602212589, 0.4347931340366735, 0.1592200137520875, 0.15197036417786092, 0.7889827539163949, 0.3894537110845183, 0.1923597274736638, 0.28243435839898967, 0.3265376231054953, 0.225505509102766, 0.17049767562437124, 0.14971681363433398, 0.20957613731672953, 0.18021788827897778, 0.14920355777879923, 0.200072138699964, 0.13306398220808258, 0.1189867283788888, 0.22013604821299582, 0.1341922933084183, 0.18268090717267704, 0.12490215827163464, 0.12678152363000805, 0.25539265676429157, 0.13650893837264444, 0.22331755217507043, 0.16963099723424058, 0.1669321805220072, 0.13213021387262291, 0.0003828573865828355, 0.03769515584015193, 0.00016437813239444932, 0.0008848923496372896, 0.020793724519173162, 0.12682954032431548, 9.999999999998899e-05, 0.00016653233596131134, 0.011884944641972095, 0.05828551067343268, 0.08470556213423919, 0.15491351707176348, 0.11077256877634778, 0.07044415578932417, 0.010789238558413072, 0.1639480232655789, 0.04762025550326565, 0.08947295756790008, 0.05398832552043753, 0.042286078007033434, 0.10220200300698312, 0.21249451155400556, 0.07434555641305973, 0.1729227704754459, 0.11202890909283836, 0.10108385757817828, 0.15438128729526013, 0.0911399210423629, 0.14301541148005492, 0.21278202124110812, 0.09722118448499062, 0.23359680194753651, 0.0398465953494439, 0.09592394207969623, 0.10773824583687142, 0.22251743534976998, 0.5046663318702491, 0.4833839046817707, 0.522190202578074, 0.49784752271247223, 0.5180784553620286, 0.4894341366473808, 0.49999320187155605, 0.501117729392335, 0.5116574868822552, 0.08331127474515665, 0.11840347125732842, 0.10569849931722819, 0.18746379515828138, 0.12627159482947503, 0.08474409900193003, 0.09483638795373495, 0.06620334737216349, 0.13155505506236298, 0.17962295707510167, 0.22765008828094857, 0.2548930711073151, 0.192223368753337, 0.16595734987590882, 0.1520234965009637, 0.189599380874786, 0.3563711369413818, 0.2013406415590181, 0.2881742314632365, 0.24457515841388433, 0.15755939667558028, 0.33300317095588716, 0.22205666021850012, 0.17288953256437867, 0.19116596702812605, 0.23293285238395312, 0.2845043647542488, 0.19282218923285332, 0.2132120615257027, 0.07695999331917391, 0.12251018889570364, 0.1667652778029537, 0.12432910934506691, 0.2202938530778491, 0.249146553170025, 0.221389860583026, 0.19372370398566696, 0.2487939292909941, 0.23979504631939497, 0.24532829776648446, 0.25432624447324415, 0.19472830837434318, 0.24219881005146227, 0.26189719245243037, 0.18448051547770639, 0.17468878914101627, 0.18395568376934512, 0.17488007567091501, 0.17882141951123653, 0.19775323318389426, 0.19207684437663652, 0.22959348726832562, 0.1794379847130647, 0.19267635549346596, 0.16946310962496902, 0.1377075278610882, 0.8931085489049351, 0.1496448581999582, 0.18003469851315657, 0.9494809609981056, 0.137700865877581, 0.11539478923582702, 0.1549314195631103, 0.2349096576293287, 0.11320992648273964, 0.8162344498419565, 0.15624668868285552, 0.21506084752350574, 0.21184400020219019, 0.21514465076694422, 0.40964428940172926, 0.4045920155758719, 0.2135005473894397, 0.19231303955633416, 0.22708156508993327, 0.21994334267773308, 0.2335916789274458, 0.22861718934565456, 0.19866634654075754, 0.20373793242846439, 0.2351299485074123, 0.1304156092701242, 0.1308073736605584, 0.07850448827271661, 0.09096848875607066, 0.07132160943942778, 0.11282617441143483, 0.06666231360353436, 0.05834872767030119, 0.09050967970018431]}, "mutation_prompt": null}
{"id": "6f726b62-4ef9-48d6-862a-3ceab9f18064", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget  # Introduced adaptive learning rate\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget))\n        # Use Lvy flight for perturbation\n        levy_flight = np.random.standard_cauchy(self.dim) * perturbation_radius\n        candidates = [\n            np.clip(current_best + np.random.uniform(-levy_flight, levy_flight, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance the candidate generation process by incorporating a Lvy flight mechanism for robust exploration.", "configspace": "", "generation": 57, "fitness": 0.23889065872709137, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "b5aa20fa-efb1-4450-90e3-a7cb7b8644c3", "metadata": {"aucs": [0.6829051141998645, 0.6606375073942814, 0.6801161318429766, 0.6565877011470008, 0.6332890405694125, 0.6692881932261963, 0.7026562662615352, 0.6624491492294264, 0.7092020302423633, 0.1192361913197234, 0.07450493039139405, 0.1158407332743494, 0.13857897358182836, 0.08026218171373911, 0.15391576167331134, 0.10367018202567435, 0.08723206873448996, 0.05919727091769833, 0.10986941420575658, 0.18802235292508396, 0.14485880498912718, 0.13492864761872259, 0.11250595168814759, 0.13329650241579583, 0.13553457948412673, 0.12541621928922309, 0.13934384553727652, 0.10655683933554805, 0.12816588022948183, 0.13333106547996454, 0.10330002141246153, 0.09725278346713517, 0.10901875018004048, 0.11308860556882627, 0.1017316172902103, 0.12924174023834656, 0.9927682559898116, 0.991650593596242, 0.9961289947904024, 0.9909359298686983, 0.9926929650461587, 0.9922931413328128, 0.9873940647214448, 0.9850906105142767, 0.9911306603101484, 0.403277756355658, 0.41759926263426916, 0.39493131707906115, 0.49149806146517383, 0.4758894129734016, 0.48101100520263473, 0.47926332550544315, 0.3653633430624069, 0.36910064022887623, 0.27515263698123915, 0.15070126176346965, 0.17946439024574634, 0.2799514375861607, 0.21220597508659944, 0.1976140781471023, 0.5443902068959585, 0.13564511922016298, 0.20174002395358015, 0.18235595734975063, 0.20288066608346755, 0.15729154919691613, 0.14309389863951671, 0.1582271090269507, 0.1706679980342869, 0.15994789490789918, 0.207872468422429, 0.1340566579878718, 0.27693005724861564, 0.16626602575540406, 0.12424466925461397, 0.15414172656112057, 0.15586329048544645, 0.13661881913141405, 0.1340839855982927, 0.10717005165014448, 0.20473287336109858, 0.007561563607457855, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004297276038072728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08786521106189882, 0.056230470643621966, 0.09252987343162711, 0.10932571750458697, 0.04425936231062588, 0.05656263568239306, 0.0740352466044305, 0.04606405321660456, 0.04064299639214608, 0.0945831831962527, 0.06534021882270313, 0.04901453986487192, 0.07347397972417713, 0.1825838143044266, 0.19403483368106877, 0.08855487529924666, 0.12482727592701792, 0.06168181538282824, 0.06685755042178076, 0.12485499934537203, 0.057649415539020255, 0.1552482202641079, 0.06497181853636358, 0.03129638196907558, 0.12657653586953788, 0.06299379021135687, 0.09665912273175525, 0.4580087073671377, 0.5338575093810478, 0.47703675743179463, 0.4813038639226792, 0.491155210797249, 0.46867555101466285, 0.46516214315860027, 0.49868235415955686, 0.46558560055377807, 0.11489795403284953, 0.07060543849505485, 0.09993968529657982, 0.12921964822780463, 0.09602361255759462, 0.11194005972174059, 0.06505125776787624, 0.0838079996473351, 0.0669180881981365, 0.2243943911551055, 0.2493481524181611, 0.19262036656847803, 0.17288502506956815, 0.20858084370452723, 0.20939042246661188, 0.19692843279779115, 0.3924836451563114, 0.1624848838102283, 0.33771287799360705, 0.22517620004995187, 0.16383972895375665, 0.22260618818634037, 0.20201474393604235, 0.23196210060016142, 0.3043850157175919, 0.18654861218284646, 0.13962450699201323, 0.20909455707267643, 0.24331455039432603, 0.09393716392712359, 0.10872430804941635, 0.21695501464834976, 0.08531559491325302, 0.16245972056809332, 0.1433269583815303, 0.15027990588691986, 0.23289536353911355, 0.2061641872355513, 0.20459986735024127, 0.25221278943207504, 0.1805992289353655, 0.253395408647595, 0.19107424606796863, 0.20734348155452986, 0.24020548523453678, 0.1926970617665582, 0.20999480771909407, 0.20328784519221532, 0.18526651086124024, 0.22736326197968415, 0.20668650321329862, 0.19691542548881913, 0.21786387055366196, 0.20312675756036924, 0.16883400954398053, 0.13655292476518277, 0.1309150312087839, 0.4884843640347831, 0.15578145071936833, 0.39725915036443493, 0.841142935727491, 0.12713325397033914, 0.1338475639426211, 0.32196019670748355, 0.1955422995579874, 0.3707457768811656, 0.15683273046379942, 0.2095647401594296, 0.12817109039683205, 0.41788199942971516, 0.16872779758297474, 0.3515299262779056, 0.20866080024727984, 0.20591788426272983, 0.2186520187249631, 0.21380816793618584, 0.25396236628356295, 0.1850154338323442, 0.20875407153400105, 0.22004472256929297, 0.23816779615680184, 0.07039958933848978, 0.08039311926970061, 0.0801880490742446, 0.09673798804398082, 0.09364288191895098, 0.1265625757723874, 0.07431673841228803, 0.0816973477159445, 0.08895604062297824]}, "mutation_prompt": null}
{"id": "40496fe9-eaf1-40c0-89a7-5b1d45e63835", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius and introduce a temperature-like parameter\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a temperature-inspired mechanism to gradually reduce the perturbation radius, enhancing convergence by increasing focus over time.", "configspace": "", "generation": 58, "fitness": 0.24872144748138675, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "b5aa20fa-efb1-4450-90e3-a7cb7b8644c3", "metadata": {"aucs": [0.7819622921464807, 0.8020927858159081, 0.7444708289449926, 0.7658230126515307, 0.7926758998834855, 0.7660972510852704, 0.7353425145480823, 0.7283202800878401, 0.7693594875285964, 0.018029096456463445, 9.999999999998899e-05, 9.999999999998899e-05, 0.0792764943065215, 9.999999999998899e-05, 9.999999999998899e-05, 0.09086188293561204, 9.999999999998899e-05, 9.999999999998899e-05, 0.08790649849679155, 0.07698705563365615, 0.058645549106340567, 0.0634785427438157, 0.12764001671189618, 0.07319165106190917, 0.097530385918711, 0.1478832653826062, 0.0849913025360578, 0.12021835889370358, 0.04310449082681189, 0.015900317938043917, 0.08348068441718548, 0.11837363546941992, 0.05633600717213416, 0.040301933569205306, 0.07357882133997684, 0.04981528571310412, 0.9620333475205692, 0.9828264189893856, 0.9846110640900507, 0.9593362004909587, 0.9796906192241269, 0.9869039801700883, 0.9781752999835777, 0.9942045096487431, 0.9700540605899397, 0.5570783060885207, 0.5205523554406195, 0.49099504775683855, 0.524635561242329, 0.5472480988769135, 0.5126511197811898, 0.533988931846916, 0.4937911770486959, 0.4837138754321568, 0.1706119682848517, 0.20111020243346434, 0.23172645706991146, 0.3912733251237639, 0.1895433780403346, 0.25761131253199265, 0.37340879348203015, 0.23315855314382683, 0.1679211966019888, 0.1949726643445241, 0.23064665379238236, 0.19865444834495816, 0.2157313407181285, 0.2192653496653728, 0.1353756582959239, 0.12039837189714431, 0.22548621164348936, 0.13699600966255476, 0.19788314167182952, 0.1270321458094782, 0.12640631741857178, 0.25320200002133797, 0.13560304911946952, 0.17366188510320368, 0.19203305425734352, 0.1987914113577267, 0.1314724319327777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003146618320618133, 0.00984872791964031, 0.035129138869040455, 0.003105207479277672, 9.999999999998899e-05, 0.08592760633409291, 0.07720847984341239, 0.07799368368276394, 0.16819857917806313, 0.1150932764754029, 0.07840448763512808, 0.013575667721657192, 0.14131108196972886, 0.06076849090375058, 0.08404312875579567, 0.07713972581801576, 0.04139957354053492, 0.1062259890535926, 0.25895663504761024, 0.09627947092657996, 0.17079696705434622, 0.12366569517790027, 0.13116222888874107, 0.18716588943990264, 0.08405536908863431, 0.1541312075024811, 0.1846693271945843, 0.11407326955274277, 0.14524235880103642, 0.03831087053197757, 0.08732828511839108, 0.09992908689643953, 0.20202319204902264, 0.514430123223905, 0.4928006197560578, 0.5226724028445324, 0.5564098765308125, 0.5154647449922021, 0.47990760488214657, 0.5085414210175822, 0.4773853938036424, 0.5030142835280023, 0.07138833888995866, 0.0928363422568036, 0.06552725468273424, 0.14668453001415205, 0.07629254676450614, 0.07140660328169068, 0.1339680122670286, 0.0747820068122903, 0.11222450208682244, 0.2218717574808604, 0.19006121164369727, 0.24706737348474983, 0.34459703873267244, 0.17596914062934754, 0.1576942118648058, 0.2180509801689292, 0.1784526115814199, 0.34644886813818443, 0.28574742994757407, 0.2516068278077199, 0.15219299390998875, 0.1732929755852317, 0.2203658441029488, 0.17398244472368318, 0.1764737879298689, 0.3289767173170014, 0.351390740023486, 0.26882034590239645, 0.14390035470028273, 0.08575549866793697, 0.23085568913029242, 0.13377114260620548, 0.17288598133695554, 0.1898591700010246, 0.24390689905716656, 0.11586233953769931, 0.1761117357884936, 0.19754642897422992, 0.17545198217657854, 0.22642067053554815, 0.19484015019926337, 0.23944103268065597, 0.23810023804721325, 0.22189819223194807, 0.24920011465345893, 0.1771583846294903, 0.1716078396759867, 0.21121776623869326, 0.1726853898604993, 0.1913071325852176, 0.17767111710034555, 0.23046385175439676, 0.17940458451290686, 0.1807672004388603, 0.16946917033059072, 0.1375707924457552, 0.9089648828342424, 0.1496454937324957, 0.18005232435639895, 0.9550185301784742, 0.13770481014834945, 0.14006439725262265, 0.15502194514489565, 0.1284977722702817, 0.11315203900533599, 0.7430753888055519, 0.15641591067149252, 0.21508729788891712, 0.21163226612007502, 0.21516590412651893, 0.20389057685470668, 0.45362884372522383, 0.21843927876916913, 0.19025132657403376, 0.22647573717618386, 0.21148985206173276, 0.21985427866523155, 0.20807333418792218, 0.28399550960292996, 0.2330535022259167, 0.20247060909618597, 0.13245322963509298, 0.10179470331762008, 0.0965651559909444, 0.14844660755206007, 0.07924787276941847, 0.1425508293459028, 0.05393455325467733, 0.06579743029790663, 0.08453745175082694]}, "mutation_prompt": null}
{"id": "22e33bec-992b-4c36-8c94-a3890368cb44", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius and introduce a temperature-like parameter\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        # Change: Adjust candidate count based on recent success rate\n        if self.calculate_adaptation() > 0.8:\n            num_candidates += 1\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance convergence by dynamically adjusting candidate generation based on historical improvement trends.", "configspace": "", "generation": 59, "fitness": 0.24872144748138675, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "40496fe9-eaf1-40c0-89a7-5b1d45e63835", "metadata": {"aucs": [0.7819622921464807, 0.8020927858159081, 0.7444708289449926, 0.7658230126515307, 0.7926758998834855, 0.7660972510852704, 0.7353425145480823, 0.7283202800878401, 0.7693594875285964, 0.018029096456463445, 9.999999999998899e-05, 9.999999999998899e-05, 0.0792764943065215, 9.999999999998899e-05, 9.999999999998899e-05, 0.09086188293561204, 9.999999999998899e-05, 9.999999999998899e-05, 0.08790649849679155, 0.07698705563365615, 0.058645549106340567, 0.0634785427438157, 0.12764001671189618, 0.07319165106190917, 0.097530385918711, 0.1478832653826062, 0.0849913025360578, 0.12021835889370358, 0.04310449082681189, 0.015900317938043917, 0.08348068441718548, 0.11837363546941992, 0.05633600717213416, 0.040301933569205306, 0.07357882133997684, 0.04981528571310412, 0.9620333475205692, 0.9828264189893856, 0.9846110640900507, 0.9593362004909587, 0.9796906192241269, 0.9869039801700883, 0.9781752999835777, 0.9942045096487431, 0.9700540605899397, 0.5570783060885207, 0.5205523554406195, 0.49099504775683855, 0.524635561242329, 0.5472480988769135, 0.5126511197811898, 0.533988931846916, 0.4937911770486959, 0.4837138754321568, 0.1706119682848517, 0.20111020243346434, 0.23172645706991146, 0.3912733251237639, 0.1895433780403346, 0.25761131253199265, 0.37340879348203015, 0.23315855314382683, 0.1679211966019888, 0.1949726643445241, 0.23064665379238236, 0.19865444834495816, 0.2157313407181285, 0.2192653496653728, 0.1353756582959239, 0.12039837189714431, 0.22548621164348936, 0.13699600966255476, 0.19788314167182952, 0.1270321458094782, 0.12640631741857178, 0.25320200002133797, 0.13560304911946952, 0.17366188510320368, 0.19203305425734352, 0.1987914113577267, 0.1314724319327777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003146618320618133, 0.00984872791964031, 0.035129138869040455, 0.003105207479277672, 9.999999999998899e-05, 0.08592760633409291, 0.07720847984341239, 0.07799368368276394, 0.16819857917806313, 0.1150932764754029, 0.07840448763512808, 0.013575667721657192, 0.14131108196972886, 0.06076849090375058, 0.08404312875579567, 0.07713972581801576, 0.04139957354053492, 0.1062259890535926, 0.25895663504761024, 0.09627947092657996, 0.17079696705434622, 0.12366569517790027, 0.13116222888874107, 0.18716588943990264, 0.08405536908863431, 0.1541312075024811, 0.1846693271945843, 0.11407326955274277, 0.14524235880103642, 0.03831087053197757, 0.08732828511839108, 0.09992908689643953, 0.20202319204902264, 0.514430123223905, 0.4928006197560578, 0.5226724028445324, 0.5564098765308125, 0.5154647449922021, 0.47990760488214657, 0.5085414210175822, 0.4773853938036424, 0.5030142835280023, 0.07138833888995866, 0.0928363422568036, 0.06552725468273424, 0.14668453001415205, 0.07629254676450614, 0.07140660328169068, 0.1339680122670286, 0.0747820068122903, 0.11222450208682244, 0.2218717574808604, 0.19006121164369727, 0.24706737348474983, 0.34459703873267244, 0.17596914062934754, 0.1576942118648058, 0.2180509801689292, 0.1784526115814199, 0.34644886813818443, 0.28574742994757407, 0.2516068278077199, 0.15219299390998875, 0.1732929755852317, 0.2203658441029488, 0.17398244472368318, 0.1764737879298689, 0.3289767173170014, 0.351390740023486, 0.26882034590239645, 0.14390035470028273, 0.08575549866793697, 0.23085568913029242, 0.13377114260620548, 0.17288598133695554, 0.1898591700010246, 0.24390689905716656, 0.11586233953769931, 0.1761117357884936, 0.19754642897422992, 0.17545198217657854, 0.22642067053554815, 0.19484015019926337, 0.23944103268065597, 0.23810023804721325, 0.22189819223194807, 0.24920011465345893, 0.1771583846294903, 0.1716078396759867, 0.21121776623869326, 0.1726853898604993, 0.1913071325852176, 0.17767111710034555, 0.23046385175439676, 0.17940458451290686, 0.1807672004388603, 0.16946917033059072, 0.1375707924457552, 0.9089648828342424, 0.1496454937324957, 0.18005232435639895, 0.9550185301784742, 0.13770481014834945, 0.14006439725262265, 0.15502194514489565, 0.1284977722702817, 0.11315203900533599, 0.7430753888055519, 0.15641591067149252, 0.21508729788891712, 0.21163226612007502, 0.21516590412651893, 0.20389057685470668, 0.45362884372522383, 0.21843927876916913, 0.19025132657403376, 0.22647573717618386, 0.21148985206173276, 0.21985427866523155, 0.20807333418792218, 0.28399550960292996, 0.2330535022259167, 0.20247060909618597, 0.13245322963509298, 0.10179470331762008, 0.0965651559909444, 0.14844660755206007, 0.07924787276941847, 0.1425508293459028, 0.05393455325467733, 0.06579743029790663, 0.08453745175082694]}, "mutation_prompt": null}
{"id": "2b2f14db-2a39-4ca4-ad0a-c49b0b3d8a1b", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius and introduce a temperature-like parameter\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a temperature-inspired mechanism to gradually reduce the perturbation radius, enhancing convergence by increasing focus over time.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40496fe9-eaf1-40c0-89a7-5b1d45e63835", "metadata": {"aucs": [0.7819622921464807, 0.8020927858159081, 0.7444708289449926, 0.7658230126515307, 0.7926758998834855, 0.7660972510852704, 0.7353425145480823, 0.7283202800878401, 0.7693594875285964, 0.018029096456463445, 9.999999999998899e-05, 9.999999999998899e-05, 0.0792764943065215, 9.999999999998899e-05, 9.999999999998899e-05, 0.09086188293561204, 9.999999999998899e-05, 9.999999999998899e-05, 0.08790649849679155, 0.07698705563365615, 0.058645549106340567, 0.0634785427438157, 0.12764001671189618, 0.07319165106190917, 0.097530385918711, 0.1478832653826062, 0.0849913025360578, 0.12021835889370358, 0.04310449082681189, 0.015900317938043917, 0.08348068441718548, 0.11837363546941992, 0.05633600717213416, 0.040301933569205306, 0.07357882133997684, 0.04981528571310412, 0.9620333475205692, 0.9828264189893856, 0.9846110640900507, 0.9593362004909587, 0.9796906192241269, 0.9869039801700883, 0.9781752999835777, 0.9942045096487431, 0.9700540605899397, 0.5570783060885207, 0.5205523554406195, 0.49099504775683855, 0.524635561242329, 0.5472480988769135, 0.5126511197811898, 0.533988931846916, 0.4937911770486959, 0.4837138754321568, 0.1706119682848517, 0.20111020243346434, 0.23172645706991146, 0.3912733251237639, 0.1895433780403346, 0.25761131253199265, 0.37340879348203015, 0.23315855314382683, 0.1679211966019888, 0.1949726643445241, 0.23064665379238236, 0.19865444834495816, 0.2157313407181285, 0.2192653496653728, 0.1353756582959239, 0.12039837189714431, 0.22548621164348936, 0.13699600966255476, 0.19788314167182952, 0.1270321458094782, 0.12640631741857178, 0.25320200002133797, 0.13560304911946952, 0.17366188510320368, 0.19203305425734352, 0.1987914113577267, 0.1314724319327777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003146618320618133, 0.00984872791964031, 0.035129138869040455, 0.003105207479277672, 9.999999999998899e-05, 0.08592760633409291, 0.07720847984341239, 0.07799368368276394, 0.16819857917806313, 0.1150932764754029, 0.07840448763512808, 0.013575667721657192, 0.14131108196972886, 0.06076849090375058, 0.08404312875579567, 0.07713972581801576, 0.04139957354053492, 0.1062259890535926, 0.25895663504761024, 0.09627947092657996, 0.17079696705434622, 0.12366569517790027, 0.13116222888874107, 0.18716588943990264, 0.08405536908863431, 0.1541312075024811, 0.1846693271945843, 0.11407326955274277, 0.14524235880103642, 0.03831087053197757, 0.08732828511839108, 0.09992908689643953, 0.20202319204902264, 0.514430123223905, 0.4928006197560578, 0.5226724028445324, 0.5564098765308125, 0.5154647449922021, 0.47990760488214657, 0.5085414210175822, 0.4773853938036424, 0.5030142835280023, 0.07138833888995866, 0.0928363422568036, 0.06552725468273424, 0.14668453001415205, 0.07629254676450614, 0.07140660328169068, 0.1339680122670286, 0.0747820068122903, 0.11222450208682244, 0.2218717574808604, 0.19006121164369727, 0.24706737348474983, 0.34459703873267244, 0.17596914062934754, 0.1576942118648058, 0.2180509801689292, 0.1784526115814199, 0.34644886813818443, 0.28574742994757407, 0.2516068278077199, 0.15219299390998875, 0.1732929755852317, 0.2203658441029488, 0.17398244472368318, 0.1764737879298689, 0.3289767173170014, 0.351390740023486, 0.26882034590239645, 0.14390035470028273, 0.08575549866793697, 0.23085568913029242, 0.13377114260620548, 0.17288598133695554, 0.1898591700010246, 0.24390689905716656, 0.11586233953769931, 0.1761117357884936, 0.19754642897422992, 0.17545198217657854, 0.22642067053554815, 0.19484015019926337, 0.23944103268065597, 0.23810023804721325, 0.22189819223194807, 0.24920011465345893, 0.1771583846294903, 0.1716078396759867, 0.21121776623869326, 0.1726853898604993, 0.1913071325852176, 0.17767111710034555, 0.23046385175439676, 0.17940458451290686, 0.1807672004388603, 0.16946917033059072, 0.1375707924457552, 0.9089648828342424, 0.1496454937324957, 0.18005232435639895, 0.9550185301784742, 0.13770481014834945, 0.14006439725262265, 0.15502194514489565, 0.1284977722702817, 0.11315203900533599, 0.7430753888055519, 0.15641591067149252, 0.21508729788891712, 0.21163226612007502, 0.21516590412651893, 0.20389057685470668, 0.45362884372522383, 0.21843927876916913, 0.19025132657403376, 0.22647573717618386, 0.21148985206173276, 0.21985427866523155, 0.20807333418792218, 0.28399550960292996, 0.2330535022259167, 0.20247060909618597, 0.13245322963509298, 0.10179470331762008, 0.0965651559909444, 0.14844660755206007, 0.07924787276941847, 0.1425508293459028, 0.05393455325467733, 0.06579743029790663, 0.08453745175082694]}, "mutation_prompt": null}
{"id": "44d56a20-f6d2-470b-b4ac-6b5e54367606", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius and introduce a temperature-like parameter\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a temperature-inspired mechanism to gradually reduce the perturbation radius, enhancing convergence by increasing focus over time.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40496fe9-eaf1-40c0-89a7-5b1d45e63835", "metadata": {"aucs": [0.7819622921464807, 0.8020927858159081, 0.7444708289449926, 0.7658230126515307, 0.7926758998834855, 0.7660972510852704, 0.7353425145480823, 0.7283202800878401, 0.7693594875285964, 0.018029096456463445, 9.999999999998899e-05, 9.999999999998899e-05, 0.0792764943065215, 9.999999999998899e-05, 9.999999999998899e-05, 0.09086188293561204, 9.999999999998899e-05, 9.999999999998899e-05, 0.08790649849679155, 0.07698705563365615, 0.058645549106340567, 0.0634785427438157, 0.12764001671189618, 0.07319165106190917, 0.097530385918711, 0.1478832653826062, 0.0849913025360578, 0.12021835889370358, 0.04310449082681189, 0.015900317938043917, 0.08348068441718548, 0.11837363546941992, 0.05633600717213416, 0.040301933569205306, 0.07357882133997684, 0.04981528571310412, 0.9620333475205692, 0.9828264189893856, 0.9846110640900507, 0.9593362004909587, 0.9796906192241269, 0.9869039801700883, 0.9781752999835777, 0.9942045096487431, 0.9700540605899397, 0.5570783060885207, 0.5205523554406195, 0.49099504775683855, 0.524635561242329, 0.5472480988769135, 0.5126511197811898, 0.533988931846916, 0.4937911770486959, 0.4837138754321568, 0.1706119682848517, 0.20111020243346434, 0.23172645706991146, 0.3912733251237639, 0.1895433780403346, 0.25761131253199265, 0.37340879348203015, 0.23315855314382683, 0.1679211966019888, 0.1949726643445241, 0.23064665379238236, 0.19865444834495816, 0.2157313407181285, 0.2192653496653728, 0.1353756582959239, 0.12039837189714431, 0.22548621164348936, 0.13699600966255476, 0.19788314167182952, 0.1270321458094782, 0.12640631741857178, 0.25320200002133797, 0.13560304911946952, 0.17366188510320368, 0.19203305425734352, 0.1987914113577267, 0.1314724319327777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003146618320618133, 0.00984872791964031, 0.035129138869040455, 0.003105207479277672, 9.999999999998899e-05, 0.08592760633409291, 0.07720847984341239, 0.07799368368276394, 0.16819857917806313, 0.1150932764754029, 0.07840448763512808, 0.013575667721657192, 0.14131108196972886, 0.06076849090375058, 0.08404312875579567, 0.07713972581801576, 0.04139957354053492, 0.1062259890535926, 0.25895663504761024, 0.09627947092657996, 0.17079696705434622, 0.12366569517790027, 0.13116222888874107, 0.18716588943990264, 0.08405536908863431, 0.1541312075024811, 0.1846693271945843, 0.11407326955274277, 0.14524235880103642, 0.03831087053197757, 0.08732828511839108, 0.09992908689643953, 0.20202319204902264, 0.514430123223905, 0.4928006197560578, 0.5226724028445324, 0.5564098765308125, 0.5154647449922021, 0.47990760488214657, 0.5085414210175822, 0.4773853938036424, 0.5030142835280023, 0.07138833888995866, 0.0928363422568036, 0.06552725468273424, 0.14668453001415205, 0.07629254676450614, 0.07140660328169068, 0.1339680122670286, 0.0747820068122903, 0.11222450208682244, 0.2218717574808604, 0.19006121164369727, 0.24706737348474983, 0.34459703873267244, 0.17596914062934754, 0.1576942118648058, 0.2180509801689292, 0.1784526115814199, 0.34644886813818443, 0.28574742994757407, 0.2516068278077199, 0.15219299390998875, 0.1732929755852317, 0.2203658441029488, 0.17398244472368318, 0.1764737879298689, 0.3289767173170014, 0.351390740023486, 0.26882034590239645, 0.14390035470028273, 0.08575549866793697, 0.23085568913029242, 0.13377114260620548, 0.17288598133695554, 0.1898591700010246, 0.24390689905716656, 0.11586233953769931, 0.1761117357884936, 0.19754642897422992, 0.17545198217657854, 0.22642067053554815, 0.19484015019926337, 0.23944103268065597, 0.23810023804721325, 0.22189819223194807, 0.24920011465345893, 0.1771583846294903, 0.1716078396759867, 0.21121776623869326, 0.1726853898604993, 0.1913071325852176, 0.17767111710034555, 0.23046385175439676, 0.17940458451290686, 0.1807672004388603, 0.16946917033059072, 0.1375707924457552, 0.9089648828342424, 0.1496454937324957, 0.18005232435639895, 0.9550185301784742, 0.13770481014834945, 0.14006439725262265, 0.15502194514489565, 0.1284977722702817, 0.11315203900533599, 0.7430753888055519, 0.15641591067149252, 0.21508729788891712, 0.21163226612007502, 0.21516590412651893, 0.20389057685470668, 0.45362884372522383, 0.21843927876916913, 0.19025132657403376, 0.22647573717618386, 0.21148985206173276, 0.21985427866523155, 0.20807333418792218, 0.28399550960292996, 0.2330535022259167, 0.20247060909618597, 0.13245322963509298, 0.10179470331762008, 0.0965651559909444, 0.14844660755206007, 0.07924787276941847, 0.1425508293459028, 0.05393455325467733, 0.06579743029790663, 0.08453745175082694]}, "mutation_prompt": null}
{"id": "d68c22ae-18f4-45e0-93e4-ac4ba28290e8", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Use cosine decay for perturbation radius and introduce a temperature-like parameter\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a temperature-inspired mechanism to gradually reduce the perturbation radius, enhancing convergence by increasing focus over time.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40496fe9-eaf1-40c0-89a7-5b1d45e63835", "metadata": {"aucs": [0.7819622921464807, 0.8020927858159081, 0.7444708289449926, 0.7658230126515307, 0.7926758998834855, 0.7660972510852704, 0.7353425145480823, 0.7283202800878401, 0.7693594875285964, 0.018029096456463445, 9.999999999998899e-05, 9.999999999998899e-05, 0.0792764943065215, 9.999999999998899e-05, 9.999999999998899e-05, 0.09086188293561204, 9.999999999998899e-05, 9.999999999998899e-05, 0.08790649849679155, 0.07698705563365615, 0.058645549106340567, 0.0634785427438157, 0.12764001671189618, 0.07319165106190917, 0.097530385918711, 0.1478832653826062, 0.0849913025360578, 0.12021835889370358, 0.04310449082681189, 0.015900317938043917, 0.08348068441718548, 0.11837363546941992, 0.05633600717213416, 0.040301933569205306, 0.07357882133997684, 0.04981528571310412, 0.9620333475205692, 0.9828264189893856, 0.9846110640900507, 0.9593362004909587, 0.9796906192241269, 0.9869039801700883, 0.9781752999835777, 0.9942045096487431, 0.9700540605899397, 0.5570783060885207, 0.5205523554406195, 0.49099504775683855, 0.524635561242329, 0.5472480988769135, 0.5126511197811898, 0.533988931846916, 0.4937911770486959, 0.4837138754321568, 0.1706119682848517, 0.20111020243346434, 0.23172645706991146, 0.3912733251237639, 0.1895433780403346, 0.25761131253199265, 0.37340879348203015, 0.23315855314382683, 0.1679211966019888, 0.1949726643445241, 0.23064665379238236, 0.19865444834495816, 0.2157313407181285, 0.2192653496653728, 0.1353756582959239, 0.12039837189714431, 0.22548621164348936, 0.13699600966255476, 0.19788314167182952, 0.1270321458094782, 0.12640631741857178, 0.25320200002133797, 0.13560304911946952, 0.17366188510320368, 0.19203305425734352, 0.1987914113577267, 0.1314724319327777, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003146618320618133, 0.00984872791964031, 0.035129138869040455, 0.003105207479277672, 9.999999999998899e-05, 0.08592760633409291, 0.07720847984341239, 0.07799368368276394, 0.16819857917806313, 0.1150932764754029, 0.07840448763512808, 0.013575667721657192, 0.14131108196972886, 0.06076849090375058, 0.08404312875579567, 0.07713972581801576, 0.04139957354053492, 0.1062259890535926, 0.25895663504761024, 0.09627947092657996, 0.17079696705434622, 0.12366569517790027, 0.13116222888874107, 0.18716588943990264, 0.08405536908863431, 0.1541312075024811, 0.1846693271945843, 0.11407326955274277, 0.14524235880103642, 0.03831087053197757, 0.08732828511839108, 0.09992908689643953, 0.20202319204902264, 0.514430123223905, 0.4928006197560578, 0.5226724028445324, 0.5564098765308125, 0.5154647449922021, 0.47990760488214657, 0.5085414210175822, 0.4773853938036424, 0.5030142835280023, 0.07138833888995866, 0.0928363422568036, 0.06552725468273424, 0.14668453001415205, 0.07629254676450614, 0.07140660328169068, 0.1339680122670286, 0.0747820068122903, 0.11222450208682244, 0.2218717574808604, 0.19006121164369727, 0.24706737348474983, 0.34459703873267244, 0.17596914062934754, 0.1576942118648058, 0.2180509801689292, 0.1784526115814199, 0.34644886813818443, 0.28574742994757407, 0.2516068278077199, 0.15219299390998875, 0.1732929755852317, 0.2203658441029488, 0.17398244472368318, 0.1764737879298689, 0.3289767173170014, 0.351390740023486, 0.26882034590239645, 0.14390035470028273, 0.08575549866793697, 0.23085568913029242, 0.13377114260620548, 0.17288598133695554, 0.1898591700010246, 0.24390689905716656, 0.11586233953769931, 0.1761117357884936, 0.19754642897422992, 0.17545198217657854, 0.22642067053554815, 0.19484015019926337, 0.23944103268065597, 0.23810023804721325, 0.22189819223194807, 0.24920011465345893, 0.1771583846294903, 0.1716078396759867, 0.21121776623869326, 0.1726853898604993, 0.1913071325852176, 0.17767111710034555, 0.23046385175439676, 0.17940458451290686, 0.1807672004388603, 0.16946917033059072, 0.1375707924457552, 0.9089648828342424, 0.1496454937324957, 0.18005232435639895, 0.9550185301784742, 0.13770481014834945, 0.14006439725262265, 0.15502194514489565, 0.1284977722702817, 0.11315203900533599, 0.7430753888055519, 0.15641591067149252, 0.21508729788891712, 0.21163226612007502, 0.21516590412651893, 0.20389057685470668, 0.45362884372522383, 0.21843927876916913, 0.19025132657403376, 0.22647573717618386, 0.21148985206173276, 0.21985427866523155, 0.20807333418792218, 0.28399550960292996, 0.2330535022259167, 0.20247060909618597, 0.13245322963509298, 0.10179470331762008, 0.0965651559909444, 0.14844660755206007, 0.07924787276941847, 0.1425508293459028, 0.05393455325467733, 0.06579743029790663, 0.08453745175082694]}, "mutation_prompt": null}
{"id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 63, "fitness": 0.266128090480461, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.27.", "error": "", "parent_id": "40496fe9-eaf1-40c0-89a7-5b1d45e63835", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "1252923b-559b-4d10-82be-b8fedd973b05", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim) * np.random.standard_normal(self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Refine local exploration by adjusting candidate generation strategy to utilize Levy flight distribution for enhanced exploration.", "configspace": "", "generation": 64, "fitness": 0.24612473109561023, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8404141578259401, 0.8351775188198504, 0.8249647949973175, 0.8544107440421193, 0.8605368480535744, 0.8837861364907038, 0.871025081152744, 0.8596836289768613, 0.86024920158483, 0.07006949946200403, 0.05474591512623428, 0.020259216595982288, 0.130419879017605, 0.1664605025429493, 0.003647926167292481, 0.15364350322813114, 0.07572062674598579, 0.02033316088664594, 0.09156649474605327, 0.06923759778473282, 0.10669551296788105, 0.06515371666952485, 0.0767325506841775, 0.0986746076400723, 0.10941591475418411, 0.09651468604308489, 0.09048589801223539, 0.09501979375542469, 0.07577627437839218, 0.09055838123638715, 0.1057727626759064, 0.06726556267687611, 0.07943321824820848, 0.06932793937290205, 0.07721967999135593, 0.11411910166474315, 0.9802139539059039, 0.9730015161170166, 0.9657378777914731, 0.9796421939793609, 0.9834237818386785, 0.9564102777538027, 0.971397127686008, 0.9887708213770982, 0.9953571505269582, 0.5947673411916201, 0.6099378688643522, 0.6054844682404822, 0.6068592651859398, 0.638239146949075, 0.6157088932997576, 0.6126539332874475, 0.5997325540434069, 0.6229330981086507, 0.5318104367721059, 0.1112056714488322, 0.21570134183655587, 0.20800266193662287, 0.22153535396064616, 0.28299256322930355, 0.18341015676975947, 0.15720924009983805, 0.12804791952694905, 0.20614487449674435, 0.1313013513533029, 0.201881466772717, 0.13092863247844655, 0.21147166603621426, 0.1981284664615771, 0.21679275100009798, 0.19514779102734148, 0.1213401311413258, 0.13321779007227164, 0.225398181449448, 0.1297620081957802, 0.21024847927595014, 0.13387975912896477, 0.22634920138090897, 0.19854911251438878, 0.2299608052804588, 0.21619308056349984, 0.027198711512089857, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12569717945337322, 9.999999999998899e-05, 0.035140840312526955, 0.008597188442382664, 0.08703176006400648, 0.10069749603687994, 0.042901528139235645, 0.03466518756649861, 0.08332005922602781, 0.019804856183263442, 0.012333867266279608, 0.0502591856200163, 0.02969537534411193, 0.04157482593424555, 0.16390781607704463, 0.042097341803795874, 0.26888173492453893, 0.08976262670260127, 0.10698855117557782, 0.13850017608462373, 0.11958267021544433, 0.12819187244551444, 0.08021183280750188, 0.13226847338577297, 0.15583717585769064, 0.11839116581453124, 0.2190680290171405, 0.026111924040072565, 0.0837218727629202, 0.08901274576506579, 0.09903998737890474, 0.12326466434770378, 0.5380332713017335, 0.5387718349055584, 0.5286639586385264, 0.5503300933985729, 0.5459388745697635, 0.5512953237112814, 0.5630741284788543, 0.5221033353363663, 0.5512913857477618, 0.038416182267129395, 0.09433288244082216, 0.08036588422357127, 0.09857897184620812, 0.062336542887284074, 0.08134765845935477, 0.05198506906975309, 0.12064126611448778, 0.046834230398735244, 0.17442794343756995, 0.1469954946002232, 0.35877309264531065, 0.3340646578540899, 0.2088814214282554, 0.20461124537936026, 0.13623005473750038, 0.19540300701553825, 0.2857760375731111, 0.25973683184353547, 0.16897465611391194, 0.14171952873259364, 0.3626471976676283, 0.19074129153439712, 0.14716629806290948, 0.17394317711950935, 0.19507414768612397, 0.09481126403277762, 0.18077734775015342, 0.10402267027923551, 0.052952091420959135, 0.16715684042027446, 0.10846838909733647, 0.10879955565792587, 0.1565573495343353, 0.12255391738317789, 0.09350038456003218, 0.2180802715252682, 0.14213088245754113, 0.18811713561305665, 0.27150557276749776, 0.17312675963841972, 0.1861363424156911, 0.21839655946921765, 0.16465122023706935, 0.17446865357417685, 0.18927366171378912, 0.21212672292519263, 0.1946039260238296, 0.1783811394468796, 0.17706959715404902, 0.21273505108279767, 0.1824455164884159, 0.18162311074558857, 0.1790178639165031, 0.18935349628259113, 0.13782949855822102, 0.1755371714874091, 0.17421746188388132, 0.15404330210138573, 0.5918578338188506, 0.10867818979471444, 0.11536099348993101, 0.15489833098791095, 0.6159905728551593, 0.11355645130754854, 0.15652910929960728, 0.15587430053436468, 0.08309816812450577, 0.21347707239335, 0.11268221693254254, 0.16620725639843492, 0.5958602663732419, 0.2276587943935514, 0.25069929303597316, 0.2228541957654483, 0.27733402475480506, 0.2444386360082611, 0.22567019330766147, 0.24607293565731525, 0.20375937771049502, 0.19299359411227368, 0.10093581165808174, 0.08299720264251553, 0.08621079621742866, 0.07435408524231624, 0.02795095084204391, 0.07829102463493876, 0.06788334384436001, 0.07036327875329285, 0.07886698980549067]}, "mutation_prompt": null}
{"id": "a44fd110-b99f-4f6c-afd6-46b0f0a7d2f5", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "cff76aa4-29dc-407e-9fba-534c0ca7aadb", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "a755d91d-e818-4454-bb16-655ac2d12c32", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "a1d173a0-b05e-4ed7-88f1-39fc6d1a6974", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "43c4d7d9-2088-4054-ab46-81f0b3393599", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "8f445c53-d076-427c-8a66-28b42ec22d8d", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - (evals / self.budget) ** 1.5  # Adjusted decay\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce adaptive learning rate decay in candidate generation for enhanced exploration control.", "configspace": "", "generation": 70, "fitness": 0.25748552094027105, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8344015005856191, 0.8247015535560607, 0.8312354897911615, 0.7909757974087572, 0.7625312707204939, 0.8711865635938301, 0.8239527259499948, 0.8228569989853551, 0.7716597413992454, 0.013042745462425565, 9.999999999998899e-05, 9.999999999998899e-05, 0.008023303201871945, 0.0006872768751738922, 9.999999999998899e-05, 0.03207168728681631, 9.999999999998899e-05, 9.999999999998899e-05, 0.1280333242594508, 0.05191922783776959, 0.030061276777911594, 0.1083988024626047, 0.0625842724174156, 0.0740661390017342, 0.06924016951124545, 0.0759214796614337, 0.03647605399076126, 0.06956311484802258, 0.07091425610737334, 0.036978324863601975, 0.045513221393254755, 0.09734658167927646, 0.08517801328700547, 0.048027316766460215, 0.10872675772339901, 0.0734454667601191, 0.9919868962759167, 0.9783571824407525, 0.9823917315911792, 0.9658274795085455, 0.9580579987422572, 0.9796449309214054, 0.969975506794107, 0.9884006038631763, 0.9428799262754954, 0.5740502945643702, 0.5700175798558182, 0.4852970348872432, 0.5797918832216447, 0.5944906254354076, 0.5753926676510366, 0.49974838984604497, 0.4924183548676101, 0.5603598057136256, 0.3553435719060368, 0.08873961481608528, 0.20241050349430756, 0.20813562260254248, 0.1975699053060499, 0.19762504513114132, 0.2440489054567725, 0.4764271878086227, 0.20889664853175838, 0.22158975841101014, 0.2464979508910785, 0.20771503230027477, 0.21453661189214757, 0.13008062182355085, 0.11789776324377521, 0.2234607704241114, 0.2510745533189923, 0.2287993502265, 0.22005339530570522, 0.2121529808330458, 0.12532502764616982, 0.22648516302260424, 0.21217596086952217, 0.13799953011607047, 0.355389708533142, 0.1863920842573915, 0.19340698828163017, 9.999999999998899e-05, 0.05547327052851947, 0.09321576367854945, 0.06929930843688292, 0.11083418600901118, 0.047620011920771366, 0.005066126884858968, 0.006956230140047759, 0.06480562828634995, 0.018884632436367288, 0.06976662661764366, 0.1311848287493893, 0.09158796801760605, 0.026019458887718838, 0.010906745354793745, 0.13795417497824114, 0.045711063862109436, 0.07488486397845662, 0.21947910581930707, 0.04108703847457329, 0.054230587779453665, 0.32640827014611273, 0.0911068632140245, 0.08803517635834046, 0.09339026544121931, 0.24138744180131866, 0.08394039681745802, 0.14371345839659722, 0.2245427316447498, 0.07327380770213954, 0.0363191027444153, 0.2926685623928902, 0.08071930835878371, 0.11192330300249254, 0.11925006174576469, 0.10833367268916483, 0.5601584960337541, 0.5531984946412914, 0.5323955745807057, 0.5022137352601196, 0.5155071537879259, 0.5277182415960826, 0.5141869299605184, 0.52195524836478, 0.546368478944746, 0.1075877945666065, 0.07511040338361619, 0.11404105585728685, 0.0365869935762797, 0.0728266227603579, 0.06952827742403589, 0.1261565970225954, 0.07968141247270855, 0.07500556557893723, 0.20197703420795732, 0.23377660363434916, 0.222455952678016, 0.15456047456384037, 0.205277779252945, 0.22188813763757909, 0.177984831363738, 0.3788811900453567, 0.2580131266801813, 0.38138163738140274, 0.21179914934634558, 0.3345661377202406, 0.4058862178652848, 0.1731350282391093, 0.14010229454994838, 0.2242527431118011, 0.17248579163633493, 0.18867130204276084, 0.09217092332835641, 0.1702829367836206, 0.07026121060114143, 0.13236550551511483, 0.16622349755456522, 0.12042265821354159, 0.18014939960774068, 0.18336742444685938, 0.07312975952174094, 0.17698584034568143, 0.16845112537719142, 0.15500817584968996, 0.19915991514825682, 0.18565570651770014, 0.2832916790804686, 0.20690963804690732, 0.18394678893577165, 0.1745169524750083, 0.17245741296962225, 0.19267722382575025, 0.1984118558395015, 0.21453454946401662, 0.18289271938162632, 0.20523958584418256, 0.19376000121266823, 0.22047562352548578, 0.190920196928833, 0.9470303940294099, 0.13693597134493574, 0.17328846252727603, 0.17228994338956416, 0.17969253221974235, 0.9251436541409683, 0.1702275689203434, 0.12738890419408888, 0.1683537746952718, 0.832256327333696, 0.11348536335301795, 0.6986215770160511, 0.08332972627502389, 0.21414957561228343, 0.21152289047350725, 0.6779086852098379, 0.1670646120901974, 0.5272323055467996, 0.2028798269573906, 0.28994093765522766, 0.2471797927866286, 0.25405847707373397, 0.2604929805002111, 0.20347169570823465, 0.24610944029603876, 0.2415907958789708, 0.2119678898068319, 0.08264672750130098, 0.06854429238544035, 0.06412402629764291, 0.0672405623794986, 0.09896078093580896, 0.07438723690228599, 0.0823110966420958, 0.0778470261487777, 0.07658620839238228]}, "mutation_prompt": null}
{"id": "a45e75c1-9128-4cde-a44c-3901aec2df1c", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            dynamic_adjustment = 1.0 + 0.2 * (1.0 - success_rate)  # Adjustment based on success rate\n            return max(0.1, min(1.0, dynamic_adjustment))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce a dynamic adaptation mechanism to better balance exploration and exploitation based on historical success.", "configspace": "", "generation": 71, "fitness": 0.2527782008542901, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.813164327366416, 0.884879661383373, 0.7884191099590868, 0.8122698686915495, 0.8393555278632737, 0.8162818531666167, 0.8118724840233646, 0.801334437267686, 0.81027145636155, 0.024882458277323383, 9.999999999998899e-05, 9.999999999998899e-05, 0.05479221386938149, 0.0021262934782052545, 9.999999999998899e-05, 0.06559556544317457, 0.045451668031130654, 9.999999999998899e-05, 0.12850804673642302, 0.1157141958811777, 0.042372265778648166, 0.06100611011757151, 0.11953809069362453, 0.1347836895262744, 0.0738606297428307, 0.1479028749944582, 0.09606930196214003, 0.063703670863831, 0.1637686405263934, 0.020006186921693536, 0.06851035555217444, 0.049803574065191425, 0.10204012702481247, 0.09400294709717305, 0.07795726139586479, 0.06617814838993419, 0.9403277599500055, 0.96543261881728, 0.972055527383957, 0.9391251953033614, 0.9645841982904151, 0.9728334338686676, 0.9595597433891832, 0.9528351570791032, 0.9658949237713086, 0.5360436114537972, 0.5776236521869378, 0.5307666774837234, 0.5560842382039948, 0.5580079405034071, 0.5659992324891321, 0.5771934667203951, 0.5774416294102974, 0.5250632747088813, 0.1720456512780214, 0.1519193181320303, 0.1221431882546542, 0.3875896505533607, 0.21220459216167198, 0.1938442106621785, 0.7631387727497203, 0.21411609933517262, 0.16935086778002684, 0.21221860758575173, 0.2384811219642099, 0.2178407314476818, 0.18535143022419498, 0.22506801037102464, 0.2059362418053654, 0.24804114281782064, 0.2037171332613602, 0.21408263601314326, 0.19682687607360883, 0.20675714227130726, 0.13024219303405493, 0.2287875695363173, 0.11881385461967908, 0.22715854597758023, 0.2276658365871903, 0.5014531798177914, 0.20049340198703236, 9.999999999998899e-05, 9.999999999998899e-05, 0.01161491517458324, 0.07155344494193705, 0.08681626072484427, 0.057783789372335526, 0.003955032384309054, 0.01534987950868616, 0.06465936468731137, 0.01603305798376098, 0.07046474075269649, 0.12109083969576184, 0.08566031096401583, 0.024344241653308063, 0.029815906858410735, 0.14840807725215532, 0.04759850170476365, 0.04391214250558095, 0.24756265900670382, 0.040023095225706684, 0.29266689825393444, 0.24495774386759595, 0.08385708118733715, 0.10519881591775881, 0.24739680390764773, 0.11146234801670485, 0.08272676473600038, 0.07834577537450349, 0.25159332334016915, 0.09805244350099618, 0.09458014221582145, 0.13026818353639624, 0.04854868860768968, 0.28014697345239215, 0.08609265746515171, 0.09187907454392918, 0.5460281479842171, 0.5931457301515984, 0.5528203479935643, 0.5613370271553594, 0.5011455407655221, 0.5464597518874073, 0.5253572557561024, 0.538605897723718, 0.50113228020798, 0.10182767169120832, 0.14858865182269598, 0.0767116442859237, 0.050518727892683635, 0.05604722856943389, 0.07353903068675338, 0.07964844241614988, 0.0498211328488265, 0.19318144272400217, 0.240729992752705, 0.15083311868218785, 0.1947760407101975, 0.25344505869716616, 0.16477490296054242, 0.23565575986296583, 0.2499345597830247, 0.22940308480339977, 0.1956592219859613, 0.19372840870336583, 0.1535840130734576, 0.15379466831046118, 0.44850928595885087, 0.1785416419266388, 0.14477482169538836, 0.3387064164284983, 0.15256731279836333, 0.12166138095680379, 0.31709359041086616, 0.23648500245719695, 0.0672260020613279, 0.17694848536265784, 0.15230379214089484, 0.1450058643554747, 0.2572117953167118, 0.18334454618012597, 0.09158563382005813, 0.20900358496553717, 0.1639226508995918, 0.22931320622325824, 0.19527549162546476, 0.19843736047671046, 0.2812471102586077, 0.20048283973344017, 0.15830398162405035, 0.2464000935112658, 0.18844038356136183, 0.16559745906178702, 0.19148661378928022, 0.16855690686214453, 0.1949550924204566, 0.18672366863852885, 0.19199812406060324, 0.18018658497895956, 0.18986254990687512, 0.10824132465091985, 0.13773284633690708, 0.17611283324062643, 0.7522014734453721, 0.15970615423279177, 0.1618632213950284, 0.10888974896970172, 0.11540609029295612, 0.16711853437982604, 0.7224670944333829, 0.11336395707283897, 0.1302722449411724, 0.08331443242584968, 0.1129335599845055, 0.21270021576743148, 0.7329279039651795, 0.16863363449836466, 0.1998632290549025, 0.1972469130660246, 0.2509410312171282, 0.2089299842936252, 0.21702412810261218, 0.2938556716784435, 0.20760592471636552, 0.2637068620204617, 0.2527312506178059, 0.2059448839288004, 0.07788757727808626, 0.09542497396970762, 0.0947764315631906, 0.0576298419409188, 0.05785132740802423, 0.10909301929499526, 0.08398019353228936, 0.0924064574187492, 0.08130904794626481]}, "mutation_prompt": null}
{"id": "91bae01c-bd95-4d23-b416-15e766978753", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "86a1d3ed-1ab7-4e4b-b095-02d1c9beffd5", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            8 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )  # Changed 10 to 8\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.85 ** (evals / (self.budget / 10)))  # Changed 0.8 to 0.85\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Improve candidate selection by dynamically scaling perturbation based on progress, enhancing convergence.", "configspace": "", "generation": 73, "fitness": 0.2584768486352272, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8069871109776328, 0.7877953546572134, 0.7901219384483995, 0.7887755855822831, 0.8204990025030006, 0.7780864133779901, 0.8217876566630384, 0.7856351401082573, 0.7837658521471879, 0.012513591228559884, 9.999999999998899e-05, 9.999999999998899e-05, 0.05822406619785814, 9.999999999998899e-05, 9.999999999998899e-05, 0.029865299850556193, 0.06301613495767544, 9.999999999998899e-05, 0.1948416425906332, 0.07843181278804079, 0.05268697811943346, 0.11277492444775394, 0.0689709441577464, 0.07773803217121567, 0.13192311776579313, 0.07262724932199871, 0.0802678432212206, 0.0986332980353356, 0.08306762213656838, 0.03467276987160295, 0.06660188465941663, 0.061444661667026, 0.07516839520609742, 0.05105877267246284, 0.08709196928294882, 0.06734063843705629, 0.9920312018725483, 0.9682132369300761, 0.9824514026391389, 0.9499554038612156, 0.9751120764980338, 0.9792389432373767, 0.9659684674048554, 0.9885827722852109, 0.9613058992605013, 0.5786432773708468, 0.5888563656707657, 0.5821996487783037, 0.5747509631703009, 0.5600940168357129, 0.5578588509907496, 0.5731229917714653, 0.5583070504973566, 0.586049995752068, 0.14177594308971397, 0.13126033676320326, 0.19996284587319824, 0.29924639872972136, 0.19343242692704465, 0.2084771516977464, 0.2247214473409569, 0.6276976692393796, 0.6209289114380971, 0.20703680424544335, 0.13617980893432013, 0.18430254076541264, 0.20731192523818398, 0.1382811954141111, 0.13179423556196923, 0.22210417494319046, 0.1351144315217322, 0.22064454868913974, 0.21957680180144246, 0.210423985088674, 0.1266530657443904, 0.22802152091709904, 0.24150034012836574, 0.13719084238157098, 0.3307809287746587, 0.13754843993509547, 0.18065977985529957, 9.999999999998899e-05, 0.0880509138539124, 0.08247236527805923, 0.016859124508968093, 0.045206093316702556, 0.07714491588487926, 0.005336746278766458, 0.012616336214012147, 0.05818909525997662, 0.03697273073692975, 0.10775932054279524, 0.15998370824553332, 0.09105779408332959, 0.028134781277335374, 0.012239782251704079, 0.13133562631801832, 0.04677111533726641, 0.04870534900457746, 0.21904935189542662, 0.036937801315099605, 0.07965183514801089, 0.2359749982671927, 0.08882655867349987, 0.22461181081343717, 0.11431680252376097, 0.08288487856458127, 0.07589674162968807, 0.1137385222828885, 0.12470686897395822, 0.06490801059882467, 0.1113011787419137, 0.1961879883338794, 0.09453346015360764, 0.11642559309283473, 0.26902732552463704, 0.17396979806915902, 0.5156838397351353, 0.5365954097779182, 0.5216308599340633, 0.5637115378205556, 0.5310680927672722, 0.5143296284823616, 0.5601075010934011, 0.516909688977935, 0.5228376100408941, 0.09529085285888228, 0.08565553931191205, 0.08485495207136917, 0.06479404564994296, 0.10039762604701097, 0.10540616143229875, 0.09391492627671016, 0.08182277638866964, 0.0464718249863052, 0.2103798223737089, 0.15209472718506534, 0.27221130692378914, 0.16631654250215777, 0.21161813237801352, 0.1671302221466322, 0.1506161974162693, 0.19069368076960957, 0.16851282481236618, 0.40137364822977806, 0.22472908079230913, 0.22405718306323996, 0.22665734014392036, 0.1611568593340924, 0.14718745683101153, 0.26513520715355776, 0.16070836763524765, 0.1595990073962804, 0.21752581874843469, 0.2318247038319189, 0.0632193075391777, 0.26556124481546695, 0.1649334646879841, 0.1070190787740003, 0.1993174903106213, 0.11354264728279317, 0.05828533434346295, 0.1911293503912469, 0.24763722720586034, 0.19243534967788778, 0.18281158151749777, 0.18104128909931783, 0.15738085584641193, 0.21770386473118675, 0.18966622200222083, 0.19878491355312788, 0.18063503927930813, 0.23116676742840836, 0.4083601067693561, 0.1864018593004575, 0.17863497213053348, 0.20912604531227608, 0.22167584572672083, 0.18775069684736823, 0.19834726363287714, 0.9478069399031799, 0.13750383480487793, 0.15868757217048712, 0.14778470714736047, 0.11242042310274392, 0.9527766680518042, 0.13741859172641802, 0.12725641202019755, 0.15455237102067587, 0.7849475996399703, 0.11331889585851584, 0.7431724293129538, 0.15708603747755623, 0.21401978140096733, 0.21274856587155078, 0.6585925870948885, 0.1664354383981823, 0.5092719020184092, 0.23552600556962044, 0.23365562474318347, 0.20942399362035935, 0.24626172622540543, 0.2113706572196533, 0.21404732127376958, 0.24519606669636018, 0.23685633434580566, 0.2093693439529587, 0.08671795971034224, 0.06447640340709371, 0.06801772948953055, 0.06263782478694502, 0.05005971088683547, 0.062307155588475105, 0.19509336168826863, 0.05853747025558553, 0.061892945089672136]}, "mutation_prompt": null}
{"id": "7b52bcd5-8c5f-448e-976f-4c351a4aa388", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "1c782c43-eb82-405b-a811-cfd2867474cd", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius *= 1 + 0.2 * adaptation_factor  # Dynamic scaling based on success rate\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by introducing dynamic perturbation scaling based on the success rate.", "configspace": "", "generation": 75, "fitness": 0.2552509476739914, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8368832037626238, 0.8273785649084016, 0.8427273904970352, 0.7882065510721947, 0.8357610091584747, 0.801085135055901, 0.8593175219499594, 0.7997200929335028, 0.8013109721500287, 0.03195918169995016, 9.999999999998899e-05, 0.07355809294116811, 0.07936214146112486, 9.999999999998899e-05, 9.999999999998899e-05, 0.08539357414851079, 0.0003130507139917915, 9.999999999998899e-05, 0.08399307895484509, 0.05498217255087745, 0.06461150333718702, 0.08764089300252564, 0.09908111001370357, 0.06609617240581789, 0.06307937534276209, 0.06654106883069688, 0.1417134698557695, 0.08100404022907315, 0.09429557692583712, 0.01238719928707177, 0.06285869668680588, 0.06481146300221119, 0.044624041971986106, 0.06469263496624678, 0.05328348038813091, 0.05312247862577746, 0.9920168034308763, 0.9715415744959371, 0.9748568077122919, 0.9671001737705187, 0.9658893541912664, 0.9707415047687906, 0.9633763504262906, 0.9885184888790886, 0.9533549088427193, 0.6061006426718065, 0.5503852299048897, 0.5616284229819846, 0.5630197034635153, 0.6011835108834238, 0.5991495423807733, 0.5274072424773709, 0.5884856571312173, 0.6022669626109187, 0.21781808108498935, 0.1558077923000828, 0.22672304303332824, 0.35000572811034203, 0.28331793067902533, 0.2831356732296747, 0.1888923666612239, 0.2259265829285464, 0.22270728241443782, 0.22495916274964145, 0.23156149899237655, 0.20157233500753913, 0.2157938588249383, 0.2132501656090835, 0.12507146606358732, 0.20191780248984792, 0.24909048552823498, 0.2133905563999955, 0.22071278231627245, 0.21104945529623942, 0.12562846268900063, 0.22694692262970573, 0.13572909941234046, 0.13681531000541802, 0.3342305284112953, 0.1740870331930342, 0.1985048533107593, 9.999999999998899e-05, 0.05093411033647677, 0.14993314829978466, 0.017151964831625288, 0.06261386128660928, 0.10019114207620583, 9.999999999998899e-05, 0.009522466156503984, 9.999999999998899e-05, 0.04940324450809164, 0.1076827398666359, 0.1597302683256996, 0.07021735800130724, 0.02640087362588217, 0.027124347989189834, 0.16468802254002135, 0.028084134672552552, 0.12119806976769609, 0.2770588150386327, 0.041169067249398505, 0.10176831751813331, 0.22375266100661906, 0.08238418229498512, 0.1403704172295509, 0.10007999762138808, 0.24004446141386615, 0.075809532754751, 0.07232048641337752, 0.15101146656888742, 0.08359086438707541, 0.0534112103984955, 0.07132224096062023, 0.08818400473939869, 0.27957362553067255, 0.29551765766244376, 0.10191156363299725, 0.602196207206704, 0.5104699070789506, 0.5635815037541482, 0.5604284965919506, 0.5232411738482932, 0.5336105661917832, 0.5103596641285003, 0.5265207573236035, 0.5049374057306079, 0.05429298710829067, 0.11832565034099429, 0.0775437048461175, 0.06226764928670636, 0.0909383117401239, 0.07970477319614289, 0.0575640651070527, 0.08705343634922025, 0.0345419994423628, 0.273072868318738, 0.17963114409318348, 0.2095210223698849, 0.14486288714155693, 0.400475115459182, 0.14416762221518986, 0.19533196834808286, 0.21062366427491597, 0.24836433244843614, 0.45937660583654394, 0.1319409805354138, 0.1648179793522726, 0.18641524336595716, 0.17040291372866723, 0.17294420938034638, 0.23850645838767692, 0.23145675367927265, 0.2217903963520791, 0.23473090188476686, 0.19889966893436783, 0.17227245349133935, 0.13085913816752692, 0.16983800864580212, 0.10509396708209429, 0.20237929259761245, 0.12244576873472779, 0.12175539436544514, 0.22593858869786132, 0.16762754246763556, 0.1784024036862515, 0.21389270020237638, 0.2296228318857385, 0.1727188100339787, 0.20270137932001708, 0.18079888291701318, 0.14947007730176143, 0.17451389924086802, 0.17349430258564336, 0.19572656827155033, 0.18811988995345186, 0.1845179570271699, 0.2017488213892612, 0.24877978338608486, 0.1755095599147033, 0.17233693068327194, 0.9447739207109209, 0.13735152395899186, 0.14767698310350152, 0.1471650506350881, 0.18019937062606528, 0.1216222592590177, 0.10889178355685103, 0.11537912516153115, 0.15472522131382882, 0.7599724263735342, 0.19601972821173197, 0.789497589369384, 0.15708734351083353, 0.21429431979570435, 0.21252394747053394, 0.6788245686654992, 0.16651459259285262, 0.5018809103751803, 0.2079241814339976, 0.2325470446133443, 0.25324873248353474, 0.25515330817631743, 0.21887838444374896, 0.19989038768281842, 0.2442296600315893, 0.206744613059601, 0.2316618798530754, 0.0850316081278335, 0.07844913466403525, 0.0414803956328913, 0.0961338434105875, 0.0672947335253159, 0.09778612544385035, 0.09798432664172674, 0.0646510488289117, 0.05691827348023104]}, "mutation_prompt": null}
{"id": "d6bb0f5a-79fa-4380-90a1-9770639472d9", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        # Change: Modify perturbation_radius calculation\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            8 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.15)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce diversity in candidate generation by tweaking perturbation radius calculation for better exploration.", "configspace": "", "generation": 76, "fitness": 0.25954584849815254, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8058570609847415, 0.8236581145301243, 0.7822187833464916, 0.8420178291175211, 0.8177224806673392, 0.7932837989116703, 0.7840546917551775, 0.8364430047725717, 0.7771904904962158, 0.008268489069672258, 9.999999999998899e-05, 0.05516787760407005, 0.09591754539011821, 9.999999999998899e-05, 9.999999999998899e-05, 0.08894728151842479, 9.999999999998899e-05, 9.999999999998899e-05, 0.19663837204902734, 0.11761110607787872, 0.053757941359016126, 0.05811357037254128, 0.0761310540063369, 0.07270683299156278, 0.06948480616422437, 0.09554135418451082, 0.05156828652729217, 0.08083344256575398, 0.0668690927669926, 0.03748594512600045, 0.0746211353025854, 0.11208231253493528, 0.04944759967535206, 0.053162692352576424, 0.07276206522101092, 0.09575248193031438, 0.9920288727155983, 0.9695227262329026, 0.9825286783388005, 0.9499120903565605, 0.9749259387968828, 0.9791267183831549, 0.9658899741427256, 0.9886001043125261, 0.9614451501089967, 0.5603209816904613, 0.5450316771663837, 0.5338853267366588, 0.5798828810755112, 0.624501599036281, 0.6061810813354293, 0.5492508531989002, 0.5325089683370587, 0.6147289856899073, 0.17248595722131554, 0.16893307570705218, 0.16171644722090806, 0.31187457773662086, 0.2087609074652259, 0.2574348652815084, 0.24836444721366635, 0.14176351298885403, 0.6283077919290072, 0.2203327060031801, 0.13611258134494053, 0.20590920600997176, 0.17253470032811802, 0.13781041052819187, 0.13293200173767217, 0.13258563291160153, 0.24109660033197944, 0.22912902565599513, 0.2238615936516647, 0.20699237701249273, 0.12589733787699553, 0.20675452674736328, 0.23828371554138839, 0.13790928509145384, 0.3421591742066171, 0.18316939319720738, 0.1910392250570272, 9.999999999998899e-05, 0.0045227319845564384, 0.09166579252353568, 0.014927179584034445, 0.07779198972223544, 0.006678603491381385, 0.0038623576760761225, 0.010068072466714706, 0.06860561505097829, 0.035936898846309684, 0.1889478508130099, 0.17981965084596419, 0.0882406729444789, 0.029117752815901232, 0.018554155132055716, 0.147928241575621, 0.0667394378630859, 0.032304234081727334, 0.19748161799732233, 0.03614502261216734, 0.07789093978781059, 0.25402815929285594, 0.07781216956683257, 0.1522190240428054, 0.13250072894823028, 0.09947978261448931, 0.07350049010000381, 0.1191645087241322, 0.1108529183061937, 0.08948178951621466, 0.07953460427914616, 0.08371515071764057, 0.09386409642738358, 0.08880106856881631, 0.12845849697536882, 0.15804176501830625, 0.5461957988332067, 0.5069458928195472, 0.5473079851010294, 0.5656183993283299, 0.5355286507338136, 0.5163353855031285, 0.5581264659639227, 0.531044414986098, 0.5510185027934555, 0.19485240671632986, 0.057247069276314844, 0.06325472506791807, 0.04141540098753649, 0.06023540755400136, 0.07913710887658376, 0.0848408954575347, 0.14925091038872307, 0.07960188530638423, 0.13926695854991522, 0.17515981588402652, 0.2036858600007868, 0.2085590535955394, 0.13974445315039452, 0.1727470163327629, 0.13524984627805292, 0.2590465460236966, 0.27874921905626526, 0.2085442841541313, 0.26039259975746276, 0.3325077719789302, 0.2355880326437001, 0.38725033953463417, 0.17860437052625788, 0.2491123298610628, 0.16749166429366213, 0.17673801577112302, 0.20964451093465064, 0.24545000052228527, 0.0626033053898527, 0.12246760286464853, 0.29176866995803097, 0.13196274644919415, 0.1982088259169864, 0.10176661871916837, 0.07791954798803069, 0.2575944601932192, 0.20828504970880635, 0.2125204657838603, 0.21772288883084223, 0.23473464049588544, 0.28207526308426556, 0.2033531528822382, 0.20577646910093383, 0.2148201866083408, 0.17462716312900117, 0.1795391904480228, 0.17672517531041432, 0.1890171822008797, 0.20295525174581985, 0.19441565510469738, 0.2218932277517659, 0.2010667069122345, 0.19849554521954338, 0.9504354977478444, 0.1374070477356405, 0.17617620240488263, 0.14765276757296397, 0.15958598453062167, 0.9571372206267673, 0.12754797407780083, 0.12708178318984176, 0.1549346883333763, 0.8740130076813432, 0.11331527521827833, 0.8023044171580087, 0.15724557457144417, 0.21431691489716542, 0.21218687167028383, 0.7509398577071623, 0.16879292166467696, 0.4656494776690234, 0.2386542244652642, 0.2212089220937562, 0.24156223870534632, 0.19882146920919208, 0.2534958416158627, 0.23713089304381185, 0.2849229459221647, 0.21648099190506243, 0.20626023027544316, 0.08911105353199456, 0.09978893996633398, 0.06880619589641446, 0.09956259526242772, 0.07173024375605253, 0.07261515151450493, 0.09742245168449881, 0.0806284663984077, 0.05414715561921346]}, "mutation_prompt": null}
{"id": "ca2da90a-52c8-4a58-aa3e-644b8ec707e9", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = np.sin(np.pi * evals / self.budget)  # Changed adaptive scale function\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Adjust candidate perturbation using a sin-based adaptive scale to improve solution exploration.", "configspace": "", "generation": 77, "fitness": 0.22887679214255088, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.24.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8016725746343896, 0.7598548316001308, 0.8109781658444082, 0.8025247805410469, 0.7993810557163186, 0.7721397587655754, 0.7874856418491845, 0.7611398018952629, 0.7740103984571826, 0.01266411759133479, 9.999999999998899e-05, 9.999999999998899e-05, 0.03313594409589493, 0.06773215478282435, 9.999999999998899e-05, 9.999999999998899e-05, 0.14231243241528158, 9.999999999998899e-05, 0.07576234241921698, 0.04176819171148238, 0.06283756808067864, 0.06340189914233973, 0.03844157291042993, 0.03446269986243189, 0.05184067173908169, 0.06106938589355482, 0.022611240733989124, 0.06187585991182898, 0.024966291247649153, 0.04578252983414244, 0.05365409148671185, 0.00967302902396272, 0.05285999398771968, 0.052524346002684075, 0.009450731614341068, 0.04425829561142813, 0.9302151413407346, 0.8477479563857323, 0.7983161952294215, 0.8309589769825524, 0.8564746776240992, 0.8638771957452079, 0.9232423271061025, 0.8577328221688265, 0.8948620002503906, 0.6063297886082912, 0.5788320937481007, 0.5612645694748015, 0.5807051600292615, 0.612028722455668, 0.5604905235140798, 0.5871966443118366, 0.5624986846186859, 0.5902377375168655, 0.1640345511368434, 0.093428095972803, 0.21274031234507518, 0.3525256517107379, 0.24559787655462306, 0.17763172112997672, 0.15232959772503651, 0.1256632449551014, 0.22240850232604603, 0.2243475020851251, 0.12758333108718178, 0.21374216140693703, 0.19171961420226746, 0.22319500998826025, 0.20044292842634936, 0.24449370991590957, 0.2126453823970762, 0.22203227793338243, 0.2107696219912859, 0.21155030508129735, 0.1304392152185555, 0.27147268619264675, 0.21579144866192923, 0.19745725323640528, 0.22820795798962257, 0.1983339680829458, 0.1979028274257869, 9.999999999998899e-05, 9.999999999998899e-05, 0.05809799431764329, 0.009606160575415967, 0.013468255893607228, 0.04868531065429127, 0.0028778887111642337, 9.999999999998899e-05, 0.10706469640174432, 0.053132015411314404, 0.06430969762849947, 0.18917762531970028, 0.13563390902558126, 0.02291289931044338, 0.028022043485231407, 0.16392437742519994, 0.028505069725076826, 0.10573813845845492, 0.13914641121779714, 0.047229857594589864, 0.20285307757343563, 0.12095934624071447, 0.0802227790906318, 0.07715447862244307, 0.18626354035590553, 0.1735746319027459, 0.08705789661504149, 0.1033447860171327, 0.23506731636889688, 0.06905857665920978, 0.06016267066548675, 0.26783657822088525, 0.05487668358362585, 0.1351349212553885, 0.16080321990949542, 0.08489268865483768, 0.5327233440076264, 0.5078475143027408, 0.5284876799700775, 0.538158970672905, 0.5052377132124389, 0.5100523379365383, 0.5290917805670361, 0.503484234066869, 0.5264890705737193, 0.05907753131508886, 0.021520906038600685, 0.031134969292700765, 0.06963425308209059, 0.061970958004328947, 0.060132234686821384, 0.07661199952693987, 0.06734207682348137, 0.03623197338259798, 0.1919699417533106, 0.15487738039981103, 0.16762071730693517, 0.3074727806517773, 0.16816993460228113, 0.16247528209833295, 0.13390049712258567, 0.13296086393970685, 0.17339144145541086, 0.2037955772688108, 0.13853352609783942, 0.11990576685530452, 0.21986509153594647, 0.13866793533141697, 0.1638306254812889, 0.1449294915936844, 0.09022639695087875, 0.09290862559172675, 0.13249390862470778, 0.19269150241765776, 0.03388951713507993, 0.160907584680808, 0.11442612348960557, 0.07332698106740099, 0.21037592869441946, 0.049901285024354314, 0.08168478345633634, 0.18051714914042183, 0.17905896229324425, 0.20355378728813778, 0.1898955147169923, 0.17325928306889504, 0.17808945002790788, 0.19300632666822337, 0.22326061045021095, 0.1713692978933986, 0.17175618390686054, 0.15879866305720458, 0.1890299366748862, 0.17125192935971467, 0.19514237427686598, 0.17367667043972002, 0.1854581466083357, 0.16852304899717585, 0.15042830059594547, 0.18643041928970372, 0.13494374564979228, 0.09661593205645291, 0.17107944201459468, 0.16894200622390732, 0.12639271704789246, 0.10720121918439907, 0.11434850126304208, 0.16587164733873305, 0.7542246601931475, 0.11229844777198672, 0.5677283303095111, 0.20256365907688267, 0.20316091708438377, 0.20434875511237516, 0.6799363761508707, 0.1482995677446557, 0.4911836664163095, 0.1908566805543902, 0.18129667203120747, 0.22607579316713444, 0.2409564361379295, 0.22734632971784352, 0.19905108902049407, 0.22075147857145994, 0.24612188100355936, 0.24792298638757726, 0.05250109529886193, 0.06558704257732972, 0.04517205695953275, 0.047570309728996785, 0.0637096644411973, 0.06034062865666079, 0.06617123804144753, 0.04729331108868029, 0.03522181133987601]}, "mutation_prompt": null}
{"id": "e82854b4-fa1c-4b91-9eab-1eb52f48018f", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "d60f3989-db51-447d-be1e-907fe0684a08", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "87a3e602-0997-423c-aa1f-9b37eda38ed5", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "ce59aba4-b3a4-4d46-872d-1956e849cb7f", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= (0.5 + 0.5 * evals / self.budget) * np.sqrt(self.dim)  # Dynamic scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce dynamic candidate scaling based on evaluation progress to better balance exploration and exploitation.", "configspace": "", "generation": 81, "fitness": 0.2603060186785558, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8229403011407874, 0.7856523357520165, 0.7770209330584521, 0.7827013231761917, 0.8061371718829695, 0.7528177340658281, 0.7799539661854169, 0.78656519625437, 0.7460521691026354, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08531361617038491, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053459822015798464, 0.08393158385885613, 0.07879214221475961, 0.11810675261081582, 0.09661042220932248, 0.0400304897762469, 0.07024151083162722, 0.12869764304639697, 0.05784791997086636, 0.10737825461835104, 0.04866833421840655, 0.032218338610978, 0.08089141696693691, 0.10208918303794512, 0.09253531467285137, 0.06427016054467227, 0.07326092518927707, 0.08817792826756232, 0.9831024683592781, 0.9827560780207081, 0.9834152979059078, 0.9590812775557095, 0.9796382005002173, 0.9868571789536158, 0.9774321220190014, 0.9701212427540156, 0.968021773713046, 0.5977327601322752, 0.5163514007926229, 0.5609420548203043, 0.5706632189292757, 0.5464843730041593, 0.5675099452881174, 0.5338132686563352, 0.5556752757970722, 0.531385922132415, 0.32623267165882397, 0.17110383588348255, 0.2210876468602102, 0.31651041047330464, 0.19995564600059856, 0.2563946063253939, 0.3254064905809476, 0.2372139330818247, 0.34200658398998895, 0.1329789682109891, 0.23232697654165801, 0.20307116118517765, 0.2060789545897348, 0.20928830420600353, 0.2196148427868323, 0.20601929984482714, 0.13268163518524456, 0.20749547071836583, 0.19243505940033045, 0.13757710573681015, 0.12386131186504867, 0.20396553714491406, 0.21819925607328194, 0.21183003131641842, 0.372373673468668, 0.19769378224767276, 0.1344135393849918, 9.999999999998899e-05, 0.007735820991002562, 0.05777415888438975, 0.06966041027608738, 0.02845018887833395, 0.10557625026538298, 0.00890923109068631, 9.999999999998899e-05, 0.11047926261170993, 0.11843071237612568, 0.08764809631052628, 0.08668642153983253, 0.10655647166554649, 0.030792115051682778, 0.015821768840750705, 0.1306819117701079, 0.03498501044569369, 0.09510196532724913, 0.07442823606206328, 0.044331522323877603, 0.10673690969500238, 0.21391591604379212, 0.16065141048744225, 0.2300421355724498, 0.20046615073821872, 0.202808601656277, 0.07372281230313349, 0.06147080204368727, 0.10748725799369807, 0.1860877945223468, 0.12056233781097236, 0.0277634871004655, 0.057391745299027574, 0.14364103741946999, 0.12470903945584799, 0.08942521593452024, 0.5285986570527896, 0.5566058428671717, 0.5038544873432561, 0.4928871292285285, 0.5203989155695177, 0.5054348948071925, 0.514165054955192, 0.5247368819069103, 0.5228260270881702, 0.0818117191443769, 0.06715480188029599, 0.07284193262495542, 0.045805879321699106, 0.08330421077381656, 0.09879547649443188, 0.16394049069649663, 0.08232288816098188, 0.11287308548079178, 0.18359406990612892, 0.17377298319931944, 0.4642081114892773, 0.20438777518180617, 0.20601903584376113, 0.23886725359641148, 0.2685051180168302, 0.2817932168652747, 0.19034919464427458, 0.30569787835975426, 0.3672975217287622, 0.1696903743711562, 0.18213606688691186, 0.15423487926941504, 0.15691223223057116, 0.17244385657586225, 0.33281013938675263, 0.15527788874168713, 0.08549629080831056, 0.15322583662327127, 0.19260915651955524, 0.16394592843322842, 0.36343387306313957, 0.0945672177055249, 0.20796349465835962, 0.17434484158854902, 0.07562740485644004, 0.17894505030430496, 0.230894420558304, 0.23661032910663227, 0.23984193355860994, 0.2684181868055302, 0.22748240987906554, 0.28894438382995424, 0.2581238577996674, 0.2202462860401504, 0.19903980394846132, 0.19146551685079805, 0.19231673406622274, 0.21166417786133096, 0.16932498921594652, 0.18315948385667258, 0.19305638691934213, 0.190369155961728, 0.19472327597309813, 0.18969793128694112, 0.13751064733091622, 0.9617883465548481, 0.14956801323343172, 0.15945187870078958, 0.9428307952093914, 0.10891426824215811, 0.11540006139804193, 0.15513164455905604, 0.9046125457794486, 0.11313758283321951, 0.6951150349958376, 0.1580517819998729, 0.21451981715671775, 0.21256505755017785, 0.7200249211484042, 0.16044800153055583, 0.6164656646967108, 0.22341066602554194, 0.2374479070592591, 0.24690219157567772, 0.19517492873727593, 0.23846639683324045, 0.221124007144208, 0.23248222224793247, 0.2649521031992257, 0.23555919666000447, 0.05193001263745578, 0.09802459659352336, 0.06190019216099685, 0.05687030215891742, 0.09128324705062696, 0.15665264388451483, 0.1284930741042858, 0.05331340625791914, 0.07158685521444919]}, "mutation_prompt": null}
{"id": "e6da2444-e856-4afe-bbc0-cde2cf1f097b", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "2a2f41c4-aece-48b1-affc-1c3cb311c810", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius *= np.exp(-0.002 * evals)  # Introduce exponential decay\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce exponential decay to the perturbation radius for more effective exploration-convergence balance.", "configspace": "", "generation": 83, "fitness": 0.23912252290425967, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.28.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.9424255648986732, 0.9421048406114614, 0.9445676315773444, 0.9342636328856383, 0.9424144662534135, 0.9355678852916152, 0.9407264496664793, 0.9432181704015156, 0.9371385102834626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01979921358068837, 9.999999999998899e-05, 9.999999999998899e-05, 0.01907159144456705, 9.999999999998899e-05, 9.999999999998899e-05, 0.12105720496405081, 0.09084586049374499, 0.011977883878504514, 0.03464970939313694, 0.02674885335599042, 0.03649732717767207, 0.05832844175066332, 0.06918170719124705, 0.0518223205084567, 0.06976279815304243, 0.05120147999729019, 0.025281695387295633, 0.015217885553683974, 0.03747053534339162, 0.021076532690796013, 0.04418180052733656, 0.06495843372987509, 0.07745849908184188, 0.9919781843380037, 0.9782423786656181, 0.9253882993297085, 0.9577703055288874, 0.16870552248116377, 0.9628042268169633, 0.967996161057877, 0.978277239330038, 0.16325079114910734, 0.8448103617059582, 0.8642626622974096, 0.766101543063486, 0.8502239802598479, 0.8896460504992565, 0.8714062414903849, 0.0572730616718059, 0.25385737726602153, 0.8544063522336874, 0.13171086929026843, 0.14094866420742092, 0.0984665445408811, 0.18860259518190436, 0.17325903687527622, 0.14879394968649717, 0.1984817230047875, 0.12023536124588408, 0.18022954866687746, 0.20339479877982514, 0.20441946877409867, 0.2002904791022071, 0.21416761037915033, 0.17854609245285014, 9.999999999998899e-05, 0.19621944104263656, 0.22358745285310866, 0.18794291424528842, 0.2041598819840471, 0.16743153733832206, 0.1260650833746707, 0.2212073806617072, 0.2832771349282981, 0.13481889583310147, 0.28186712053162244, 0.18188641203375078, 0.17472927972779784, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04024495663656402, 0.0884934035791124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010093699803405465, 0.05566304534509603, 0.1267655000091008, 0.06531676771224393, 0.008222735499840983, 0.008568099268111973, 0.18650255487676037, 0.03704940593948525, 0.051356142687526196, 0.3025954130215772, 0.039503711427538835, 0.04905033087187727, 0.23117666042677854, 0.12104652197110843, 0.08482159628876529, 0.0821238405565562, 0.1092792835873091, 0.08682921391905818, 0.06743865419764461, 0.1406939141500868, 0.06351517575926924, 0.46576428331707465, 0.35627700618018976, 0.07284640015076949, 0.14393796714521445, 0.27217209086739136, 0.09177562422388386, 0.5562010627776137, 0.585041009853287, 0.591084140179776, 0.54479938329501, 0.5592653610910447, 0.5447340474997882, 0.5523299670142172, 0.5899139697521524, 0.5810885903981489, 0.10963285483723462, 0.049337266109586886, 9.999999999998899e-05, 0.026657578148205352, 0.05082132270963702, 0.06553587349433398, 0.06515865370774832, 0.09131028106441519, 0.044056010943677726, 0.18726361920482382, 0.17465452759493405, 0.16181521974826119, 0.15017845436353439, 0.2092656978409394, 0.16219713251325685, 0.20364979429655627, 0.13549881544582, 0.19661564112792762, 0.12983862306591964, 0.14521892388453184, 0.1434741426907331, 0.17630089249309933, 0.1659217333718831, 0.1538873649212663, 0.14337727360589392, 0.11763943384897879, 0.1575253703330003, 0.06621112779642624, 0.07064783369272098, 0.0592004526546942, 0.1295235439161514, 0.09880836915861368, 0.07336608659325827, 0.11391137414270669, 0.14426125444713567, 0.028777006474913103, 0.2735267381137223, 0.1327093900219739, 0.17948595197882955, 0.15803640309332767, 0.18159081864475635, 0.12734388736178937, 0.2251722236328937, 0.1615845281561562, 0.15507294425255846, 0.16079916507805558, 0.17886134961179978, 0.18208735377567942, 0.19229670689842493, 0.18312508050957754, 0.1778590633519498, 0.16775339155530733, 0.1569049562807553, 0.2573126850221017, 0.9571428330650903, 0.1376260789376751, 0.17865883190782605, 0.17140416703275296, 0.13123341956502677, 0.062034754589574415, 0.1088717864952683, 0.12676686857236874, 0.16836590560131737, 0.9718454140309468, 0.11349488594373291, 0.5907677093590781, 0.21362648407563134, 0.2140341979999385, 0.21178166228137874, 0.5066509407822066, 0.16813007090968768, 0.20907825800003588, 0.22631917582712435, 0.21386235418932253, 0.2303789178868858, 0.2891464837667135, 0.1991722624183967, 0.26698577097369414, 0.25457297524462996, 0.30985163515737624, 0.25988373601721415, 0.09890441509149583, 0.05294373923741169, 0.05520686597765767, 0.05667098965704265, 0.07825541750157938, 0.04726353764933733, 0.13488782898523877, 0.054840989496097614, 0.04140292223009567]}, "mutation_prompt": null}
{"id": "a5e9a699-996b-49ce-a97c-f963a52aebe9", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        phi = 1.61803398875  # Golden ratio\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            phi * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Refining candidate generation by using adaptive scaling and incorporating the golden ratio for enhanced exploration and convergence balance.", "configspace": "", "generation": 84, "fitness": 0.24195561429289925, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.24.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.6796278796304847, 0.6916831517504849, 0.6561972427469598, 0.7106935416866115, 0.6968064324135543, 0.6691890535972259, 0.6742326692123026, 0.6985697402247424, 0.669918518678682, 9.999999999998899e-05, 0.0003609835720701504, 9.999999999998899e-05, 0.026782360757796275, 9.999999999998899e-05, 9.999999999998899e-05, 0.043542565829923996, 0.04774338204697015, 0.016814558845946292, 0.11543344026965019, 0.11794736579117548, 0.0969154732186347, 0.1096821281898348, 0.12312893588819185, 0.09466488599007827, 0.07786565537964363, 0.10866792120815683, 0.1604823192677879, 0.06077845548067995, 0.04343013772442317, 0.0684874547341977, 0.06997904995287096, 0.13217762492145557, 0.06266745383467953, 0.08254563224441513, 0.095262800594486, 0.08204485914023041, 0.992621158449464, 0.9848892472706869, 0.9937089806361212, 0.9925769161491713, 0.9893391994160118, 0.9845172629399455, 0.992289046219119, 0.9815757756080079, 0.9882878622787956, 0.47106871654367655, 0.4714974523352389, 0.4487560207450513, 0.44808477709539996, 0.5124293897763029, 0.48890103992684075, 0.44619543097980163, 0.47936875742311025, 0.4567957624813549, 0.3195889291392223, 0.1669949613877748, 0.33779409802828053, 0.20919909721643137, 0.21498204820739453, 0.2771965464006866, 0.7387112319296413, 0.23846756868974484, 0.23466085567285877, 0.13325585585934674, 0.2060206820398094, 0.20037131286105603, 0.15433773714428933, 0.22144257870898731, 0.13191720072282676, 0.11222103559290808, 0.15708522914989842, 0.18487148726698055, 0.2896999100524409, 0.1817763952797532, 0.13181884293221335, 0.1292179700762508, 0.18378637911161644, 0.19305358210098034, 0.15686455988796422, 0.17745361616657518, 0.19677096701164898, 0.0024663442747836495, 9.999999999998899e-05, 0.057616970066314055, 9.999999999998899e-05, 0.001183198977887101, 0.004994899788632434, 0.0011147437484647638, 9.999999999998899e-05, 0.028437313650363505, 0.06187941758960824, 0.05093246184674283, 0.06546864554172493, 0.11428362156769911, 0.05097701075450567, 0.017588524922282467, 0.08926458823951777, 0.07166616897598266, 0.06679298838899217, 0.05983497162804596, 0.03221243720831968, 0.039069802206679216, 0.09525329651520664, 0.11063013509412578, 0.062234176690310616, 0.11297950635066589, 0.10819170625461594, 0.08123426822928237, 0.17679992526615151, 0.050385880739972744, 0.16484429980351611, 0.15498047038845686, 0.05102546099991123, 0.1210564241091604, 0.1455152341546727, 0.11468300886333094, 0.10575591446901378, 0.5120373818237616, 0.45369032473573645, 0.482190070536507, 0.48893815594023904, 0.4818816737974476, 0.5052243829067238, 0.4581164804454555, 0.4788411540266453, 0.47303861826700544, 0.18497272822091526, 0.06328842678395563, 0.10046032279648898, 0.11119820865257601, 0.11727830059231514, 0.07789296726651807, 0.1248953623426089, 0.0856564069235054, 0.09967082714522602, 0.15284371357107918, 0.21140603039023986, 0.1896170097890586, 0.1730586296582003, 0.35689216506517585, 0.16520673991675283, 0.16768716681630846, 0.1742519582522546, 0.2154714430969512, 0.2140931643254761, 0.29510620426211265, 0.15690138609427617, 0.23430297119701204, 0.2644938350090018, 0.33183317484133223, 0.3163636350176283, 0.2936004219602032, 0.13533529070589723, 0.21253992552632683, 0.2985022193041531, 0.16498081107849227, 0.2196494795416959, 0.1653264222754326, 0.12459844058290692, 0.160384370981837, 0.2309849121012788, 0.06712881025880002, 0.2898773311177656, 0.1813744081055958, 0.1695563072378118, 0.1983960293455591, 0.21267067832129294, 0.25060590691732654, 0.20067481323865932, 0.16173409899422186, 0.19707030431363926, 0.1749440098951638, 0.2030455883783715, 0.17371261998518472, 0.17750583572990586, 0.17568465899021135, 0.20153794983227646, 0.18649568658799287, 0.2120217875790884, 0.20138316232214415, 0.15994214373908522, 0.1620864427662072, 0.17214387686452537, 0.1704207784877111, 0.17984171590481424, 0.9094200203536326, 0.8824102690635753, 0.11515422360607919, 0.1884116489691905, 0.11241662209060155, 0.21196950162013828, 0.11186253681631186, 0.21351592686508492, 0.5727836003601219, 0.5591844217042307, 0.19614539682241627, 0.2151869239331341, 0.3581761415542253, 0.20603923116100697, 0.23331930911246312, 0.2082302837977381, 0.20330628005942586, 0.2159100129703474, 0.2338146475229208, 0.21207151710908811, 0.20438072609772107, 0.23619160874598788, 0.07611578788640194, 0.11298662689174666, 0.06536020471239334, 0.07018513948503091, 0.10746282980956368, 0.105112035455873, 0.0940562293685554, 0.09322187060993381, 0.07461188619225723]}, "mutation_prompt": null}
{"id": "9633a9cf-15ae-4c0a-a35a-b901a22d772d", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "b08115dc-f490-4710-b190-9cbadbcfbe2f", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "e210a025-3b9b-41a3-a750-a1aa963acff8", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "d4da6453-e93b-4d53-a34a-8c084325d6cd", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        # Modified line: Combine Cauchy and Gaussian perturbations\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * (0.5 * np.abs(np.random.standard_cauchy()) + 0.5 * np.abs(np.random.normal(0, 1)))\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Improve adaptive scaling by utilizing weighted Cauchy and Gaussian distributions for better candidate diversification.", "configspace": "", "generation": 88, "fitness": 0.24358587688448838, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.25.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.7818413053026347, 0.7991975814654418, 0.8002666009606862, 0.7940987414093306, 0.7969067461341154, 0.7952153689303108, 0.7793457748974633, 0.8181869738545071, 0.7473604736267028, 0.005156978930051848, 9.999999999998899e-05, 9.999999999998899e-05, 0.04181900817874962, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041831500851309156, 9.999999999998899e-05, 0.11342313284503835, 0.040880101625821785, 0.024598470927995164, 0.019416838974777972, 0.06979087226803027, 0.03250059865162369, 0.08025982754215488, 0.11613497221664237, 0.02519090864099094, 0.10147027845312828, 0.04598405202385747, 0.006676970913311209, 0.03827925337886262, 0.039507292554915696, 0.03016467037533499, 0.10755329013208736, 0.05732152044376493, 0.04385877120280002, 0.9520081287301494, 0.8323294877986493, 0.8686247061828398, 0.9500104107246808, 0.8389657991095676, 0.9628568723060363, 0.9409867663173566, 0.960971817254451, 0.9325185200029428, 0.5784434260494855, 0.5936996171754118, 0.5968877163171171, 0.5434665458948806, 0.5718927428242992, 0.5445444170607139, 0.5697333785523144, 0.5469981172938683, 0.5498768808873955, 0.2095123714920304, 0.12703026834649156, 0.1556620995068253, 0.2847161513774461, 0.19332831359033087, 0.588478192171878, 0.18882165554461838, 0.1916414195564624, 0.16174496251867276, 0.2489417387183469, 0.23013772110958675, 0.1648280049895764, 0.20383420145709008, 0.13585927704242862, 0.21349858576339453, 0.2190390182957026, 0.24100972939117982, 0.2103379979413117, 0.19884667574302461, 0.15776181530047817, 0.12465544023774566, 0.25551211917628713, 0.13337133586496552, 0.1370030292632366, 0.20767169564329102, 0.38779017020354745, 0.21365364842969414, 9.999999999998899e-05, 9.999999999998899e-05, 0.011145173496045602, 0.06746050820293825, 0.19517505996505757, 0.084654634043419, 0.003388559654998957, 0.005495662463050555, 0.0668524910800552, 0.02287422823155505, 0.09013083602414973, 0.15834315085365236, 0.09382949445617927, 0.0208716618098721, 0.021291738143536576, 0.13739673568824495, 0.03631088198960164, 0.1583608818462331, 0.23007401660231064, 0.06795354448364921, 0.034252175787928496, 0.07906045975331821, 0.07961748318238893, 0.08668198818457917, 0.17095834328059356, 0.11236055050610283, 0.07572201095276287, 0.12547420724354796, 0.16583925068455863, 0.06348487175612516, 0.12058765589083009, 0.06251612797406048, 0.02576919365593744, 0.2026917605551335, 0.16679937987108462, 0.11253659158770146, 0.5606786110814425, 0.508828077548723, 0.5783167851123576, 0.5854332546611445, 0.5668536003755668, 0.5129607905670635, 0.5200105431224169, 0.5517025401409874, 0.5129949500764294, 0.08071299335516802, 0.11146133932346713, 0.06282829342484875, 0.040208841826886554, 0.08102313412830209, 0.09113926590953902, 0.04477790147420657, 0.09472978259032994, 0.084014585942635, 0.18853384016260344, 0.19547808864512617, 0.32953502978681914, 0.42694184330718654, 0.1653055982040671, 0.20596734781759196, 0.3032689811408903, 0.20939311103469394, 0.1291921134418439, 0.17804580960715632, 0.10314215112844705, 0.11622229157309827, 0.36516307360212075, 0.13731025225153515, 0.2019801836937516, 0.13603185446323385, 0.10844716996882875, 0.09429496098410761, 0.21190966581873594, 0.049228086489783496, 0.04437661168670837, 0.19408341399751416, 0.2571869219688965, 0.10046759078779754, 0.18912759613934227, 0.052660815111870374, 0.03345310114879452, 0.20366761372932785, 0.1804483295849426, 0.18527762450928853, 0.1850819744705906, 0.2282031265190929, 0.19414811925207964, 0.22943683808321824, 0.1622593891684042, 0.20088788736610963, 0.1793256096957866, 0.20112787131309018, 0.21123122805959882, 0.1828811126085167, 0.2027853078087365, 0.17302576188916174, 0.20224919896050375, 0.18108121680558964, 0.1907904600708995, 0.18943969247689751, 0.1375867689890441, 0.0996104942301026, 0.17354779857396585, 0.11322200389906034, 0.9607708174854847, 0.10878920299017703, 0.12738735377319665, 0.15512211502580653, 0.7760092515264951, 0.11357453288014274, 0.6645674200993801, 0.10887906550229931, 0.2140908381817539, 0.21236657554296567, 0.663438306962624, 0.16831651425911864, 0.5769634757876569, 0.2729100938857759, 0.20155609590759171, 0.233006829164759, 0.24840323929698327, 0.21338848743401584, 0.2464252044780214, 0.21628486142419157, 0.2750257761698254, 0.21465816625503964, 0.08404371131064581, 0.0435164799200255, 0.06465153990768957, 0.05710838170957955, 0.08072600998524848, 0.0671392112815975, 0.10883953655279932, 0.057965338606513095, 0.08538357428256493]}, "mutation_prompt": null}
{"id": "e1156cef-d48f-49bc-a7b8-0f623a20b581", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        \n        # Use Lvy flight for perturbation\n        levy_flight = np.random.standard_cauchy(size=self.dim)\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim) * levy_flight,\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Improve candidate selection diversity by using a Lvy flight perturbation to enhance exploration capabilities.", "configspace": "", "generation": 89, "fitness": 0.2578685428897311, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.7673195263996078, 0.7432167869778584, 0.7439822106389435, 0.789256754923586, 0.7609046787156271, 0.8283219827770087, 0.7855716934626042, 0.7955324738103663, 0.7681368156248392, 0.1928092366948132, 0.08816787353049371, 0.16078908986876317, 0.1316939574680266, 0.08826124806226932, 0.11455783256199048, 0.1158836755979088, 0.1360907010977167, 0.0978480408038398, 0.10972160113661322, 0.12557422661436846, 0.16281585675655408, 0.15439594965055237, 0.2448133155046186, 0.31992786496469283, 0.10638942717669109, 0.18904687778723883, 0.12154616153177844, 0.1392912346669718, 0.11418882478374837, 0.11248646741262724, 0.13658245704923044, 0.16078805731302015, 0.11008517577049493, 0.1441084619869789, 0.12267418198881663, 0.14818295508862434, 0.9863043051575827, 0.9870551593392739, 0.9944002877273729, 0.9683512101943565, 0.9860348971870081, 0.9871455037844254, 0.9801155182043061, 0.9855793611576775, 0.9896845018405522, 0.4820897832977493, 0.49208753061676114, 0.5508110380174459, 0.4617408592214358, 0.5157736478372115, 0.5522442537331981, 0.5131253745982365, 0.5081487463973919, 0.5008703863620425, 0.14207062674077608, 0.20109693311317212, 0.15812983753683274, 0.20977051243240452, 0.2182792262757296, 0.21309573400631698, 0.22093039031100592, 0.16681270869441922, 0.19571120776185658, 0.22846942715026541, 0.18270594104211235, 0.1982385962954858, 0.13583680937893494, 0.2088917677680866, 0.17480908281504748, 0.3158298414292581, 0.20345746905605477, 0.27840102420932444, 0.19339893870154246, 0.2110075990789676, 0.12499642124187615, 0.20162042395548185, 0.22335377585601268, 0.17658179192389833, 0.22430135222361436, 0.13304469177083633, 0.1685360134536229, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022931724265619735, 0.053619673478327745, 9.999999999998899e-05, 0.00010327639698970437, 9.999999999998899e-05, 0.06216869930062641, 0.10588234826447018, 0.10211174302897785, 0.08701547501518891, 0.09152355485568553, 0.022078099020309327, 0.06612432928795753, 0.16974853670502965, 0.07650431401069069, 0.04643038769805241, 0.12051493344406261, 0.054920699662303174, 0.18898701031777076, 0.16178567677927969, 0.12527394908259626, 0.0829402214583973, 0.1254062628257787, 0.10169213953744238, 0.08209313144394581, 0.10786750249725774, 0.04766318224711508, 0.13946289995222305, 0.1921784191466398, 0.11886209025798145, 0.01585384446669391, 0.1765882341764785, 0.11887006706268599, 0.08617819826340112, 0.49296701771503626, 0.5233357254269381, 0.5168954873354759, 0.5425256825395778, 0.5413402176389668, 0.5149741854614407, 0.525970216882711, 0.5227595643913705, 0.5145104338112672, 0.08118085852665424, 0.11806554359751842, 0.12001190158212172, 0.16173436002736197, 0.08078710302432524, 0.056541912969259145, 0.08149600044033045, 0.09127500978172376, 0.13723017833983597, 0.2461273787214977, 0.18722291015657344, 0.15884292006680467, 0.216049873267265, 0.22789229691695723, 0.14633552207487577, 0.23125802153543373, 0.15305465497224613, 0.19505181248965708, 0.20760628610711207, 0.35244871271747646, 0.12624442054613505, 0.2678020127196278, 0.15077878945035394, 0.23331116538197783, 0.17651664509170462, 0.24129979307173488, 0.2581722605755744, 0.10153795681933064, 0.09371575648150587, 0.09908703729804147, 0.21450283702989525, 0.13134315424605536, 0.21038020414096015, 0.24530114704215988, 0.1348273017460957, 0.13654211577786823, 0.2341617967862033, 0.2295083042227507, 0.2733086618362527, 0.25174923542344285, 0.1636493601243879, 0.25538168686840657, 0.24663929111674, 0.15050629666784154, 0.18387559595339298, 0.2103977009029523, 0.19666092012445613, 0.20927420362778792, 0.25812727540629055, 0.21165540470263366, 0.17867233299026053, 0.19603117519662427, 0.20330186072963674, 0.19353123398324756, 0.18980002112752614, 0.20122874131742519, 0.945204051945665, 0.8626694831233572, 0.16811669381892103, 0.11734903336028857, 0.10867263533514993, 0.1272785072321223, 0.10725793170897868, 0.645908621910251, 0.11342567695999173, 0.12841436477483315, 0.1285549639470468, 0.2134269210373101, 0.11290348752768664, 0.7380366739684796, 0.16470973348765638, 0.6057875702740194, 0.22837077427468233, 0.22774518513868147, 0.22140038297102171, 0.23914594161739322, 0.24556129317797348, 0.21347038597750057, 0.25463708152901243, 0.2027303657230365, 0.23510243295580247, 0.1476622969788015, 0.09736416429036143, 0.08834922565119163, 0.07084182630102709, 0.06473600654976797, 0.094977427218499, 0.07569848909514798, 0.09611184526265115, 0.06788349496568824]}, "mutation_prompt": null}
{"id": "3e1122ec-3439-4ee9-a50d-2af92fa5c254", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        # Change: Apply exponential decay to perturbation_radius for enhanced dynamic scaling\n        perturbation_radius *= np.exp(-evals / self.budget)\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Adaptively control the perturbation radius using an exponential decay to enhance exploration-exploitation balance.", "configspace": "", "generation": 90, "fitness": 0.252817355899879, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.26.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8302006370488151, 0.8537091199880233, 0.8479196944275301, 0.810130820519289, 0.8865384874531325, 0.8131004621887772, 0.8750590398945325, 0.8602558896034667, 0.8149177538608441, 0.013305637565879214, 9.999999999998899e-05, 9.999999999998899e-05, 0.018507387573903133, 9.999999999998899e-05, 9.999999999998899e-05, 0.041594241232786544, 9.999999999998899e-05, 9.999999999998899e-05, 0.12743118675834664, 0.06278027340677217, 0.04467256477258674, 0.1085300692822655, 0.0979351130268209, 0.10772064638371326, 0.04460791096753003, 0.0761141290272862, 0.09169263347363854, 0.0695161978426968, 0.07139964982700897, 0.013160692413155428, 0.05012392355670403, 0.09440977172750009, 0.0720059230106519, 0.06095438398725128, 0.07552038513127934, 0.04077886508245787, 0.9919860317228592, 0.9783422659458116, 0.9823889667125343, 0.9577981066991175, 0.9558838872534791, 0.9796118943239016, 0.9699810717561312, 0.9846606330431804, 0.9427211437376903, 0.6455116205211564, 0.6338473152266477, 0.5876120122655719, 0.6609495447839895, 0.678279778557706, 0.6011614193682433, 0.607161588537418, 0.583879492807036, 0.5657577674437464, 0.22910522581777848, 0.09882867784826377, 0.11794921090096577, 0.21152030315278747, 0.1613410779152339, 0.2762038222414681, 0.1752888946976, 0.20042484303810215, 0.23160763729596912, 0.2299697605836183, 0.23418652082965774, 0.21352037342069852, 0.2194648868389555, 0.1334021470999449, 0.12937259041362525, 0.23140672293586406, 0.22914958463531943, 0.22797821936964235, 0.2351779567811425, 0.20774620148513767, 0.12273217056472763, 0.23247202606269501, 0.2263267485078403, 0.13763273870527615, 0.3591770034642692, 0.13489796873518467, 0.1997042593910422, 9.999999999998899e-05, 0.041319039442743066, 0.14411490394757187, 0.002833732176798165, 0.09941302054316625, 0.12890017900332718, 0.004767650258536205, 0.006473702691244254, 0.08767447200064016, 0.04280769889857017, 0.06569411547124748, 0.11244495387666575, 0.08952290147393338, 0.01504053293776364, 0.012698198154415863, 0.1415109538249839, 0.041470176319829966, 0.06638245265514198, 0.20210232024092123, 0.04127104213282473, 0.054442214217992335, 0.26444328872264455, 0.09053332405925707, 0.08266244440124759, 0.10849327097396966, 0.2501933430138099, 0.08150514862472158, 0.1640822066434463, 0.14145772053924155, 0.07947034134189868, 0.1906446699176898, 0.27229342312082494, 0.09881106169755671, 0.09010521477870193, 0.13968927976452628, 0.10086529699380475, 0.5634797711116442, 0.550100175372545, 0.5656096190515525, 0.5605820226307173, 0.5183235141954365, 0.5086100514043314, 0.5613929743074951, 0.5219848570277906, 0.5571617764324952, 0.11298575722471926, 0.08093912565402539, 0.03929115886302259, 0.04800467083712645, 0.08531105016140483, 0.08765419675597419, 0.0833823523593552, 0.07460460357404441, 0.07252101885262185, 0.23722895182576254, 0.22001457882992592, 0.18796577582468377, 0.13079147291325677, 0.18990639540016774, 0.16737022064897533, 0.17430756212232268, 0.17367516249403436, 0.22442229556981552, 0.21786425256698772, 0.13953321419676923, 0.1106583610490115, 0.18488850034459947, 0.1767780195039641, 0.15144444284727887, 0.197182457888608, 0.2777202008725863, 0.170201591269609, 0.16903328429664233, 0.16315429505818901, 0.07670366330283929, 0.12432159135653675, 0.17543334525829413, 0.1101737349615205, 0.19469487233491123, 0.13608981475279958, 0.06879833311410366, 0.1795345267825651, 0.1765686801174694, 0.1965344145321224, 0.26846895113472125, 0.17980444451556854, 0.2360125597369359, 0.20398191515478692, 0.1917455984053389, 0.1907912284118991, 0.1724947667012966, 0.19269938295960742, 0.184030959653953, 0.16143095062658974, 0.18300710494456296, 0.16676342642212205, 0.17879802910869835, 0.20153596659553408, 0.2008984219850216, 0.9516897885366766, 0.13692120100609495, 0.14864365365471932, 0.17239777970892467, 0.14433726541440905, 0.11537007887398709, 0.17022823442828172, 0.12734302252569274, 0.16836048659960634, 0.8522141352796759, 0.19601112292910672, 0.6930514495645415, 0.08332310648572516, 0.21402361302053607, 0.2115668209275734, 0.7123063717885698, 0.16706716413279243, 0.5712601753788648, 0.2237075316508479, 0.3065266026663761, 0.24017384320266366, 0.23489672114651738, 0.23673236288757615, 0.22988314674544674, 0.20627937033970112, 0.28963625652346636, 0.3433910885441661, 0.08596659202209522, 0.07449746808003088, 0.045648321135488, 0.06137033002020631, 0.07722336398008078, 0.04419343000286102, 0.08536099809678632, 0.06958154417982931, 0.06441811934933084]}, "mutation_prompt": null}
{"id": "206bec75-39f6-4d27-a94a-3560d3bc5d51", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "38e66e6a-5155-4b5d-a4e1-688664443c12", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "6522e339-369d-4167-844c-70c0f4dc15a6", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius *= (0.9 ** sum(1 for i in range(1, len(self.history)) if self.history[i][1] >= self.history[i - 1][1]))  # Success-based damping\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Introduce adaptive mutation scaling with historical success-based damping to improve convergence.", "configspace": "", "generation": 93, "fitness": 0.19990892474636843, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.26.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.9709299882197627, 0.970918223197934, 0.9659694453158122, 0.9514217759632895, 0.9605906136425615, 0.9588934395799216, 0.966212592001321, 0.9659877315091386, 0.9578911284827609, 0.010855088419146508, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1215652843336329, 0.05211163376256267, 0.026047464030968692, 0.03375878499534868, 0.010340202328714798, 0.03759727251121747, 0.06756748516920796, 0.03656663788012904, 0.025988242779977355, 0.06993131003497599, 0.06932620022898806, 0.008820487538472865, 9.999999999998899e-05, 0.05055763218306586, 0.013770153094582738, 0.11278813376027352, 9.999999999998899e-05, 0.013833493455966184, 0.9919772002936788, 0.978298150614887, 0.979208678073656, 0.23172996458874906, 0.12192367617875755, 0.9796132413118679, 0.1803365951554824, 0.9850265801731253, 0.1260022582760565, 0.49389112902972365, 0.3207157604312735, 0.2471961326688431, 0.8719592399777538, 0.6612563866516221, 0.47267974027199144, 0.04082665819549525, 0.8888548843958056, 0.9079436464446353, 0.12397293301385981, 0.08551255341420161, 0.029246952860334186, 0.10269567304324279, 0.13971134169550625, 9.999999999998899e-05, 0.12233431930178995, 0.016578389922519254, 9.999999999998899e-05, 0.145454147235894, 0.18471960332415516, 0.14216137143528973, 0.07490013464569001, 0.16132654764600995, 0.003474191081901723, 0.15808182381879687, 0.18582586561482184, 0.16225553910384993, 0.21178238211290523, 0.17869328120466366, 0.12555191560052503, 0.23337980424386617, 0.18194284871316813, 0.13792828418362113, 0.2203351251404082, 0.15077664778773014, 0.16569190465348915, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016458584741263493, 0.05206955283845838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010237000543818042, 0.05195824778584157, 0.11064646271652345, 0.06246257368074015, 0.0026862990212562776, 0.006284102341899245, 0.12574726504848477, 0.024168971813397944, 0.05347976480699723, 0.19328196727191205, 0.04225050346635728, 0.06286775643053677, 0.2536176517249953, 0.11461722700865462, 0.09415054998529937, 0.09998199734671831, 0.2748633627814331, 0.08445389272208481, 0.1301804992326051, 0.17156996067363184, 0.045577873407915304, 0.13855974827840767, 0.3415931636619999, 0.039687996962027294, 0.10000443695371453, 0.09503034358313434, 0.08732877581594767, 0.5210737427010157, 0.5045499278213723, 0.5089853957785694, 0.5252707578441018, 0.4989882998991657, 0.4920563961378088, 0.5183587842126574, 0.5058460430050693, 0.4956171763253928, 0.02539724304749691, 0.0773630812524605, 0.0751102435517087, 0.008872042087369247, 0.043119106575309374, 0.03291868845251811, 0.020926354414886217, 0.05817475694842755, 0.00880322637674158, 0.1685317078018843, 0.17326134878098287, 0.1589683265847046, 0.13227582947563865, 0.12916510047048724, 0.08720264553341073, 0.10341833885987084, 0.12811472024291437, 0.19079885596980506, 0.12856583406215372, 0.10084287247263468, 0.11205692049184413, 0.17442952027410685, 0.11272510335081642, 0.13245931290766966, 0.1376653907084857, 0.08745856623968429, 0.08943097005016265, 0.05290643115109939, 0.04592069663059917, 0.04028204979464367, 0.107231875770323, 0.0644422437390364, 0.07333915759289578, 0.06956745521446406, 0.06279812464740842, 0.02450866519455208, 0.1837457173518462, 0.1325488569342853, 0.14390631057655223, 0.13049054313628694, 0.11605932184266732, 0.1693467889358573, 0.2063422737886611, 0.17905717971837998, 0.16669222963604602, 0.17068337960610114, 0.19283098117131736, 0.17629737517625566, 0.16249400948161474, 0.19084122722838626, 0.1711820460020026, 0.1788919488933587, 0.22919518355644508, 0.1836327492826807, 0.07321255945185712, 0.13762597276899413, 0.0986754321035902, 0.17295281894896775, 0.11120357624927169, 0.06202137663004992, 0.10886253479423635, 0.12479560098099463, 0.168003618978403, 0.7246145630718304, 0.11304505708845969, 0.48588217558957314, 0.2131040408535788, 0.21424024026320498, 0.2110375864163414, 0.3904559558717937, 0.16607342014132587, 0.17189546011119705, 0.24274015943865124, 0.1606331749214871, 0.18051853919393668, 0.17138336123926579, 0.18527476515808528, 0.25454424995156655, 0.22576381229528697, 0.1672294333848806, 0.18237292119270365, 0.09522515833911349, 0.04259965465444171, 0.04149778408757687, 0.06801185554688505, 0.04818669751470939, 0.036169382001284944, 0.07275635104232592, 0.07875138642906587, 0.04319913515011575]}, "mutation_prompt": null}
{"id": "a9e34007-d706-4592-bd9d-2b740007b3a4", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "d49c5e6f-a393-414f-9db8-33840122e170", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "09dac099-691e-4ee6-ab07-65b57b7dbb7a", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        # Adjust perturbation radius with inertia based on the success rate\n        inertia = np.cos(np.pi * evals / self.budget) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius *= 0.5 * (1 + inertia)\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Refine local exploration by dynamically balancing perturbation based on recent success rate and inertia.", "configspace": "", "generation": 96, "fitness": 0.2515422602569033, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.787492911380925, 0.7444585326843858, 0.7440463944392796, 0.7669205794603873, 0.7652046587464587, 0.7641004862491201, 0.7962395695917114, 0.8049399803259868, 0.7809315325609664, 0.006076686860865488, 9.999999999998899e-05, 9.999999999998899e-05, 0.003984279974944327, 0.00034707925334420686, 9.999999999998899e-05, 0.011857430848463246, 9.999999999998899e-05, 9.999999999998899e-05, 0.12802549868700475, 0.09723603429433714, 0.034233757852549895, 0.10835452000447388, 0.06267792587493037, 0.029338954167245523, 0.08199841198203917, 0.07592208081842278, 0.04268258327836372, 0.06948688047789597, 0.07107612840284694, 0.03695420947531458, 0.02515722568529255, 0.09743456405663187, 0.07261554835403616, 0.07603926693730423, 0.046090167990419095, 0.06164477774482202, 0.9919869778748709, 0.9783591950218511, 0.9823920352928985, 0.9658320786889927, 0.9581336912552261, 0.9796488864535169, 0.9699752793249072, 0.9884011337211784, 0.9429086701596576, 0.5412320614059904, 0.5303143974777511, 0.41263125328983474, 0.5511219281047863, 0.5199536370413467, 0.5132637028349386, 0.4340715327269059, 0.4474577030488135, 0.5168178204419398, 0.22864805035093638, 0.12717071977367156, 0.21335193914095996, 0.2152757245044532, 0.27927607903284557, 0.19826954422828535, 0.22241543827198074, 0.19932196833138327, 0.21750606133348194, 0.21410876043313543, 0.2415920106582613, 0.19215292459921052, 0.20970015162823497, 0.17908026094202723, 0.14969129807222037, 0.21350138633828009, 0.24508210688248333, 0.2016704804559778, 0.20520138409185595, 0.1889709446683726, 0.12527484740761496, 0.2182579892055373, 0.1955616672793683, 0.13793343950191883, 0.3532091000130948, 0.19346155442110247, 0.1703937436839853, 9.999999999998899e-05, 0.08326478715073748, 0.12427000743744376, 0.07344003449703962, 0.09472706065153302, 0.07033334287738291, 0.001420810439311193, 0.004692439359341716, 0.0582899630838154, 0.028787170486530567, 0.08506040811329507, 0.13354262769131509, 0.10920006318296871, 0.02678754568195274, 0.01278136138500885, 0.10939049978840543, 0.03974556769989557, 0.07667202258994454, 0.23012096311475483, 0.04091868818204092, 0.05208198921713825, 0.2344774305586801, 0.0875784721582169, 0.08753315609253876, 0.09407471551095348, 0.2302058406578793, 0.08834365671692723, 0.14238189159905956, 0.11946521549609712, 0.06550919480344797, 0.02841411963461704, 0.27179986242448506, 0.08032436932007547, 0.11426879193991879, 0.1344127246967246, 0.10845684810959466, 0.5191782967466212, 0.5049777844457471, 0.5561505488979815, 0.5226095487884461, 0.48375276050566995, 0.5217052760224411, 0.49145529122040765, 0.5066159472098877, 0.5182299699149591, 0.10739307624449645, 0.07468275515560308, 0.1264202171131097, 0.07055916441632759, 0.04612231254777377, 0.08575038971428695, 0.1257061924189169, 0.07989364135349586, 0.08249633224133102, 0.19329582574666415, 0.24850705555300123, 0.19596860370487723, 0.20255735736111924, 0.19830285128194658, 0.23732928282196575, 0.1714593230291368, 0.18037510017191472, 0.17147813194799477, 0.22756750670753867, 0.2047099674758769, 0.21426839184178204, 0.3372793608132856, 0.19614902252889832, 0.15029926833210505, 0.24952402668255158, 0.26502642733303927, 0.3326091887048468, 0.09529364420203323, 0.10123831005135475, 0.13748017250705746, 0.1554568589630646, 0.14310002133286903, 0.09903715817477554, 0.1893648913441549, 0.12581523013513873, 0.08581064368427538, 0.18727879407167458, 0.2324435455588677, 0.17849071365262503, 0.21420241134549745, 0.19009882767938757, 0.18620586106433068, 0.23386786486621292, 0.21425211132300404, 0.21688074467662433, 0.17245559511995867, 0.19267413110809306, 0.1889423937379765, 0.2147755983938301, 0.20422566073701998, 0.2539613277649371, 0.18545333334004388, 0.20151984036520088, 0.17082875804238973, 0.9504799254162841, 0.136938881189003, 0.7043226944249269, 0.1723488749376929, 0.18527563549700254, 0.9176262495607337, 0.17022710933253182, 0.12736185310784764, 0.16835465670378946, 0.8391621597077552, 0.11348799840848134, 0.6126219203930612, 0.3626652239968571, 0.2141525933710755, 0.2115845479671672, 0.5823441901511872, 0.16704996315930853, 0.47773915459310656, 0.19626644516911418, 0.22207865816937067, 0.23505289180576805, 0.2402071583215729, 0.2219733385834679, 0.22018015498476295, 0.20960182537639882, 0.2545793986349033, 0.20991786605985763, 0.09637895459396661, 0.07361880949936239, 0.07539690752685835, 0.08318618643684217, 0.06935755121715959, 0.0933619688378361, 0.09409803240188797, 0.0835710181613758, 0.07147291732842709]}, "mutation_prompt": null}
{"id": "9c8c6053-58c6-41c5-bc3c-2068b059f6d5", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Enhance local exploration by adjusting candidate generation based on dimensional scaling during optimization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8416467010988957, 0.8559275433385946, 0.7802601362175159, 0.8549194301476226, 0.831121698789751, 0.8168402831799679, 0.8399614306747198, 0.8252720491600893, 0.7870544462310501, 0.007432811164209463, 9.999999999998899e-05, 9.999999999998899e-05, 0.010662151763340288, 9.999999999998899e-05, 9.999999999998899e-05, 0.029078975783613847, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273152462190843, 0.06930418928486137, 0.03399557141374754, 0.10831176325575875, 0.11301946276479635, 0.05391920567961683, 0.05232492712261827, 0.07621285439782588, 0.045698750931889465, 0.06942967104833553, 0.0732032380957206, 0.023608871030588285, 0.0260842844100323, 0.08098740448208097, 0.07050814118553006, 0.04773077422967531, 0.09007452566468566, 0.08248790482103008, 0.9919864763853123, 0.9783492798944037, 0.982390396986072, 0.957797625005558, 0.95692991625151, 0.9796293341857569, 0.9699781726892415, 0.9883859290508007, 0.9427989087836869, 0.6048225180320618, 0.5777010764008083, 0.5166504595181162, 0.6121594650595078, 0.609960905896846, 0.5663681902331325, 0.5668321894081647, 0.5786774538449619, 0.600408739569875, 0.22868797102254557, 0.08558027570862359, 0.19373917343583746, 0.2092536981013159, 0.29385758497863457, 0.21009975216354826, 0.25115400134062316, 0.19710126618420432, 0.8269203721992922, 0.21774284723469384, 0.2506694331229826, 0.2108431825149787, 0.20929059429690966, 0.17125762108769682, 0.12304693827811464, 0.22615367032314215, 0.24102395536226873, 0.2155348535703001, 0.22486116380997723, 0.1969732687984408, 0.12272090146799508, 0.24552118999056327, 0.2027017744003048, 0.1376195253702508, 0.36190420375166243, 0.13283374747753296, 0.19494560305637032, 9.999999999998899e-05, 0.006671709225453792, 0.10586720485833956, 0.03674492191992862, 0.08304184398870706, 0.07681327294448204, 0.006869813364703825, 0.005077948578022018, 0.10371344608112065, 0.04372455371012496, 0.06591825544767549, 0.12232280792232797, 0.08523958994086855, 0.01750552568184971, 0.024406288819036837, 0.13529078368358094, 0.0445148686323249, 0.06336608402612942, 0.2174920779049766, 0.04117169365276929, 0.05075250048308921, 0.34047740008805527, 0.08743932661555265, 0.08962539680337744, 0.10748181214660868, 0.24919912922305865, 0.08406875112320245, 0.13551265902739307, 0.14070255621254202, 0.0745700120319871, 0.16464953948054462, 0.23293575279607803, 0.12304074938218024, 0.08757969274968314, 0.12362213720824944, 0.10779052699424252, 0.5451158981323967, 0.5284017458183523, 0.6225098232532966, 0.520431071814023, 0.6076904591041438, 0.5208583102038206, 0.6194790984295453, 0.5517042869505293, 0.5436053736647729, 0.08751300188679889, 0.07523246088136804, 0.09831517255266442, 0.06316447943326309, 0.06471655427590994, 0.10850476289516886, 0.07146233480009945, 0.07997008313467979, 0.11899167224729101, 0.23500758451294845, 0.26412206974189445, 0.3563744881710359, 0.1894897017654017, 0.18798686829736466, 0.21133151908276726, 0.16674760846389214, 0.23834344886816883, 0.2127279126187036, 0.2368296483573814, 0.17951988728963464, 0.18437363021422237, 0.3761620795823787, 0.1943813202304231, 0.15218709094872795, 0.2412776381447418, 0.21410260291511662, 0.15687718378896298, 0.18218615218107548, 0.09025611456310512, 0.23729454197400823, 0.12485519499684672, 0.21198354625775606, 0.1009447522721666, 0.19456139753086665, 0.1240981447774746, 0.06667325262218127, 0.21932123364920286, 0.17155240803856764, 0.20882662207950975, 0.28318899794901253, 0.20483700794621995, 0.2267186027161049, 0.21029355244331793, 0.18065635804243196, 0.18627356875370638, 0.17244728157271183, 0.19263235269352086, 0.20007408560852113, 0.21506503604730853, 0.1828526776600602, 0.1645314900076248, 0.17879531527017567, 0.2014064399633788, 0.18522637048035417, 0.9518660713085036, 0.1369996370944898, 0.8772639443569276, 0.17232706844965195, 0.179860991707687, 0.9179562052116356, 0.17022870200574924, 0.12738635773541485, 0.538877370392882, 0.8468052856444915, 0.11348928798976099, 0.7462298961752388, 0.08332666772686748, 0.21420397064710606, 0.2114814691105169, 0.6769155070989705, 0.16704425087365948, 0.5249208018993032, 0.27403004270117004, 0.2230285030264485, 0.2112635353991953, 0.18042519755259567, 0.20092105105106717, 0.20779289305631132, 0.22293406416709804, 0.2055678764280251, 0.26009876694051026, 0.09241195866482177, 0.1287809886146588, 0.07721993921753145, 0.060419736794735224, 0.07053484829827361, 0.06391334133232451, 0.077396559828534, 0.08443249702007183, 0.06809020510811148]}, "mutation_prompt": null}
{"id": "b8d1e49f-b989-407b-903a-214c730afc42", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget) * np.log1p(evals)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.8 ** (evals / (self.budget / 10)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 5:  # Change from 2 to 5 for adaptation threshold\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.4 * success_rate))  # Change factor from 0.5 to 0.4", "name": "AdaptiveRandomLocalSearch", "description": "Adaptive Random Local Search with enhanced adaptation factor calculation for improved convergence.", "configspace": "", "generation": 98, "fitness": 0.24987154924725025, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.8668824044490071, 0.836726125482481, 0.8402270025573617, 0.8162519184860557, 0.8538779056068821, 0.8098672440830859, 0.8258073038603955, 0.8147731938165638, 0.8003685349996156, 0.012565067453502499, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0055945676819463275, 9.999999999998899e-05, 9.999999999998899e-05, 0.05577838472473917, 9.999999999998899e-05, 0.12896475306268296, 0.07381979655847914, 0.09219148833494673, 0.061194659785575256, 0.08965657390244175, 0.09269530471366638, 0.046452259544317864, 0.06474065248709504, 0.07135074023925192, 0.06727943858984309, 0.07051423365331988, 0.06588686055064696, 0.07255816575024732, 0.06485041876834907, 0.04268906281964591, 0.07093314498229197, 0.05129843166744741, 0.06420981023147687, 0.9848120832388237, 0.9435577244754497, 0.9730483380861783, 0.9971132868378886, 0.9568328822549529, 0.9818252990682058, 0.9676995871973952, 0.9660727345682252, 0.9613124805895154, 0.6177009796873605, 0.5451899687421673, 0.5655799406958248, 0.6283021550776096, 0.6284657376993656, 0.6093659459795797, 0.5792780370182831, 0.5454128406338435, 0.6011196027447304, 0.17292801930102142, 0.10251401589992915, 0.21627990859623136, 0.3731351559942654, 0.20700445055976957, 0.17445864917210907, 0.40788993541810237, 0.22785589496602865, 0.22617249593691713, 0.1378366181906362, 0.24388195691654613, 0.21652511742863967, 0.19174219677026627, 0.24237236505054638, 0.13725640894987878, 0.25341736524808955, 0.22914797479875515, 0.1345514224567772, 0.2257571533634869, 0.19122576449092465, 0.1356796833891667, 0.2323178096636882, 0.11795791606912043, 0.13302831736541698, 0.25341660678337974, 0.3875247864978296, 0.198009083771037, 0.0005104142129191969, 0.056475074516027624, 0.005395182836545387, 0.035623321956722465, 0.055713409133779535, 0.00219614585200123, 0.003990359930774012, 0.006375349237630168, 9.999999999998899e-05, 0.00618863337216935, 0.10411397176445136, 0.13986169105211244, 0.08630745696626163, 0.030398386636133368, 0.019177064995880233, 0.14758294879697764, 0.051513076698736726, 0.05040879599878478, 0.14514635536567444, 0.04707208446815547, 0.12790450749348414, 0.2227334092986576, 0.10389172293618154, 0.21623187782289954, 0.20093635399485887, 0.10259059612640253, 0.09163423778101065, 0.0810362065098017, 0.14489957657910746, 0.05427294450844744, 0.09882201491483833, 0.11632102550415768, 0.16285577920830074, 0.13939401801636508, 0.10622917625579809, 0.21260696763731357, 0.5391245236205404, 0.5198571976830888, 0.571995807530087, 0.5412546374692706, 0.571339211333193, 0.5416131865072993, 0.5658277019489881, 0.5629455087536783, 0.5817134705058895, 0.061217828680075415, 0.08307357569423768, 0.08680844157669709, 0.07121275933051552, 0.08450456775506443, 0.13691740074694003, 0.07965238109820094, 0.050818663845297096, 0.07075107278894643, 0.16422612383313084, 0.14908507831307416, 0.1729126339293422, 0.35429804804246323, 0.15067552152561658, 0.2062825260301998, 0.27577701816187206, 0.2288919012707581, 0.22785549597322197, 0.2076880521281642, 0.27004838675982445, 0.1532176788477838, 0.19882708341675892, 0.24776794621250953, 0.15213923622502357, 0.22833540338899105, 0.15713616967011168, 0.19533504700826199, 0.3074581099726974, 0.17236818459946046, 0.16476728657931472, 0.12702996939514155, 0.22718681605134528, 0.13551669551176693, 0.16737154073034965, 0.13214215084834724, 0.07726517120987597, 0.23931639345786848, 0.1682010362826164, 0.20269161089837107, 0.24977341021642452, 0.20085791909769546, 0.1824535381155793, 0.21278223874933233, 0.15709096989461235, 0.20187798984046224, 0.17593495141318094, 0.17844160281241306, 0.17063339396113186, 0.20252144199301148, 0.18803199719661157, 0.18012536839193327, 0.19219147989837537, 0.18724036360884988, 0.1758461499591767, 0.18963085951850966, 0.13767450786249757, 0.9584130953781911, 0.16779138836533625, 0.15950145040811947, 0.11200748506189562, 0.10882015153025493, 0.11539688229306522, 0.16651767449463228, 0.7714476545503459, 0.11296498713516356, 0.14594211888031317, 0.13177898255080855, 0.21304483398137541, 0.21343064275881984, 0.6321596648724668, 0.16945492443006638, 0.4820119839007453, 0.1972469045902856, 0.23113824562395724, 0.24601122018953525, 0.21702411067773741, 0.24080595083548528, 0.2077600106789601, 0.21590290961435865, 0.2598555628915695, 0.23268783402552562, 0.12735404351920476, 0.09315813075060908, 0.07351659137036548, 0.0402001088008912, 0.04287259339092564, 0.08234847780513699, 0.08392018258685963, 0.0691361012644014, 0.05538901765989379]}, "mutation_prompt": null}
{"id": "9afafc87-1993-4346-8193-e7dfe6806367", "solution": "import numpy as np\n\nclass AdaptiveRandomLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.history = []\n\n    def __call__(self, func):\n        evals = 0\n        best_solution = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_solution)\n        evals += 1\n\n        # Store the initial solution\n        self.history.append((best_solution, best_value))\n\n        while evals < self.budget:\n            # Calculate adaptation factor based on feedback\n            adaptation_factor = self.calculate_adaptation()\n\n            # Generate candidate solutions around the current best\n            candidate_solutions = self.generate_candidates(best_solution, adaptation_factor, evals)\n            candidate_values = [func(cand) for cand in candidate_solutions]\n            evals += len(candidate_solutions)\n\n            # Find the best candidate\n            best_idx = np.argmin(candidate_values)\n            if candidate_values[best_idx] < best_value:\n                best_value = candidate_values[best_idx]\n                best_solution = candidate_solutions[best_idx]\n\n            # Store the new best solution\n            self.history.append((best_solution, best_value))\n\n        return best_solution\n\n    def generate_candidates(self, current_best, adaptation_factor, evals):\n        num_candidates = min(self.budget - len(self.history), max(5, int(10 - 5 * self.calculate_adaptation())))\n        adaptive_scale = 1.0 - (evals / self.budget)\n        learning_rate = 1.0 - evals / self.budget\n        perturbation_radius = learning_rate * adaptation_factor * adaptive_scale * (self.upper_bound - self.lower_bound) / (\n            10 * adaptation_factor * np.abs(np.random.standard_cauchy()) + np.random.normal(0, 0.1)\n        )\n        perturbation_radius *= 0.5 * (1 + np.cos(np.pi * evals / self.budget)) * (0.9 ** (evals / (self.budget / 15)))\n        perturbation_radius /= np.sqrt(self.dim)  # Dimensional scaling adjustment\n        candidates = [\n            np.clip(current_best + np.random.uniform(-perturbation_radius, perturbation_radius, self.dim),\n                    self.lower_bound, self.upper_bound)\n            for _ in range(num_candidates)\n        ]\n        return candidates\n\n    def calculate_adaptation(self):\n        if len(self.history) < 2:\n            return 1.0\n        else:\n            recent_history = self.history[-10:]\n            improvements = sum(1 for i in range(1, len(recent_history))\n                               if recent_history[i][1] < recent_history[i - 1][1])\n            success_rate = improvements / len(recent_history)\n            return max(0.1, min(1.0, 1.0 - 0.5 * success_rate))", "name": "AdaptiveRandomLocalSearch", "description": "Incorporate dynamic perturbation scaling with cosine perturbation modulation to improve exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.2560655774876647, "feedback": "The algorithm AdaptiveRandomLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "6d473c9e-0ff6-4ad1-8250-a5c4d7451617", "metadata": {"aucs": [0.7820506941616284, 0.7918156907831665, 0.7789567413279067, 0.7795819654676326, 0.8292512391203156, 0.8197148681298705, 0.7733541917022835, 0.8089697563515847, 0.8083243265466198, 0.01212545111143204, 9.999999999998899e-05, 9.999999999998899e-05, 0.002836080520250084, 9.999999999998899e-05, 9.999999999998899e-05, 0.051310558082216406, 9.999999999998899e-05, 9.999999999998899e-05, 0.12803004730197842, 0.06328025073139831, 0.0704979005867421, 0.06652239184664321, 0.11939893091405918, 0.05762105225491543, 0.08610858660125253, 0.07370719628368916, 0.07049123051112605, 0.0695953362947388, 0.07083934928669, 0.06974353780947273, 0.06148062921481667, 0.11307989856149103, 0.09378926458826886, 0.06446652751111082, 0.07469209304710589, 0.05805657223076155, 0.9919879926589532, 0.9682299091710518, 0.974807270102941, 0.9668786212541787, 0.9645662836119604, 0.9797436010556106, 0.973793641391198, 0.9884054408242032, 0.9437391627350348, 0.6343890192063231, 0.5982483230991473, 0.6104256099515304, 0.613969042706141, 0.634390900095859, 0.6112002665980452, 0.587412543235153, 0.5908295384917981, 0.618164021570004, 0.22978616222669168, 0.11518911362651174, 0.2250687033121147, 0.28149296752300257, 0.19237562114692597, 0.19176010618945694, 0.22328436693184828, 0.23212775113881967, 0.1711239367194266, 0.23789858150887155, 0.2417608617462894, 0.21146217011920576, 0.22805282136013183, 0.13206589328780882, 0.20657800954746708, 0.21064093837233744, 0.24011584654628515, 0.22210185226821755, 0.21483425856370364, 0.1942344079325964, 0.12521656300224038, 0.23797137671676882, 0.2116085949071509, 0.1376065233996151, 0.3697101050702125, 0.19574934495201413, 0.19927823899131014, 9.999999999998899e-05, 0.10308611664636169, 0.056225849474769385, 0.03901729334549686, 0.08328952978615922, 0.15857215984333395, 0.00040343026817935, 0.004617776315672395, 0.024116330134851927, 0.015028066549808483, 0.07045833153858239, 0.14636418131078222, 0.09021031764279541, 0.015396201812102328, 0.01980995837831634, 0.09437785027914503, 0.042928457289802435, 0.07678738454880263, 0.19516818086456267, 0.038660744480472076, 0.03530692541196512, 0.242990361937778, 0.09608548615205692, 0.08152866760824706, 0.08130809412856577, 0.22219724663849882, 0.08775988048537564, 0.12694825857094894, 0.13446970287259408, 0.09102121509435779, 0.028890262147717505, 0.3062798491333901, 0.08398366737433294, 0.12832879107310002, 0.12042714274426558, 0.10312574902410798, 0.5205312789899981, 0.5348066979451713, 0.5237837284116464, 0.5555782353463767, 0.5609178562512478, 0.5266657837261717, 0.5693744343168182, 0.5386446383562635, 0.5206614738409895, 0.10233696758559785, 0.055460080556853475, 0.12505249518839623, 0.03964373327936277, 0.07136586022539781, 0.08035758062221066, 0.05906788664488738, 0.08264034169774859, 0.07579976664534382, 0.1622786565114035, 0.20556836314325821, 0.2011425682236334, 0.2194160909256866, 0.15587209409424363, 0.22803829770506512, 0.1725706799356851, 0.319626033025733, 0.1541832185368125, 0.4066960750253039, 0.1566364229934255, 0.12011099515331802, 0.17294530403823594, 0.15951000365301915, 0.14512823105421724, 0.2526494577269771, 0.22530099441756168, 0.1877086665035116, 0.27821818994466563, 0.16562644384954306, 0.0538118278491142, 0.13005508397350418, 0.15507714251513516, 0.12309610774810009, 0.21436637536148107, 0.14367528288456344, 0.08009159401145005, 0.21557840643478932, 0.20156273718120976, 0.21209083673585138, 0.21777025715400533, 0.21160428228515027, 0.20164205187352013, 0.2019974574303347, 0.23279595847528056, 0.21965316859628936, 0.1726545355610981, 0.18929417703798002, 0.21017309377365367, 0.21103459656594703, 0.18277206758889264, 0.18345612005969125, 0.18781278348001262, 0.2013524995185655, 0.1784191450627992, 0.9449032632488549, 0.13696885100923883, 0.16580946008988917, 0.1144811701940105, 0.17744975297334364, 0.9068606275599984, 0.10886636436042574, 0.12694215287805566, 0.16830481897186433, 0.8975525965449158, 0.11351039236382798, 0.607523508578874, 0.08333201343589502, 0.21424148864767767, 0.2114790767684802, 0.7671320073059384, 0.16722770586458557, 0.5412992416318196, 0.21752544335018864, 0.24805634559834422, 0.2116498073565819, 0.28973171884001225, 0.19797468098301274, 0.2673070320587332, 0.2769655703109133, 0.2175688668958523, 0.21399728344867963, 0.08694647645629427, 0.08239065972887438, 0.07781493574391174, 0.06382920368984868, 0.06613481003469313, 0.06546985255595628, 0.10953487922971195, 0.09403095947740436, 0.07976037924403168]}, "mutation_prompt": null}
