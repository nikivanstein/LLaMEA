{"id": "0234027f-5661-41cb-80f5-b189db239506", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                # Differential Evolution Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Evaluate trial\n                trial_fitness = func(trial)\n                evals += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Simulated Annealing Perturbation\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                # Metropolis criterion\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.16568681883381678, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.16.", "error": "", "parent_id": null, "metadata": {"aucs": [0.29757796607347387, 0.2974670892626482, 0.2957038430693939, 0.3383049021761614, 0.34153270404296476, 0.3187143572802522, 0.3005023508050475, 0.31254584298613897, 0.3424281273290911, 0.054072572487920856, 0.07012353789293646, 0.08039419344087073, 0.05638487233691469, 0.06678060493261151, 0.09941893902696941, 0.09669138274621569, 0.09114879378922636, 0.06334223514183701, 0.07663473425259637, 0.08592614985049785, 0.08495343689032198, 0.08406849691430873, 0.09422269119988891, 0.08425754989686773, 0.08008082376004022, 0.09658557166097304, 0.08113194198496043, 0.07281710012697917, 0.06859907969864687, 0.07323993807971496, 0.06827291141003355, 0.07215371065706244, 0.0724880631232907, 0.07086951578760947, 0.07299317579864184, 0.06695698580433618, 0.7068645596559684, 0.9480931493858354, 0.9006243244714849, 0.9168413699974216, 0.47505639549461065, 0.6670683002361277, 0.8598197967963295, 0.8184068726309914, 0.9674789679375879, 0.13947395828586795, 0.13601962173306203, 0.13558232448909624, 0.13905541912971275, 0.12953933208190616, 0.13050648242154417, 0.13141480600201771, 0.14658103940699752, 0.15050080823568257, 0.2006503745258177, 0.20784899749009278, 0.18802018402918985, 0.21395812143905424, 0.20755458474171729, 0.19144947046163108, 0.18846818536590315, 0.21408628092723903, 0.18872631457383415, 0.09530597982579037, 0.08275220004172712, 0.0718063249697849, 0.07732861021661375, 0.09865346927388985, 0.10491972963613039, 0.09292842016394154, 0.0985742337547556, 0.09461322689275442, 0.09182702488573835, 0.1122553258419342, 0.08712297417863824, 0.07930168222862044, 0.07147387532722804, 0.07091318439085514, 0.08181895910805892, 0.09925130449915176, 0.11933838761144033, 0.02451341422924358, 0.00871614989318914, 0.04316886990165636, 0.022417876825262306, 0.042226259683472045, 0.029347254338969453, 0.042906856237249325, 0.005225296957982906, 0.025465903547916224, 0.10086410709310911, 0.12475627825220326, 0.09747383464243053, 0.10455055428390825, 0.10023130472997621, 0.12149917195150717, 0.10214791125066836, 0.11983048274140728, 0.12692252155974815, 9.999999999998899e-05, 0.007995973838429982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007982833817852253, 0.00025502539718513795, 9.999999999998899e-05, 0.0006056241084967384, 0.045499045764860635, 0.05125717675209651, 0.03437346527059748, 0.041221574563393926, 0.0507499647117029, 0.05526377190248388, 0.0578680913331302, 0.04804206766542851, 0.04554108428288839, 0.2892115302587387, 0.2920151984181202, 0.30048585638681946, 0.30600447675895937, 0.31718432795475204, 0.2966697889640464, 0.2973613111641773, 0.2840999003391159, 0.32158110953951324, 0.08658493944109502, 0.07250303333742703, 0.08755221194940821, 0.08555855936893442, 0.08044133115113039, 0.0894695465879316, 0.07224743616311202, 0.0798601616610749, 0.08339948958228527, 0.1669794449397759, 0.15526593889621476, 0.1669183426916634, 0.1761226128580169, 0.1658639785063344, 0.16167174405033258, 0.1469290829982165, 0.16524614644954072, 0.16099168789047713, 0.23510485390611324, 0.21583945841635166, 0.2291982838009563, 0.19413494055845715, 0.19782715752631885, 0.18992756512010234, 0.21681331035506268, 0.234931912047187, 0.2223620639719739, 0.1664502542061369, 0.15827613257969209, 0.15931056727889714, 0.13691684865700515, 0.1433615429155568, 0.1507109665262376, 0.15602423445425506, 0.17244589092211593, 0.16218008244797621, 0.1773824674458392, 0.17558597248197094, 0.19147918770334704, 0.2009708250721044, 0.1732858194242779, 0.18549524500224024, 0.18676926017359563, 0.183240630980682, 0.1897766466701768, 0.15886554004044262, 0.1821664601820857, 0.17239597232549497, 0.17206626028249616, 0.16999128143954878, 0.17869752474445355, 0.1662302225480382, 0.16882047512630738, 0.16948516197214902, 0.22038015321694393, 0.16319393895978007, 0.2171978938684067, 0.18747684991974745, 0.20760919956139556, 0.19816309521182363, 0.22118563241875822, 0.16465411562839072, 0.19376600601127925, 0.22562542434756738, 0.18389906352506813, 0.21566122500124452, 0.17986182209650192, 0.18341094286633963, 0.16318231576129072, 0.18823157250298828, 0.19900748324718998, 0.19943538799139038, 0.18532618207280493, 0.18283779392846866, 0.18912093508910588, 0.2010692537969001, 0.1754934478779594, 0.18288634889335043, 0.1797500365985477, 0.17937374704668585, 0.18947905413685018, 0.06440945716723401, 0.062223067416202094, 0.06743957593276717, 0.06613724071826677, 0.07422174249042779, 0.06963461952899419, 0.06430916447967416, 0.08181882741496171, 0.06664370016265786]}, "mutation_prompt": null}
{"id": "526a446e-7156-482e-a7c8-97ae7bbe0df6", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                # Differential Evolution Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Evaluate trial\n                trial_fitness = func(trial)\n                evals += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Simulated Annealing Perturbation\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                # Metropolis criterion\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0234027f-5661-41cb-80f5-b189db239506", "metadata": {"aucs": [0.29757796607347387, 0.2974670892626482, 0.2957038430693939, 0.3383049021761614, 0.34153270404296476, 0.3187143572802522, 0.3005023508050475, 0.31254584298613897, 0.3424281273290911, 0.054072572487920856, 0.07012353789293646, 0.08039419344087073, 0.05638487233691469, 0.06678060493261151, 0.09941893902696941, 0.09669138274621569, 0.09114879378922636, 0.06334223514183701, 0.07663473425259637, 0.08592614985049785, 0.08495343689032198, 0.08406849691430873, 0.09422269119988891, 0.08425754989686773, 0.08008082376004022, 0.09658557166097304, 0.08113194198496043, 0.07281710012697917, 0.06859907969864687, 0.07323993807971496, 0.06827291141003355, 0.07215371065706244, 0.0724880631232907, 0.07086951578760947, 0.07299317579864184, 0.06695698580433618, 0.7068645596559684, 0.9480931493858354, 0.9006243244714849, 0.9168413699974216, 0.47505639549461065, 0.6670683002361277, 0.8598197967963295, 0.8184068726309914, 0.9674789679375879, 0.13947395828586795, 0.13601962173306203, 0.13558232448909624, 0.13905541912971275, 0.12953933208190616, 0.13050648242154417, 0.13141480600201771, 0.14658103940699752, 0.15050080823568257, 0.2006503745258177, 0.20784899749009278, 0.18802018402918985, 0.21395812143905424, 0.20755458474171729, 0.19144947046163108, 0.18846818536590315, 0.21408628092723903, 0.18872631457383415, 0.09530597982579037, 0.08275220004172712, 0.0718063249697849, 0.07732861021661375, 0.09865346927388985, 0.10491972963613039, 0.09292842016394154, 0.0985742337547556, 0.09461322689275442, 0.09182702488573835, 0.1122553258419342, 0.08712297417863824, 0.07930168222862044, 0.07147387532722804, 0.07091318439085514, 0.08181895910805892, 0.09925130449915176, 0.11933838761144033, 0.02451341422924358, 0.00871614989318914, 0.04316886990165636, 0.022417876825262306, 0.042226259683472045, 0.029347254338969453, 0.042906856237249325, 0.005225296957982906, 0.025465903547916224, 0.10086410709310911, 0.12475627825220326, 0.09747383464243053, 0.10455055428390825, 0.10023130472997621, 0.12149917195150717, 0.10214791125066836, 0.11983048274140728, 0.12692252155974815, 9.999999999998899e-05, 0.007995973838429982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007982833817852253, 0.00025502539718513795, 9.999999999998899e-05, 0.0006056241084967384, 0.045499045764860635, 0.05125717675209651, 0.03437346527059748, 0.041221574563393926, 0.0507499647117029, 0.05526377190248388, 0.0578680913331302, 0.04804206766542851, 0.04554108428288839, 0.2892115302587387, 0.2920151984181202, 0.30048585638681946, 0.30600447675895937, 0.31718432795475204, 0.2966697889640464, 0.2973613111641773, 0.2840999003391159, 0.32158110953951324, 0.08658493944109502, 0.07250303333742703, 0.08755221194940821, 0.08555855936893442, 0.08044133115113039, 0.0894695465879316, 0.07224743616311202, 0.0798601616610749, 0.08339948958228527, 0.1669794449397759, 0.15526593889621476, 0.1669183426916634, 0.1761226128580169, 0.1658639785063344, 0.16167174405033258, 0.1469290829982165, 0.16524614644954072, 0.16099168789047713, 0.23510485390611324, 0.21583945841635166, 0.2291982838009563, 0.19413494055845715, 0.19782715752631885, 0.18992756512010234, 0.21681331035506268, 0.234931912047187, 0.2223620639719739, 0.1664502542061369, 0.15827613257969209, 0.15931056727889714, 0.13691684865700515, 0.1433615429155568, 0.1507109665262376, 0.15602423445425506, 0.17244589092211593, 0.16218008244797621, 0.1773824674458392, 0.17558597248197094, 0.19147918770334704, 0.2009708250721044, 0.1732858194242779, 0.18549524500224024, 0.18676926017359563, 0.183240630980682, 0.1897766466701768, 0.15886554004044262, 0.1821664601820857, 0.17239597232549497, 0.17206626028249616, 0.16999128143954878, 0.17869752474445355, 0.1662302225480382, 0.16882047512630738, 0.16948516197214902, 0.22038015321694393, 0.16319393895978007, 0.2171978938684067, 0.18747684991974745, 0.20760919956139556, 0.19816309521182363, 0.22118563241875822, 0.16465411562839072, 0.19376600601127925, 0.22562542434756738, 0.18389906352506813, 0.21566122500124452, 0.17986182209650192, 0.18341094286633963, 0.16318231576129072, 0.18823157250298828, 0.19900748324718998, 0.19943538799139038, 0.18532618207280493, 0.18283779392846866, 0.18912093508910588, 0.2010692537969001, 0.1754934478779594, 0.18288634889335043, 0.1797500365985477, 0.17937374704668585, 0.18947905413685018, 0.06440945716723401, 0.062223067416202094, 0.06743957593276717, 0.06613724071826677, 0.07422174249042779, 0.06963461952899419, 0.06430916447967416, 0.08181882741496171, 0.06664370016265786]}, "mutation_prompt": null}
{"id": "3635818f-1281-4d07-969d-3d2d7628a520", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                # Differential Evolution Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Adaptive Crossover\n                self.CR = 0.9 - (0.8 * (evals / self.budget))\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Evaluate trial\n                trial_fitness = func(trial)\n                evals += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Simulated Annealing Perturbation\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                # Metropolis criterion\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Improved perturbation and adaptive crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.1643573226688327, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "0234027f-5661-41cb-80f5-b189db239506", "metadata": {"aucs": [0.3158227111482199, 0.31303287384421574, 0.30783655379866737, 0.33018045447052646, 0.3209562164732014, 0.31800556439664074, 0.3264262058284234, 0.31910659793112406, 0.32321798853672157, 0.08732987825444671, 0.09016210083620413, 0.08270052971746189, 0.09176797236483492, 0.07566975819725319, 0.0817521212910659, 0.06878443261665201, 0.08825008171227056, 0.075143066391122, 0.07764514023700664, 0.08722475930384777, 0.08932173285929335, 0.08151360319725331, 0.08901100154001573, 0.10995976674201025, 0.08962036562256948, 0.08646120376382005, 0.08476716975400922, 0.07159834987031477, 0.08744149281712721, 0.07666591629080355, 0.08115558283817303, 0.06892519497798189, 0.07519146713352642, 0.0870015179990774, 0.07348356869651429, 0.08233229919493135, 0.8652832554220453, 0.8220574051221048, 0.7518540000922138, 0.938618889256626, 0.872257923710045, 0.8317441813774389, 0.7679927733889923, 0.5901695797358115, 0.904240305533115, 0.15324666280304666, 0.1348796014371514, 0.13394447584585467, 0.1410038267281909, 0.12612965027599987, 0.12783592664343835, 0.13448989645676213, 0.13305374012970783, 0.13510275823900897, 0.18216199913146192, 0.15797406446719708, 0.1722619084946766, 0.2023097547373417, 0.20017313369256085, 0.17858024545365192, 0.19372961226587027, 0.20384636897363606, 0.1908476305157002, 0.07465641024350367, 0.08215917040914333, 0.08757554708280946, 0.1075490816403788, 0.08871005116108377, 0.09000536120819902, 0.10212499009488696, 0.08775973033980722, 0.08251612912558726, 0.07522025691272116, 0.07589869093282309, 0.05855111374839195, 0.09905269437819586, 0.08304315079746649, 0.07222434914991738, 0.0626720693465237, 0.07865429825489978, 0.057242758758190404, 0.0012534277021192253, 0.006638967637422, 9.999999999998899e-05, 0.005128241642080367, 0.004138096380851497, 0.005315139848284578, 9.999999999998899e-05, 0.01974504404804589, 9.999999999998899e-05, 0.09487267427188395, 0.07106593520670945, 0.0850488368440776, 0.07115138695334877, 0.11856087707023144, 0.07538902273111103, 0.07165099165596933, 0.09736407794225599, 0.08626365910174716, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003715829617514377, 0.00010519318732693517, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030714005559909885, 0.03477406386748827, 0.04206424832538724, 0.03568042885856482, 0.05876065501459782, 0.04793612783370571, 0.04190498889897787, 0.04595912072058983, 0.047649086228067294, 0.3008011997633373, 0.3023494583956382, 0.2985639496769189, 0.2895844859217649, 0.29587390394072544, 0.31479929847704546, 0.307894020572417, 0.3109887548987764, 0.3118894674017605, 0.09036578067668855, 0.07764365040079624, 0.08338021197049439, 0.08079447054733013, 0.07976875316669685, 0.08092036142177239, 0.08061102139167486, 0.08016697041411136, 0.10367733476864271, 0.17829865415509938, 0.1752587000561231, 0.18589026871483438, 0.17233655901819167, 0.16217988238648107, 0.17087095983171352, 0.1826465155825011, 0.15569902408458425, 0.14397789984485465, 0.2086993857372642, 0.23868998351699333, 0.21957223550960825, 0.18696888188454108, 0.20122088201579635, 0.19315500276349262, 0.22422441697777862, 0.22334322027655384, 0.21766108210928092, 0.15208282324002576, 0.1601531412972288, 0.13596679317871863, 0.14845366971942553, 0.15474032102858126, 0.13872740842888087, 0.15895370277845777, 0.1553087085475876, 0.15761401012742593, 0.20011242202920554, 0.17154858370622605, 0.17949269570093274, 0.16739257588403977, 0.16641261219356585, 0.1838777243278018, 0.1930419876254792, 0.1780647872041865, 0.18914988924404552, 0.16867953553889514, 0.16520153687291772, 0.19485265111154582, 0.165634579579506, 0.18020282135671062, 0.17375033265138973, 0.1677031087761277, 0.16738171406252844, 0.1698442447844054, 0.1683469924479163, 0.14533922503819507, 0.23506194661166624, 0.1510140407770394, 0.24659133102493902, 0.21958368290054087, 0.20439648944374667, 0.18470671650846793, 0.19814635040238993, 0.31203135512316627, 0.2536994893775013, 0.1709029188408553, 0.15824614236448664, 0.16652001700636754, 0.2277925755915634, 0.20660209292527154, 0.24314935794166048, 0.20112906099125305, 0.19370964631386, 0.1810479873661036, 0.1932594553037401, 0.17988136338191252, 0.185739600710512, 0.18623837411222088, 0.187830923490922, 0.19063608093533335, 0.18491279617462164, 0.061057423648800846, 0.07305372337979588, 0.06802719003014734, 0.06787675914828817, 0.07855880708101015, 0.06486142117542693, 0.06506590409129531, 0.07262106467349216, 0.0710558162112156]}, "mutation_prompt": null}
{"id": "47281129-51cf-4683-8b34-ffb07070c0ed", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                # Differential Evolution Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Evaluate trial\n                trial_fitness = func(trial)\n                evals += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Simulated Annealing Perturbation\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                # Metropolis criterion\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0234027f-5661-41cb-80f5-b189db239506", "metadata": {"aucs": [0.29757796607347387, 0.2974670892626482, 0.2957038430693939, 0.3383049021761614, 0.34153270404296476, 0.3187143572802522, 0.3005023508050475, 0.31254584298613897, 0.3424281273290911, 0.054072572487920856, 0.07012353789293646, 0.08039419344087073, 0.05638487233691469, 0.06678060493261151, 0.09941893902696941, 0.09669138274621569, 0.09114879378922636, 0.06334223514183701, 0.07663473425259637, 0.08592614985049785, 0.08495343689032198, 0.08406849691430873, 0.09422269119988891, 0.08425754989686773, 0.08008082376004022, 0.09658557166097304, 0.08113194198496043, 0.07281710012697917, 0.06859907969864687, 0.07323993807971496, 0.06827291141003355, 0.07215371065706244, 0.0724880631232907, 0.07086951578760947, 0.07299317579864184, 0.06695698580433618, 0.7068645596559684, 0.9480931493858354, 0.9006243244714849, 0.9168413699974216, 0.47505639549461065, 0.6670683002361277, 0.8598197967963295, 0.8184068726309914, 0.9674789679375879, 0.13947395828586795, 0.13601962173306203, 0.13558232448909624, 0.13905541912971275, 0.12953933208190616, 0.13050648242154417, 0.13141480600201771, 0.14658103940699752, 0.15050080823568257, 0.2006503745258177, 0.20784899749009278, 0.18802018402918985, 0.21395812143905424, 0.20755458474171729, 0.19144947046163108, 0.18846818536590315, 0.21408628092723903, 0.18872631457383415, 0.09530597982579037, 0.08275220004172712, 0.0718063249697849, 0.07732861021661375, 0.09865346927388985, 0.10491972963613039, 0.09292842016394154, 0.0985742337547556, 0.09461322689275442, 0.09182702488573835, 0.1122553258419342, 0.08712297417863824, 0.07930168222862044, 0.07147387532722804, 0.07091318439085514, 0.08181895910805892, 0.09925130449915176, 0.11933838761144033, 0.02451341422924358, 0.00871614989318914, 0.04316886990165636, 0.022417876825262306, 0.042226259683472045, 0.029347254338969453, 0.042906856237249325, 0.005225296957982906, 0.025465903547916224, 0.10086410709310911, 0.12475627825220326, 0.09747383464243053, 0.10455055428390825, 0.10023130472997621, 0.12149917195150717, 0.10214791125066836, 0.11983048274140728, 0.12692252155974815, 9.999999999998899e-05, 0.007995973838429982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007982833817852253, 0.00025502539718513795, 9.999999999998899e-05, 0.0006056241084967384, 0.045499045764860635, 0.05125717675209651, 0.03437346527059748, 0.041221574563393926, 0.0507499647117029, 0.05526377190248388, 0.0578680913331302, 0.04804206766542851, 0.04554108428288839, 0.2892115302587387, 0.2920151984181202, 0.30048585638681946, 0.30600447675895937, 0.31718432795475204, 0.2966697889640464, 0.2973613111641773, 0.2840999003391159, 0.32158110953951324, 0.08658493944109502, 0.07250303333742703, 0.08755221194940821, 0.08555855936893442, 0.08044133115113039, 0.0894695465879316, 0.07224743616311202, 0.0798601616610749, 0.08339948958228527, 0.1669794449397759, 0.15526593889621476, 0.1669183426916634, 0.1761226128580169, 0.1658639785063344, 0.16167174405033258, 0.1469290829982165, 0.16524614644954072, 0.16099168789047713, 0.23510485390611324, 0.21583945841635166, 0.2291982838009563, 0.19413494055845715, 0.19782715752631885, 0.18992756512010234, 0.21681331035506268, 0.234931912047187, 0.2223620639719739, 0.1664502542061369, 0.15827613257969209, 0.15931056727889714, 0.13691684865700515, 0.1433615429155568, 0.1507109665262376, 0.15602423445425506, 0.17244589092211593, 0.16218008244797621, 0.1773824674458392, 0.17558597248197094, 0.19147918770334704, 0.2009708250721044, 0.1732858194242779, 0.18549524500224024, 0.18676926017359563, 0.183240630980682, 0.1897766466701768, 0.15886554004044262, 0.1821664601820857, 0.17239597232549497, 0.17206626028249616, 0.16999128143954878, 0.17869752474445355, 0.1662302225480382, 0.16882047512630738, 0.16948516197214902, 0.22038015321694393, 0.16319393895978007, 0.2171978938684067, 0.18747684991974745, 0.20760919956139556, 0.19816309521182363, 0.22118563241875822, 0.16465411562839072, 0.19376600601127925, 0.22562542434756738, 0.18389906352506813, 0.21566122500124452, 0.17986182209650192, 0.18341094286633963, 0.16318231576129072, 0.18823157250298828, 0.19900748324718998, 0.19943538799139038, 0.18532618207280493, 0.18283779392846866, 0.18912093508910588, 0.2010692537969001, 0.1754934478779594, 0.18288634889335043, 0.1797500365985477, 0.17937374704668585, 0.18947905413685018, 0.06440945716723401, 0.062223067416202094, 0.06743957593276717, 0.06613724071826677, 0.07422174249042779, 0.06963461952899419, 0.06430916447967416, 0.08181882741496171, 0.06664370016265786]}, "mutation_prompt": null}
{"id": "22a83fce-74d5-413b-aab6-609c952da487", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                # Differential Evolution Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Evaluate trial\n                trial_fitness = func(trial)\n                evals += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Simulated Annealing Perturbation\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                # Metropolis criterion\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0234027f-5661-41cb-80f5-b189db239506", "metadata": {"aucs": [0.29757796607347387, 0.2974670892626482, 0.2957038430693939, 0.3383049021761614, 0.34153270404296476, 0.3187143572802522, 0.3005023508050475, 0.31254584298613897, 0.3424281273290911, 0.054072572487920856, 0.07012353789293646, 0.08039419344087073, 0.05638487233691469, 0.06678060493261151, 0.09941893902696941, 0.09669138274621569, 0.09114879378922636, 0.06334223514183701, 0.07663473425259637, 0.08592614985049785, 0.08495343689032198, 0.08406849691430873, 0.09422269119988891, 0.08425754989686773, 0.08008082376004022, 0.09658557166097304, 0.08113194198496043, 0.07281710012697917, 0.06859907969864687, 0.07323993807971496, 0.06827291141003355, 0.07215371065706244, 0.0724880631232907, 0.07086951578760947, 0.07299317579864184, 0.06695698580433618, 0.7068645596559684, 0.9480931493858354, 0.9006243244714849, 0.9168413699974216, 0.47505639549461065, 0.6670683002361277, 0.8598197967963295, 0.8184068726309914, 0.9674789679375879, 0.13947395828586795, 0.13601962173306203, 0.13558232448909624, 0.13905541912971275, 0.12953933208190616, 0.13050648242154417, 0.13141480600201771, 0.14658103940699752, 0.15050080823568257, 0.2006503745258177, 0.20784899749009278, 0.18802018402918985, 0.21395812143905424, 0.20755458474171729, 0.19144947046163108, 0.18846818536590315, 0.21408628092723903, 0.18872631457383415, 0.09530597982579037, 0.08275220004172712, 0.0718063249697849, 0.07732861021661375, 0.09865346927388985, 0.10491972963613039, 0.09292842016394154, 0.0985742337547556, 0.09461322689275442, 0.09182702488573835, 0.1122553258419342, 0.08712297417863824, 0.07930168222862044, 0.07147387532722804, 0.07091318439085514, 0.08181895910805892, 0.09925130449915176, 0.11933838761144033, 0.02451341422924358, 0.00871614989318914, 0.04316886990165636, 0.022417876825262306, 0.042226259683472045, 0.029347254338969453, 0.042906856237249325, 0.005225296957982906, 0.025465903547916224, 0.10086410709310911, 0.12475627825220326, 0.09747383464243053, 0.10455055428390825, 0.10023130472997621, 0.12149917195150717, 0.10214791125066836, 0.11983048274140728, 0.12692252155974815, 9.999999999998899e-05, 0.007995973838429982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007982833817852253, 0.00025502539718513795, 9.999999999998899e-05, 0.0006056241084967384, 0.045499045764860635, 0.05125717675209651, 0.03437346527059748, 0.041221574563393926, 0.0507499647117029, 0.05526377190248388, 0.0578680913331302, 0.04804206766542851, 0.04554108428288839, 0.2892115302587387, 0.2920151984181202, 0.30048585638681946, 0.30600447675895937, 0.31718432795475204, 0.2966697889640464, 0.2973613111641773, 0.2840999003391159, 0.32158110953951324, 0.08658493944109502, 0.07250303333742703, 0.08755221194940821, 0.08555855936893442, 0.08044133115113039, 0.0894695465879316, 0.07224743616311202, 0.0798601616610749, 0.08339948958228527, 0.1669794449397759, 0.15526593889621476, 0.1669183426916634, 0.1761226128580169, 0.1658639785063344, 0.16167174405033258, 0.1469290829982165, 0.16524614644954072, 0.16099168789047713, 0.23510485390611324, 0.21583945841635166, 0.2291982838009563, 0.19413494055845715, 0.19782715752631885, 0.18992756512010234, 0.21681331035506268, 0.234931912047187, 0.2223620639719739, 0.1664502542061369, 0.15827613257969209, 0.15931056727889714, 0.13691684865700515, 0.1433615429155568, 0.1507109665262376, 0.15602423445425506, 0.17244589092211593, 0.16218008244797621, 0.1773824674458392, 0.17558597248197094, 0.19147918770334704, 0.2009708250721044, 0.1732858194242779, 0.18549524500224024, 0.18676926017359563, 0.183240630980682, 0.1897766466701768, 0.15886554004044262, 0.1821664601820857, 0.17239597232549497, 0.17206626028249616, 0.16999128143954878, 0.17869752474445355, 0.1662302225480382, 0.16882047512630738, 0.16948516197214902, 0.22038015321694393, 0.16319393895978007, 0.2171978938684067, 0.18747684991974745, 0.20760919956139556, 0.19816309521182363, 0.22118563241875822, 0.16465411562839072, 0.19376600601127925, 0.22562542434756738, 0.18389906352506813, 0.21566122500124452, 0.17986182209650192, 0.18341094286633963, 0.16318231576129072, 0.18823157250298828, 0.19900748324718998, 0.19943538799139038, 0.18532618207280493, 0.18283779392846866, 0.18912093508910588, 0.2010692537969001, 0.1754934478779594, 0.18288634889335043, 0.1797500365985477, 0.17937374704668585, 0.18947905413685018, 0.06440945716723401, 0.062223067416202094, 0.06743957593276717, 0.06613724071826677, 0.07422174249042779, 0.06963461952899419, 0.06430916447967416, 0.08181882741496171, 0.06664370016265786]}, "mutation_prompt": null}
{"id": "2bac14f2-2d06-46cd-bd47-ea93e3141b5c", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                # Differential Evolution Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Evaluate trial\n                trial_fitness = func(trial)\n                evals += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Simulated Annealing Perturbation\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                # Metropolis criterion\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0234027f-5661-41cb-80f5-b189db239506", "metadata": {"aucs": [0.29757796607347387, 0.2974670892626482, 0.2957038430693939, 0.3383049021761614, 0.34153270404296476, 0.3187143572802522, 0.3005023508050475, 0.31254584298613897, 0.3424281273290911, 0.054072572487920856, 0.07012353789293646, 0.08039419344087073, 0.05638487233691469, 0.06678060493261151, 0.09941893902696941, 0.09669138274621569, 0.09114879378922636, 0.06334223514183701, 0.07663473425259637, 0.08592614985049785, 0.08495343689032198, 0.08406849691430873, 0.09422269119988891, 0.08425754989686773, 0.08008082376004022, 0.09658557166097304, 0.08113194198496043, 0.07281710012697917, 0.06859907969864687, 0.07323993807971496, 0.06827291141003355, 0.07215371065706244, 0.0724880631232907, 0.07086951578760947, 0.07299317579864184, 0.06695698580433618, 0.7068645596559684, 0.9480931493858354, 0.9006243244714849, 0.9168413699974216, 0.47505639549461065, 0.6670683002361277, 0.8598197967963295, 0.8184068726309914, 0.9674789679375879, 0.13947395828586795, 0.13601962173306203, 0.13558232448909624, 0.13905541912971275, 0.12953933208190616, 0.13050648242154417, 0.13141480600201771, 0.14658103940699752, 0.15050080823568257, 0.2006503745258177, 0.20784899749009278, 0.18802018402918985, 0.21395812143905424, 0.20755458474171729, 0.19144947046163108, 0.18846818536590315, 0.21408628092723903, 0.18872631457383415, 0.09530597982579037, 0.08275220004172712, 0.0718063249697849, 0.07732861021661375, 0.09865346927388985, 0.10491972963613039, 0.09292842016394154, 0.0985742337547556, 0.09461322689275442, 0.09182702488573835, 0.1122553258419342, 0.08712297417863824, 0.07930168222862044, 0.07147387532722804, 0.07091318439085514, 0.08181895910805892, 0.09925130449915176, 0.11933838761144033, 0.02451341422924358, 0.00871614989318914, 0.04316886990165636, 0.022417876825262306, 0.042226259683472045, 0.029347254338969453, 0.042906856237249325, 0.005225296957982906, 0.025465903547916224, 0.10086410709310911, 0.12475627825220326, 0.09747383464243053, 0.10455055428390825, 0.10023130472997621, 0.12149917195150717, 0.10214791125066836, 0.11983048274140728, 0.12692252155974815, 9.999999999998899e-05, 0.007995973838429982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007982833817852253, 0.00025502539718513795, 9.999999999998899e-05, 0.0006056241084967384, 0.045499045764860635, 0.05125717675209651, 0.03437346527059748, 0.041221574563393926, 0.0507499647117029, 0.05526377190248388, 0.0578680913331302, 0.04804206766542851, 0.04554108428288839, 0.2892115302587387, 0.2920151984181202, 0.30048585638681946, 0.30600447675895937, 0.31718432795475204, 0.2966697889640464, 0.2973613111641773, 0.2840999003391159, 0.32158110953951324, 0.08658493944109502, 0.07250303333742703, 0.08755221194940821, 0.08555855936893442, 0.08044133115113039, 0.0894695465879316, 0.07224743616311202, 0.0798601616610749, 0.08339948958228527, 0.1669794449397759, 0.15526593889621476, 0.1669183426916634, 0.1761226128580169, 0.1658639785063344, 0.16167174405033258, 0.1469290829982165, 0.16524614644954072, 0.16099168789047713, 0.23510485390611324, 0.21583945841635166, 0.2291982838009563, 0.19413494055845715, 0.19782715752631885, 0.18992756512010234, 0.21681331035506268, 0.234931912047187, 0.2223620639719739, 0.1664502542061369, 0.15827613257969209, 0.15931056727889714, 0.13691684865700515, 0.1433615429155568, 0.1507109665262376, 0.15602423445425506, 0.17244589092211593, 0.16218008244797621, 0.1773824674458392, 0.17558597248197094, 0.19147918770334704, 0.2009708250721044, 0.1732858194242779, 0.18549524500224024, 0.18676926017359563, 0.183240630980682, 0.1897766466701768, 0.15886554004044262, 0.1821664601820857, 0.17239597232549497, 0.17206626028249616, 0.16999128143954878, 0.17869752474445355, 0.1662302225480382, 0.16882047512630738, 0.16948516197214902, 0.22038015321694393, 0.16319393895978007, 0.2171978938684067, 0.18747684991974745, 0.20760919956139556, 0.19816309521182363, 0.22118563241875822, 0.16465411562839072, 0.19376600601127925, 0.22562542434756738, 0.18389906352506813, 0.21566122500124452, 0.17986182209650192, 0.18341094286633963, 0.16318231576129072, 0.18823157250298828, 0.19900748324718998, 0.19943538799139038, 0.18532618207280493, 0.18283779392846866, 0.18912093508910588, 0.2010692537969001, 0.1754934478779594, 0.18288634889335043, 0.1797500365985477, 0.17937374704668585, 0.18947905413685018, 0.06440945716723401, 0.062223067416202094, 0.06743957593276717, 0.06613724071826677, 0.07422174249042779, 0.06963461952899419, 0.06430916447967416, 0.08181882741496171, 0.06664370016265786]}, "mutation_prompt": null}
{"id": "953c19eb-97f1-42f7-a030-ea30c3a9e09c", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                # Differential Evolution Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Evaluate trial\n                trial_fitness = func(trial)\n                evals += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Simulated Annealing Perturbation\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                # Metropolis criterion\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0234027f-5661-41cb-80f5-b189db239506", "metadata": {"aucs": [0.29757796607347387, 0.2974670892626482, 0.2957038430693939, 0.3383049021761614, 0.34153270404296476, 0.3187143572802522, 0.3005023508050475, 0.31254584298613897, 0.3424281273290911, 0.054072572487920856, 0.07012353789293646, 0.08039419344087073, 0.05638487233691469, 0.06678060493261151, 0.09941893902696941, 0.09669138274621569, 0.09114879378922636, 0.06334223514183701, 0.07663473425259637, 0.08592614985049785, 0.08495343689032198, 0.08406849691430873, 0.09422269119988891, 0.08425754989686773, 0.08008082376004022, 0.09658557166097304, 0.08113194198496043, 0.07281710012697917, 0.06859907969864687, 0.07323993807971496, 0.06827291141003355, 0.07215371065706244, 0.0724880631232907, 0.07086951578760947, 0.07299317579864184, 0.06695698580433618, 0.7068645596559684, 0.9480931493858354, 0.9006243244714849, 0.9168413699974216, 0.47505639549461065, 0.6670683002361277, 0.8598197967963295, 0.8184068726309914, 0.9674789679375879, 0.13947395828586795, 0.13601962173306203, 0.13558232448909624, 0.13905541912971275, 0.12953933208190616, 0.13050648242154417, 0.13141480600201771, 0.14658103940699752, 0.15050080823568257, 0.2006503745258177, 0.20784899749009278, 0.18802018402918985, 0.21395812143905424, 0.20755458474171729, 0.19144947046163108, 0.18846818536590315, 0.21408628092723903, 0.18872631457383415, 0.09530597982579037, 0.08275220004172712, 0.0718063249697849, 0.07732861021661375, 0.09865346927388985, 0.10491972963613039, 0.09292842016394154, 0.0985742337547556, 0.09461322689275442, 0.09182702488573835, 0.1122553258419342, 0.08712297417863824, 0.07930168222862044, 0.07147387532722804, 0.07091318439085514, 0.08181895910805892, 0.09925130449915176, 0.11933838761144033, 0.02451341422924358, 0.00871614989318914, 0.04316886990165636, 0.022417876825262306, 0.042226259683472045, 0.029347254338969453, 0.042906856237249325, 0.005225296957982906, 0.025465903547916224, 0.10086410709310911, 0.12475627825220326, 0.09747383464243053, 0.10455055428390825, 0.10023130472997621, 0.12149917195150717, 0.10214791125066836, 0.11983048274140728, 0.12692252155974815, 9.999999999998899e-05, 0.007995973838429982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007982833817852253, 0.00025502539718513795, 9.999999999998899e-05, 0.0006056241084967384, 0.045499045764860635, 0.05125717675209651, 0.03437346527059748, 0.041221574563393926, 0.0507499647117029, 0.05526377190248388, 0.0578680913331302, 0.04804206766542851, 0.04554108428288839, 0.2892115302587387, 0.2920151984181202, 0.30048585638681946, 0.30600447675895937, 0.31718432795475204, 0.2966697889640464, 0.2973613111641773, 0.2840999003391159, 0.32158110953951324, 0.08658493944109502, 0.07250303333742703, 0.08755221194940821, 0.08555855936893442, 0.08044133115113039, 0.0894695465879316, 0.07224743616311202, 0.0798601616610749, 0.08339948958228527, 0.1669794449397759, 0.15526593889621476, 0.1669183426916634, 0.1761226128580169, 0.1658639785063344, 0.16167174405033258, 0.1469290829982165, 0.16524614644954072, 0.16099168789047713, 0.23510485390611324, 0.21583945841635166, 0.2291982838009563, 0.19413494055845715, 0.19782715752631885, 0.18992756512010234, 0.21681331035506268, 0.234931912047187, 0.2223620639719739, 0.1664502542061369, 0.15827613257969209, 0.15931056727889714, 0.13691684865700515, 0.1433615429155568, 0.1507109665262376, 0.15602423445425506, 0.17244589092211593, 0.16218008244797621, 0.1773824674458392, 0.17558597248197094, 0.19147918770334704, 0.2009708250721044, 0.1732858194242779, 0.18549524500224024, 0.18676926017359563, 0.183240630980682, 0.1897766466701768, 0.15886554004044262, 0.1821664601820857, 0.17239597232549497, 0.17206626028249616, 0.16999128143954878, 0.17869752474445355, 0.1662302225480382, 0.16882047512630738, 0.16948516197214902, 0.22038015321694393, 0.16319393895978007, 0.2171978938684067, 0.18747684991974745, 0.20760919956139556, 0.19816309521182363, 0.22118563241875822, 0.16465411562839072, 0.19376600601127925, 0.22562542434756738, 0.18389906352506813, 0.21566122500124452, 0.17986182209650192, 0.18341094286633963, 0.16318231576129072, 0.18823157250298828, 0.19900748324718998, 0.19943538799139038, 0.18532618207280493, 0.18283779392846866, 0.18912093508910588, 0.2010692537969001, 0.1754934478779594, 0.18288634889335043, 0.1797500365985477, 0.17937374704668585, 0.18947905413685018, 0.06440945716723401, 0.062223067416202094, 0.06743957593276717, 0.06613724071826677, 0.07422174249042779, 0.06963461952899419, 0.06430916447967416, 0.08181882741496171, 0.06664370016265786]}, "mutation_prompt": null}
{"id": "64c89f92-0398-4972-862e-009b175efed2", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                # Differential Evolution Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Evaluate trial\n                trial_fitness = func(trial)\n                evals += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Simulated Annealing Perturbation\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                # Metropolis criterion\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0234027f-5661-41cb-80f5-b189db239506", "metadata": {"aucs": [0.29757796607347387, 0.2974670892626482, 0.2957038430693939, 0.3383049021761614, 0.34153270404296476, 0.3187143572802522, 0.3005023508050475, 0.31254584298613897, 0.3424281273290911, 0.054072572487920856, 0.07012353789293646, 0.08039419344087073, 0.05638487233691469, 0.06678060493261151, 0.09941893902696941, 0.09669138274621569, 0.09114879378922636, 0.06334223514183701, 0.07663473425259637, 0.08592614985049785, 0.08495343689032198, 0.08406849691430873, 0.09422269119988891, 0.08425754989686773, 0.08008082376004022, 0.09658557166097304, 0.08113194198496043, 0.07281710012697917, 0.06859907969864687, 0.07323993807971496, 0.06827291141003355, 0.07215371065706244, 0.0724880631232907, 0.07086951578760947, 0.07299317579864184, 0.06695698580433618, 0.7068645596559684, 0.9480931493858354, 0.9006243244714849, 0.9168413699974216, 0.47505639549461065, 0.6670683002361277, 0.8598197967963295, 0.8184068726309914, 0.9674789679375879, 0.13947395828586795, 0.13601962173306203, 0.13558232448909624, 0.13905541912971275, 0.12953933208190616, 0.13050648242154417, 0.13141480600201771, 0.14658103940699752, 0.15050080823568257, 0.2006503745258177, 0.20784899749009278, 0.18802018402918985, 0.21395812143905424, 0.20755458474171729, 0.19144947046163108, 0.18846818536590315, 0.21408628092723903, 0.18872631457383415, 0.09530597982579037, 0.08275220004172712, 0.0718063249697849, 0.07732861021661375, 0.09865346927388985, 0.10491972963613039, 0.09292842016394154, 0.0985742337547556, 0.09461322689275442, 0.09182702488573835, 0.1122553258419342, 0.08712297417863824, 0.07930168222862044, 0.07147387532722804, 0.07091318439085514, 0.08181895910805892, 0.09925130449915176, 0.11933838761144033, 0.02451341422924358, 0.00871614989318914, 0.04316886990165636, 0.022417876825262306, 0.042226259683472045, 0.029347254338969453, 0.042906856237249325, 0.005225296957982906, 0.025465903547916224, 0.10086410709310911, 0.12475627825220326, 0.09747383464243053, 0.10455055428390825, 0.10023130472997621, 0.12149917195150717, 0.10214791125066836, 0.11983048274140728, 0.12692252155974815, 9.999999999998899e-05, 0.007995973838429982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007982833817852253, 0.00025502539718513795, 9.999999999998899e-05, 0.0006056241084967384, 0.045499045764860635, 0.05125717675209651, 0.03437346527059748, 0.041221574563393926, 0.0507499647117029, 0.05526377190248388, 0.0578680913331302, 0.04804206766542851, 0.04554108428288839, 0.2892115302587387, 0.2920151984181202, 0.30048585638681946, 0.30600447675895937, 0.31718432795475204, 0.2966697889640464, 0.2973613111641773, 0.2840999003391159, 0.32158110953951324, 0.08658493944109502, 0.07250303333742703, 0.08755221194940821, 0.08555855936893442, 0.08044133115113039, 0.0894695465879316, 0.07224743616311202, 0.0798601616610749, 0.08339948958228527, 0.1669794449397759, 0.15526593889621476, 0.1669183426916634, 0.1761226128580169, 0.1658639785063344, 0.16167174405033258, 0.1469290829982165, 0.16524614644954072, 0.16099168789047713, 0.23510485390611324, 0.21583945841635166, 0.2291982838009563, 0.19413494055845715, 0.19782715752631885, 0.18992756512010234, 0.21681331035506268, 0.234931912047187, 0.2223620639719739, 0.1664502542061369, 0.15827613257969209, 0.15931056727889714, 0.13691684865700515, 0.1433615429155568, 0.1507109665262376, 0.15602423445425506, 0.17244589092211593, 0.16218008244797621, 0.1773824674458392, 0.17558597248197094, 0.19147918770334704, 0.2009708250721044, 0.1732858194242779, 0.18549524500224024, 0.18676926017359563, 0.183240630980682, 0.1897766466701768, 0.15886554004044262, 0.1821664601820857, 0.17239597232549497, 0.17206626028249616, 0.16999128143954878, 0.17869752474445355, 0.1662302225480382, 0.16882047512630738, 0.16948516197214902, 0.22038015321694393, 0.16319393895978007, 0.2171978938684067, 0.18747684991974745, 0.20760919956139556, 0.19816309521182363, 0.22118563241875822, 0.16465411562839072, 0.19376600601127925, 0.22562542434756738, 0.18389906352506813, 0.21566122500124452, 0.17986182209650192, 0.18341094286633963, 0.16318231576129072, 0.18823157250298828, 0.19900748324718998, 0.19943538799139038, 0.18532618207280493, 0.18283779392846866, 0.18912093508910588, 0.2010692537969001, 0.1754934478779594, 0.18288634889335043, 0.1797500365985477, 0.17937374704668585, 0.18947905413685018, 0.06440945716723401, 0.062223067416202094, 0.06743957593276717, 0.06613724071826677, 0.07422174249042779, 0.06963461952899419, 0.06430916447967416, 0.08181882741496171, 0.06664370016265786]}, "mutation_prompt": null}
{"id": "b17a1501-79c0-4571-ad6c-05240d4e4361", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for _ in range(self.iterations):\n            for i in range(self.population_size):\n                # Adaptive Mutation\n                self.F = 0.5 + np.random.rand() * 0.5  \n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Evaluate trial\n                trial_fitness = func(trial)\n                evals += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Adaptive Annealing Perturbation\n            for i in range(self.population_size):\n                perturb_scale = 0.1 * (fitness[i] / (best_fitness + 1e-8))\n                perturbed = population[i] + np.random.normal(0, perturb_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                # Metropolis criterion\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with Adaptive Mutation Factor and Adaptive Annealing for improved convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "0234027f-5661-41cb-80f5-b189db239506", "metadata": {}, "mutation_prompt": null}
{"id": "a5308c98-25d4-4e34-96e1-3ba9fccfd021", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by dynamic adjustment of mutation factor and integrate a memory mechanism for elite solutions.", "configspace": "", "generation": 9, "fitness": 0.18099502299340248, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "0234027f-5661-41cb-80f5-b189db239506", "metadata": {"aucs": [0.32777167951801556, 0.34070308693590456, 0.345170027428511, 0.34902490293118427, 0.3371376991087126, 0.37309104032585605, 0.35444804365419036, 0.342104720675525, 0.349516765289827, 0.09915155095242922, 0.10565606236508207, 0.09572141856659022, 0.0951206863939178, 0.08869439675940571, 0.10133425739099888, 0.12429213132668815, 0.11232646972321814, 0.09438036632659841, 0.0897484939518528, 0.10284562242107309, 0.09418232991173103, 0.09768854314108177, 0.10214751506055386, 0.09687528217221553, 0.08810700479922129, 0.08091893972328068, 0.08307371800678143, 0.08414399659717486, 0.08572180137799057, 0.08248594123202524, 0.08493742740110588, 0.0810086337791841, 0.07905852045657136, 0.09165976224714556, 0.08909589037706978, 0.0782106061766562, 0.7663874294296147, 0.7557827562539697, 0.7420395706999321, 0.9081890614050239, 0.8354706283466012, 0.7385634861262056, 0.7568606746667547, 0.7988143725952087, 0.8001927472937694, 0.156776569977221, 0.1543429162461618, 0.16884736971742298, 0.148679218785577, 0.18311871516640799, 0.17908865767093085, 0.1562344589237744, 0.1773713753799735, 0.16501857796522523, 0.2211753005328514, 0.2408215401870587, 0.22764224476770234, 0.26902761299224254, 0.2484701615923417, 0.2776069571213947, 0.24727530182329516, 0.2669235770236147, 0.25707094132791086, 0.10258589806189045, 0.1338236039480296, 0.1332449884113972, 0.10795749221304596, 0.11579313153174009, 0.10664940987652849, 0.10607362317269231, 0.13177360458271792, 0.12482348075055483, 0.10561079575617005, 0.0909466101880847, 0.08792421458320587, 0.1178677604329208, 0.1088343293445243, 0.1149504543892661, 0.11820619034961655, 0.12653236011063163, 0.11269311353682443, 0.043816284036837905, 0.05208223541049006, 0.04032415721613347, 0.05116559785709962, 0.055373542891675065, 0.04792381762654063, 0.05066552587721984, 0.037978421019964514, 0.043459268785227545, 0.1492501681645857, 0.1304109275967218, 0.11447781448373973, 0.10888308513717437, 0.10758140938647753, 0.1363859766436486, 0.13157336682187093, 0.13725180941298332, 0.13305490513243712, 0.011901473659804096, 0.013525583265254992, 0.005093047174915433, 0.02720326829684383, 0.014913090060753031, 0.0013229515272538128, 0.004841286954407775, 0.013500897312670568, 0.006902738518327345, 0.08904477121281928, 0.058209668395264424, 0.06621931471034492, 0.0651479345353626, 0.058716818909852586, 0.0678470324464735, 0.06550550888075635, 0.06627667701968654, 0.06476692679032203, 0.3266660073252713, 0.33217792425623593, 0.3217651894362644, 0.3226244496417787, 0.33171687523081295, 0.3325647505644088, 0.33547805374860895, 0.3192136361654352, 0.33191562426067256, 0.09329295098852108, 0.09417832975741225, 0.07875707048694325, 0.08276670101006, 0.08372957274220794, 0.09320373539275661, 0.09658389269825751, 0.08626771038154946, 0.0906072226195842, 0.14855903209875776, 0.1569586641422358, 0.15973559484478572, 0.18746385734522675, 0.17451953859854363, 0.15593210248511458, 0.19036787397492383, 0.161057077537885, 0.2211340209849343, 0.22513628517048245, 0.22495669061394163, 0.2350807017388693, 0.22548444198446593, 0.24935995914667397, 0.23007429168908888, 0.2360397133835509, 0.234717946489431, 0.24743119159767868, 0.16968324117430533, 0.1758980579064766, 0.1743399451897374, 0.16105754196848643, 0.1778721217966297, 0.1833582485698847, 0.18930321508390258, 0.18987574083420056, 0.19220321499164483, 0.1819679553925635, 0.21654782304768205, 0.20061839082043276, 0.19287673655473114, 0.18465801622382239, 0.19582927456499466, 0.19168664456241757, 0.208779694326241, 0.20096568760138134, 0.18275815216938607, 0.17149302017297596, 0.19591916064603354, 0.1804494669529969, 0.19138507586608777, 0.18171971698626443, 0.18044317295280365, 0.18969757826764033, 0.17828109965790684, 0.1701559957065154, 0.23516598153747514, 0.17290030432046988, 0.17063210874765078, 0.18737137919536717, 0.1601429800909704, 0.1851356223109628, 0.32015281053920175, 0.2119239941005977, 0.19014484073078008, 0.21557937811166394, 0.18654865968204382, 0.1758141377990109, 0.17215752858879818, 0.20648759991446497, 0.10863394135285287, 0.20797684199836475, 0.21546632184771963, 0.18602674370744587, 0.17563045772525765, 0.19529632451758072, 0.1973571812292949, 0.17908573553536733, 0.18953767233233898, 0.18445731066277715, 0.18834830118178092, 0.18313824768334985, 0.07275819996357802, 0.07134592623772529, 0.069107052340592, 0.07965199350939278, 0.06626474943973792, 0.07198718498530521, 0.08649910261149507, 0.08254495329189504, 0.07207480529476251]}, "mutation_prompt": null}
{"id": "63a4ab50-5336-40e4-aaea-d5e4f0a3f370", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)\n            self.CR = 0.5 + 0.4 * np.cos(np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        if len(self.elite_solutions) < 5:  # Limit elite solutions\n                            self.elite_solutions.append(trial)\n\n            if self.elite_solutions:  # Diversify elite solution usage\n                elite = np.random.choice(self.elite_solutions)\n                for i in range(self.population_size):\n                    perturbed = elite + np.random.normal(0, 0.1, self.dim)\n                    perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                    perturbed_fitness = func(perturbed)\n                    evals += 1\n                    \n                    if perturbed_fitness < fitness[i] or \\\n                       np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                        population[i] = perturbed\n                        fitness[i] = perturbed_fitness\n                        if perturbed_fitness < best_fitness:\n                            best_solution = perturbed\n                            best_fitness = perturbed_fitness\n\n            T *= self.alpha\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive crossover rate and diversify elite solution usage to improve convergence speed and solution diversity.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "a5308c98-25d4-4e34-96e1-3ba9fccfd021", "metadata": {}, "mutation_prompt": null}
{"id": "99bf31c2-c3ce-4e85-86c5-db84dd0cec57", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            adaptive_pop_size = max(4, int(self.population_size * (0.5 + 0.5 * np.cos(np.pi * it / self.iterations))))\n            for i in range(adaptive_pop_size):  # Adaptive population size\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(adaptive_pop_size):  # Adaptive population size\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Incorporate adaptive population size for improved balance between exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.1779495234791789, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "a5308c98-25d4-4e34-96e1-3ba9fccfd021", "metadata": {"aucs": [0.3439844287544501, 0.3500298949604336, 0.34162713778244647, 0.3655311715099624, 0.3530108241333402, 0.3653687748466484, 0.36445663569666753, 0.33501754283631435, 0.33568918370256395, 0.1057428206012786, 0.08772046589969107, 0.09163976675423635, 0.09215563824341766, 0.0763536309651619, 0.11211839374955757, 0.07479554390486831, 0.07347975793942263, 0.09892566761828625, 0.09137125699582738, 0.09952770007881695, 0.0867209651748937, 0.0910143819204925, 0.0853925144133415, 0.09456591581097529, 0.11839535380125377, 0.10160267318475236, 0.08584389179996688, 0.08268453226957939, 0.08224743648459076, 0.08661778678876109, 0.08169101559215342, 0.08456202511587796, 0.07838510317115543, 0.081293197425365, 0.0812548451391003, 0.07959575809601416, 0.8692773591491627, 0.8203758239525358, 0.882093631372654, 0.8096229216256803, 0.8195394824880948, 0.6756644392854906, 0.8699303905396327, 0.5549915632066731, 0.6641802719930456, 0.1823160203963956, 0.13487487894365457, 0.13749440949326674, 0.1664585970767123, 0.16686346763312376, 0.1492974256925027, 0.1693330624759506, 0.14851561481337672, 0.1590432641079662, 0.23868679085743405, 0.21304561829236623, 0.23502683207802721, 0.22923348600449678, 0.23682719865962132, 0.21805837459824529, 0.21179531116397188, 0.2457947914585501, 0.219034525177349, 0.11365053851009776, 0.11816552502612154, 0.11281006701535479, 0.09658408811288632, 0.10953034777086446, 0.11852255077593199, 0.12842394048681982, 0.10162499395636349, 0.11924511175390085, 0.09903509108051545, 0.0900825783386957, 0.11999018247311943, 0.11118983255187853, 0.10204046587151294, 0.10910921126045081, 0.10850884566054464, 0.09525087919739017, 0.10599298570909954, 0.03878264401604048, 0.03451591215657113, 0.028211975585706983, 0.037450260443251726, 0.02260910567669816, 0.04150493524257781, 0.04275938132519841, 0.050725929798907554, 0.024658520185676047, 0.13857683824403633, 0.13733362201340138, 0.11608041453960194, 0.09680730896710943, 0.10455542816135566, 0.13910308800710502, 0.10865025236822135, 0.12275739688157972, 0.16356202248723162, 9.999999999998899e-05, 9.999999999998899e-05, 0.005986003208922952, 9.999999999998899e-05, 0.009824630412880064, 0.005911078782681045, 0.0023454135840329515, 0.013515638046200595, 9.999999999998899e-05, 0.04690614183271935, 0.05607558103009924, 0.06484487548740181, 0.07088601524155569, 0.05596577084151666, 0.04966114307969782, 0.0530900806598098, 0.06086307267825086, 0.06175725213046479, 0.3049361778767259, 0.3213623283638686, 0.31783450907703237, 0.3256953114368757, 0.3355130341633601, 0.324024123597358, 0.34842537516039906, 0.33873317813215387, 0.32519044600676117, 0.09073819055752319, 0.09315509208576189, 0.08796637675878194, 0.08681245254218062, 0.09219169695230867, 0.09344333367767454, 0.08444498683692114, 0.0782305650488555, 0.07467179858081341, 0.13999086900324786, 0.1729445721434325, 0.16075490118567082, 0.1585036757408922, 0.18160430511654935, 0.15695308511082662, 0.17964924059155762, 0.15107859611351726, 0.15061674286598536, 0.21964606823334165, 0.23391378985120803, 0.2407381596762681, 0.22771587775603908, 0.22756966673799495, 0.22865131150865148, 0.24373110664837672, 0.23445890553561033, 0.23919663838606164, 0.17706538644191838, 0.17237042532600444, 0.17245547269164585, 0.16844472978785108, 0.17036975822770217, 0.17771861029411506, 0.17351056300176593, 0.1771925463348596, 0.16480272515984218, 0.2172089895867103, 0.17623507036720054, 0.2201906111738764, 0.1881953295352632, 0.1837455613731508, 0.1914708520889099, 0.19179934619831418, 0.1913370444574739, 0.19744892865256214, 0.1674820379738967, 0.17580128266479733, 0.168572523302278, 0.18014407938196253, 0.18674386247673302, 0.17109904497751427, 0.19240198140980624, 0.17602559803426898, 0.17258622242828026, 0.21876389526598172, 0.2871189509847878, 0.31598481351765373, 0.41168892991784356, 0.2371100097273554, 0.18708896923291507, 0.26677586949916055, 0.15956870810637014, 0.19832328268450805, 0.21675797219189818, 0.18693842037042907, 0.18153423609999497, 0.1650571029506842, 0.18723410926968964, 0.15598083886517544, 0.1958286585674539, 0.21643077896925, 0.19461513032483668, 0.18757537331428853, 0.1877899631810972, 0.1881420023139896, 0.186142073236801, 0.17434793993006514, 0.18751255127672561, 0.17794146947056344, 0.18630278636787323, 0.19082145595741773, 0.07927661981060208, 0.06895570434915776, 0.07728063199723167, 0.07349129114576247, 0.07181711281123737, 0.07882152310416746, 0.07148758050724224, 0.07118137700652738, 0.06767971240091264]}, "mutation_prompt": null}
{"id": "5f392230-2b8b-483d-89c3-788082e4d94d", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            self.CR = 0.5 + 0.4 * np.cos(np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                if np.random.rand() < 0.1 and self.elite_solutions:  # Elite-guided mutation\n                    elite = self.elite_solutions[np.random.randint(0, len(self.elite_solutions))]\n                    mutant += 0.1 * (elite - x1)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive crossover rate and employ elite-guided mutation to enhance convergence.", "configspace": "", "generation": 12, "fitness": 0.17866679919653475, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "a5308c98-25d4-4e34-96e1-3ba9fccfd021", "metadata": {"aucs": [0.36495207154514553, 0.3476108554461891, 0.3478073401022653, 0.3590399103657149, 0.36330216658583003, 0.369976820712135, 0.35687858411584783, 0.3433681486313648, 0.36800062457571536, 0.08630787387572891, 0.12930718085927562, 0.09986807122966801, 0.10181129273273692, 0.09602198610918333, 0.09935702901968702, 0.08473693685917005, 0.10498216451581266, 0.1040128310313223, 0.10329663114188004, 0.12114688259790785, 0.09528714686448236, 0.08623179781117973, 0.08812897789307972, 0.0947975796238103, 0.10011755195355143, 0.09194798557703165, 0.09625972854653941, 0.07970208091057562, 0.07726877039822644, 0.0785362418474671, 0.08452555570258935, 0.08488199633576277, 0.07401801488164905, 0.09428096294886634, 0.07878880685933531, 0.08155681359357203, 0.7471867986444027, 0.747713915574893, 0.8446345213142243, 0.6603141210199192, 0.7518741032621982, 0.8745780834113661, 0.6472937110691237, 0.8600094363933937, 0.7890872455802393, 0.16286181561012858, 0.15246498736203773, 0.1690278832452906, 0.17136988985088264, 0.15691165644361738, 0.17141707642671133, 0.1726699314936444, 0.14200718845178595, 0.15531203488168777, 0.23120276803425666, 0.22122583995407186, 0.24465537986251096, 0.22646555998004747, 0.26319662080310957, 0.21704369695810732, 0.23751305128154532, 0.2348408173087424, 0.25839582590535537, 0.10971401042605888, 0.10059725901695205, 0.11785254735481865, 0.11480058751966993, 0.1181356254611643, 0.12226228172944753, 0.1104656785710928, 0.10473477484291704, 0.1151896609196621, 0.11315964989740368, 0.111926092319943, 0.11103553645337239, 0.11646330341976407, 0.11180781745128665, 0.1161799526657663, 0.09536870300148348, 0.1335185105768545, 0.10828346799902844, 0.030511249104686833, 0.07608504070102373, 0.019017825422712353, 0.015263826645575906, 0.02592280212168152, 0.03855747730309689, 0.03880306360309316, 0.021006539705668903, 0.04326225770295078, 0.12425251684915672, 0.12601154447915108, 0.11235104365806925, 0.08052952084879128, 0.09364701871824077, 0.13342592257830221, 0.14724280860668404, 0.12331264672844156, 0.11861731698967792, 0.0011690670275362747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00573689057383342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04867494331793898, 0.054900888895387245, 0.05650881627438098, 0.061316629448473936, 0.07417737257961832, 0.07470594696648314, 0.06780564832276081, 0.05984431929107792, 0.05154221408231929, 0.3386313049908538, 0.33234270879823347, 0.34617963261408846, 0.3363979404657014, 0.35371298044708943, 0.3852902166325267, 0.3333990036204374, 0.335183422717654, 0.32701521593336114, 0.08738671146825672, 0.08818180391761721, 0.09012499782495431, 0.10335480209223391, 0.08271248951283683, 0.08890207981322984, 0.08899350416639151, 0.07986725078515233, 0.08531314410068158, 0.1735404320581989, 0.17516531802295854, 0.1780030050215049, 0.17686101196607107, 0.1611009904107139, 0.16352609616340708, 0.14465996326377806, 0.14022482331747266, 0.15705439609450056, 0.23054115941650843, 0.24766074303918217, 0.23446279106202905, 0.2310920464801699, 0.22318640168071802, 0.23971163090441416, 0.23495599833578695, 0.2568583207025473, 0.2393279553527181, 0.16904155002907661, 0.17633999628379893, 0.17145789731897443, 0.16780088470830856, 0.16315947101949368, 0.17318818499666155, 0.18181482677661343, 0.2202012525983713, 0.16403722282264444, 0.19960065599426924, 0.19496081372970298, 0.1888105270072269, 0.17842543471307037, 0.19757734600179788, 0.1982450874955588, 0.18495021642700227, 0.1910052096058522, 0.19736596046323496, 0.17608116936557505, 0.17659392357543802, 0.17605600080891015, 0.17766449332936152, 0.19997726195548593, 0.1744159793494593, 0.1818202212338954, 0.17706982502868718, 0.16831315073997088, 0.15762500610925967, 0.2322820426993043, 0.2709914461833075, 0.22138859017882073, 0.2874242040860605, 0.19983987765958022, 0.1470656137012929, 0.15656377258984033, 0.19391588331962373, 0.2610210013351425, 0.1941941293809366, 0.16873426775631628, 0.18071687422925664, 0.17406776531607338, 0.17865826557793785, 0.1978322780332482, 0.20241333019234475, 0.19842649639270615, 0.19008017340366623, 0.18044327423399187, 0.1807280439338188, 0.19816804790821274, 0.1723191947960353, 0.18408108061839945, 0.1807214253258087, 0.1921420158584155, 0.1834615433388661, 0.07335147569998013, 0.07593547409560597, 0.06959275464313319, 0.07271403139550747, 0.080272443076016, 0.07455158209752444, 0.07013950372558231, 0.08144326057140994, 0.0860376083189689]}, "mutation_prompt": null}
{"id": "5af81fbe-29e8-4111-9d68-d4027d0810e2", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * self.diversity_rate)\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce a diversity mechanism by periodically reinitializing a fraction of the population to prevent premature convergence.", "configspace": "", "generation": 13, "fitness": 0.18127089471828323, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "a5308c98-25d4-4e34-96e1-3ba9fccfd021", "metadata": {"aucs": [0.35059906688803744, 0.3606887997761884, 0.3418324431629569, 0.33287151547570915, 0.3468501303488656, 0.350035243819357, 0.3359201306137657, 0.3409155498645253, 0.34023922649386207, 0.07518089521201488, 0.07189869058266429, 0.1190066002332476, 0.10108508232418423, 0.09263106528973697, 0.09877096474969438, 0.09768535625877628, 0.09051376568459835, 0.0891852714956125, 0.09127140442165216, 0.08895519590238166, 0.08825945612882302, 0.09259308711197067, 0.08711425409942564, 0.09175721125308645, 0.08793539524255589, 0.08687417074181125, 0.09252694205221301, 0.07025025608644064, 0.0673869552606362, 0.08227715289296134, 0.07813177051030251, 0.08151675465020747, 0.06874549932961838, 0.08410434702489888, 0.07538441482219882, 0.07405394176340618, 0.8069183630764633, 0.7063153818536724, 0.9337775267458048, 0.8021453773014311, 0.7913276176218095, 0.877050563025577, 0.8759110003616064, 0.7981578046033818, 0.7767146504801232, 0.16473118405672216, 0.16508761078021328, 0.1557410545518576, 0.15655546529504205, 0.14736995959294819, 0.16376311771037422, 0.16681674906932809, 0.16498645239386422, 0.1837642658823615, 0.23772162722372359, 0.2199291839917954, 0.25116114508985954, 0.2622425205784855, 0.24851184344608723, 0.24980219399084702, 0.21428269971211344, 0.21448876373347303, 0.22279449377339977, 0.10013633626613505, 0.10267616465672524, 0.1191579727344273, 0.11184572483350952, 0.1075503117582346, 0.10373505438136599, 0.10911899083200971, 0.11159314698823652, 0.11439337738882727, 0.10622630944532774, 0.11411358941378458, 0.1074960911064804, 0.11530019094166488, 0.11089852896456764, 0.1152124392506696, 0.10893518996799723, 0.10328358658309922, 0.1115912357832809, 0.031752415758916186, 0.034345982050503654, 0.04144815234884869, 0.04569116760886338, 0.05918188098505073, 0.04424363551363042, 0.03025057667815778, 0.026001544017138056, 0.02605144718435981, 0.11006512118917378, 0.11582915870276134, 0.14773599647142333, 0.13649069748051368, 0.14044082227508992, 0.1079193599016216, 0.10405357552178851, 0.12007148189753392, 0.15088364196077986, 9.999999999998899e-05, 0.009555122010148076, 9.999999999998899e-05, 0.008469139150994676, 0.0017744118530039765, 0.0044397288279866, 0.016172295236548728, 0.004553073018669251, 0.0040636497058994525, 0.06245027106000256, 0.08440742240137533, 0.05695354729332014, 0.06353786480952928, 0.07245403245549098, 0.06388842449391652, 0.05216963740427405, 0.06806047733699339, 0.05841728545342362, 0.3143493779728743, 0.33458861554826114, 0.3182832531214793, 0.32208150809643343, 0.31932533959180165, 0.3495371874744878, 0.33890493504142727, 0.32389902951287664, 0.3311456644727807, 0.08966776093675266, 0.10437177185151691, 0.08461048578781116, 0.08374992137989934, 0.0837883120991686, 0.08889747379188428, 0.07756085706917437, 0.09105146746047599, 0.08228953891678048, 0.14761188376435963, 0.1878930573269394, 0.17332493140080518, 0.1414147963709944, 0.14476775093805705, 0.16231977770097672, 0.16187222075696117, 0.1481113774329471, 0.1436041933955695, 0.23365105754198745, 0.2263139689545638, 0.2273814616028329, 0.23397309614480055, 0.22454306321614714, 0.24449418499404374, 0.23257155250376205, 0.25322941828794154, 0.23777177328828358, 0.17323981378969888, 0.1832863670177991, 0.1712231544774453, 0.1598230157761834, 0.15502432498649865, 0.17839450997557016, 0.17946456223358054, 0.1761372073482631, 0.17565660083307588, 0.20940732662774308, 0.20765239894799647, 0.18932270957887265, 0.1847243521389823, 0.17765654604480718, 0.20165362601862458, 0.18399523099441106, 0.20024909153564063, 0.21575553093567745, 0.17579801219332425, 0.20386405276714603, 0.17078445449108604, 0.1822388673540153, 0.18006336735853423, 0.17909853326168246, 0.17154173231248893, 0.18111464502139418, 0.1912109780977176, 0.28779811607598726, 0.28179170409463705, 0.17993538187497948, 0.2994809750175136, 0.2562139323677529, 0.15882602022963055, 0.17651467632601725, 0.1847519296300547, 0.1635005726136851, 0.2291376621773653, 0.29461643026471374, 0.18556796846896384, 0.2888469327345279, 0.2119470820401651, 0.17701469367260092, 0.24831375789864896, 0.284689734833652, 0.19032439329995554, 0.18907931402452127, 0.17643234838437238, 0.1768228734721271, 0.19673112030804374, 0.1963505918109183, 0.2013408631607465, 0.19203100828711217, 0.18159225996388362, 0.1888004483859711, 0.07713540575633016, 0.07651680753814794, 0.06579942297004604, 0.07841745502269226, 0.07567154869552195, 0.07103687810326087, 0.08121544640250866, 0.07880035768944493, 0.06973016282173217]}, "mutation_prompt": null}
{"id": "060629b5-df52-49b4-9e76-75c032c52744", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * self.diversity_rate)\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce a diversity mechanism by periodically reinitializing a fraction of the population to prevent premature convergence.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5af81fbe-29e8-4111-9d68-d4027d0810e2", "metadata": {"aucs": [0.35059906688803744, 0.3606887997761884, 0.3418324431629569, 0.33287151547570915, 0.3468501303488656, 0.350035243819357, 0.3359201306137657, 0.3409155498645253, 0.34023922649386207, 0.07518089521201488, 0.07189869058266429, 0.1190066002332476, 0.10108508232418423, 0.09263106528973697, 0.09877096474969438, 0.09768535625877628, 0.09051376568459835, 0.0891852714956125, 0.09127140442165216, 0.08895519590238166, 0.08825945612882302, 0.09259308711197067, 0.08711425409942564, 0.09175721125308645, 0.08793539524255589, 0.08687417074181125, 0.09252694205221301, 0.07025025608644064, 0.0673869552606362, 0.08227715289296134, 0.07813177051030251, 0.08151675465020747, 0.06874549932961838, 0.08410434702489888, 0.07538441482219882, 0.07405394176340618, 0.8069183630764633, 0.7063153818536724, 0.9337775267458048, 0.8021453773014311, 0.7913276176218095, 0.877050563025577, 0.8759110003616064, 0.7981578046033818, 0.7767146504801232, 0.16473118405672216, 0.16508761078021328, 0.1557410545518576, 0.15655546529504205, 0.14736995959294819, 0.16376311771037422, 0.16681674906932809, 0.16498645239386422, 0.1837642658823615, 0.23772162722372359, 0.2199291839917954, 0.25116114508985954, 0.2622425205784855, 0.24851184344608723, 0.24980219399084702, 0.21428269971211344, 0.21448876373347303, 0.22279449377339977, 0.10013633626613505, 0.10267616465672524, 0.1191579727344273, 0.11184572483350952, 0.1075503117582346, 0.10373505438136599, 0.10911899083200971, 0.11159314698823652, 0.11439337738882727, 0.10622630944532774, 0.11411358941378458, 0.1074960911064804, 0.11530019094166488, 0.11089852896456764, 0.1152124392506696, 0.10893518996799723, 0.10328358658309922, 0.1115912357832809, 0.031752415758916186, 0.034345982050503654, 0.04144815234884869, 0.04569116760886338, 0.05918188098505073, 0.04424363551363042, 0.03025057667815778, 0.026001544017138056, 0.02605144718435981, 0.11006512118917378, 0.11582915870276134, 0.14773599647142333, 0.13649069748051368, 0.14044082227508992, 0.1079193599016216, 0.10405357552178851, 0.12007148189753392, 0.15088364196077986, 9.999999999998899e-05, 0.009555122010148076, 9.999999999998899e-05, 0.008469139150994676, 0.0017744118530039765, 0.0044397288279866, 0.016172295236548728, 0.004553073018669251, 0.0040636497058994525, 0.06245027106000256, 0.08440742240137533, 0.05695354729332014, 0.06353786480952928, 0.07245403245549098, 0.06388842449391652, 0.05216963740427405, 0.06806047733699339, 0.05841728545342362, 0.3143493779728743, 0.33458861554826114, 0.3182832531214793, 0.32208150809643343, 0.31932533959180165, 0.3495371874744878, 0.33890493504142727, 0.32389902951287664, 0.3311456644727807, 0.08966776093675266, 0.10437177185151691, 0.08461048578781116, 0.08374992137989934, 0.0837883120991686, 0.08889747379188428, 0.07756085706917437, 0.09105146746047599, 0.08228953891678048, 0.14761188376435963, 0.1878930573269394, 0.17332493140080518, 0.1414147963709944, 0.14476775093805705, 0.16231977770097672, 0.16187222075696117, 0.1481113774329471, 0.1436041933955695, 0.23365105754198745, 0.2263139689545638, 0.2273814616028329, 0.23397309614480055, 0.22454306321614714, 0.24449418499404374, 0.23257155250376205, 0.25322941828794154, 0.23777177328828358, 0.17323981378969888, 0.1832863670177991, 0.1712231544774453, 0.1598230157761834, 0.15502432498649865, 0.17839450997557016, 0.17946456223358054, 0.1761372073482631, 0.17565660083307588, 0.20940732662774308, 0.20765239894799647, 0.18932270957887265, 0.1847243521389823, 0.17765654604480718, 0.20165362601862458, 0.18399523099441106, 0.20024909153564063, 0.21575553093567745, 0.17579801219332425, 0.20386405276714603, 0.17078445449108604, 0.1822388673540153, 0.18006336735853423, 0.17909853326168246, 0.17154173231248893, 0.18111464502139418, 0.1912109780977176, 0.28779811607598726, 0.28179170409463705, 0.17993538187497948, 0.2994809750175136, 0.2562139323677529, 0.15882602022963055, 0.17651467632601725, 0.1847519296300547, 0.1635005726136851, 0.2291376621773653, 0.29461643026471374, 0.18556796846896384, 0.2888469327345279, 0.2119470820401651, 0.17701469367260092, 0.24831375789864896, 0.284689734833652, 0.19032439329995554, 0.18907931402452127, 0.17643234838437238, 0.1768228734721271, 0.19673112030804374, 0.1963505918109183, 0.2013408631607465, 0.19203100828711217, 0.18159225996388362, 0.1888004483859711, 0.07713540575633016, 0.07651680753814794, 0.06579942297004604, 0.07841745502269226, 0.07567154869552195, 0.07103687810326087, 0.08121544640250866, 0.07880035768944493, 0.06973016282173217]}, "mutation_prompt": null}
{"id": "bd0ae96b-3089-4188-abb3-728566f439fa", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * self.diversity_rate)\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce a diversity mechanism by periodically reinitializing a fraction of the population to prevent premature convergence.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5af81fbe-29e8-4111-9d68-d4027d0810e2", "metadata": {"aucs": [0.35059906688803744, 0.3606887997761884, 0.3418324431629569, 0.33287151547570915, 0.3468501303488656, 0.350035243819357, 0.3359201306137657, 0.3409155498645253, 0.34023922649386207, 0.07518089521201488, 0.07189869058266429, 0.1190066002332476, 0.10108508232418423, 0.09263106528973697, 0.09877096474969438, 0.09768535625877628, 0.09051376568459835, 0.0891852714956125, 0.09127140442165216, 0.08895519590238166, 0.08825945612882302, 0.09259308711197067, 0.08711425409942564, 0.09175721125308645, 0.08793539524255589, 0.08687417074181125, 0.09252694205221301, 0.07025025608644064, 0.0673869552606362, 0.08227715289296134, 0.07813177051030251, 0.08151675465020747, 0.06874549932961838, 0.08410434702489888, 0.07538441482219882, 0.07405394176340618, 0.8069183630764633, 0.7063153818536724, 0.9337775267458048, 0.8021453773014311, 0.7913276176218095, 0.877050563025577, 0.8759110003616064, 0.7981578046033818, 0.7767146504801232, 0.16473118405672216, 0.16508761078021328, 0.1557410545518576, 0.15655546529504205, 0.14736995959294819, 0.16376311771037422, 0.16681674906932809, 0.16498645239386422, 0.1837642658823615, 0.23772162722372359, 0.2199291839917954, 0.25116114508985954, 0.2622425205784855, 0.24851184344608723, 0.24980219399084702, 0.21428269971211344, 0.21448876373347303, 0.22279449377339977, 0.10013633626613505, 0.10267616465672524, 0.1191579727344273, 0.11184572483350952, 0.1075503117582346, 0.10373505438136599, 0.10911899083200971, 0.11159314698823652, 0.11439337738882727, 0.10622630944532774, 0.11411358941378458, 0.1074960911064804, 0.11530019094166488, 0.11089852896456764, 0.1152124392506696, 0.10893518996799723, 0.10328358658309922, 0.1115912357832809, 0.031752415758916186, 0.034345982050503654, 0.04144815234884869, 0.04569116760886338, 0.05918188098505073, 0.04424363551363042, 0.03025057667815778, 0.026001544017138056, 0.02605144718435981, 0.11006512118917378, 0.11582915870276134, 0.14773599647142333, 0.13649069748051368, 0.14044082227508992, 0.1079193599016216, 0.10405357552178851, 0.12007148189753392, 0.15088364196077986, 9.999999999998899e-05, 0.009555122010148076, 9.999999999998899e-05, 0.008469139150994676, 0.0017744118530039765, 0.0044397288279866, 0.016172295236548728, 0.004553073018669251, 0.0040636497058994525, 0.06245027106000256, 0.08440742240137533, 0.05695354729332014, 0.06353786480952928, 0.07245403245549098, 0.06388842449391652, 0.05216963740427405, 0.06806047733699339, 0.05841728545342362, 0.3143493779728743, 0.33458861554826114, 0.3182832531214793, 0.32208150809643343, 0.31932533959180165, 0.3495371874744878, 0.33890493504142727, 0.32389902951287664, 0.3311456644727807, 0.08966776093675266, 0.10437177185151691, 0.08461048578781116, 0.08374992137989934, 0.0837883120991686, 0.08889747379188428, 0.07756085706917437, 0.09105146746047599, 0.08228953891678048, 0.14761188376435963, 0.1878930573269394, 0.17332493140080518, 0.1414147963709944, 0.14476775093805705, 0.16231977770097672, 0.16187222075696117, 0.1481113774329471, 0.1436041933955695, 0.23365105754198745, 0.2263139689545638, 0.2273814616028329, 0.23397309614480055, 0.22454306321614714, 0.24449418499404374, 0.23257155250376205, 0.25322941828794154, 0.23777177328828358, 0.17323981378969888, 0.1832863670177991, 0.1712231544774453, 0.1598230157761834, 0.15502432498649865, 0.17839450997557016, 0.17946456223358054, 0.1761372073482631, 0.17565660083307588, 0.20940732662774308, 0.20765239894799647, 0.18932270957887265, 0.1847243521389823, 0.17765654604480718, 0.20165362601862458, 0.18399523099441106, 0.20024909153564063, 0.21575553093567745, 0.17579801219332425, 0.20386405276714603, 0.17078445449108604, 0.1822388673540153, 0.18006336735853423, 0.17909853326168246, 0.17154173231248893, 0.18111464502139418, 0.1912109780977176, 0.28779811607598726, 0.28179170409463705, 0.17993538187497948, 0.2994809750175136, 0.2562139323677529, 0.15882602022963055, 0.17651467632601725, 0.1847519296300547, 0.1635005726136851, 0.2291376621773653, 0.29461643026471374, 0.18556796846896384, 0.2888469327345279, 0.2119470820401651, 0.17701469367260092, 0.24831375789864896, 0.284689734833652, 0.19032439329995554, 0.18907931402452127, 0.17643234838437238, 0.1768228734721271, 0.19673112030804374, 0.1963505918109183, 0.2013408631607465, 0.19203100828711217, 0.18159225996388362, 0.1888004483859711, 0.07713540575633016, 0.07651680753814794, 0.06579942297004604, 0.07841745502269226, 0.07567154869552195, 0.07103687810326087, 0.08121544640250866, 0.07880035768944493, 0.06973016282173217]}, "mutation_prompt": null}
{"id": "d2e0cfc7-c584-4a86-af22-b33ec7ba5acd", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * self.diversity_rate)\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce a diversity mechanism by periodically reinitializing a fraction of the population to prevent premature convergence.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5af81fbe-29e8-4111-9d68-d4027d0810e2", "metadata": {"aucs": [0.35059906688803744, 0.3606887997761884, 0.3418324431629569, 0.33287151547570915, 0.3468501303488656, 0.350035243819357, 0.3359201306137657, 0.3409155498645253, 0.34023922649386207, 0.07518089521201488, 0.07189869058266429, 0.1190066002332476, 0.10108508232418423, 0.09263106528973697, 0.09877096474969438, 0.09768535625877628, 0.09051376568459835, 0.0891852714956125, 0.09127140442165216, 0.08895519590238166, 0.08825945612882302, 0.09259308711197067, 0.08711425409942564, 0.09175721125308645, 0.08793539524255589, 0.08687417074181125, 0.09252694205221301, 0.07025025608644064, 0.0673869552606362, 0.08227715289296134, 0.07813177051030251, 0.08151675465020747, 0.06874549932961838, 0.08410434702489888, 0.07538441482219882, 0.07405394176340618, 0.8069183630764633, 0.7063153818536724, 0.9337775267458048, 0.8021453773014311, 0.7913276176218095, 0.877050563025577, 0.8759110003616064, 0.7981578046033818, 0.7767146504801232, 0.16473118405672216, 0.16508761078021328, 0.1557410545518576, 0.15655546529504205, 0.14736995959294819, 0.16376311771037422, 0.16681674906932809, 0.16498645239386422, 0.1837642658823615, 0.23772162722372359, 0.2199291839917954, 0.25116114508985954, 0.2622425205784855, 0.24851184344608723, 0.24980219399084702, 0.21428269971211344, 0.21448876373347303, 0.22279449377339977, 0.10013633626613505, 0.10267616465672524, 0.1191579727344273, 0.11184572483350952, 0.1075503117582346, 0.10373505438136599, 0.10911899083200971, 0.11159314698823652, 0.11439337738882727, 0.10622630944532774, 0.11411358941378458, 0.1074960911064804, 0.11530019094166488, 0.11089852896456764, 0.1152124392506696, 0.10893518996799723, 0.10328358658309922, 0.1115912357832809, 0.031752415758916186, 0.034345982050503654, 0.04144815234884869, 0.04569116760886338, 0.05918188098505073, 0.04424363551363042, 0.03025057667815778, 0.026001544017138056, 0.02605144718435981, 0.11006512118917378, 0.11582915870276134, 0.14773599647142333, 0.13649069748051368, 0.14044082227508992, 0.1079193599016216, 0.10405357552178851, 0.12007148189753392, 0.15088364196077986, 9.999999999998899e-05, 0.009555122010148076, 9.999999999998899e-05, 0.008469139150994676, 0.0017744118530039765, 0.0044397288279866, 0.016172295236548728, 0.004553073018669251, 0.0040636497058994525, 0.06245027106000256, 0.08440742240137533, 0.05695354729332014, 0.06353786480952928, 0.07245403245549098, 0.06388842449391652, 0.05216963740427405, 0.06806047733699339, 0.05841728545342362, 0.3143493779728743, 0.33458861554826114, 0.3182832531214793, 0.32208150809643343, 0.31932533959180165, 0.3495371874744878, 0.33890493504142727, 0.32389902951287664, 0.3311456644727807, 0.08966776093675266, 0.10437177185151691, 0.08461048578781116, 0.08374992137989934, 0.0837883120991686, 0.08889747379188428, 0.07756085706917437, 0.09105146746047599, 0.08228953891678048, 0.14761188376435963, 0.1878930573269394, 0.17332493140080518, 0.1414147963709944, 0.14476775093805705, 0.16231977770097672, 0.16187222075696117, 0.1481113774329471, 0.1436041933955695, 0.23365105754198745, 0.2263139689545638, 0.2273814616028329, 0.23397309614480055, 0.22454306321614714, 0.24449418499404374, 0.23257155250376205, 0.25322941828794154, 0.23777177328828358, 0.17323981378969888, 0.1832863670177991, 0.1712231544774453, 0.1598230157761834, 0.15502432498649865, 0.17839450997557016, 0.17946456223358054, 0.1761372073482631, 0.17565660083307588, 0.20940732662774308, 0.20765239894799647, 0.18932270957887265, 0.1847243521389823, 0.17765654604480718, 0.20165362601862458, 0.18399523099441106, 0.20024909153564063, 0.21575553093567745, 0.17579801219332425, 0.20386405276714603, 0.17078445449108604, 0.1822388673540153, 0.18006336735853423, 0.17909853326168246, 0.17154173231248893, 0.18111464502139418, 0.1912109780977176, 0.28779811607598726, 0.28179170409463705, 0.17993538187497948, 0.2994809750175136, 0.2562139323677529, 0.15882602022963055, 0.17651467632601725, 0.1847519296300547, 0.1635005726136851, 0.2291376621773653, 0.29461643026471374, 0.18556796846896384, 0.2888469327345279, 0.2119470820401651, 0.17701469367260092, 0.24831375789864896, 0.284689734833652, 0.19032439329995554, 0.18907931402452127, 0.17643234838437238, 0.1768228734721271, 0.19673112030804374, 0.1963505918109183, 0.2013408631607465, 0.19203100828711217, 0.18159225996388362, 0.1888004483859711, 0.07713540575633016, 0.07651680753814794, 0.06579942297004604, 0.07841745502269226, 0.07567154869552195, 0.07103687810326087, 0.08121544640250866, 0.07880035768944493, 0.06973016282173217]}, "mutation_prompt": null}
{"id": "f1821703-9fec-4055-a2a8-954acf614e75", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3 + np.random.uniform(-0.1, 0.1, self.dim))  # Adapted mutation\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n            \n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * self.diversity_rate)\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n            if len(self.elite_solutions) > 5:  # Selective elitism\n                self.elite_solutions = sorted(self.elite_solutions, key=func)[:5]\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance convergence by adapting mutation strategies and incorporating a selective elitism mechanism.", "configspace": "", "generation": 17, "fitness": 0.17684240860977082, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "5af81fbe-29e8-4111-9d68-d4027d0810e2", "metadata": {"aucs": [0.35250265922177115, 0.38667973970031266, 0.3422389918490375, 0.35981621928108165, 0.3789421319004923, 0.3344836983118218, 0.32650473594631124, 0.3353520353139504, 0.3300625008511141, 0.0635369961557748, 0.029407571595477244, 0.04755311351467095, 0.04133328938745018, 0.06095463407087531, 0.03866143513074827, 0.031199739083234035, 0.05083352514275463, 0.043549946055269184, 0.08568064659533081, 0.09765984076685597, 0.09530042752072587, 0.09382211967884746, 0.09428678939214352, 0.09414804743680238, 0.1031605565979622, 0.09235021899894291, 0.0907500901903261, 0.08991568600847766, 0.07879089545013596, 0.09279018153304519, 0.08276918989176851, 0.0741125224367315, 0.07803114977467507, 0.07575354552059066, 0.07794352822400308, 0.0783709941135663, 0.7744523761196835, 0.794765333928952, 0.9096517891106194, 0.7962107408510307, 0.9131264602924652, 0.7828073201345903, 0.8396350870974308, 0.8692353546212922, 0.8866375037118427, 0.14955735338849696, 0.13832711006647969, 0.15759544564882544, 0.16762465945604577, 0.13410732861348884, 0.1675880724009714, 0.16862074033216268, 0.1618666065990665, 0.17023198512148396, 0.207867578912872, 0.2217355986178744, 0.2179676304006768, 0.22368665416870215, 0.24146089920449654, 0.26269772854492834, 0.2230315284347515, 0.2391251241986071, 0.22602159475067207, 0.11657229939954072, 0.10575340693435997, 0.09656028194127542, 0.10556479481790626, 0.09952197470092083, 0.11836481873649152, 0.11810148204071502, 0.11105772236932299, 0.10784299867700031, 0.11607829192866481, 0.10326555362044743, 0.1163563861000686, 0.1265383875953776, 0.11398385405677813, 0.1093251667083488, 0.11281206952794032, 0.11022126100851004, 0.1110823811814442, 0.010075406957865018, 0.0236750325037296, 0.03214134602601337, 0.016360793016522268, 0.013072272185427725, 0.00793326886483503, 0.013354320135625097, 0.009510329566385534, 0.019970976301584953, 0.10381627064992316, 0.10948296516186817, 0.12699207454170192, 0.11345943531504532, 0.09506792374788986, 0.1133911951181501, 0.12367428082381449, 0.1301003797090814, 0.1353375920454999, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06290912018099593, 0.06742435643645917, 0.05746022892172664, 0.050797281878812495, 0.06466854617289186, 0.05803168399580971, 0.05184459634608374, 0.05676731207903718, 0.06207910465844202, 0.32328526311194905, 0.3186989079465833, 0.32009484830265633, 0.3335931567261835, 0.36257965206391074, 0.3033742832501273, 0.31044427339740954, 0.32346801187112073, 0.3215915957581862, 0.08409746986242206, 0.08397271261935091, 0.08338814358036595, 0.08790710676222147, 0.11601055237530766, 0.08485632949079869, 0.08362492224921914, 0.08395603762895609, 0.09062582049445045, 0.1496802328254322, 0.17472517838333856, 0.16944698282387693, 0.16501338020538936, 0.15162101402101558, 0.19733201661297417, 0.1493675333236033, 0.16314035693081785, 0.17456952092543399, 0.22552878777446372, 0.2286118171028838, 0.23928023313373603, 0.22332354995177783, 0.21244814817901603, 0.22430882564562493, 0.2390381750915802, 0.23067722940460722, 0.23063874192912115, 0.18933965752545645, 0.17625371871388174, 0.17569734575619045, 0.1554472225645792, 0.1666559370451116, 0.1603816124025731, 0.1738646925077293, 0.18390905745099784, 0.17500394847386247, 0.18644873421920172, 0.1911243125996286, 0.19343018036225545, 0.19571916479389184, 0.19051070199075926, 0.18584336139033175, 0.1844444565776402, 0.17689849761834908, 0.18203499013947355, 0.17175977822448074, 0.16962922377211376, 0.17164937317138884, 0.17424023522002807, 0.1810007750552901, 0.18943331294471366, 0.17463929789527377, 0.17405674484899625, 0.17373738113457804, 0.3871271394994349, 0.15415560800766126, 0.22719310445973806, 0.2682928627537383, 0.19776311925022594, 0.26568433850060247, 0.1873903835949402, 0.19972192868423466, 0.1890476642861162, 0.2145053879012686, 0.18043990776969454, 0.1875580645353756, 0.15914647901291323, 0.28281538635313275, 0.1998495841818626, 0.20351183988436117, 0.2020137337211766, 0.18524436000883338, 0.17515132926292643, 0.1778357502813782, 0.1856176252067685, 0.1913962245784192, 0.18335641889981813, 0.18067654722475668, 0.1808875466874461, 0.18611511608301812, 0.18097742382954418, 0.07171614078693078, 0.0740316677945706, 0.0659396556073285, 0.0773694989752357, 0.0753854399203312, 0.08056300677374006, 0.07200226475609284, 0.07761016243648777, 0.0782067999877849]}, "mutation_prompt": null}
{"id": "1fdbdb51-2776-46f5-9486-64828b46072f", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.cos(np.pi * it / self.iterations)  # Changed F to cosine\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 5 == 0:  # Increase frequency of reinitialization to every 5 iterations\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(np.pi * it / self.iterations))) # Dynamic diversity rate\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance convergence by adapting mutation strategy and using a dynamic diversity mechanism.", "configspace": "", "generation": 18, "fitness": 0.16719092917757153, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "5af81fbe-29e8-4111-9d68-d4027d0810e2", "metadata": {"aucs": [0.3137860784626877, 0.3115043260387771, 0.3096101174503596, 0.3235653532618493, 0.33340562299855303, 0.32341955020469504, 0.3026373508989415, 0.3098096402110643, 0.32484971271235585, 0.08424029136429712, 0.08126774449420737, 0.06978007679538145, 0.06834733450791008, 0.08727312282303479, 0.0589291440293962, 0.0654454281265191, 0.06960666297739337, 0.08035026813672153, 0.0993545543008939, 0.07225443033904977, 0.08695512057123556, 0.0749979210747862, 0.08717277882684171, 0.06994545932440799, 0.09243439612181192, 0.1040083750495665, 0.08524769204642124, 0.07364680074242314, 0.06981353932255496, 0.07623669494390417, 0.0683227919423347, 0.07582768024489217, 0.061019439186654534, 0.05908357557027999, 0.06953515737125437, 0.07603718777751278, 0.8823622773810148, 0.8785774871610996, 0.9165577172789596, 0.8682920874949878, 0.8741977465760513, 0.8657377839345728, 0.8974710151179751, 0.8794810602196232, 0.8303595758576902, 0.13258812927857855, 0.13767829752966987, 0.12988742229447836, 0.1346929040540299, 0.12820057408309382, 0.1214327217971426, 0.13826515166404152, 0.1340115656123244, 0.12360769998466326, 0.20183077388925308, 0.19485999473943427, 0.2205784972567626, 0.1946543413063383, 0.19117691479823562, 0.2161734679732118, 0.21611928189267293, 0.20769908626674716, 0.21038523097448403, 0.09472703937806404, 0.0776903288688996, 0.0881016520860568, 0.08653860429531923, 0.06164167509080232, 0.09268752099850008, 0.07978157846168654, 0.07627916063822937, 0.09211329983280137, 0.09005064464386325, 0.08905294910849604, 0.0650901927382107, 0.07811914435289857, 0.08418250281061779, 0.07259360979555873, 0.08859750016708234, 0.058696404191780904, 0.10427769729703629, 0.01378456177331877, 0.017609646718388494, 0.04770847441745918, 0.03288564136401584, 0.03993976365316376, 0.02935509966605221, 0.02659678274348498, 0.02310036519168457, 0.03886959026219161, 0.08747964721857093, 0.10574803631067975, 0.12329601857805117, 0.09695906607665872, 0.11327521325704293, 0.11027814408739689, 0.10865157142874837, 0.09036064983013836, 0.11680261433556915, 9.999999999998899e-05, 0.0013727704788736306, 0.0004318372809644089, 0.0032708187476481188, 9.999999999998899e-05, 0.0014377988291709443, 9.999999999998899e-05, 0.005483593670594589, 0.0009374697186204095, 0.053558623006768946, 0.0348042560499815, 0.05072515948786238, 0.05038424331367364, 0.039974357814658856, 0.041661624645723316, 0.04855304772167168, 0.05986326489347882, 0.04814056286605228, 0.3239000365609368, 0.28995789095470215, 0.2887888016495086, 0.30605895940861505, 0.305148307649321, 0.30334739164566205, 0.29812864538206774, 0.2884445530745704, 0.32552721568799625, 0.09066011491840364, 0.0793441668733329, 0.08354756051385426, 0.08458387760692532, 0.06884561255037569, 0.08590733727202993, 0.08355657711810416, 0.07083254015767093, 0.08473577556073686, 0.16479523632938253, 0.17468922517773355, 0.1719735768016435, 0.1446473529759904, 0.1514974233938836, 0.1692163112619861, 0.1745768339272834, 0.13015494993725407, 0.1603550858970284, 0.21331126220486907, 0.2244032360664192, 0.2140489211412301, 0.21615655790142763, 0.19451977444116353, 0.2142424571180641, 0.21227049671600373, 0.21186491837692234, 0.2162903087852861, 0.14433804346124268, 0.14476949746542866, 0.16427090245116815, 0.15886913111284262, 0.15296207930235906, 0.1561437251125226, 0.15195092940314603, 0.15089726846974771, 0.15562676258960706, 0.16933501299800247, 0.17472996326637114, 0.17699181347897142, 0.1982819989322243, 0.17923418365579435, 0.18222540820491262, 0.1728182013947207, 0.22911405996266998, 0.16738307101546057, 0.16100226660362482, 0.16255266379083, 0.16926369246210615, 0.16223044559678024, 0.17529566100327865, 0.18062249981115297, 0.16095221830596018, 0.17089482539055667, 0.15774173353445198, 0.20740043874286151, 0.14874602575073081, 0.25260989314750604, 0.17527594440235694, 0.15750112583149645, 0.17204601527366625, 0.22122448821176244, 0.15227971373368232, 0.16134822090311607, 0.18891871806182614, 0.1765103108149655, 0.15231403647103492, 0.22028829357517954, 0.1573187931163318, 0.19434611702670734, 0.29199320256008476, 0.20159179254537407, 0.18961788618768682, 0.17630705495907661, 0.19118939951347957, 0.1974285081817263, 0.19077067850015406, 0.1868771584952924, 0.19001324853789514, 0.19178337456568073, 0.2057204985510782, 0.19791581250362522, 0.06322190369811198, 0.06339681624002391, 0.06561459641421041, 0.07793801706901216, 0.06910594818962668, 0.08086473243577619, 0.05822124316828303, 0.0788393804967421, 0.06545191580259435]}, "mutation_prompt": null}
{"id": "39774ed4-a90f-4aea-88b6-57ad843532a3", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            elite_idx = np.random.choice(self.population_size, 1, p=fitness/fitness.sum())\n            elite_solution = population[elite_idx]\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)  # Changed 3 to 4\n                x1, x2, x3, x4 = population[indices]\n                if i % 2 == 0:  # Alternate mutation strategies\n                    mutant = x1 + self.F * (x2 - x3)\n                else:\n                    mutant = x1 + self.F * (x2 - x3 + x4 - elite_solution)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.1, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n\n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / T):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * self.diversity_rate)\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance convergence dynamics by dynamically adjusting mutation strategy and implementing elite selection.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence.').", "error": "ValueError('setting an array element with a sequence.')", "parent_id": "5af81fbe-29e8-4111-9d68-d4027d0810e2", "metadata": {}, "mutation_prompt": null}
{"id": "7f7713e4-6ca1-4de8-a33f-d069d4c74985", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.05, self.dim)  # Adjusted noise \n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  # Adjusted acceptance \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))  # Dynamic reinit rate\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance solution diversity by dynamically adjusting reinitialization rates and improving SA perturbation acceptance.", "configspace": "", "generation": 20, "fitness": 0.18480911850486895, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "5af81fbe-29e8-4111-9d68-d4027d0810e2", "metadata": {"aucs": [0.3514977147811239, 0.3692440105207423, 0.3512645797289964, 0.36951028022606214, 0.3820534642098221, 0.3865116984936271, 0.37405432601443644, 0.3643327905275814, 0.3673728847972949, 0.08175495895414497, 0.09673956265119521, 0.10263070340485159, 0.09627690022961066, 0.09059469438100765, 0.08968088942929331, 0.08281752880323634, 0.09228461540797839, 0.09567425661784945, 0.09855587762589546, 0.08034219048987956, 0.09105681940992305, 0.08675378419614443, 0.10716213810926656, 0.09905921230024306, 0.08821420077472719, 0.08320731129428693, 0.09754478569066072, 0.08607761095475563, 0.0754898588033941, 0.07616627307491453, 0.07997334764955288, 0.08496253316415059, 0.08659882162926602, 0.08291386574975912, 0.0846109380159149, 0.08215403194378745, 0.7857290712913759, 0.7874893223761803, 0.8019930579661843, 0.9532562037547598, 0.8732303548173073, 0.8788374802863549, 0.8842901201544037, 0.7999857640940223, 0.871126150375497, 0.19433363479121402, 0.14769607519201478, 0.16378867723104773, 0.15033307075538216, 0.15412149974790268, 0.1720574601589827, 0.1921514799492413, 0.17049698601826546, 0.16805822946157456, 0.23067847530924923, 0.2843189017505664, 0.2554703889530682, 0.25235193938649214, 0.26317333140942134, 0.2612694059595273, 0.22182933696570484, 0.2426329233067399, 0.24960607276098168, 0.11447484683794351, 0.09468759683331696, 0.120197850167165, 0.1274999005170272, 0.10535781662129007, 0.1274725186169282, 0.12156914112000927, 0.137767346729897, 0.11847922458840499, 0.12627384898519645, 0.1172355691647543, 0.11168028601802527, 0.09805267371597293, 0.12753563947615043, 0.11744357916370485, 0.10532316130336439, 0.09118809920147342, 0.1339920394533587, 0.07335844131575908, 0.061787686858418955, 0.05674430333288838, 0.03442183365673879, 0.05661225458580921, 0.0690182169385305, 0.03628641892694773, 0.05508557103096534, 0.049950572028766294, 0.13725696466244786, 0.1313629525942368, 0.10012941568677747, 0.11658142435025909, 0.1379271582056103, 0.106240823135201, 0.1452114943389412, 0.17012909589233327, 0.12068851484234833, 0.0020066124257031026, 0.00970260116736954, 0.008580584201566821, 0.00059280581975929, 0.02542711898743477, 0.016436222389476507, 0.000906014585736914, 0.005426283212277672, 0.025285011045332095, 0.07540699178517629, 0.06908893772565883, 0.06832329063045017, 0.07472406899278572, 0.058458401935772786, 0.08952484813461814, 0.07681219737227551, 0.07318601310895634, 0.06753556682207762, 0.35234379044415143, 0.33439540996445294, 0.36149635066203345, 0.34544036691843694, 0.35177063669476605, 0.37819276561370596, 0.34539931575204796, 0.3352363288903424, 0.346468622024783, 0.09446706756985312, 0.08226202553945128, 0.08245921074157647, 0.08865758874350627, 0.08755901955970546, 0.14215238921116302, 0.0867219355150668, 0.08658429151796643, 0.09361382125092876, 0.1508284127663223, 0.15227797848951719, 0.15462679570308246, 0.17186347015938608, 0.17089624149799842, 0.1470741047032863, 0.15623038124474975, 0.15923165541905637, 0.15595245938520597, 0.24686761012489555, 0.2334433199246544, 0.24161089783233158, 0.2304472026727714, 0.22500717308242524, 0.2416050328127458, 0.23715483269755677, 0.2664733351373687, 0.23208107820261192, 0.1768178749008874, 0.16287414773536635, 0.18165242897174272, 0.1667488898825824, 0.16984110095068772, 0.17979916153270825, 0.18214205227171332, 0.18743097658075125, 0.17323751268883447, 0.19041923293667373, 0.20824579960078649, 0.21384492295859037, 0.19181904150950868, 0.22421614380658628, 0.17898966470931899, 0.19160326215329038, 0.20181884555040164, 0.19270437464815382, 0.17429948222832425, 0.17740188637599164, 0.17374860579185591, 0.18591145583804813, 0.1789862761207729, 0.17312818540353858, 0.1750885513528374, 0.16394690296948133, 0.1768463414412732, 0.19298642799638943, 0.1555053001874509, 0.17139622752455874, 0.223467231488641, 0.153983423991903, 0.19932555498316007, 0.15401398690369283, 0.16761915854070653, 0.16365115497355232, 0.3176044863645763, 0.19385343724141735, 0.18132602112097862, 0.17390815085231226, 0.21007738440059864, 0.21084155801999738, 0.1409209730648432, 0.2165448073896028, 0.19210420941772488, 0.2011113341616153, 0.1833230482848882, 0.17642077460394634, 0.17916484388194642, 0.1899925440004515, 0.1907040262254207, 0.18976267753444664, 0.17825051664491998, 0.18792907605650644, 0.08585922598551243, 0.07311596017396804, 0.0793566366465116, 0.06841043635636801, 0.0685424456895043, 0.07154005901395688, 0.07704782246210506, 0.07490316405403286, 0.0738567459146432]}, "mutation_prompt": null}
{"id": "53b708b7-a486-4f3a-b730-a5b8cd044000", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.05, self.dim)  # Adjusted noise \n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  # Adjusted acceptance \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))  # Dynamic reinit rate\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance solution diversity by dynamically adjusting reinitialization rates and improving SA perturbation acceptance.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7f7713e4-6ca1-4de8-a33f-d069d4c74985", "metadata": {"aucs": [0.3514977147811239, 0.3692440105207423, 0.3512645797289964, 0.36951028022606214, 0.3820534642098221, 0.3865116984936271, 0.37405432601443644, 0.3643327905275814, 0.3673728847972949, 0.08175495895414497, 0.09673956265119521, 0.10263070340485159, 0.09627690022961066, 0.09059469438100765, 0.08968088942929331, 0.08281752880323634, 0.09228461540797839, 0.09567425661784945, 0.09855587762589546, 0.08034219048987956, 0.09105681940992305, 0.08675378419614443, 0.10716213810926656, 0.09905921230024306, 0.08821420077472719, 0.08320731129428693, 0.09754478569066072, 0.08607761095475563, 0.0754898588033941, 0.07616627307491453, 0.07997334764955288, 0.08496253316415059, 0.08659882162926602, 0.08291386574975912, 0.0846109380159149, 0.08215403194378745, 0.7857290712913759, 0.7874893223761803, 0.8019930579661843, 0.9532562037547598, 0.8732303548173073, 0.8788374802863549, 0.8842901201544037, 0.7999857640940223, 0.871126150375497, 0.19433363479121402, 0.14769607519201478, 0.16378867723104773, 0.15033307075538216, 0.15412149974790268, 0.1720574601589827, 0.1921514799492413, 0.17049698601826546, 0.16805822946157456, 0.23067847530924923, 0.2843189017505664, 0.2554703889530682, 0.25235193938649214, 0.26317333140942134, 0.2612694059595273, 0.22182933696570484, 0.2426329233067399, 0.24960607276098168, 0.11447484683794351, 0.09468759683331696, 0.120197850167165, 0.1274999005170272, 0.10535781662129007, 0.1274725186169282, 0.12156914112000927, 0.137767346729897, 0.11847922458840499, 0.12627384898519645, 0.1172355691647543, 0.11168028601802527, 0.09805267371597293, 0.12753563947615043, 0.11744357916370485, 0.10532316130336439, 0.09118809920147342, 0.1339920394533587, 0.07335844131575908, 0.061787686858418955, 0.05674430333288838, 0.03442183365673879, 0.05661225458580921, 0.0690182169385305, 0.03628641892694773, 0.05508557103096534, 0.049950572028766294, 0.13725696466244786, 0.1313629525942368, 0.10012941568677747, 0.11658142435025909, 0.1379271582056103, 0.106240823135201, 0.1452114943389412, 0.17012909589233327, 0.12068851484234833, 0.0020066124257031026, 0.00970260116736954, 0.008580584201566821, 0.00059280581975929, 0.02542711898743477, 0.016436222389476507, 0.000906014585736914, 0.005426283212277672, 0.025285011045332095, 0.07540699178517629, 0.06908893772565883, 0.06832329063045017, 0.07472406899278572, 0.058458401935772786, 0.08952484813461814, 0.07681219737227551, 0.07318601310895634, 0.06753556682207762, 0.35234379044415143, 0.33439540996445294, 0.36149635066203345, 0.34544036691843694, 0.35177063669476605, 0.37819276561370596, 0.34539931575204796, 0.3352363288903424, 0.346468622024783, 0.09446706756985312, 0.08226202553945128, 0.08245921074157647, 0.08865758874350627, 0.08755901955970546, 0.14215238921116302, 0.0867219355150668, 0.08658429151796643, 0.09361382125092876, 0.1508284127663223, 0.15227797848951719, 0.15462679570308246, 0.17186347015938608, 0.17089624149799842, 0.1470741047032863, 0.15623038124474975, 0.15923165541905637, 0.15595245938520597, 0.24686761012489555, 0.2334433199246544, 0.24161089783233158, 0.2304472026727714, 0.22500717308242524, 0.2416050328127458, 0.23715483269755677, 0.2664733351373687, 0.23208107820261192, 0.1768178749008874, 0.16287414773536635, 0.18165242897174272, 0.1667488898825824, 0.16984110095068772, 0.17979916153270825, 0.18214205227171332, 0.18743097658075125, 0.17323751268883447, 0.19041923293667373, 0.20824579960078649, 0.21384492295859037, 0.19181904150950868, 0.22421614380658628, 0.17898966470931899, 0.19160326215329038, 0.20181884555040164, 0.19270437464815382, 0.17429948222832425, 0.17740188637599164, 0.17374860579185591, 0.18591145583804813, 0.1789862761207729, 0.17312818540353858, 0.1750885513528374, 0.16394690296948133, 0.1768463414412732, 0.19298642799638943, 0.1555053001874509, 0.17139622752455874, 0.223467231488641, 0.153983423991903, 0.19932555498316007, 0.15401398690369283, 0.16761915854070653, 0.16365115497355232, 0.3176044863645763, 0.19385343724141735, 0.18132602112097862, 0.17390815085231226, 0.21007738440059864, 0.21084155801999738, 0.1409209730648432, 0.2165448073896028, 0.19210420941772488, 0.2011113341616153, 0.1833230482848882, 0.17642077460394634, 0.17916484388194642, 0.1899925440004515, 0.1907040262254207, 0.18976267753444664, 0.17825051664491998, 0.18792907605650644, 0.08585922598551243, 0.07311596017396804, 0.0793566366465116, 0.06841043635636801, 0.0685424456895043, 0.07154005901395688, 0.07704782246210506, 0.07490316405403286, 0.0738567459146432]}, "mutation_prompt": null}
{"id": "3b01d4e5-9ff5-46d6-bc7d-eb7d2348704e", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.05, self.dim)  # Adjusted noise \n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  # Adjusted acceptance \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))  # Dynamic reinit rate\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance solution diversity by dynamically adjusting reinitialization rates and improving SA perturbation acceptance.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7f7713e4-6ca1-4de8-a33f-d069d4c74985", "metadata": {"aucs": [0.3514977147811239, 0.3692440105207423, 0.3512645797289964, 0.36951028022606214, 0.3820534642098221, 0.3865116984936271, 0.37405432601443644, 0.3643327905275814, 0.3673728847972949, 0.08175495895414497, 0.09673956265119521, 0.10263070340485159, 0.09627690022961066, 0.09059469438100765, 0.08968088942929331, 0.08281752880323634, 0.09228461540797839, 0.09567425661784945, 0.09855587762589546, 0.08034219048987956, 0.09105681940992305, 0.08675378419614443, 0.10716213810926656, 0.09905921230024306, 0.08821420077472719, 0.08320731129428693, 0.09754478569066072, 0.08607761095475563, 0.0754898588033941, 0.07616627307491453, 0.07997334764955288, 0.08496253316415059, 0.08659882162926602, 0.08291386574975912, 0.0846109380159149, 0.08215403194378745, 0.7857290712913759, 0.7874893223761803, 0.8019930579661843, 0.9532562037547598, 0.8732303548173073, 0.8788374802863549, 0.8842901201544037, 0.7999857640940223, 0.871126150375497, 0.19433363479121402, 0.14769607519201478, 0.16378867723104773, 0.15033307075538216, 0.15412149974790268, 0.1720574601589827, 0.1921514799492413, 0.17049698601826546, 0.16805822946157456, 0.23067847530924923, 0.2843189017505664, 0.2554703889530682, 0.25235193938649214, 0.26317333140942134, 0.2612694059595273, 0.22182933696570484, 0.2426329233067399, 0.24960607276098168, 0.11447484683794351, 0.09468759683331696, 0.120197850167165, 0.1274999005170272, 0.10535781662129007, 0.1274725186169282, 0.12156914112000927, 0.137767346729897, 0.11847922458840499, 0.12627384898519645, 0.1172355691647543, 0.11168028601802527, 0.09805267371597293, 0.12753563947615043, 0.11744357916370485, 0.10532316130336439, 0.09118809920147342, 0.1339920394533587, 0.07335844131575908, 0.061787686858418955, 0.05674430333288838, 0.03442183365673879, 0.05661225458580921, 0.0690182169385305, 0.03628641892694773, 0.05508557103096534, 0.049950572028766294, 0.13725696466244786, 0.1313629525942368, 0.10012941568677747, 0.11658142435025909, 0.1379271582056103, 0.106240823135201, 0.1452114943389412, 0.17012909589233327, 0.12068851484234833, 0.0020066124257031026, 0.00970260116736954, 0.008580584201566821, 0.00059280581975929, 0.02542711898743477, 0.016436222389476507, 0.000906014585736914, 0.005426283212277672, 0.025285011045332095, 0.07540699178517629, 0.06908893772565883, 0.06832329063045017, 0.07472406899278572, 0.058458401935772786, 0.08952484813461814, 0.07681219737227551, 0.07318601310895634, 0.06753556682207762, 0.35234379044415143, 0.33439540996445294, 0.36149635066203345, 0.34544036691843694, 0.35177063669476605, 0.37819276561370596, 0.34539931575204796, 0.3352363288903424, 0.346468622024783, 0.09446706756985312, 0.08226202553945128, 0.08245921074157647, 0.08865758874350627, 0.08755901955970546, 0.14215238921116302, 0.0867219355150668, 0.08658429151796643, 0.09361382125092876, 0.1508284127663223, 0.15227797848951719, 0.15462679570308246, 0.17186347015938608, 0.17089624149799842, 0.1470741047032863, 0.15623038124474975, 0.15923165541905637, 0.15595245938520597, 0.24686761012489555, 0.2334433199246544, 0.24161089783233158, 0.2304472026727714, 0.22500717308242524, 0.2416050328127458, 0.23715483269755677, 0.2664733351373687, 0.23208107820261192, 0.1768178749008874, 0.16287414773536635, 0.18165242897174272, 0.1667488898825824, 0.16984110095068772, 0.17979916153270825, 0.18214205227171332, 0.18743097658075125, 0.17323751268883447, 0.19041923293667373, 0.20824579960078649, 0.21384492295859037, 0.19181904150950868, 0.22421614380658628, 0.17898966470931899, 0.19160326215329038, 0.20181884555040164, 0.19270437464815382, 0.17429948222832425, 0.17740188637599164, 0.17374860579185591, 0.18591145583804813, 0.1789862761207729, 0.17312818540353858, 0.1750885513528374, 0.16394690296948133, 0.1768463414412732, 0.19298642799638943, 0.1555053001874509, 0.17139622752455874, 0.223467231488641, 0.153983423991903, 0.19932555498316007, 0.15401398690369283, 0.16761915854070653, 0.16365115497355232, 0.3176044863645763, 0.19385343724141735, 0.18132602112097862, 0.17390815085231226, 0.21007738440059864, 0.21084155801999738, 0.1409209730648432, 0.2165448073896028, 0.19210420941772488, 0.2011113341616153, 0.1833230482848882, 0.17642077460394634, 0.17916484388194642, 0.1899925440004515, 0.1907040262254207, 0.18976267753444664, 0.17825051664491998, 0.18792907605650644, 0.08585922598551243, 0.07311596017396804, 0.0793566366465116, 0.06841043635636801, 0.0685424456895043, 0.07154005901395688, 0.07704782246210506, 0.07490316405403286, 0.0738567459146432]}, "mutation_prompt": null}
{"id": "97fc7f47-e349-44d4-bffa-adc5cdb9d1a8", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            self.CR = 0.7 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                neighborhood = np.median(population, axis=0)  # Use median of population as neighborhood\n                perturbed = neighborhood + np.random.normal(0, 0.05, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  # Adjusted acceptance \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))  # Dynamic reinit rate\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce neighborhood-based perturbation and adaptive crossover rate to improve exploitation-exploration balance.", "configspace": "", "generation": 23, "fitness": 0.10229054325608765, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.07.", "error": "", "parent_id": "7f7713e4-6ca1-4de8-a33f-d069d4c74985", "metadata": {"aucs": [0.3622737597680854, 0.2710789415243754, 0.22702909390156345, 0.13319424604343455, 0.11445994163467998, 0.13145792734710504, 0.1421804846691308, 0.14304789129132656, 0.13564387373880493, 0.10152067954487975, 0.0598542368026892, 0.11438936756725382, 0.08080700174123889, 0.07381944514324512, 0.050811668115374964, 0.09755662934884235, 0.10846163743696757, 0.07589532889892525, 0.06425797658380328, 0.07514403816901072, 0.06469098013588503, 0.07648110751691506, 0.032230494432832324, 0.03457527601448329, 0.057208146368814106, 0.025994131074526194, 0.015626666371924114, 0.006622406792784696, 0.014347862204093675, 0.03803290698376116, 0.021691247366298905, 0.013243371842968199, 0.021481542655514163, 0.0287752793988284, 0.009282513629358835, 0.006688038551848852, 0.10264983188408605, 0.06629982124787948, 0.060640117716212805, 0.10876124727566894, 0.07588181582849884, 0.07423404106469078, 0.08146424840083344, 0.056863358651958684, 0.05986669685850776, 0.07012519793722027, 0.055801171235368874, 0.08983681581199232, 0.04547038035230255, 0.03580068361800315, 0.06145123254974205, 0.10703409926610608, 0.05635733887736383, 0.10478939950623212, 0.12291378300802114, 0.12619034287680242, 0.09418371435948325, 0.14320794387025804, 0.0893565851844893, 0.058419065809903414, 0.07631436470443076, 0.09635520507925033, 0.15135629716859422, 0.14230115413392141, 0.03703719153006746, 9.999999999998899e-05, 9.999999999998899e-05, 0.11021153420604302, 0.0465186425439813, 0.13541652338550847, 0.12752391835112797, 0.15437628494801647, 0.1453011213539812, 0.07222399815168679, 0.10962519975948959, 0.08882506908349819, 0.1283603030638475, 0.21144176220451028, 0.11366720951184384, 0.10963243351277052, 0.1596817110506379, 9.999999999998899e-05, 0.05665821572605656, 9.999999999998899e-05, 0.07829339751048625, 0.03651227672241397, 0.010916231153268785, 0.03120402060014371, 9.999999999998899e-05, 0.15339083014996724, 0.12580304323332825, 0.08853263121687249, 0.11085739870377964, 0.05995162559721079, 0.07154898364645557, 0.05367635553320471, 0.14581754552816328, 0.10297256273536004, 0.12878265215539975, 0.04213068537365272, 0.06774884407037685, 0.06913140072604196, 0.04694863984551978, 0.0348977113913681, 0.08552312448417965, 0.022751112335242407, 0.03901112689381114, 0.030952356151356053, 9.999999999998899e-05, 0.002057610152970124, 9.999999999998899e-05, 0.0024320170106107986, 0.0008697038883234143, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015227072762494798, 0.1892079188470488, 0.19727826682822003, 0.2446198305050914, 0.166613440678528, 0.18241281513790497, 0.1820204092025286, 0.1860086461442214, 0.23073072947774653, 0.21405718167266918, 0.030198985210865392, 0.007315020205250766, 0.02198412468535549, 0.04433968003782973, 0.03301280826866482, 0.03144990598771691, 0.029552298679911604, 0.03465080700897483, 0.03894065656605561, 0.11172727633092272, 0.11769841235430745, 0.12344404054334468, 0.13766266535167793, 0.11031235353320479, 0.10840028529661028, 0.18550976147109954, 0.10699091809847106, 0.10436085666669315, 0.13358168218006372, 0.15437550273033795, 0.1613932299901244, 0.14887413094844704, 0.1644541408821798, 0.17520360686583902, 0.13357285966229815, 0.17377774300845283, 0.13426855827159545, 0.08155772658138849, 0.10345657642158113, 0.08398582550377798, 0.09272205458242155, 0.11120684582849882, 0.11759409403847276, 0.08783639503643459, 0.0999710548796362, 0.09549171114199362, 0.20808039840508008, 0.24799469132203944, 0.23857769617569813, 0.2284373330187458, 0.22581351303939678, 0.18596658540809963, 0.19514359847628937, 0.2571859365974024, 0.23843948573978235, 0.1574202286389842, 0.1544085186523565, 0.15454191108802728, 0.16485710342022797, 0.15672218571728735, 0.1542495508876891, 0.16300497985587958, 0.1606708777046746, 0.14837574798713538, 0.1754110794961924, 0.13001445899071673, 0.12142304285373062, 0.10391024841558227, 0.1207914665021157, 0.09180286074658395, 0.12008194702451713, 0.11224313492616333, 0.11775482940306725, 0.14724859783688626, 0.10297773482780848, 0.14068856428976173, 0.0971272342554812, 0.09450228686053763, 0.09522558912573931, 0.09215701648209229, 0.0900512556666263, 0.10699573743907276, 0.19465849150032533, 0.17975610060146208, 0.18093456391377605, 0.19488621347007506, 0.17581402455333917, 0.20129936860968067, 0.18264254659300472, 0.1899918208875323, 0.18877844238213015, 0.07188032700037417, 0.06173141616406541, 0.05370545426369466, 0.0853442638998878, 0.0800416363993176, 0.057487445826936545, 0.07757320051101635, 0.04336514712980111, 0.05522581162835993]}, "mutation_prompt": null}
{"id": "88738a1c-3b8a-42a0-b284-bef1c3f0d0f8", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.05, self.dim)  # Adjusted noise \n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  # Adjusted acceptance \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))  # Dynamic reinit rate\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance solution diversity by dynamically adjusting reinitialization rates and improving SA perturbation acceptance.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7f7713e4-6ca1-4de8-a33f-d069d4c74985", "metadata": {"aucs": [0.3514977147811239, 0.3692440105207423, 0.3512645797289964, 0.36951028022606214, 0.3820534642098221, 0.3865116984936271, 0.37405432601443644, 0.3643327905275814, 0.3673728847972949, 0.08175495895414497, 0.09673956265119521, 0.10263070340485159, 0.09627690022961066, 0.09059469438100765, 0.08968088942929331, 0.08281752880323634, 0.09228461540797839, 0.09567425661784945, 0.09855587762589546, 0.08034219048987956, 0.09105681940992305, 0.08675378419614443, 0.10716213810926656, 0.09905921230024306, 0.08821420077472719, 0.08320731129428693, 0.09754478569066072, 0.08607761095475563, 0.0754898588033941, 0.07616627307491453, 0.07997334764955288, 0.08496253316415059, 0.08659882162926602, 0.08291386574975912, 0.0846109380159149, 0.08215403194378745, 0.7857290712913759, 0.7874893223761803, 0.8019930579661843, 0.9532562037547598, 0.8732303548173073, 0.8788374802863549, 0.8842901201544037, 0.7999857640940223, 0.871126150375497, 0.19433363479121402, 0.14769607519201478, 0.16378867723104773, 0.15033307075538216, 0.15412149974790268, 0.1720574601589827, 0.1921514799492413, 0.17049698601826546, 0.16805822946157456, 0.23067847530924923, 0.2843189017505664, 0.2554703889530682, 0.25235193938649214, 0.26317333140942134, 0.2612694059595273, 0.22182933696570484, 0.2426329233067399, 0.24960607276098168, 0.11447484683794351, 0.09468759683331696, 0.120197850167165, 0.1274999005170272, 0.10535781662129007, 0.1274725186169282, 0.12156914112000927, 0.137767346729897, 0.11847922458840499, 0.12627384898519645, 0.1172355691647543, 0.11168028601802527, 0.09805267371597293, 0.12753563947615043, 0.11744357916370485, 0.10532316130336439, 0.09118809920147342, 0.1339920394533587, 0.07335844131575908, 0.061787686858418955, 0.05674430333288838, 0.03442183365673879, 0.05661225458580921, 0.0690182169385305, 0.03628641892694773, 0.05508557103096534, 0.049950572028766294, 0.13725696466244786, 0.1313629525942368, 0.10012941568677747, 0.11658142435025909, 0.1379271582056103, 0.106240823135201, 0.1452114943389412, 0.17012909589233327, 0.12068851484234833, 0.0020066124257031026, 0.00970260116736954, 0.008580584201566821, 0.00059280581975929, 0.02542711898743477, 0.016436222389476507, 0.000906014585736914, 0.005426283212277672, 0.025285011045332095, 0.07540699178517629, 0.06908893772565883, 0.06832329063045017, 0.07472406899278572, 0.058458401935772786, 0.08952484813461814, 0.07681219737227551, 0.07318601310895634, 0.06753556682207762, 0.35234379044415143, 0.33439540996445294, 0.36149635066203345, 0.34544036691843694, 0.35177063669476605, 0.37819276561370596, 0.34539931575204796, 0.3352363288903424, 0.346468622024783, 0.09446706756985312, 0.08226202553945128, 0.08245921074157647, 0.08865758874350627, 0.08755901955970546, 0.14215238921116302, 0.0867219355150668, 0.08658429151796643, 0.09361382125092876, 0.1508284127663223, 0.15227797848951719, 0.15462679570308246, 0.17186347015938608, 0.17089624149799842, 0.1470741047032863, 0.15623038124474975, 0.15923165541905637, 0.15595245938520597, 0.24686761012489555, 0.2334433199246544, 0.24161089783233158, 0.2304472026727714, 0.22500717308242524, 0.2416050328127458, 0.23715483269755677, 0.2664733351373687, 0.23208107820261192, 0.1768178749008874, 0.16287414773536635, 0.18165242897174272, 0.1667488898825824, 0.16984110095068772, 0.17979916153270825, 0.18214205227171332, 0.18743097658075125, 0.17323751268883447, 0.19041923293667373, 0.20824579960078649, 0.21384492295859037, 0.19181904150950868, 0.22421614380658628, 0.17898966470931899, 0.19160326215329038, 0.20181884555040164, 0.19270437464815382, 0.17429948222832425, 0.17740188637599164, 0.17374860579185591, 0.18591145583804813, 0.1789862761207729, 0.17312818540353858, 0.1750885513528374, 0.16394690296948133, 0.1768463414412732, 0.19298642799638943, 0.1555053001874509, 0.17139622752455874, 0.223467231488641, 0.153983423991903, 0.19932555498316007, 0.15401398690369283, 0.16761915854070653, 0.16365115497355232, 0.3176044863645763, 0.19385343724141735, 0.18132602112097862, 0.17390815085231226, 0.21007738440059864, 0.21084155801999738, 0.1409209730648432, 0.2165448073896028, 0.19210420941772488, 0.2011113341616153, 0.1833230482848882, 0.17642077460394634, 0.17916484388194642, 0.1899925440004515, 0.1907040262254207, 0.18976267753444664, 0.17825051664491998, 0.18792907605650644, 0.08585922598551243, 0.07311596017396804, 0.0793566366465116, 0.06841043635636801, 0.0685424456895043, 0.07154005901395688, 0.07704782246210506, 0.07490316405403286, 0.0738567459146432]}, "mutation_prompt": null}
{"id": "c71657be-7eee-409d-a32d-6aff778a03b9", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.05, self.dim)  # Adjusted noise \n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  # Adjusted acceptance \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))  # Dynamic reinit rate\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance solution diversity by dynamically adjusting reinitialization rates and improving SA perturbation acceptance.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7f7713e4-6ca1-4de8-a33f-d069d4c74985", "metadata": {"aucs": [0.3514977147811239, 0.3692440105207423, 0.3512645797289964, 0.36951028022606214, 0.3820534642098221, 0.3865116984936271, 0.37405432601443644, 0.3643327905275814, 0.3673728847972949, 0.08175495895414497, 0.09673956265119521, 0.10263070340485159, 0.09627690022961066, 0.09059469438100765, 0.08968088942929331, 0.08281752880323634, 0.09228461540797839, 0.09567425661784945, 0.09855587762589546, 0.08034219048987956, 0.09105681940992305, 0.08675378419614443, 0.10716213810926656, 0.09905921230024306, 0.08821420077472719, 0.08320731129428693, 0.09754478569066072, 0.08607761095475563, 0.0754898588033941, 0.07616627307491453, 0.07997334764955288, 0.08496253316415059, 0.08659882162926602, 0.08291386574975912, 0.0846109380159149, 0.08215403194378745, 0.7857290712913759, 0.7874893223761803, 0.8019930579661843, 0.9532562037547598, 0.8732303548173073, 0.8788374802863549, 0.8842901201544037, 0.7999857640940223, 0.871126150375497, 0.19433363479121402, 0.14769607519201478, 0.16378867723104773, 0.15033307075538216, 0.15412149974790268, 0.1720574601589827, 0.1921514799492413, 0.17049698601826546, 0.16805822946157456, 0.23067847530924923, 0.2843189017505664, 0.2554703889530682, 0.25235193938649214, 0.26317333140942134, 0.2612694059595273, 0.22182933696570484, 0.2426329233067399, 0.24960607276098168, 0.11447484683794351, 0.09468759683331696, 0.120197850167165, 0.1274999005170272, 0.10535781662129007, 0.1274725186169282, 0.12156914112000927, 0.137767346729897, 0.11847922458840499, 0.12627384898519645, 0.1172355691647543, 0.11168028601802527, 0.09805267371597293, 0.12753563947615043, 0.11744357916370485, 0.10532316130336439, 0.09118809920147342, 0.1339920394533587, 0.07335844131575908, 0.061787686858418955, 0.05674430333288838, 0.03442183365673879, 0.05661225458580921, 0.0690182169385305, 0.03628641892694773, 0.05508557103096534, 0.049950572028766294, 0.13725696466244786, 0.1313629525942368, 0.10012941568677747, 0.11658142435025909, 0.1379271582056103, 0.106240823135201, 0.1452114943389412, 0.17012909589233327, 0.12068851484234833, 0.0020066124257031026, 0.00970260116736954, 0.008580584201566821, 0.00059280581975929, 0.02542711898743477, 0.016436222389476507, 0.000906014585736914, 0.005426283212277672, 0.025285011045332095, 0.07540699178517629, 0.06908893772565883, 0.06832329063045017, 0.07472406899278572, 0.058458401935772786, 0.08952484813461814, 0.07681219737227551, 0.07318601310895634, 0.06753556682207762, 0.35234379044415143, 0.33439540996445294, 0.36149635066203345, 0.34544036691843694, 0.35177063669476605, 0.37819276561370596, 0.34539931575204796, 0.3352363288903424, 0.346468622024783, 0.09446706756985312, 0.08226202553945128, 0.08245921074157647, 0.08865758874350627, 0.08755901955970546, 0.14215238921116302, 0.0867219355150668, 0.08658429151796643, 0.09361382125092876, 0.1508284127663223, 0.15227797848951719, 0.15462679570308246, 0.17186347015938608, 0.17089624149799842, 0.1470741047032863, 0.15623038124474975, 0.15923165541905637, 0.15595245938520597, 0.24686761012489555, 0.2334433199246544, 0.24161089783233158, 0.2304472026727714, 0.22500717308242524, 0.2416050328127458, 0.23715483269755677, 0.2664733351373687, 0.23208107820261192, 0.1768178749008874, 0.16287414773536635, 0.18165242897174272, 0.1667488898825824, 0.16984110095068772, 0.17979916153270825, 0.18214205227171332, 0.18743097658075125, 0.17323751268883447, 0.19041923293667373, 0.20824579960078649, 0.21384492295859037, 0.19181904150950868, 0.22421614380658628, 0.17898966470931899, 0.19160326215329038, 0.20181884555040164, 0.19270437464815382, 0.17429948222832425, 0.17740188637599164, 0.17374860579185591, 0.18591145583804813, 0.1789862761207729, 0.17312818540353858, 0.1750885513528374, 0.16394690296948133, 0.1768463414412732, 0.19298642799638943, 0.1555053001874509, 0.17139622752455874, 0.223467231488641, 0.153983423991903, 0.19932555498316007, 0.15401398690369283, 0.16761915854070653, 0.16365115497355232, 0.3176044863645763, 0.19385343724141735, 0.18132602112097862, 0.17390815085231226, 0.21007738440059864, 0.21084155801999738, 0.1409209730648432, 0.2165448073896028, 0.19210420941772488, 0.2011113341616153, 0.1833230482848882, 0.17642077460394634, 0.17916484388194642, 0.1899925440004515, 0.1907040262254207, 0.18976267753444664, 0.17825051664491998, 0.18792907605650644, 0.08585922598551243, 0.07311596017396804, 0.0793566366465116, 0.06841043635636801, 0.0685424456895043, 0.07154005901395688, 0.07704782246210506, 0.07490316405403286, 0.0738567459146432]}, "mutation_prompt": null}
{"id": "c27974a1-2cbd-44a7-ae09-aa2499366b65", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.05, self.dim)  # Adjusted noise \n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  # Adjusted acceptance \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))  # Dynamic reinit rate\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance solution diversity by dynamically adjusting reinitialization rates and improving SA perturbation acceptance.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7f7713e4-6ca1-4de8-a33f-d069d4c74985", "metadata": {"aucs": [0.3514977147811239, 0.3692440105207423, 0.3512645797289964, 0.36951028022606214, 0.3820534642098221, 0.3865116984936271, 0.37405432601443644, 0.3643327905275814, 0.3673728847972949, 0.08175495895414497, 0.09673956265119521, 0.10263070340485159, 0.09627690022961066, 0.09059469438100765, 0.08968088942929331, 0.08281752880323634, 0.09228461540797839, 0.09567425661784945, 0.09855587762589546, 0.08034219048987956, 0.09105681940992305, 0.08675378419614443, 0.10716213810926656, 0.09905921230024306, 0.08821420077472719, 0.08320731129428693, 0.09754478569066072, 0.08607761095475563, 0.0754898588033941, 0.07616627307491453, 0.07997334764955288, 0.08496253316415059, 0.08659882162926602, 0.08291386574975912, 0.0846109380159149, 0.08215403194378745, 0.7857290712913759, 0.7874893223761803, 0.8019930579661843, 0.9532562037547598, 0.8732303548173073, 0.8788374802863549, 0.8842901201544037, 0.7999857640940223, 0.871126150375497, 0.19433363479121402, 0.14769607519201478, 0.16378867723104773, 0.15033307075538216, 0.15412149974790268, 0.1720574601589827, 0.1921514799492413, 0.17049698601826546, 0.16805822946157456, 0.23067847530924923, 0.2843189017505664, 0.2554703889530682, 0.25235193938649214, 0.26317333140942134, 0.2612694059595273, 0.22182933696570484, 0.2426329233067399, 0.24960607276098168, 0.11447484683794351, 0.09468759683331696, 0.120197850167165, 0.1274999005170272, 0.10535781662129007, 0.1274725186169282, 0.12156914112000927, 0.137767346729897, 0.11847922458840499, 0.12627384898519645, 0.1172355691647543, 0.11168028601802527, 0.09805267371597293, 0.12753563947615043, 0.11744357916370485, 0.10532316130336439, 0.09118809920147342, 0.1339920394533587, 0.07335844131575908, 0.061787686858418955, 0.05674430333288838, 0.03442183365673879, 0.05661225458580921, 0.0690182169385305, 0.03628641892694773, 0.05508557103096534, 0.049950572028766294, 0.13725696466244786, 0.1313629525942368, 0.10012941568677747, 0.11658142435025909, 0.1379271582056103, 0.106240823135201, 0.1452114943389412, 0.17012909589233327, 0.12068851484234833, 0.0020066124257031026, 0.00970260116736954, 0.008580584201566821, 0.00059280581975929, 0.02542711898743477, 0.016436222389476507, 0.000906014585736914, 0.005426283212277672, 0.025285011045332095, 0.07540699178517629, 0.06908893772565883, 0.06832329063045017, 0.07472406899278572, 0.058458401935772786, 0.08952484813461814, 0.07681219737227551, 0.07318601310895634, 0.06753556682207762, 0.35234379044415143, 0.33439540996445294, 0.36149635066203345, 0.34544036691843694, 0.35177063669476605, 0.37819276561370596, 0.34539931575204796, 0.3352363288903424, 0.346468622024783, 0.09446706756985312, 0.08226202553945128, 0.08245921074157647, 0.08865758874350627, 0.08755901955970546, 0.14215238921116302, 0.0867219355150668, 0.08658429151796643, 0.09361382125092876, 0.1508284127663223, 0.15227797848951719, 0.15462679570308246, 0.17186347015938608, 0.17089624149799842, 0.1470741047032863, 0.15623038124474975, 0.15923165541905637, 0.15595245938520597, 0.24686761012489555, 0.2334433199246544, 0.24161089783233158, 0.2304472026727714, 0.22500717308242524, 0.2416050328127458, 0.23715483269755677, 0.2664733351373687, 0.23208107820261192, 0.1768178749008874, 0.16287414773536635, 0.18165242897174272, 0.1667488898825824, 0.16984110095068772, 0.17979916153270825, 0.18214205227171332, 0.18743097658075125, 0.17323751268883447, 0.19041923293667373, 0.20824579960078649, 0.21384492295859037, 0.19181904150950868, 0.22421614380658628, 0.17898966470931899, 0.19160326215329038, 0.20181884555040164, 0.19270437464815382, 0.17429948222832425, 0.17740188637599164, 0.17374860579185591, 0.18591145583804813, 0.1789862761207729, 0.17312818540353858, 0.1750885513528374, 0.16394690296948133, 0.1768463414412732, 0.19298642799638943, 0.1555053001874509, 0.17139622752455874, 0.223467231488641, 0.153983423991903, 0.19932555498316007, 0.15401398690369283, 0.16761915854070653, 0.16365115497355232, 0.3176044863645763, 0.19385343724141735, 0.18132602112097862, 0.17390815085231226, 0.21007738440059864, 0.21084155801999738, 0.1409209730648432, 0.2165448073896028, 0.19210420941772488, 0.2011113341616153, 0.1833230482848882, 0.17642077460394634, 0.17916484388194642, 0.1899925440004515, 0.1907040262254207, 0.18976267753444664, 0.17825051664491998, 0.18792907605650644, 0.08585922598551243, 0.07311596017396804, 0.0793566366465116, 0.06841043635636801, 0.0685424456895043, 0.07154005901395688, 0.07704782246210506, 0.07490316405403286, 0.0738567459146432]}, "mutation_prompt": null}
{"id": "0a21f69c-1e58-42da-b1e5-2bec49ef566c", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(np.pi * it / self.iterations)  # Dynamic F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                perturbed = population[i] + np.random.normal(0, 0.05, self.dim)  # Adjusted noise \n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  # Adjusted acceptance \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  # Every 10 iterations\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))  # Dynamic reinit rate\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  # Cool down the temperature\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance solution diversity by dynamically adjusting reinitialization rates and improving SA perturbation acceptance.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7f7713e4-6ca1-4de8-a33f-d069d4c74985", "metadata": {"aucs": [0.3514977147811239, 0.3692440105207423, 0.3512645797289964, 0.36951028022606214, 0.3820534642098221, 0.3865116984936271, 0.37405432601443644, 0.3643327905275814, 0.3673728847972949, 0.08175495895414497, 0.09673956265119521, 0.10263070340485159, 0.09627690022961066, 0.09059469438100765, 0.08968088942929331, 0.08281752880323634, 0.09228461540797839, 0.09567425661784945, 0.09855587762589546, 0.08034219048987956, 0.09105681940992305, 0.08675378419614443, 0.10716213810926656, 0.09905921230024306, 0.08821420077472719, 0.08320731129428693, 0.09754478569066072, 0.08607761095475563, 0.0754898588033941, 0.07616627307491453, 0.07997334764955288, 0.08496253316415059, 0.08659882162926602, 0.08291386574975912, 0.0846109380159149, 0.08215403194378745, 0.7857290712913759, 0.7874893223761803, 0.8019930579661843, 0.9532562037547598, 0.8732303548173073, 0.8788374802863549, 0.8842901201544037, 0.7999857640940223, 0.871126150375497, 0.19433363479121402, 0.14769607519201478, 0.16378867723104773, 0.15033307075538216, 0.15412149974790268, 0.1720574601589827, 0.1921514799492413, 0.17049698601826546, 0.16805822946157456, 0.23067847530924923, 0.2843189017505664, 0.2554703889530682, 0.25235193938649214, 0.26317333140942134, 0.2612694059595273, 0.22182933696570484, 0.2426329233067399, 0.24960607276098168, 0.11447484683794351, 0.09468759683331696, 0.120197850167165, 0.1274999005170272, 0.10535781662129007, 0.1274725186169282, 0.12156914112000927, 0.137767346729897, 0.11847922458840499, 0.12627384898519645, 0.1172355691647543, 0.11168028601802527, 0.09805267371597293, 0.12753563947615043, 0.11744357916370485, 0.10532316130336439, 0.09118809920147342, 0.1339920394533587, 0.07335844131575908, 0.061787686858418955, 0.05674430333288838, 0.03442183365673879, 0.05661225458580921, 0.0690182169385305, 0.03628641892694773, 0.05508557103096534, 0.049950572028766294, 0.13725696466244786, 0.1313629525942368, 0.10012941568677747, 0.11658142435025909, 0.1379271582056103, 0.106240823135201, 0.1452114943389412, 0.17012909589233327, 0.12068851484234833, 0.0020066124257031026, 0.00970260116736954, 0.008580584201566821, 0.00059280581975929, 0.02542711898743477, 0.016436222389476507, 0.000906014585736914, 0.005426283212277672, 0.025285011045332095, 0.07540699178517629, 0.06908893772565883, 0.06832329063045017, 0.07472406899278572, 0.058458401935772786, 0.08952484813461814, 0.07681219737227551, 0.07318601310895634, 0.06753556682207762, 0.35234379044415143, 0.33439540996445294, 0.36149635066203345, 0.34544036691843694, 0.35177063669476605, 0.37819276561370596, 0.34539931575204796, 0.3352363288903424, 0.346468622024783, 0.09446706756985312, 0.08226202553945128, 0.08245921074157647, 0.08865758874350627, 0.08755901955970546, 0.14215238921116302, 0.0867219355150668, 0.08658429151796643, 0.09361382125092876, 0.1508284127663223, 0.15227797848951719, 0.15462679570308246, 0.17186347015938608, 0.17089624149799842, 0.1470741047032863, 0.15623038124474975, 0.15923165541905637, 0.15595245938520597, 0.24686761012489555, 0.2334433199246544, 0.24161089783233158, 0.2304472026727714, 0.22500717308242524, 0.2416050328127458, 0.23715483269755677, 0.2664733351373687, 0.23208107820261192, 0.1768178749008874, 0.16287414773536635, 0.18165242897174272, 0.1667488898825824, 0.16984110095068772, 0.17979916153270825, 0.18214205227171332, 0.18743097658075125, 0.17323751268883447, 0.19041923293667373, 0.20824579960078649, 0.21384492295859037, 0.19181904150950868, 0.22421614380658628, 0.17898966470931899, 0.19160326215329038, 0.20181884555040164, 0.19270437464815382, 0.17429948222832425, 0.17740188637599164, 0.17374860579185591, 0.18591145583804813, 0.1789862761207729, 0.17312818540353858, 0.1750885513528374, 0.16394690296948133, 0.1768463414412732, 0.19298642799638943, 0.1555053001874509, 0.17139622752455874, 0.223467231488641, 0.153983423991903, 0.19932555498316007, 0.15401398690369283, 0.16761915854070653, 0.16365115497355232, 0.3176044863645763, 0.19385343724141735, 0.18132602112097862, 0.17390815085231226, 0.21007738440059864, 0.21084155801999738, 0.1409209730648432, 0.2165448073896028, 0.19210420941772488, 0.2011113341616153, 0.1833230482848882, 0.17642077460394634, 0.17916484388194642, 0.1899925440004515, 0.1907040262254207, 0.18976267753444664, 0.17825051664491998, 0.18792907605650644, 0.08585922598551243, 0.07311596017396804, 0.0793566366465116, 0.06841043635636801, 0.0685424456895043, 0.07154005901395688, 0.07704782246210506, 0.07490316405403286, 0.0738567459146432]}, "mutation_prompt": null}
{"id": "0335aebb-5b32-4c0e-a8d9-fd34032b73a8", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * it / self.iterations)  # Adaptive F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive mutation scaling and elitist perturbation for improved exploration and exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.18750586702510455, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "7f7713e4-6ca1-4de8-a33f-d069d4c74985", "metadata": {"aucs": [0.3778521797829981, 0.4160863301047779, 0.35515192690067, 0.39462694404307064, 0.3826317587760648, 0.3629289341721088, 0.37572152915621604, 0.39094376703681366, 0.3858019840060235, 0.09173046240760119, 0.07567752269355565, 0.08611305659338608, 0.08082865970395703, 0.07089771606028605, 0.08569311624106668, 0.08905781813281077, 0.08687635832054696, 0.0800869027122657, 0.10921207711112146, 0.1068446764610953, 0.10763041408962659, 0.10686716969543197, 0.09259474697747394, 0.08813061400035771, 0.08833149215024116, 0.07984442841849837, 0.08272019589878077, 0.0862826266909047, 0.08119277330260488, 0.09138969691851928, 0.07813689538872981, 0.09060005754940048, 0.07387602580748731, 0.08306666443627486, 0.07822168305143384, 0.08427397887276544, 0.8051272649529772, 0.8743405008043869, 0.7749838242835704, 0.8026072633675173, 0.8819068903837534, 0.802977279583905, 0.8683474606956798, 0.7820470572196399, 0.8746218087880675, 0.18984001964978303, 0.18131683285970834, 0.17532641254382253, 0.16320891929131487, 0.18249367882617085, 0.14730319273779402, 0.18372342003663134, 0.18117771316363662, 0.1900647106138469, 0.2615021872300065, 0.24428098690919053, 0.28685052506822395, 0.2357669022596316, 0.26283487861548716, 0.26456636136563716, 0.26448896550258283, 0.2339423029051355, 0.21712719652523216, 0.10083735177121256, 0.11734497096927721, 0.1334718627399326, 0.12482563499560584, 0.120108366916727, 0.1390854435505704, 0.14734358631354083, 0.13147093164178203, 0.12836599526563164, 0.12837428259789407, 0.10031466400290379, 0.12289256058602549, 0.1279364538695723, 0.13589054877076856, 0.13870679246893614, 0.13278514051400891, 0.12311066821322492, 0.12339985151324506, 0.045203190845302554, 0.06062126102590193, 0.05457233762486535, 0.06908154907959818, 0.03610374940472649, 0.07175862791903453, 0.055869621058137864, 0.03373311746991747, 0.06859279785860306, 0.14229627125509725, 0.14265893764958548, 0.1420686178091024, 0.10865633883600678, 0.11365430496161077, 0.1458838314492521, 0.1263746448736922, 0.12765245385063007, 0.11095039963413111, 0.008672481337354432, 0.010882627796228728, 0.0041316836266011014, 0.0012222475601327831, 0.008239107278439017, 0.013835323913653719, 0.017204040898468498, 0.007247686663685138, 0.0049654751409554665, 0.08084078626906599, 0.07019753239076743, 0.06423376997502217, 0.10076004695697705, 0.10511549558882582, 0.10993405431382597, 0.0980213881236115, 0.08794169947829433, 0.09526470456584724, 0.34852560499298557, 0.34690807531353673, 0.33730478127570995, 0.36056537355591467, 0.3706551704631007, 0.3498696766516005, 0.3552612693764149, 0.3428469262170326, 0.35480791865477324, 0.09195797931167449, 0.09110449615491034, 0.09439533801522881, 0.09468482554451108, 0.08203632331314947, 0.09088267225476643, 0.09084061464074389, 0.07990885826853178, 0.08508661316645105, 0.1496196727721636, 0.15714924651637507, 0.17127309724477413, 0.1838330213485121, 0.1723548911602516, 0.144512100250056, 0.14228368468381503, 0.16082848816011497, 0.14316926867493585, 0.2534625384157818, 0.22940583868075115, 0.24261465707089147, 0.24567962280537392, 0.2443676401023379, 0.26015890911968265, 0.23930353542933758, 0.2696341008616773, 0.24989611098361353, 0.1888352283723681, 0.16709406963031648, 0.17140866817800415, 0.17894750253523395, 0.17766878070535785, 0.17581266918469296, 0.20269995284720543, 0.19106069950340276, 0.19214267832308018, 0.19135026538648536, 0.19672140018725326, 0.18400308698595869, 0.19993838613895654, 0.19238325719561422, 0.19096810557272725, 0.17853063832187177, 0.18865578988616083, 0.18340313482991755, 0.19588269584436746, 0.17744562933705998, 0.18242060199355048, 0.17888392360123084, 0.1939338362215951, 0.18106452538094742, 0.18118159081816587, 0.1726811509303241, 0.17429208188939338, 0.16130335993714162, 0.16053299994201675, 0.1630948451960441, 0.3297547846884703, 0.16279998330308876, 0.18442705011048588, 0.1966352095415338, 0.23487110062499594, 0.20392626905935718, 0.186780248936655, 0.18486803946325836, 0.19139571132341726, 0.16037296646374632, 0.15498644257435956, 0.16810928306210082, 0.3100232764165637, 0.20127506289637243, 0.1965308750252459, 0.1910842876160238, 0.1800532936791358, 0.18438084560726853, 0.19057296255055467, 0.19266484788939486, 0.1909994645739409, 0.18883220616822505, 0.18524152604703747, 0.17985573324547477, 0.08375033246953045, 0.07772459614145633, 0.07195897142579055, 0.07747488316027851, 0.07058704197445931, 0.08607789677844069, 0.07621953816775351, 0.07571100081069349, 0.07838599826743631]}, "mutation_prompt": null}
{"id": "78dd17ca-e818-41ce-8716-a25c2dcd462d", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * it / self.iterations)  # Adaptive F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive mutation scaling and elitist perturbation for improved exploration and exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0335aebb-5b32-4c0e-a8d9-fd34032b73a8", "metadata": {"aucs": [0.3778521797829981, 0.4160863301047779, 0.35515192690067, 0.39462694404307064, 0.3826317587760648, 0.3629289341721088, 0.37572152915621604, 0.39094376703681366, 0.3858019840060235, 0.09173046240760119, 0.07567752269355565, 0.08611305659338608, 0.08082865970395703, 0.07089771606028605, 0.08569311624106668, 0.08905781813281077, 0.08687635832054696, 0.0800869027122657, 0.10921207711112146, 0.1068446764610953, 0.10763041408962659, 0.10686716969543197, 0.09259474697747394, 0.08813061400035771, 0.08833149215024116, 0.07984442841849837, 0.08272019589878077, 0.0862826266909047, 0.08119277330260488, 0.09138969691851928, 0.07813689538872981, 0.09060005754940048, 0.07387602580748731, 0.08306666443627486, 0.07822168305143384, 0.08427397887276544, 0.8051272649529772, 0.8743405008043869, 0.7749838242835704, 0.8026072633675173, 0.8819068903837534, 0.802977279583905, 0.8683474606956798, 0.7820470572196399, 0.8746218087880675, 0.18984001964978303, 0.18131683285970834, 0.17532641254382253, 0.16320891929131487, 0.18249367882617085, 0.14730319273779402, 0.18372342003663134, 0.18117771316363662, 0.1900647106138469, 0.2615021872300065, 0.24428098690919053, 0.28685052506822395, 0.2357669022596316, 0.26283487861548716, 0.26456636136563716, 0.26448896550258283, 0.2339423029051355, 0.21712719652523216, 0.10083735177121256, 0.11734497096927721, 0.1334718627399326, 0.12482563499560584, 0.120108366916727, 0.1390854435505704, 0.14734358631354083, 0.13147093164178203, 0.12836599526563164, 0.12837428259789407, 0.10031466400290379, 0.12289256058602549, 0.1279364538695723, 0.13589054877076856, 0.13870679246893614, 0.13278514051400891, 0.12311066821322492, 0.12339985151324506, 0.045203190845302554, 0.06062126102590193, 0.05457233762486535, 0.06908154907959818, 0.03610374940472649, 0.07175862791903453, 0.055869621058137864, 0.03373311746991747, 0.06859279785860306, 0.14229627125509725, 0.14265893764958548, 0.1420686178091024, 0.10865633883600678, 0.11365430496161077, 0.1458838314492521, 0.1263746448736922, 0.12765245385063007, 0.11095039963413111, 0.008672481337354432, 0.010882627796228728, 0.0041316836266011014, 0.0012222475601327831, 0.008239107278439017, 0.013835323913653719, 0.017204040898468498, 0.007247686663685138, 0.0049654751409554665, 0.08084078626906599, 0.07019753239076743, 0.06423376997502217, 0.10076004695697705, 0.10511549558882582, 0.10993405431382597, 0.0980213881236115, 0.08794169947829433, 0.09526470456584724, 0.34852560499298557, 0.34690807531353673, 0.33730478127570995, 0.36056537355591467, 0.3706551704631007, 0.3498696766516005, 0.3552612693764149, 0.3428469262170326, 0.35480791865477324, 0.09195797931167449, 0.09110449615491034, 0.09439533801522881, 0.09468482554451108, 0.08203632331314947, 0.09088267225476643, 0.09084061464074389, 0.07990885826853178, 0.08508661316645105, 0.1496196727721636, 0.15714924651637507, 0.17127309724477413, 0.1838330213485121, 0.1723548911602516, 0.144512100250056, 0.14228368468381503, 0.16082848816011497, 0.14316926867493585, 0.2534625384157818, 0.22940583868075115, 0.24261465707089147, 0.24567962280537392, 0.2443676401023379, 0.26015890911968265, 0.23930353542933758, 0.2696341008616773, 0.24989611098361353, 0.1888352283723681, 0.16709406963031648, 0.17140866817800415, 0.17894750253523395, 0.17766878070535785, 0.17581266918469296, 0.20269995284720543, 0.19106069950340276, 0.19214267832308018, 0.19135026538648536, 0.19672140018725326, 0.18400308698595869, 0.19993838613895654, 0.19238325719561422, 0.19096810557272725, 0.17853063832187177, 0.18865578988616083, 0.18340313482991755, 0.19588269584436746, 0.17744562933705998, 0.18242060199355048, 0.17888392360123084, 0.1939338362215951, 0.18106452538094742, 0.18118159081816587, 0.1726811509303241, 0.17429208188939338, 0.16130335993714162, 0.16053299994201675, 0.1630948451960441, 0.3297547846884703, 0.16279998330308876, 0.18442705011048588, 0.1966352095415338, 0.23487110062499594, 0.20392626905935718, 0.186780248936655, 0.18486803946325836, 0.19139571132341726, 0.16037296646374632, 0.15498644257435956, 0.16810928306210082, 0.3100232764165637, 0.20127506289637243, 0.1965308750252459, 0.1910842876160238, 0.1800532936791358, 0.18438084560726853, 0.19057296255055467, 0.19266484788939486, 0.1909994645739409, 0.18883220616822505, 0.18524152604703747, 0.17985573324547477, 0.08375033246953045, 0.07772459614145633, 0.07195897142579055, 0.07747488316027851, 0.07058704197445931, 0.08607789677844069, 0.07621953816775351, 0.07571100081069349, 0.07838599826743631]}, "mutation_prompt": null}
{"id": "177af1e8-e536-43fe-9106-09f6e916f0c9", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * it / self.iterations)  # Adaptive F\n            diversity = np.std(population, axis=0).mean()  # Added diversity measurement\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Adaptive Crossover Rate\n                self.CR = 0.6 + 0.3 * np.abs(np.sin(2 * np.pi * it / self.iterations))  # Changed crossover rate adaptively\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n                # Dynamic population resizing based on diversity\n                if diversity < 0.1:  # If diversity is low, increase population size\n                    self.population_size += 2  # Incremental increase\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by introducing adaptive crossover rate and dynamic population resizing based on diversity.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "0335aebb-5b32-4c0e-a8d9-fd34032b73a8", "metadata": {}, "mutation_prompt": null}
{"id": "2208585a-3112-4839-86a9-023ea583966f", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * it / self.iterations)  # Adaptive F\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive mutation scaling and elitist perturbation for improved exploration and exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0335aebb-5b32-4c0e-a8d9-fd34032b73a8", "metadata": {"aucs": [0.3778521797829981, 0.4160863301047779, 0.35515192690067, 0.39462694404307064, 0.3826317587760648, 0.3629289341721088, 0.37572152915621604, 0.39094376703681366, 0.3858019840060235, 0.09173046240760119, 0.07567752269355565, 0.08611305659338608, 0.08082865970395703, 0.07089771606028605, 0.08569311624106668, 0.08905781813281077, 0.08687635832054696, 0.0800869027122657, 0.10921207711112146, 0.1068446764610953, 0.10763041408962659, 0.10686716969543197, 0.09259474697747394, 0.08813061400035771, 0.08833149215024116, 0.07984442841849837, 0.08272019589878077, 0.0862826266909047, 0.08119277330260488, 0.09138969691851928, 0.07813689538872981, 0.09060005754940048, 0.07387602580748731, 0.08306666443627486, 0.07822168305143384, 0.08427397887276544, 0.8051272649529772, 0.8743405008043869, 0.7749838242835704, 0.8026072633675173, 0.8819068903837534, 0.802977279583905, 0.8683474606956798, 0.7820470572196399, 0.8746218087880675, 0.18984001964978303, 0.18131683285970834, 0.17532641254382253, 0.16320891929131487, 0.18249367882617085, 0.14730319273779402, 0.18372342003663134, 0.18117771316363662, 0.1900647106138469, 0.2615021872300065, 0.24428098690919053, 0.28685052506822395, 0.2357669022596316, 0.26283487861548716, 0.26456636136563716, 0.26448896550258283, 0.2339423029051355, 0.21712719652523216, 0.10083735177121256, 0.11734497096927721, 0.1334718627399326, 0.12482563499560584, 0.120108366916727, 0.1390854435505704, 0.14734358631354083, 0.13147093164178203, 0.12836599526563164, 0.12837428259789407, 0.10031466400290379, 0.12289256058602549, 0.1279364538695723, 0.13589054877076856, 0.13870679246893614, 0.13278514051400891, 0.12311066821322492, 0.12339985151324506, 0.045203190845302554, 0.06062126102590193, 0.05457233762486535, 0.06908154907959818, 0.03610374940472649, 0.07175862791903453, 0.055869621058137864, 0.03373311746991747, 0.06859279785860306, 0.14229627125509725, 0.14265893764958548, 0.1420686178091024, 0.10865633883600678, 0.11365430496161077, 0.1458838314492521, 0.1263746448736922, 0.12765245385063007, 0.11095039963413111, 0.008672481337354432, 0.010882627796228728, 0.0041316836266011014, 0.0012222475601327831, 0.008239107278439017, 0.013835323913653719, 0.017204040898468498, 0.007247686663685138, 0.0049654751409554665, 0.08084078626906599, 0.07019753239076743, 0.06423376997502217, 0.10076004695697705, 0.10511549558882582, 0.10993405431382597, 0.0980213881236115, 0.08794169947829433, 0.09526470456584724, 0.34852560499298557, 0.34690807531353673, 0.33730478127570995, 0.36056537355591467, 0.3706551704631007, 0.3498696766516005, 0.3552612693764149, 0.3428469262170326, 0.35480791865477324, 0.09195797931167449, 0.09110449615491034, 0.09439533801522881, 0.09468482554451108, 0.08203632331314947, 0.09088267225476643, 0.09084061464074389, 0.07990885826853178, 0.08508661316645105, 0.1496196727721636, 0.15714924651637507, 0.17127309724477413, 0.1838330213485121, 0.1723548911602516, 0.144512100250056, 0.14228368468381503, 0.16082848816011497, 0.14316926867493585, 0.2534625384157818, 0.22940583868075115, 0.24261465707089147, 0.24567962280537392, 0.2443676401023379, 0.26015890911968265, 0.23930353542933758, 0.2696341008616773, 0.24989611098361353, 0.1888352283723681, 0.16709406963031648, 0.17140866817800415, 0.17894750253523395, 0.17766878070535785, 0.17581266918469296, 0.20269995284720543, 0.19106069950340276, 0.19214267832308018, 0.19135026538648536, 0.19672140018725326, 0.18400308698595869, 0.19993838613895654, 0.19238325719561422, 0.19096810557272725, 0.17853063832187177, 0.18865578988616083, 0.18340313482991755, 0.19588269584436746, 0.17744562933705998, 0.18242060199355048, 0.17888392360123084, 0.1939338362215951, 0.18106452538094742, 0.18118159081816587, 0.1726811509303241, 0.17429208188939338, 0.16130335993714162, 0.16053299994201675, 0.1630948451960441, 0.3297547846884703, 0.16279998330308876, 0.18442705011048588, 0.1966352095415338, 0.23487110062499594, 0.20392626905935718, 0.186780248936655, 0.18486803946325836, 0.19139571132341726, 0.16037296646374632, 0.15498644257435956, 0.16810928306210082, 0.3100232764165637, 0.20127506289637243, 0.1965308750252459, 0.1910842876160238, 0.1800532936791358, 0.18438084560726853, 0.19057296255055467, 0.19266484788939486, 0.1909994645739409, 0.18883220616822505, 0.18524152604703747, 0.17985573324547477, 0.08375033246953045, 0.07772459614145633, 0.07195897142579055, 0.07747488316027851, 0.07058704197445931, 0.08607789677844069, 0.07621953816775351, 0.07571100081069349, 0.07838599826743631]}, "mutation_prompt": null}
{"id": "5eccc649-247a-4fdb-870b-3f8f4d370bce", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * it / self.iterations)  # Adaptive F\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by dynamically adjusting crossover rate and increasing diversity during stagnation.", "configspace": "", "generation": 32, "fitness": 0.193493767180695, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "0335aebb-5b32-4c0e-a8d9-fd34032b73a8", "metadata": {"aucs": [0.4197821846216657, 0.34303886493263214, 0.38093093581059934, 0.4038952448008901, 0.3867731316481351, 0.3690667892245879, 0.3672049464211161, 0.3678830077252574, 0.37177533700882337, 0.10566130116445693, 0.1085707914195071, 0.09031147276218598, 0.07828856725977185, 0.09647916278908564, 0.11674668563232116, 0.06670527693273576, 0.07348867567801387, 0.08735368605560945, 0.10263113968192483, 0.09329155208909234, 0.09998857571243502, 0.09020586650799067, 0.10809886430163529, 0.10088851734702897, 0.09932349219074199, 0.09718985019452064, 0.08979941527257673, 0.09026238170912093, 0.07788022867657618, 0.07793031059659117, 0.09300925910764801, 0.079923450761337, 0.08167649894238471, 0.09348033521389665, 0.08514921652652263, 0.0781881409390699, 0.7642098659325396, 0.7599052187913741, 0.7600619409998816, 0.8745470785550618, 0.7702628565790299, 0.7554908062227348, 0.874632274300918, 0.8742458653048292, 0.8033980016784881, 0.205078323554998, 0.1655799164789118, 0.15794332233252206, 0.18543164506006304, 0.1905998975623755, 0.20064076056655178, 0.18969113581607844, 0.17966131838537913, 0.19108251236763407, 0.2842858438938737, 0.733648895346081, 0.2698537195407943, 0.25004761549827204, 0.26907651276812616, 0.25683473904272125, 0.27656510342749263, 0.25874835115521133, 0.3072843196544953, 0.13396497210238945, 0.11886274751495052, 0.1270316552858869, 0.13059739063857434, 0.12365928248704017, 0.1100653834567683, 0.1237501727047624, 0.129989520021629, 0.13789595608015914, 0.10720807086382078, 0.11618136975602955, 0.13525427888589914, 0.12446197433392003, 0.12091446635320258, 0.11318025509892427, 0.14224035765035747, 0.12869243950970544, 0.12443757216478302, 0.08121834094246583, 0.06999306002161665, 0.04576513601247567, 0.07406136121868168, 0.07920197797956119, 0.05802374274656774, 0.08110589178867544, 0.08214823947959338, 0.04019310347704308, 0.11143433792694413, 0.13638033592787757, 0.14203267251353358, 0.18504336261187748, 0.11780356393550284, 0.12270643032456807, 0.13573765541976612, 0.14679416730095907, 0.14134299853133692, 0.0033021251108164007, 0.002285622679010335, 0.012875816615042779, 0.025149891749547515, 0.009250841563228973, 0.0007957633902040406, 0.035044466398862606, 9.999999999998899e-05, 0.012838436642587658, 0.08288796291178147, 0.06889980900742243, 0.0959225421058374, 0.06644204231553252, 0.08521667613759598, 0.09140055987869078, 0.07997116121021741, 0.0808351309739046, 0.08234430826672978, 0.37058770074379876, 0.343122043808857, 0.37181161835592647, 0.37512101082316707, 0.3667461187040213, 0.35279671521761125, 0.3568398440214594, 0.35348006054395087, 0.36430136081297815, 0.08979599650494752, 0.09095378429479173, 0.08776248184698365, 0.09825758240178495, 0.07935549770014583, 0.10010102995103953, 0.0785480943059732, 0.08916915259949088, 0.10997430611851233, 0.14706283068755766, 0.16600055222265564, 0.15546974513749923, 0.18797471904222507, 0.1651029317505034, 0.18055928906622176, 0.1566896059607179, 0.1525278047868016, 0.14928843501255273, 0.2386746481698626, 0.24590923558773214, 0.2560526921098015, 0.23820422283806597, 0.2280465572252074, 0.24192761727162415, 0.24866922713946482, 0.24294280102277055, 0.2537400042855612, 0.18539157114650695, 0.18076720339118624, 0.17710049501962477, 0.18283212001032734, 0.19403148607476228, 0.17987881356083557, 0.18312474979888393, 0.18218831979803207, 0.18700313055987794, 0.20069991740131587, 0.1833595301565749, 0.1976607124024693, 0.20251037243575953, 0.21452162962998345, 0.1688380722701479, 0.21612124074664163, 0.18001702571928058, 0.22011828717295334, 0.1712857977845339, 0.18196524923271884, 0.17616354535646317, 0.18148242643268309, 0.19188874016990354, 0.17357671798959995, 0.18278357369554343, 0.1804068434646482, 0.18073794877662608, 0.2052661756515799, 0.5127724272690531, 0.25679303882630744, 0.2219713333904184, 0.16900855629768718, 0.23394547534737098, 0.2803744648398516, 0.19664817531783108, 0.22112187074567136, 0.15772979113857832, 0.19977731922027964, 0.30377736902105357, 0.17080649468435516, 0.16589682131185202, 0.19875178638119628, 0.14659478421286443, 0.19108851273104488, 0.17998002175379824, 0.19307663266945085, 0.17880543489680822, 0.17544163105006483, 0.18122466785351943, 0.2016821844642448, 0.19493634671674465, 0.17961754488249349, 0.1874121928190543, 0.20198570784312742, 0.07727044899629787, 0.0733478284371597, 0.07790950217650339, 0.07816156991542211, 0.07576202587477288, 0.0698425244858406, 0.07925871744325319, 0.06880871272495004, 0.08116438286968075]}, "mutation_prompt": null}
{"id": "35b646ee-9f43-4973-88d0-6af3b1e1c3ef", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * it / self.iterations)  # Adaptive F\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by dynamically adjusting crossover rate and increasing diversity during stagnation.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5eccc649-247a-4fdb-870b-3f8f4d370bce", "metadata": {"aucs": [0.4197821846216657, 0.34303886493263214, 0.38093093581059934, 0.4038952448008901, 0.3867731316481351, 0.3690667892245879, 0.3672049464211161, 0.3678830077252574, 0.37177533700882337, 0.10566130116445693, 0.1085707914195071, 0.09031147276218598, 0.07828856725977185, 0.09647916278908564, 0.11674668563232116, 0.06670527693273576, 0.07348867567801387, 0.08735368605560945, 0.10263113968192483, 0.09329155208909234, 0.09998857571243502, 0.09020586650799067, 0.10809886430163529, 0.10088851734702897, 0.09932349219074199, 0.09718985019452064, 0.08979941527257673, 0.09026238170912093, 0.07788022867657618, 0.07793031059659117, 0.09300925910764801, 0.079923450761337, 0.08167649894238471, 0.09348033521389665, 0.08514921652652263, 0.0781881409390699, 0.7642098659325396, 0.7599052187913741, 0.7600619409998816, 0.8745470785550618, 0.7702628565790299, 0.7554908062227348, 0.874632274300918, 0.8742458653048292, 0.8033980016784881, 0.205078323554998, 0.1655799164789118, 0.15794332233252206, 0.18543164506006304, 0.1905998975623755, 0.20064076056655178, 0.18969113581607844, 0.17966131838537913, 0.19108251236763407, 0.2842858438938737, 0.733648895346081, 0.2698537195407943, 0.25004761549827204, 0.26907651276812616, 0.25683473904272125, 0.27656510342749263, 0.25874835115521133, 0.3072843196544953, 0.13396497210238945, 0.11886274751495052, 0.1270316552858869, 0.13059739063857434, 0.12365928248704017, 0.1100653834567683, 0.1237501727047624, 0.129989520021629, 0.13789595608015914, 0.10720807086382078, 0.11618136975602955, 0.13525427888589914, 0.12446197433392003, 0.12091446635320258, 0.11318025509892427, 0.14224035765035747, 0.12869243950970544, 0.12443757216478302, 0.08121834094246583, 0.06999306002161665, 0.04576513601247567, 0.07406136121868168, 0.07920197797956119, 0.05802374274656774, 0.08110589178867544, 0.08214823947959338, 0.04019310347704308, 0.11143433792694413, 0.13638033592787757, 0.14203267251353358, 0.18504336261187748, 0.11780356393550284, 0.12270643032456807, 0.13573765541976612, 0.14679416730095907, 0.14134299853133692, 0.0033021251108164007, 0.002285622679010335, 0.012875816615042779, 0.025149891749547515, 0.009250841563228973, 0.0007957633902040406, 0.035044466398862606, 9.999999999998899e-05, 0.012838436642587658, 0.08288796291178147, 0.06889980900742243, 0.0959225421058374, 0.06644204231553252, 0.08521667613759598, 0.09140055987869078, 0.07997116121021741, 0.0808351309739046, 0.08234430826672978, 0.37058770074379876, 0.343122043808857, 0.37181161835592647, 0.37512101082316707, 0.3667461187040213, 0.35279671521761125, 0.3568398440214594, 0.35348006054395087, 0.36430136081297815, 0.08979599650494752, 0.09095378429479173, 0.08776248184698365, 0.09825758240178495, 0.07935549770014583, 0.10010102995103953, 0.0785480943059732, 0.08916915259949088, 0.10997430611851233, 0.14706283068755766, 0.16600055222265564, 0.15546974513749923, 0.18797471904222507, 0.1651029317505034, 0.18055928906622176, 0.1566896059607179, 0.1525278047868016, 0.14928843501255273, 0.2386746481698626, 0.24590923558773214, 0.2560526921098015, 0.23820422283806597, 0.2280465572252074, 0.24192761727162415, 0.24866922713946482, 0.24294280102277055, 0.2537400042855612, 0.18539157114650695, 0.18076720339118624, 0.17710049501962477, 0.18283212001032734, 0.19403148607476228, 0.17987881356083557, 0.18312474979888393, 0.18218831979803207, 0.18700313055987794, 0.20069991740131587, 0.1833595301565749, 0.1976607124024693, 0.20251037243575953, 0.21452162962998345, 0.1688380722701479, 0.21612124074664163, 0.18001702571928058, 0.22011828717295334, 0.1712857977845339, 0.18196524923271884, 0.17616354535646317, 0.18148242643268309, 0.19188874016990354, 0.17357671798959995, 0.18278357369554343, 0.1804068434646482, 0.18073794877662608, 0.2052661756515799, 0.5127724272690531, 0.25679303882630744, 0.2219713333904184, 0.16900855629768718, 0.23394547534737098, 0.2803744648398516, 0.19664817531783108, 0.22112187074567136, 0.15772979113857832, 0.19977731922027964, 0.30377736902105357, 0.17080649468435516, 0.16589682131185202, 0.19875178638119628, 0.14659478421286443, 0.19108851273104488, 0.17998002175379824, 0.19307663266945085, 0.17880543489680822, 0.17544163105006483, 0.18122466785351943, 0.2016821844642448, 0.19493634671674465, 0.17961754488249349, 0.1874121928190543, 0.20198570784312742, 0.07727044899629787, 0.0733478284371597, 0.07790950217650339, 0.07816156991542211, 0.07576202587477288, 0.0698425244858406, 0.07925871744325319, 0.06880871272495004, 0.08116438286968075]}, "mutation_prompt": null}
{"id": "d74358b6-a1bf-4cb3-a3eb-a552e2e3a4ca", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * it / self.iterations)  # Adaptive F\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by dynamically adjusting crossover rate and increasing diversity during stagnation.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5eccc649-247a-4fdb-870b-3f8f4d370bce", "metadata": {"aucs": [0.4197821846216657, 0.34303886493263214, 0.38093093581059934, 0.4038952448008901, 0.3867731316481351, 0.3690667892245879, 0.3672049464211161, 0.3678830077252574, 0.37177533700882337, 0.10566130116445693, 0.1085707914195071, 0.09031147276218598, 0.07828856725977185, 0.09647916278908564, 0.11674668563232116, 0.06670527693273576, 0.07348867567801387, 0.08735368605560945, 0.10263113968192483, 0.09329155208909234, 0.09998857571243502, 0.09020586650799067, 0.10809886430163529, 0.10088851734702897, 0.09932349219074199, 0.09718985019452064, 0.08979941527257673, 0.09026238170912093, 0.07788022867657618, 0.07793031059659117, 0.09300925910764801, 0.079923450761337, 0.08167649894238471, 0.09348033521389665, 0.08514921652652263, 0.0781881409390699, 0.7642098659325396, 0.7599052187913741, 0.7600619409998816, 0.8745470785550618, 0.7702628565790299, 0.7554908062227348, 0.874632274300918, 0.8742458653048292, 0.8033980016784881, 0.205078323554998, 0.1655799164789118, 0.15794332233252206, 0.18543164506006304, 0.1905998975623755, 0.20064076056655178, 0.18969113581607844, 0.17966131838537913, 0.19108251236763407, 0.2842858438938737, 0.733648895346081, 0.2698537195407943, 0.25004761549827204, 0.26907651276812616, 0.25683473904272125, 0.27656510342749263, 0.25874835115521133, 0.3072843196544953, 0.13396497210238945, 0.11886274751495052, 0.1270316552858869, 0.13059739063857434, 0.12365928248704017, 0.1100653834567683, 0.1237501727047624, 0.129989520021629, 0.13789595608015914, 0.10720807086382078, 0.11618136975602955, 0.13525427888589914, 0.12446197433392003, 0.12091446635320258, 0.11318025509892427, 0.14224035765035747, 0.12869243950970544, 0.12443757216478302, 0.08121834094246583, 0.06999306002161665, 0.04576513601247567, 0.07406136121868168, 0.07920197797956119, 0.05802374274656774, 0.08110589178867544, 0.08214823947959338, 0.04019310347704308, 0.11143433792694413, 0.13638033592787757, 0.14203267251353358, 0.18504336261187748, 0.11780356393550284, 0.12270643032456807, 0.13573765541976612, 0.14679416730095907, 0.14134299853133692, 0.0033021251108164007, 0.002285622679010335, 0.012875816615042779, 0.025149891749547515, 0.009250841563228973, 0.0007957633902040406, 0.035044466398862606, 9.999999999998899e-05, 0.012838436642587658, 0.08288796291178147, 0.06889980900742243, 0.0959225421058374, 0.06644204231553252, 0.08521667613759598, 0.09140055987869078, 0.07997116121021741, 0.0808351309739046, 0.08234430826672978, 0.37058770074379876, 0.343122043808857, 0.37181161835592647, 0.37512101082316707, 0.3667461187040213, 0.35279671521761125, 0.3568398440214594, 0.35348006054395087, 0.36430136081297815, 0.08979599650494752, 0.09095378429479173, 0.08776248184698365, 0.09825758240178495, 0.07935549770014583, 0.10010102995103953, 0.0785480943059732, 0.08916915259949088, 0.10997430611851233, 0.14706283068755766, 0.16600055222265564, 0.15546974513749923, 0.18797471904222507, 0.1651029317505034, 0.18055928906622176, 0.1566896059607179, 0.1525278047868016, 0.14928843501255273, 0.2386746481698626, 0.24590923558773214, 0.2560526921098015, 0.23820422283806597, 0.2280465572252074, 0.24192761727162415, 0.24866922713946482, 0.24294280102277055, 0.2537400042855612, 0.18539157114650695, 0.18076720339118624, 0.17710049501962477, 0.18283212001032734, 0.19403148607476228, 0.17987881356083557, 0.18312474979888393, 0.18218831979803207, 0.18700313055987794, 0.20069991740131587, 0.1833595301565749, 0.1976607124024693, 0.20251037243575953, 0.21452162962998345, 0.1688380722701479, 0.21612124074664163, 0.18001702571928058, 0.22011828717295334, 0.1712857977845339, 0.18196524923271884, 0.17616354535646317, 0.18148242643268309, 0.19188874016990354, 0.17357671798959995, 0.18278357369554343, 0.1804068434646482, 0.18073794877662608, 0.2052661756515799, 0.5127724272690531, 0.25679303882630744, 0.2219713333904184, 0.16900855629768718, 0.23394547534737098, 0.2803744648398516, 0.19664817531783108, 0.22112187074567136, 0.15772979113857832, 0.19977731922027964, 0.30377736902105357, 0.17080649468435516, 0.16589682131185202, 0.19875178638119628, 0.14659478421286443, 0.19108851273104488, 0.17998002175379824, 0.19307663266945085, 0.17880543489680822, 0.17544163105006483, 0.18122466785351943, 0.2016821844642448, 0.19493634671674465, 0.17961754488249349, 0.1874121928190543, 0.20198570784312742, 0.07727044899629787, 0.0733478284371597, 0.07790950217650339, 0.07816156991542211, 0.07576202587477288, 0.0698425244858406, 0.07925871744325319, 0.06880871272495004, 0.08116438286968075]}, "mutation_prompt": null}
{"id": "8c6f7f90-2fde-4b86-8fa0-27a39b318e60", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * it / self.iterations)  # Adaptive F\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 + 0.03 * self.diversity_rate  # Adaptive elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 8 == 0:  # More frequent restarts\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive perturbation scale during elitist perturbation and refine restart strategy to enhance exploration.", "configspace": "", "generation": 35, "fitness": 0.1928212507708499, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "5eccc649-247a-4fdb-870b-3f8f4d370bce", "metadata": {"aucs": [0.3859745476439882, 0.3748100343553127, 0.3943258328632956, 0.40934855217989685, 0.4152051725196919, 0.41242311899217676, 0.40437746014769416, 0.39737860624944166, 0.4236548307006397, 0.08566542955854128, 0.10503469449593561, 0.09444308718924399, 0.12856204970991658, 0.08301990458869246, 0.08721851585184504, 0.07534703281005217, 0.09377366528212894, 0.09231264268542383, 0.0891318748840213, 0.10856783397040759, 0.10116324345958605, 0.09854540651816646, 0.08689490674435496, 0.09826690433937946, 0.09128890882035012, 0.09542987493199684, 0.11703725704320334, 0.10441746554008446, 0.09662457479135733, 0.08444376505813889, 0.07081905301509928, 0.08270773221465133, 0.07723200430015509, 0.07934063155766924, 0.08613361122166752, 0.07676790747197049, 0.8944232749086005, 0.6439225266067239, 0.7329315794556062, 0.8243889454189091, 0.7378690600727467, 0.8058060432612786, 0.8114927402497667, 0.735888065523993, 0.8147550716514651, 0.18977073525873833, 0.1811780854001559, 0.16114151826730316, 0.18792644473238174, 0.17123037375308736, 0.17780602869095308, 0.20531104054050964, 0.16590154082865305, 0.17561338704738516, 0.27657663754731077, 0.30374414744685174, 0.7029555664085794, 0.3040926495550269, 0.2918883813830805, 0.2890563253629551, 0.2991826168160633, 0.27366025410764694, 0.3005005157874363, 0.14782912704743956, 0.13001176728295938, 0.12740553027315982, 0.12077608172951748, 0.130944812330115, 0.11561305473249106, 0.11456415689854405, 0.13915146915302412, 0.1274233225509368, 0.09189858982392762, 0.1241901267445874, 0.13316647868706655, 0.13272720087487455, 0.10551313242280225, 0.10960363225662917, 0.14650138050139339, 0.09089150056222739, 0.13993011544914535, 0.05457371769878505, 0.06373505188756301, 0.05527239356312097, 0.07401661107185431, 0.07740793912687094, 0.06554285662282833, 0.057379422732103724, 0.08689855294280424, 0.05135069270986092, 0.14631609464475182, 0.13666206657368107, 0.1662926725496876, 0.1481740790149666, 0.15579821909087843, 0.1398764614381185, 0.15833173533789036, 0.13376588425738523, 0.14028873874433034, 0.004849178864967163, 0.009211152153992264, 0.0020668487857991025, 0.02781240439828858, 0.020256272040883427, 0.020692734235626786, 0.00280463710372858, 0.01129532386516019, 0.03354983377378862, 0.08442543971992766, 0.09536982455356902, 0.08686829378514249, 0.07715320251712987, 0.0864503068204463, 0.09231853463605999, 0.09414021828786134, 0.09832053878070979, 0.09199557678017067, 0.37307514099892525, 0.3897918058473281, 0.3661413506889287, 0.3476199128546217, 0.3778109317690638, 0.39218843028033457, 0.369916032825803, 0.39397624517633056, 0.37857885325982743, 0.08903701631708627, 0.10514116086981862, 0.08769609244583065, 0.08215127746726081, 0.08189873040918827, 0.10399729251153966, 0.09429590396093823, 0.09812123803376849, 0.09884747295832252, 0.17602557511771122, 0.14768995522355832, 0.14231877911882074, 0.18771828380897004, 0.14189915931463126, 0.14059683543781898, 0.19197396635356134, 0.16237339501454884, 0.14913233127108616, 0.25313823121593515, 0.26900194428936197, 0.2414916912926307, 0.25849555487225084, 0.25070549255844776, 0.24585692857107844, 0.2514913334427574, 0.243690460191183, 0.24655506214685674, 0.183257756978096, 0.18951245963071073, 0.1882535103865144, 0.1895877742608677, 0.194660581629704, 0.20197128067034542, 0.17813775327104575, 0.18690435787449067, 0.20425354646402483, 0.17976431823457384, 0.19153275178903761, 0.19592876190198028, 0.20997885501957203, 0.20216523212059923, 0.18935468451860238, 0.2163997238312132, 0.21549372980269743, 0.18627076973471213, 0.17301812991095922, 0.17180336693027132, 0.1759383040862118, 0.18483862759519198, 0.19627698911710034, 0.17079814161006612, 0.18541729439802035, 0.17943351156614795, 0.17611424909348317, 0.164182105277636, 0.21154270988520618, 0.18090138064744465, 0.2615890232023329, 0.186407370066749, 0.16521399603018505, 0.1703538983501619, 0.15573479195890938, 0.18747931455481648, 0.2234516077763935, 0.20064142403753016, 0.16220485290390152, 0.18827306535439225, 0.18711162332000564, 0.17628952949004761, 0.1406756656224627, 0.1627405915763338, 0.24220326992644936, 0.18470712716810644, 0.19452243856283202, 0.1786492943300193, 0.18172065317200703, 0.1830523054161336, 0.18668927408818603, 0.1853465128604902, 0.2044531107289943, 0.19340442633715482, 0.06941839243336112, 0.07330685245570434, 0.07081332227902437, 0.07119908341958803, 0.08876901260740255, 0.07923406718887249, 0.09187916650905059, 0.07665676828283485, 0.07495912811953043]}, "mutation_prompt": null}
{"id": "8697d96a-0132-4f82-ab04-d34beac5ff32", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            diversity = np.std(population, axis=0).mean()\n            self.F = 0.4 + 0.5 * (1 - diversity / (self.upper_bound - self.lower_bound))  # Adaptive F based on diversity\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive mutation scaling based on population diversity to enhance convergence rates.", "configspace": "", "generation": 36, "fitness": 0.16445170767268275, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "5eccc649-247a-4fdb-870b-3f8f4d370bce", "metadata": {"aucs": [0.294451931210432, 0.3181786502126769, 0.2719508658962847, 0.31258018506424334, 0.35026269848277014, 0.32225153114043736, 0.3044391651200784, 0.32246832552998017, 0.3339627899020231, 0.06318856202103251, 0.0646438736368351, 0.06262689871010774, 0.06688011601881794, 0.06978649289841177, 0.0861599483830976, 0.06835049044263763, 0.06349410414739032, 0.08718138406488929, 0.0838752441913646, 0.07966912787489056, 0.0823306806256322, 0.08181676347326261, 0.07820098861236147, 0.08035146122949444, 0.08504725912378708, 0.07937570746287403, 0.07745285443241356, 0.07009495802913002, 0.07834299176467086, 0.07714287274192899, 0.06733200071280931, 0.06732973571141643, 0.07081621055745602, 0.06853351830557863, 0.06514606716836246, 0.06225320294049508, 0.8740590400389224, 0.7699698737726157, 0.8702343918554819, 0.9720451369847617, 0.8859091613423962, 0.7033148483600835, 0.8877408865988228, 0.7621856775103916, 0.7106380994247454, 0.14989000876868708, 0.11510026830864117, 0.12847889767675247, 0.12152988563902778, 0.11387615145491925, 0.11913499820528883, 0.1390161291353963, 0.13624225775928367, 0.12127238757136838, 0.19592722762288928, 0.23922911555838544, 0.1927274987380757, 0.2159349524199049, 0.1896975470376514, 0.18446103387573398, 0.23538644948229925, 0.22798640104334278, 0.20565156053471212, 0.07062769155233306, 0.07647550228563671, 0.0793081269705117, 0.07668183888412583, 0.07452694659196446, 0.06153005337058004, 0.09533114666072506, 0.09932828257697746, 0.08509033357896445, 0.0893286164149586, 0.091496477345822, 0.09714270552281401, 0.08585324542586781, 0.07635708593782875, 0.06403776538368255, 0.06412729650574145, 0.09861199417298228, 0.08306194228401487, 0.01696859078919044, 0.03185884532858041, 0.04222404195321927, 0.033254432256691, 0.006847553934765882, 0.04539173837779231, 0.003139118386865425, 0.03572070747049694, 0.02012686823528187, 0.1312951587318152, 0.11601251053069717, 0.13074550806618368, 0.10645345343001589, 0.10406309046177542, 0.09479500228507076, 0.1162409093659571, 0.11964505533395664, 0.1265988215540419, 9.999999999998899e-05, 0.00047361520700450743, 9.999999999998899e-05, 9.999999999998899e-05, 0.001000860461865316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03493288707272846, 0.042885981106973836, 0.03916812326936647, 0.038942537976429215, 0.04089612179401758, 0.04620404471023687, 0.044330140729817114, 0.057336751142912035, 0.06289251013695762, 0.2692741530773217, 0.3058785867184777, 0.3102569487426705, 0.2915372260199699, 0.28636854021527824, 0.30164927010573306, 0.288156267013027, 0.286069923548525, 0.278400479527137, 0.09433375440348357, 0.0835365888393349, 0.10096786163406923, 0.09697965859318447, 0.0847173505771105, 0.08219578974904229, 0.0845816505269702, 0.07704854174589326, 0.08022323425776356, 0.21232026392740633, 0.1480350414371745, 0.16577350982480044, 0.21645164182092336, 0.14017611535856944, 0.17554682882824857, 0.16301303683018264, 0.17293047327112654, 0.1679064578384064, 0.20942964609956705, 0.20405729497421232, 0.20470144141909674, 0.2021121394852854, 0.20506715761862648, 0.20322105421149128, 0.22423494075217054, 0.21687574413952415, 0.21913874515142506, 0.14337767236239995, 0.1416287339976534, 0.1657647191413476, 0.15588936257242536, 0.15175608477424152, 0.13296946880842753, 0.15804677554672797, 0.1522132105083992, 0.18372406539851782, 0.18352423095664805, 0.18748970705719048, 0.1855706949340188, 0.1802587821827859, 0.188727877652329, 0.19761635276065148, 0.18249447547713682, 0.20089648505115998, 0.1723738706183061, 0.16080891376487272, 0.15911551444317773, 0.16623832227527802, 0.17316696650757457, 0.17281549495545334, 0.17991963060695448, 0.16821600502039014, 0.16752017598994606, 0.16904177300134904, 0.16232445495819958, 0.1678302566343849, 0.16597477189336318, 0.18823163005235466, 0.1563110073406282, 0.1777463100533474, 0.2557341257103001, 0.15497113598289558, 0.13725143910673776, 0.15792981591714583, 0.21814098437449392, 0.16948424320276922, 0.15238221475485447, 0.18995760476687262, 0.31029225307947494, 0.18769373767584596, 0.19067064048655236, 0.19673527585454043, 0.18580531411321832, 0.19272958304435772, 0.1878258551617239, 0.18700735503023735, 0.18029637675886245, 0.21098243103145964, 0.17865150638262983, 0.18564880320903432, 0.1795748766631996, 0.07107490622797175, 0.06292871849499226, 0.07084717801323082, 0.06952695995276148, 0.07448768897111846, 0.06571831871950284, 0.06983644379712639, 0.06914884339275307, 0.059811495715041185]}, "mutation_prompt": null}
{"id": "9bc57261-4df3-41f5-b64e-66d4b0b9639e", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * it / self.iterations)  # Adaptive F\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by dynamically adjusting crossover rate and increasing diversity during stagnation.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5eccc649-247a-4fdb-870b-3f8f4d370bce", "metadata": {"aucs": [0.4197821846216657, 0.34303886493263214, 0.38093093581059934, 0.4038952448008901, 0.3867731316481351, 0.3690667892245879, 0.3672049464211161, 0.3678830077252574, 0.37177533700882337, 0.10566130116445693, 0.1085707914195071, 0.09031147276218598, 0.07828856725977185, 0.09647916278908564, 0.11674668563232116, 0.06670527693273576, 0.07348867567801387, 0.08735368605560945, 0.10263113968192483, 0.09329155208909234, 0.09998857571243502, 0.09020586650799067, 0.10809886430163529, 0.10088851734702897, 0.09932349219074199, 0.09718985019452064, 0.08979941527257673, 0.09026238170912093, 0.07788022867657618, 0.07793031059659117, 0.09300925910764801, 0.079923450761337, 0.08167649894238471, 0.09348033521389665, 0.08514921652652263, 0.0781881409390699, 0.7642098659325396, 0.7599052187913741, 0.7600619409998816, 0.8745470785550618, 0.7702628565790299, 0.7554908062227348, 0.874632274300918, 0.8742458653048292, 0.8033980016784881, 0.205078323554998, 0.1655799164789118, 0.15794332233252206, 0.18543164506006304, 0.1905998975623755, 0.20064076056655178, 0.18969113581607844, 0.17966131838537913, 0.19108251236763407, 0.2842858438938737, 0.733648895346081, 0.2698537195407943, 0.25004761549827204, 0.26907651276812616, 0.25683473904272125, 0.27656510342749263, 0.25874835115521133, 0.3072843196544953, 0.13396497210238945, 0.11886274751495052, 0.1270316552858869, 0.13059739063857434, 0.12365928248704017, 0.1100653834567683, 0.1237501727047624, 0.129989520021629, 0.13789595608015914, 0.10720807086382078, 0.11618136975602955, 0.13525427888589914, 0.12446197433392003, 0.12091446635320258, 0.11318025509892427, 0.14224035765035747, 0.12869243950970544, 0.12443757216478302, 0.08121834094246583, 0.06999306002161665, 0.04576513601247567, 0.07406136121868168, 0.07920197797956119, 0.05802374274656774, 0.08110589178867544, 0.08214823947959338, 0.04019310347704308, 0.11143433792694413, 0.13638033592787757, 0.14203267251353358, 0.18504336261187748, 0.11780356393550284, 0.12270643032456807, 0.13573765541976612, 0.14679416730095907, 0.14134299853133692, 0.0033021251108164007, 0.002285622679010335, 0.012875816615042779, 0.025149891749547515, 0.009250841563228973, 0.0007957633902040406, 0.035044466398862606, 9.999999999998899e-05, 0.012838436642587658, 0.08288796291178147, 0.06889980900742243, 0.0959225421058374, 0.06644204231553252, 0.08521667613759598, 0.09140055987869078, 0.07997116121021741, 0.0808351309739046, 0.08234430826672978, 0.37058770074379876, 0.343122043808857, 0.37181161835592647, 0.37512101082316707, 0.3667461187040213, 0.35279671521761125, 0.3568398440214594, 0.35348006054395087, 0.36430136081297815, 0.08979599650494752, 0.09095378429479173, 0.08776248184698365, 0.09825758240178495, 0.07935549770014583, 0.10010102995103953, 0.0785480943059732, 0.08916915259949088, 0.10997430611851233, 0.14706283068755766, 0.16600055222265564, 0.15546974513749923, 0.18797471904222507, 0.1651029317505034, 0.18055928906622176, 0.1566896059607179, 0.1525278047868016, 0.14928843501255273, 0.2386746481698626, 0.24590923558773214, 0.2560526921098015, 0.23820422283806597, 0.2280465572252074, 0.24192761727162415, 0.24866922713946482, 0.24294280102277055, 0.2537400042855612, 0.18539157114650695, 0.18076720339118624, 0.17710049501962477, 0.18283212001032734, 0.19403148607476228, 0.17987881356083557, 0.18312474979888393, 0.18218831979803207, 0.18700313055987794, 0.20069991740131587, 0.1833595301565749, 0.1976607124024693, 0.20251037243575953, 0.21452162962998345, 0.1688380722701479, 0.21612124074664163, 0.18001702571928058, 0.22011828717295334, 0.1712857977845339, 0.18196524923271884, 0.17616354535646317, 0.18148242643268309, 0.19188874016990354, 0.17357671798959995, 0.18278357369554343, 0.1804068434646482, 0.18073794877662608, 0.2052661756515799, 0.5127724272690531, 0.25679303882630744, 0.2219713333904184, 0.16900855629768718, 0.23394547534737098, 0.2803744648398516, 0.19664817531783108, 0.22112187074567136, 0.15772979113857832, 0.19977731922027964, 0.30377736902105357, 0.17080649468435516, 0.16589682131185202, 0.19875178638119628, 0.14659478421286443, 0.19108851273104488, 0.17998002175379824, 0.19307663266945085, 0.17880543489680822, 0.17544163105006483, 0.18122466785351943, 0.2016821844642448, 0.19493634671674465, 0.17961754488249349, 0.1874121928190543, 0.20198570784312742, 0.07727044899629787, 0.0733478284371597, 0.07790950217650339, 0.07816156991542211, 0.07576202587477288, 0.0698425244858406, 0.07925871744325319, 0.06880871272495004, 0.08116438286968075]}, "mutation_prompt": null}
{"id": "57de5303-f09b-4298-9ac4-244d2c75213a", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 + 0.3 * np.sin(2 * np.pi * it / self.iterations)  # Adaptive F\n            self.CR = 0.7 + 0.3 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.03 if np.random.rand() < 0.2 else 0.05  # Enhanced perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Increase exploration by introducing adaptive mutation scaling and enhancing perturbation strategy during stagnation.", "configspace": "", "generation": 38, "fitness": 0.1771304526856945, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "5eccc649-247a-4fdb-870b-3f8f4d370bce", "metadata": {"aucs": [0.37421070711145676, 0.32148443566600104, 0.35624754124462354, 0.34046730385697344, 0.391553788448637, 0.3799563213938528, 0.36158262523052176, 0.36546852122226414, 0.35192103581621414, 0.07539924430481226, 0.06956521864009224, 0.10116786024066116, 0.08874173192359758, 0.09041428157788378, 0.09074684653392528, 0.0835939138082451, 0.0779609386969441, 0.08832193313812586, 0.09764091442040312, 0.10009546045282658, 0.09097902873946118, 0.0892795049634546, 0.09526450744848447, 0.09015669335771104, 0.0979487328432368, 0.08936594650235641, 0.09475110397311559, 0.09183835293744502, 0.08410629347083354, 0.07484856395167949, 0.08152277868303559, 0.10200318272697861, 0.07358318525725949, 0.07258833547880694, 0.08498750899639651, 0.07596443793984087, 0.8307648298661086, 0.7874479819191365, 0.7712403224513316, 0.8107980096682269, 0.660843172209052, 0.6765574056007035, 0.8736213624378325, 0.7586842223114121, 0.7625621538863826, 0.18396886981987348, 0.13078728711097487, 0.14591346826575446, 0.16031824662042926, 0.11629075028510383, 0.17298075106539113, 0.1514309007601492, 0.17883698323878872, 0.13623219516598561, 0.2593629879682453, 0.21512619347811202, 0.20528278981257952, 0.29103791171664506, 0.27895784893248365, 0.24377429303768594, 0.24911939933868255, 0.23501939256523996, 0.25374076488767117, 0.11604996170098458, 0.10928412923135111, 0.11379179751700708, 0.1183036625914703, 0.10536896994888723, 0.09969837881479815, 0.11130854998867457, 0.1327167051073691, 0.11434772848354446, 0.11212385311193007, 0.073226758985097, 0.06324322408253413, 0.09525353312140739, 0.10053783441170994, 0.10609281075543453, 0.07669385796639838, 0.10175753419590694, 0.10798542885945828, 0.041843734560680024, 0.03373897435294548, 0.017705690500131044, 0.049592476207736214, 0.025134680184809577, 0.03799195884606965, 0.058704036348303124, 0.05606804694876233, 0.047515694401754405, 0.14454693566247312, 0.15436163093453248, 0.1295560030551507, 0.15491218216402614, 0.0954058874738275, 0.09813438073183567, 0.14283195018063288, 0.1076657673516267, 0.1196246147073845, 0.0007184627194468662, 9.999999999998899e-05, 9.999999999998899e-05, 0.006037856792873719, 9.999999999998899e-05, 0.00036595344806555907, 0.01040069160329582, 0.0027756326147176935, 0.01725646221970778, 0.06693189169284508, 0.09078459733054789, 0.06809495487738093, 0.06030893031280593, 0.05282218859100374, 0.06586390604945591, 0.05467040922422017, 0.0613134944945688, 0.08197003399776537, 0.3475011821742515, 0.32966062359496207, 0.3333690861141375, 0.3264567760941198, 0.340138481277923, 0.3361868110090912, 0.33457649231868225, 0.33865681707747863, 0.36574872949857895, 0.09026593259772453, 0.09414014871277199, 0.09574780677612849, 0.09612634338475545, 0.09141543214687153, 0.08497305109848297, 0.09558965932862085, 0.08156187159101702, 0.09494680066511396, 0.15108250760513908, 0.15742549402490857, 0.2049777417262303, 0.15550842689402178, 0.1709755472918545, 0.17080138047127946, 0.14205770869234913, 0.1669414695797795, 0.16297298473399058, 0.21987594994410153, 0.22922684257257298, 0.2345395896895539, 0.2380091742750471, 0.236484862040501, 0.2497555602317698, 0.23043581705359406, 0.23946081855497592, 0.25865750655743547, 0.1687748185536282, 0.18132105035180535, 0.178661246834234, 0.1565880620960972, 0.15847935320831763, 0.16907953363258899, 0.1748508196610925, 0.18814464504958706, 0.1704244010400695, 0.18979700255015441, 0.17159755480096484, 0.18704892403289775, 0.18215600730643855, 0.17873420149249575, 0.179593312881412, 0.1856590213280569, 0.19269434886233328, 0.20309439490620596, 0.1665495037177227, 0.17030227289094202, 0.18932558006378608, 0.18100862014036645, 0.18839913103354233, 0.1757055665940268, 0.1878293276814499, 0.1790733222611458, 0.18282409332366711, 0.1814041131478048, 0.14852490969132903, 0.20374968514893876, 0.19752565445783643, 0.21217880749822515, 0.2222613972013644, 0.19642490134788326, 0.14760295718493122, 0.18714389644984908, 0.15764755094090888, 0.16505057496929132, 0.23969709495159464, 0.1830494335738706, 0.17881587329574722, 0.18607347445488776, 0.12622215225476963, 0.3014616922336377, 0.2149010024392619, 0.1744498253484006, 0.17828709084120187, 0.19782036520375168, 0.19574482801347393, 0.18340232268085077, 0.20509763124941705, 0.1753627619670548, 0.1984259919314343, 0.19127290295432775, 0.0687198503505615, 0.06618720466691552, 0.06550756654213852, 0.08225649311280081, 0.07292601989212122, 0.06913883441040292, 0.06707267221282909, 0.06747247506393284, 0.06716612385793219]}, "mutation_prompt": null}
{"id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 39, "fitness": 0.199126818999531, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.15.", "error": "", "parent_id": "5eccc649-247a-4fdb-870b-3f8f4d370bce", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "bfcdb9a5-cd1a-46ba-80f3-df256c86bfec", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "066af203-28d6-42b2-928a-5a8a43113d8b", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "d54e4f2e-4978-4e27-936e-d135406b3c47", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 * np.sin(0.5 * np.pi * it / self.iterations) + 0.03  # Chaotic perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            if it % 30 == 0:\n                self.population_size += 1  # Dynamic resizing\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce dynamic population resizing and chaotic perturbation to further enhance exploration and convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {}, "mutation_prompt": null}
{"id": "e580b025-4d54-4f26-8dcd-58d656b13439", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "955528c2-1cf7-4e44-b75c-7c009de6b9e4", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "ebfaa0fc-b065-49d3-bd39-88c56b4c7192", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "924662d9-d9a1-43e4-af51-136cbbcfa2d7", "solution": "import numpy as np\n\nclass HybridDE_LevySA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                # Apply Lvy flight in mutation\n                mutant = x1 + self.F * (x2 - x3) + 0.01 * self.levy_flight()\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:\n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):\n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha\n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_LevySA", "description": "Incorporate Lvy flight in mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.19580715557128697, "feedback": "The algorithm HybridDE_LevySA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.3997249006327216, 0.4271504341089434, 0.3913153026687911, 0.4258691489735865, 0.3814003493603786, 0.4045751006904318, 0.43128322299844946, 0.419273609838123, 0.4173162636375286, 0.10604611694127886, 0.07818951371476723, 0.0871670467385185, 0.08340431502583212, 0.10111794254622275, 0.09949063728327945, 0.08776072850727323, 0.10740981500800717, 0.11316083685058898, 0.10516107416438136, 0.11172915103916381, 0.0990267153273795, 0.09994279545972329, 0.10072980238085716, 0.10321476049695744, 0.09921776106417524, 0.10306247901486953, 0.10924525755430348, 0.08330346937242761, 0.08381193534975484, 0.08118388607323701, 0.09199029567324613, 0.09014991362945513, 0.09008926951784524, 0.08734668236065868, 0.0939424516891526, 0.09431354503727885, 0.7594381596688925, 0.8320335127786258, 0.775577007823355, 0.7571665065157913, 0.7744662074014972, 0.7739833897878187, 0.7673767260903837, 0.7591316716112005, 0.7545074951829545, 0.20356730223933506, 0.219792700126212, 0.17735522189716812, 0.19827816188412595, 0.1637392810374667, 0.17458570373966353, 0.20566127544640045, 0.21271151418912737, 0.17824671728168673, 0.30474928765520903, 0.30735932574193126, 0.29897415357044965, 0.2663209657188451, 0.271483604580253, 0.2801130279330486, 0.2875573378299259, 0.28465260861867037, 0.30425774622797075, 0.1323345940760321, 0.1227508100129664, 0.11668229804685781, 0.12124703074221999, 0.11698991952798243, 0.1412059325628754, 0.14274039793316728, 0.1304387378421168, 0.13535115594658487, 0.1047272926788615, 0.13833015139093474, 0.1309050804003562, 0.11124101888255156, 0.12357185736644061, 0.1326622922294649, 0.129233052998192, 0.14747679630127675, 0.1309887402199087, 0.06268391476300661, 0.04799041438219154, 0.07080116525453706, 0.0538628920218549, 0.0528641864504058, 0.0794472394822816, 0.08188252293998044, 0.06865062808910971, 0.10285147825349628, 0.10035039689402148, 0.11737097555026998, 0.11150255633470352, 0.09642798860276092, 0.12759874200485322, 0.1194616031823742, 0.14226905807859858, 0.13788150386456421, 0.12573833116728528, 9.999999999998899e-05, 0.01893974642404883, 0.004232748693141719, 9.999999999998899e-05, 0.0032837226800475072, 0.004647514602627467, 0.014727231389674356, 0.033974303606380984, 0.014969453366015628, 0.08689012753249137, 0.08239805413456613, 0.08749848627949686, 0.09000440616890171, 0.07267130479352268, 0.0924310219579575, 0.07143832104245285, 0.08300797573181584, 0.10002624974386798, 0.36019588671739977, 0.3822623638241749, 0.3617904484178973, 0.359113010669863, 0.37596830229666023, 0.40161177516759095, 0.3712068708449032, 0.36840793832471386, 0.37558645402798263, 0.10555600183402936, 0.11020517377951344, 0.0912345042247873, 0.09073279013793145, 0.08819218129018103, 0.09627711643800607, 0.09767027684282859, 0.09451895001618427, 0.09366147812155123, 0.16402197171113098, 0.15976984169262942, 0.14548690835073153, 0.16138003781916999, 0.1605847615201088, 0.15288070145994803, 0.16155463779411128, 0.14903017622205572, 0.1573887598400624, 0.265624043956626, 0.2504183803471699, 0.26906224738049067, 0.24862891087677363, 0.27081995681243753, 0.26559702068113056, 0.2702958362999004, 0.2689907847936146, 0.2714907625214288, 0.18605437990285023, 0.19409748746479905, 0.1996027685808346, 0.19056024373215963, 0.2028814809079057, 0.18628498245578617, 0.2147728024950124, 0.2116883062332774, 0.2010584956771485, 0.22129028738086998, 0.20759054117398745, 0.1846551616439046, 0.21037168513121873, 0.22255059727871562, 0.19922630986628898, 0.19877663694797942, 0.21795918672483083, 0.18783564298785682, 0.17533717691663753, 0.17905441308452175, 0.18132609302197866, 0.17999901407850016, 0.17282351356105596, 0.17574061314675216, 0.181384927736584, 0.16828327387595143, 0.17915464579053897, 0.1732326917807141, 0.16251488006359727, 0.4711306735524068, 0.39119698595883867, 0.3353702475543179, 0.18042089168283493, 0.3731685409831268, 0.1763259838127602, 0.19705452315169314, 0.17272369159523093, 0.18806633505440984, 0.20403681964126885, 0.19472904986387707, 0.1973493892147098, 0.16121738464319424, 0.20135589256801634, 0.269700496445752, 0.20153011114802755, 0.17577602835089146, 0.18803580543950316, 0.17757888014310286, 0.17764326203052638, 0.18003189417919607, 0.19093404432024397, 0.1830733363714897, 0.18492827028206815, 0.17678543194121898, 0.07065047057294016, 0.08688104073580305, 0.07343701807735692, 0.07966520715196945, 0.0835948943470396, 0.07761221512244121, 0.07432477479039246, 0.07966320668208804, 0.08297073536157873]}, "mutation_prompt": null}
{"id": "fb1da376-7199-43a1-b6e4-ca72dbb2b431", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "8a8999c3-2353-419f-8a56-5b8365f81874", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            # Adjust diversity rate based on fitness variance\n            if np.std(fitness) < 0.01:\n                self.diversity_rate = 0.3  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by dynamically adjusting the diversity rate based on fitness variance.", "configspace": "", "generation": 48, "fitness": 0.1978397774138372, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.15.", "error": "", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4268318695986102, 0.4202057703203388, 0.3904174395126272, 0.43278731053185515, 0.4087333007651024, 0.3849346475311659, 0.42861154796591516, 0.41552942502858314, 0.4013819219799347, 0.14069224010548842, 0.12736583950926428, 0.0985146458726518, 0.1106633363728573, 0.1267942576921801, 0.1130702563769953, 0.10609923621049533, 0.12488733823395848, 0.10800799979183717, 0.09600491168664571, 0.09433273568770983, 0.12204067525859041, 0.11777711561649118, 0.09902515336495621, 0.08988685933113849, 0.10374184413174448, 0.10245204150474618, 0.09684233817188725, 0.08800977068960836, 0.09138439135895793, 0.09630560586390058, 0.09000139125494244, 0.08415074576576609, 0.07593268059629521, 0.08537416551224264, 0.0904905976666649, 0.0879629080657125, 0.767362309089531, 0.7374263856835293, 0.7718409514767981, 0.9785634867043032, 0.5348640653047558, 0.6608058167271802, 0.8793403497301566, 0.7669795955656324, 0.7832253114985169, 0.21352030230569508, 0.17011260853981525, 0.19084508904925868, 0.19400945719874318, 0.17778775642437017, 0.2180554632933397, 0.19789785733864684, 0.19285307781100303, 0.20108524295296004, 0.2963140354623153, 0.28362743306456073, 0.6020990522959011, 0.30047683878677467, 0.2945751516126047, 0.32795254124973994, 0.30802189020896953, 0.2987432626134472, 0.28438577744441007, 0.1179498766946393, 0.13452616995256172, 0.12443303608234346, 0.11238248318790467, 0.12770977020887042, 0.11788273039185548, 0.12771428000445217, 0.14681720238481089, 0.13578959185448458, 0.15556850254301857, 0.1447549261642962, 0.13971804781710417, 0.1289093516619907, 0.12385241836206262, 0.132385425726691, 0.11839407517205802, 0.13870671049552052, 0.11502312282603888, 0.11509486215089892, 0.057535212963660154, 0.06490253242490052, 0.07659103687480806, 0.08294804377249732, 0.05615529309425327, 0.06480964799588529, 0.09435274815756034, 0.07884183091516883, 0.16121160275317414, 0.15126468145661842, 0.14419647886490894, 0.18714570852115653, 0.1845346850491083, 0.1790590169934665, 0.17318440629361143, 0.1507701189399464, 0.18533796072970699, 9.999999999998899e-05, 0.004020059713607194, 0.021512116078581167, 0.024992414193028, 0.006815273503510966, 0.021158595594610197, 0.03192175754971627, 0.009369124337417989, 0.03149265544343782, 0.08597597059058704, 0.0727098306533539, 0.08603594509446777, 0.08641910837795252, 0.09975633808895168, 0.09032584086152196, 0.08046915855317782, 0.07567754066986876, 0.0976857804020097, 0.41040795946654784, 0.3758547640705221, 0.3785288563114336, 0.37422477498996154, 0.3619566921973254, 0.37683694473885043, 0.3743310370454377, 0.3747514499644622, 0.365216648947264, 0.09230305781639836, 0.09731265178501547, 0.10436729366023334, 0.09730913589350099, 0.10766998120840654, 0.10347650917856732, 0.09596619420543862, 0.09304702570836632, 0.10448016596242793, 0.17018237730975105, 0.15876114249022633, 0.15970190173380905, 0.17412276303786933, 0.15007986697316011, 0.14559269289297694, 0.1464907704647509, 0.18042425304728837, 0.1735124200723278, 0.2582910165177035, 0.25594209068228224, 0.26225222966733286, 0.26121282117744427, 0.2751374965037652, 0.2605364033335975, 0.28654544058579456, 0.25811038803540665, 0.2605238368607534, 0.2019575159490974, 0.20105136181808525, 0.20414838898249832, 0.21414311169393385, 0.18639489087992234, 0.20474718812295445, 0.19951906604241199, 0.20944206193589943, 0.20293880674192377, 0.18696557749569898, 0.21051303366457697, 0.1842810050709277, 0.21044308969246417, 0.22028265306326678, 0.19189682802652375, 0.22516220105036644, 0.20173176207063925, 0.19465117561675827, 0.17421029629747808, 0.18096059182217228, 0.18242499800232548, 0.1738004213026012, 0.18010668449997902, 0.17998240936988608, 0.17501162321762842, 0.17238107392051571, 0.17862149251511306, 0.14278355006108812, 0.17076765538789518, 0.22229922845197703, 0.16014917891000335, 0.16209669979226693, 0.18808249913107944, 0.15351014365723115, 0.1884703948323304, 0.1605607883674789, 0.23838108995772156, 0.1639862971530176, 0.177684436313856, 0.1859327538500114, 0.19557353005961875, 0.21831169276415252, 0.22317180798307867, 0.22632493487778504, 0.19602846839473076, 0.18334157067226786, 0.17347662646297135, 0.18863854118973888, 0.19194781005092232, 0.20030592924420465, 0.17963658070678135, 0.18282419062180655, 0.20212637565970815, 0.18139694097015924, 0.07652018106914205, 0.08466510210303058, 0.08132950298936525, 0.07402043141054526, 0.07511172621205753, 0.09804099423411627, 0.07544836647266617, 0.07670050061032418, 0.07360851381300404]}, "mutation_prompt": null}
{"id": "8e7854a5-5534-413f-9353-46455dd7401d", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "3b3fb117-464d-4b0e-82e4-e2fc94018b98", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "662d25fd-55d3-4bee-9109-5dbb2cc3ac98", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "a2185ab4-71c1-4978-9395-f9d0d843dca2", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "ff819424-540b-4d4f-8e13-06e9890aa0f0", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "6a044ff4-ff0f-487f-837c-95d0ecb66fad", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "43388126-55ac-468b-a6c2-10614334deb1", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "9acbe71f-0e56-4dd4-b936-e9caa8affff7", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "f66486cd-9241-455f-8aa9-f1058da2d405", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "79405c64-2cb2-404e-b751-78f8ef274fae", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.9 - 0.1 * np.cos(2 * np.pi * it / self.iterations)  # Simplified adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:\n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.01 if np.random.rand() < 0.1 else 0.03  # Adjusted elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate))  # Strategic reinitialization\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Simplified chaotic adaptation with strategic reinitialization to enhance performance and maintain convergence speed.", "configspace": "", "generation": 58, "fitness": 0.1988421776002465, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.15.", "error": "", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.42499014593358475, 0.4173503654275026, 0.42051221574046493, 0.44680412476502496, 0.42528113809752854, 0.39443339247616727, 0.43790754183913627, 0.43173426065887477, 0.4071723569504111, 0.11306421623214047, 0.13384496424202552, 0.08798766958462234, 0.09098185849476303, 0.12228543036053086, 0.1113639523119524, 0.0933429707803769, 0.11404537947598548, 0.10506180497820095, 0.10720105605725694, 0.10856650754002417, 0.09976793649709237, 0.1308356195893935, 0.10581301332471793, 0.10210362857331334, 0.11644772528079461, 0.09189956177552727, 0.08741134162899311, 0.09378139622911497, 0.09727483486395927, 0.08295821345287657, 0.08719775687772258, 0.09588337163365723, 0.08462430824830103, 0.08865709931689669, 0.08293640701505667, 0.08756995428981262, 0.7925054269687919, 0.7825527409072272, 0.7161997670489694, 0.8067806016743695, 0.7769804256339441, 0.876127721295939, 0.7779846590673061, 0.720878552430297, 0.7398264365429549, 0.20217482996657832, 0.18119741063725614, 0.17950322583627654, 0.19304092770635306, 0.20160420072077578, 0.16805233978410983, 0.1927386620278756, 0.18720707430395145, 0.19924628203486272, 0.2626104478144332, 0.2906874672497253, 0.27582190191560296, 0.2663592567552775, 0.2808439254316335, 0.2812701042521416, 0.292947967498685, 0.2424354152212792, 0.2890330166780646, 0.11359321395892508, 0.12218272325066082, 0.148551017382494, 0.1301286861387031, 0.14338463450121175, 0.16803722637481133, 0.1328242431629305, 0.1242432982606464, 0.1390752026079839, 0.13685557202841048, 0.13414549493258676, 0.13910180668998362, 0.13118963786721638, 0.13339217746985088, 0.13846575693609298, 0.11684637874561299, 0.12116711901768829, 0.11977169894588802, 0.05159228145055317, 0.06609186997349736, 0.051874923926157335, 0.04479733544483211, 0.06243724456551769, 0.039948504274317065, 0.051482234047817266, 0.05481481704304536, 0.049930269460815024, 0.14651521497017983, 0.11055809072316947, 0.174818884872596, 0.12090119116465592, 0.11835630899541971, 0.13200263704233273, 0.1505727115760923, 0.1245721032953887, 0.15669053317778903, 0.017119345227726956, 0.0302644537337885, 0.018197747931171904, 0.05146274538377815, 0.0379606453466127, 0.019564477801870428, 0.03311234249961037, 0.03637342228625695, 0.036749040041735515, 0.08023670789938264, 0.09654406596904241, 0.09473509929357682, 0.0790566477748238, 0.08890848484977465, 0.09430489143862464, 0.07736012949707671, 0.08753262957786156, 0.09057598655881594, 0.3761527920813653, 0.3744726060895912, 0.38031198545753453, 0.3938825341551283, 0.36008103741273767, 0.38789600871360486, 0.3714763571886557, 0.37610536278837503, 0.38335713738314425, 0.09587151169799002, 0.08730608427658804, 0.09852522562599786, 0.10019751433437618, 0.0992544473079564, 0.10027598142965088, 0.08806511737854927, 0.09242660152888915, 0.10433624713179157, 0.18603273761191663, 0.19237305570141972, 0.16229106301619578, 0.16343829709053748, 0.1484257461951547, 0.16503333152099453, 0.13999998507660838, 0.16540718786813868, 0.19027038126869356, 0.26153947526113275, 0.2564654607059691, 0.2688342958809308, 0.25201198027719807, 0.26146993268505625, 0.2552530573788562, 0.2762167885135527, 0.2588612263893979, 0.25566505781471904, 0.2046621200102383, 0.20497787736364148, 0.21754621963815968, 0.1931564311861913, 0.18733435577415525, 0.20412169620684428, 0.1855914635149245, 0.2026123719775651, 0.18536140501430975, 0.1987867452285692, 0.20542346957352242, 0.2001803405999304, 0.2005935185697041, 0.20557512982434978, 0.20088626357739992, 0.194913080344297, 0.19485463660040314, 0.21129752841612837, 0.18072390147178063, 0.18850116473512424, 0.1967990908896481, 0.189431680472264, 0.1955086487359491, 0.1884911108915971, 0.1787374433778608, 0.1839618206656125, 0.18040689520962006, 0.17551821242971655, 0.15157698606682457, 0.24431085284988696, 0.23104834653543294, 0.2989243816967374, 0.167989825847785, 0.32907719084812614, 0.17073369087011292, 0.31983091560796106, 0.27494653966345284, 0.2217083731113858, 0.17435069815198567, 0.21943995273906558, 0.18756345107718975, 0.17363746989588158, 0.2161583954289248, 0.37072176369769294, 0.3247864770159996, 0.18370983547530073, 0.18532638133572532, 0.18595451627109516, 0.1980899174564219, 0.17740962283142925, 0.1829231319569541, 0.18235289933643428, 0.18241112175874152, 0.20038612010264822, 0.08248139658887721, 0.07436138807129633, 0.08683388492707722, 0.0967459428307742, 0.07957353189384297, 0.0744573194219329, 0.08078364649953951, 0.08291158593231629, 0.0741783579845996]}, "mutation_prompt": null}
{"id": "c82f480a-cc79-48ea-930b-99da1f92aa66", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "1afb0cd8-eaea-41df-b0dd-c38575dc9b51", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            # Replace with chaotic F adaptation\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)  # Adaptive CR\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                if best_idx in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  # Detect stagnation\n                self.diversity_rate += 0.05  # Increase diversity rate\n            else:\n                self.diversity_rate = 0.1  # Reset diversity rate\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05  # Elitist perturbation\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Adaptive mutation with chaotic maps to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.4012749253597486, 0.39001030272601933, 0.39175569802651766, 0.40330142392006485, 0.4234945669863446, 0.37905912319503254, 0.39223712581491277, 0.44248286056839725, 0.40977945774987123, 0.13449652072313512, 0.14351796753052437, 0.12752169681602377, 0.12162576725931595, 0.1024678361213619, 0.10561933463775108, 0.10009319028318042, 0.11917984658348757, 0.10763518345601064, 0.11319430327334945, 0.11505063106415359, 0.09611494253454056, 0.09834120603752672, 0.09901055966917793, 0.11113810783623901, 0.10324064597618832, 0.09402761233598922, 0.10105617086845342, 0.09348092076225945, 0.08647157755716306, 0.09810463152577809, 0.08369870257349943, 0.10044845067119168, 0.08061735658400482, 0.09185996731832657, 0.09617513255838772, 0.0821830463425064, 0.7400640562336751, 0.776609190782557, 0.7597673651908105, 0.8739636810749231, 0.6725137448408803, 0.7598926574623494, 0.7876689171946506, 0.7741707131771491, 0.773259789408005, 0.1877130745539527, 0.17256670897728932, 0.18861125835055859, 0.19385530529239148, 0.18636649832645957, 0.17746265907158376, 0.18250985048401502, 0.1942787137077414, 0.19371251013408786, 0.270457556338382, 0.30117519191995823, 0.2869727066613621, 0.3021196937387357, 0.3204835930190165, 0.2899140289230604, 0.27996372259865543, 0.3124016993248766, 0.28918514754986524, 0.1307183633333181, 0.14810247169654156, 0.13428330682000855, 0.12705508371388718, 0.13460528130911953, 0.10381549373561216, 0.14933852190248942, 0.14104139347354883, 0.1576353195439265, 0.15029575115537863, 0.16085089023168053, 0.14164743299383808, 0.15679460013631874, 0.1292473602448868, 0.15130383904657774, 0.14379486623927829, 0.14400482825821603, 0.15859219797955681, 0.0912056864453269, 0.09431930567214508, 0.12512047236418566, 0.04744522160102005, 0.10749347661581199, 0.04943668052548256, 0.060147511582399615, 0.09965668925028659, 0.029438970313423907, 0.14263755766585595, 0.18229473828171938, 0.14436196567661885, 0.13229357158200605, 0.16220781733469558, 0.155958030375984, 0.1945041845763198, 0.18268838619290872, 0.16840900449792295, 0.03635501555606402, 0.016891042606673512, 0.01835673922289638, 0.022936969993369916, 0.04141429313411449, 0.0266990321151237, 0.02093180569782438, 0.012609279211667102, 0.02484727536024589, 0.07398679460666902, 0.08185718113205498, 0.10085655569163587, 0.07143686253844894, 0.09021617829202766, 0.10402655399796479, 0.07673303962793121, 0.09444610029491307, 0.0862850990811137, 0.38273624008037965, 0.3591259694120811, 0.3801536105329477, 0.39302607860769645, 0.3709504213919109, 0.3720553422918247, 0.3824970836345104, 0.3776034071296531, 0.3759488264119045, 0.1064286974464419, 0.09034861790439574, 0.09773293614454592, 0.10933758871829546, 0.12330336105405038, 0.09586468405691051, 0.10124045943672644, 0.09881263330791756, 0.09168444301884249, 0.15645259593040195, 0.14629188170197305, 0.15283020624411237, 0.14719768730985283, 0.15606655057822028, 0.15611656018851994, 0.1564266944133369, 0.15940904199590678, 0.15191559310262892, 0.24483034458429265, 0.2559156467307151, 0.26471394401165194, 0.2318354517055965, 0.2475798953361512, 0.25170477744607267, 0.2639930925162497, 0.2604565888504552, 0.2658132664820193, 0.17815020653405644, 0.1860166739878275, 0.18939795672787607, 0.19630003380014482, 0.19936789365895125, 0.19488300822721194, 0.2024545900379192, 0.2320356095223387, 0.18693263816621697, 0.20445908692157377, 0.20287174697269672, 0.18386510859501426, 0.19303135855467235, 0.2030874495495626, 0.19959622062047389, 0.18861976247099033, 0.19904310542062753, 0.21253827286607707, 0.172216616826547, 0.17969842020893156, 0.1797918919548942, 0.18232830455022453, 0.180524539343335, 0.17619212855801358, 0.1819680071495916, 0.17544025466021396, 0.17695437930556568, 0.33818206677671037, 0.5588996204890607, 0.3425285641376, 0.3085678274772923, 0.15650492634189594, 0.16225065210089218, 0.20177123149226817, 0.1765861410577838, 0.15882246454845284, 0.18187727890426686, 0.16490487236145768, 0.19681045442031586, 0.17446707078367452, 0.15611462359564232, 0.15637169480194157, 0.1953360204665634, 0.2700469089195321, 0.15759461542656006, 0.19394716602446893, 0.17798912905603115, 0.1884728030165851, 0.19033370542762384, 0.19132749986056452, 0.18557257177459974, 0.20759718634772006, 0.1819644605540892, 0.1849220568002189, 0.07300822684853847, 0.07432040767511594, 0.07683407211658577, 0.07894960753538705, 0.07605119011939909, 0.07115055835160655, 0.07893308112022146, 0.08707533523148303, 0.07808240892334051]}, "mutation_prompt": null}
{"id": "9e58513a-6240-49ae-9a87-d71a155286cb", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations)\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                # Elite-guided mutation strategy starts\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce elite-guided mutation strategy to enhance convergence and maintain diversity.", "configspace": "", "generation": 61, "fitness": 0.22362894533795288, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "e1981d26-3387-496c-93b6-c1f5779c15b4", "metadata": {"aucs": [0.41581363245426506, 0.4244396941685632, 0.41128199485764905, 0.40044266101542425, 0.42622599691192053, 0.42942350233828286, 0.42163694533163465, 0.4314150641622595, 0.4154654745300437, 0.11974245852544518, 0.1280980846434452, 0.08161464543378005, 0.11906960067042416, 0.11069835734922195, 0.11694163447930583, 0.12924170293327297, 0.09142612493488922, 0.09667608149409057, 0.10050640395917032, 0.11825230636588746, 0.1005001751593061, 0.10180559358316954, 0.10581874092195687, 0.10140979473839107, 0.11190131752954091, 0.10687869896720603, 0.10194896829051281, 0.09855754228575497, 0.09252072582473847, 0.08913613300751366, 0.096742811055202, 0.08526998964545507, 0.09224443398079896, 0.08379020370396706, 0.10448955172100582, 0.09196976994688144, 0.8809045763311212, 0.8714690893754758, 0.8751674881962942, 0.9513497429141675, 0.6653782162500594, 0.8415598821872461, 0.8822200729184924, 0.9707155613806753, 0.8771034136301051, 0.21265556057088686, 0.18239994647624258, 0.2243495782837729, 0.23119288353300627, 0.21626802231081044, 0.20088696187055277, 0.22149378566524902, 0.2170095967183292, 0.24309952972404658, 0.3251820673607996, 0.33682469891358224, 0.33692447136038206, 0.3350823841775169, 0.2579814240089219, 0.3063041011557791, 0.34386745876570457, 0.3260134949555318, 0.3446676836218704, 0.1665031345713911, 0.13841233837718014, 0.15470925873663233, 0.15088833577054794, 0.10030523816308068, 0.16287047299495916, 0.137241823377228, 0.15274406650457062, 0.16707598585287542, 0.14561220147317677, 0.15907881990289374, 0.13209264253358144, 0.14416157569290533, 0.12620793753794257, 0.15453640070987784, 0.17011472059602073, 0.13146144196237874, 0.12101744831490635, 0.10217530444028211, 0.12336949066168867, 0.0797260239560259, 0.08566173823812917, 0.11024457814848154, 0.07773532740084355, 0.09203592606681654, 0.16769695083795066, 0.12241867414969854, 0.18130950220058661, 0.2194839133544083, 0.19731250366234576, 0.16403404263086108, 0.15227366638399797, 0.14593108348590744, 0.17789728400118476, 0.2030294286030493, 0.20636579669693844, 0.016135372057025754, 0.05422874715415982, 0.018726091536729328, 0.03176913212522048, 0.029629643682684614, 0.00988902373971634, 0.08848397614879833, 0.021864618101285815, 0.023236922948564054, 0.09425928636277336, 0.08021978586466882, 0.09745993431340771, 0.0996164153136162, 0.10456098718748763, 0.11147944187830527, 0.09561958944941984, 0.10797857550518764, 0.09991361028028767, 0.384437021352553, 0.3868223150459026, 0.39057453334513326, 0.39684527879514786, 0.4139102118132595, 0.41144203365241516, 0.40973462783209824, 0.39852432065886956, 0.37250664959960134, 0.09784378910928115, 0.11522540858364083, 0.09875396233201883, 0.09125843864280647, 0.1029814182323413, 0.11799869712875044, 0.11601737986176774, 0.11372906648013681, 0.13159314667503696, 0.1386773157769149, 0.15468453987876551, 0.1515795350344723, 0.16136718856169152, 0.1678755656782176, 0.1862962311386155, 0.18219846706107112, 0.2292355746784499, 0.16306824473746928, 0.28530503193691037, 0.2576504201541904, 0.2892430418731464, 0.2677018403248097, 0.2916376376680856, 0.28120756553383053, 0.3058918388405114, 0.30624146673242947, 0.2762530138759225, 0.22243605891710128, 0.17174492820996456, 0.20547582771676676, 0.2232463232187094, 0.2067059941993341, 0.21822964236570486, 0.2257847585644528, 0.221628285366692, 0.2146836097371546, 0.1947659514933131, 0.19503689174637506, 0.21637619530792906, 0.20763158888581978, 0.20732733567487127, 0.20316964604286747, 0.20463261046395143, 0.18405183391747082, 0.1936294374562082, 0.17682241438551305, 0.19530850518221965, 0.18836917932041197, 0.19351285735362977, 0.193284832739971, 0.19089284403577245, 0.19227697334631233, 0.1823829582809965, 0.2006669779610496, 0.6322155560609262, 0.47320690876101046, 0.18614595985870575, 0.5801609724646075, 0.19203677462808055, 0.17075850118084523, 0.5599488886377595, 0.5624821039938193, 0.16804908151853382, 0.45572200296762944, 0.2012464226187849, 0.4879332239946096, 0.19618973102548276, 0.1993196985554483, 0.16160147091831845, 0.16394416104431253, 0.5038985367847414, 0.20429748983188467, 0.20134909664213374, 0.18659667935895863, 0.18692668794131362, 0.18878632849005916, 0.18592565884912648, 0.20134155133644493, 0.1823611726298462, 0.2074767398205517, 0.2126159143425722, 0.07744653985225691, 0.08047707748596766, 0.09078917495945693, 0.07694434943491846, 0.07620312206301438, 0.09445745779070125, 0.076037492475856, 0.08570579581939874, 0.07659184712523948]}, "mutation_prompt": null}
{"id": "b9bebf52-13e4-4f47-9183-77fa8e03848c", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8  # Differential Evolution parameter\n        self.CR = 0.9  # Crossover rate\n        self.T0 = 1000  # Initial temperature for Simulated Annealing\n        self.alpha = 0.99  # Cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1  # Reinitialize 10% of the population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            self.F = 0.5 * (np.sin(2 * np.pi * it / self.iterations) + 1)  # Dynamic F\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.cos(np.pi * it / self.iterations)))  # Modified reinit strategy\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce a dynamic mutation factor and adaptive population reinitialization strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.18044173357829402, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "9e58513a-6240-49ae-9a87-d71a155286cb", "metadata": {"aucs": [0.34764487226145524, 0.3394223547569819, 0.34909734299536, 0.35657884958020836, 0.3395629036351927, 0.33972925017949707, 0.33050303523812796, 0.3169879159739568, 0.3604165600038486, 0.05724945014157534, 0.04661578401757305, 0.0462629047478067, 0.06431147890395494, 0.07040241708443695, 0.0737908356489283, 0.05587868836086474, 0.045878046915947435, 0.07287621749747175, 0.11556647412878862, 0.08438562032452612, 0.07981577017063024, 0.0930756443540347, 0.08397202053399488, 0.0841191143433434, 0.09311186969725438, 0.09330928980059816, 0.12471187033763675, 0.07909220245506499, 0.07820441947381529, 0.06902632466980285, 0.07552620052964654, 0.07830471417121065, 0.07776615659341624, 0.07457197779682412, 0.0659060672493188, 0.07558013183259593, 0.8957062901247459, 0.804757877170896, 0.9131943236071529, 0.8849002027408935, 0.9257332554416113, 0.9142335749211931, 0.9492445152709392, 0.8741758083501296, 0.9129631543073007, 0.14588995815553085, 0.13230447558887592, 0.16836965553964944, 0.16120968906363575, 0.15920785081125055, 0.13887901166776995, 0.15456932621775088, 0.18556232067856793, 0.1520286343499918, 0.25476219156084956, 0.22181661175334033, 0.2478149457460368, 0.24805069589708506, 0.23300924309237325, 0.22123348518773767, 0.24500305407382017, 0.22649054009023994, 0.2644662509323925, 0.11213443457818006, 0.08528059039250224, 0.11663752810056394, 0.09752338365904778, 0.11990599641168409, 0.08864339618563721, 0.12090873382082046, 0.11343600194428272, 0.12332173438233351, 0.1254094199514051, 0.1201283583197259, 0.07741524212908968, 0.11495728490565638, 0.08965740156834867, 0.10280821341874502, 0.10894683703842634, 0.10200947705684071, 0.10365652341190612, 0.05391540248839899, 0.04548790232674216, 0.025188804903991557, 0.031645056415908424, 0.008946885502724267, 0.029159196626315276, 0.023498061089927247, 0.031186840084547307, 0.01902052092517692, 0.11248369286035909, 0.09715422967650067, 0.1296964260482535, 0.09959329574656894, 0.1897318654599538, 0.10897043224122094, 0.1767031592612569, 0.10529711569180822, 0.13294711810470672, 0.004186093132477309, 0.0004900342381223277, 0.004418268224187671, 0.004220012717657706, 0.015316229694730454, 0.004394964103222043, 0.002437668578417096, 0.008904725445592843, 0.0037856865191179256, 0.08603660338528407, 0.056800235857785264, 0.056764918564533584, 0.06890819527481906, 0.062312547280956254, 0.05789600761150737, 0.07105294448440724, 0.06641147035460404, 0.06395983073587364, 0.3345229238355639, 0.366226993329302, 0.30988412643334584, 0.35152253102411335, 0.32933489305638664, 0.32290938210169007, 0.3266024401967721, 0.3271460024871822, 0.3325491949382817, 0.08461906677664921, 0.07905246396860566, 0.08943905189106849, 0.08538879760263984, 0.10677388413803368, 0.09383829356784479, 0.0727851908218834, 0.08411041936003927, 0.07748134928680372, 0.14445736034400192, 0.20545643964325377, 0.14477991681225844, 0.16639069451228605, 0.16023415039549327, 0.16242440126136914, 0.2002115835722409, 0.16881185832806056, 0.14228299429132907, 0.23604449756833168, 0.2183957489001499, 0.21995723424340863, 0.2170734669784865, 0.2156940617293891, 0.2229807578978722, 0.2655125246278066, 0.24240573323326908, 0.22779910050006524, 0.18019528597077517, 0.18650041319254018, 0.15713476617376132, 0.16305776896294866, 0.16450788336226418, 0.16661455050483454, 0.1791626469205263, 0.1778557822825373, 0.17087953544569778, 0.24195178416012197, 0.21185110706642674, 0.2379699733982351, 0.18146600495832466, 0.18400155540408136, 0.19861748071036012, 0.20836457509560058, 0.1937740124122772, 0.18955954533525265, 0.175715928933031, 0.17418179649991794, 0.18336189333469433, 0.17537546905847667, 0.1723390652044181, 0.16902095056558686, 0.17544662957157764, 0.17391718358671115, 0.1749669417250922, 0.30133254704692924, 0.1525119678939001, 0.20497517302576562, 0.18046175485564964, 0.18253109242354604, 0.18761017697940396, 0.14738871191877845, 0.16432529002086815, 0.15390914332648753, 0.30225080534843185, 0.19407281726764047, 0.24672233985080483, 0.16474557685398972, 0.14148331521672752, 0.16110175716040598, 0.22493114874123332, 0.33642714314557065, 0.11206980041252734, 0.18117493579109645, 0.17881554110915276, 0.17751477761843892, 0.19836697343423026, 0.19713559449418117, 0.1924732061847868, 0.17776999345904076, 0.19877806197661096, 0.18085252305208688, 0.09302025789673718, 0.06899937892068975, 0.07576668139800036, 0.06159006272104817, 0.07841447227867959, 0.08315640527887957, 0.07377017877551828, 0.07169000596163644, 0.06785006390038273]}, "mutation_prompt": null}
{"id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 63, "fitness": 0.22531116212342941, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "9e58513a-6240-49ae-9a87-d71a155286cb", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "a6b3eb03-3b87-4b3b-b5c4-cd22caa88fe6", "solution": "import numpy as np\n\nclass HybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.98  # Line 1: Adjusted cooling rate\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.5 + 0.4 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var  # Line 2: Modified scaling factor\n            self.CR = 0.85 + 0.15 * np.cos(2 * np.pi * it / self.iterations)  # Line 3: Modified crossover rate\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.03 if np.random.rand() < 0.1 else 0.06  # Line 4: Adjusted noise scale\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA_Improved", "description": "Integrate adaptive differential evolution with chaotic perturbations for enhanced exploration and exploitation balancing.", "configspace": "", "generation": 64, "fitness": 0.22013999709691912, "feedback": "The algorithm HybridDE_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.3931150058900872, 0.3833016525136679, 0.41501424710946866, 0.3949682312261561, 0.4009023549357775, 0.400207710812453, 0.37432396864653394, 0.41483678905553745, 0.39463041514300734, 0.14151143150860213, 0.1411783740444642, 0.1265410826627421, 0.1362705598192432, 0.1413269583231207, 0.10601283538570172, 0.12469211888326137, 0.12363989526993768, 0.11048329041922389, 0.09257914851504068, 0.0947049271057886, 0.09869777785513101, 0.10715841026018347, 0.09169073271922557, 0.09793540096032816, 0.12642797369578151, 0.11289237776272598, 0.09463864397760335, 0.0904360507986508, 0.0958486378596306, 0.08202242203517796, 0.08435843061430426, 0.10254938854395401, 0.09601063188235837, 0.0895870189278759, 0.09371585069375454, 0.10422162828369741, 0.9271976307040611, 0.7846663318191686, 0.8986321091502453, 0.9390474454954699, 0.7830399034460251, 0.8158813297835873, 0.8524703310580309, 0.9263000692279626, 0.7841690485903018, 0.19053109193166795, 0.19102404233430137, 0.208965217733716, 0.19638395135281872, 0.23841095122012945, 0.21712959450572655, 0.18476743148617392, 0.21149355312193652, 0.1976561591697088, 0.27054762798625354, 0.30777051288471025, 0.31735046417137447, 0.6316058717266131, 0.3035268466625489, 0.3158898457806796, 0.29551833115270865, 0.3463042132567994, 0.32356763742786165, 0.16407290788748974, 0.13353948125745196, 0.14068812457498592, 0.13333774155052036, 0.16562295479539135, 0.1432781498405422, 0.1413840534966081, 0.1341943348338247, 0.14377504195051238, 0.11835635713616632, 0.12716716965147623, 0.13857216838863473, 0.17043274358331095, 0.15538590324352575, 0.14556797115449704, 0.11543676749667775, 0.15090057079655694, 0.142116572059929, 0.10053380018525382, 0.0964516281256903, 0.11301060904038751, 0.09323391314622642, 0.08793521386765646, 0.08304330236765722, 0.07524902951604395, 0.1002353080356192, 0.1419141756133807, 0.15260094027598547, 0.20136744478987878, 0.18054629384931975, 0.19931738316711511, 0.18514565420078266, 0.22661074762362854, 0.20405642369898347, 0.16269687065694038, 0.18429299358750806, 0.0028092214688171246, 0.032190444600254, 0.0032668025514445143, 0.004876567309759938, 0.024225114526531644, 0.04724282308329908, 0.009204839697247391, 0.021472192736644358, 0.034922731073933955, 0.09077816037342201, 0.08516839624446126, 0.0819022081735793, 0.08010763203476268, 0.09912056544917891, 0.10096071235216464, 0.08078927706680461, 0.05602969845728201, 0.08727253675305258, 0.39401550543916475, 0.41608029328194396, 0.4170032709121049, 0.38699383887008854, 0.3720142428073273, 0.3719191596118665, 0.39111833916134053, 0.40030369817949985, 0.37057827202738214, 0.09076911030002588, 0.12586186541713285, 0.09620596333339582, 0.09816861049943215, 0.09302382979035684, 0.10457091457287482, 0.09470750696804864, 0.1157931933735683, 0.08925544365946847, 0.15000298293997016, 0.13999529813858047, 0.16913745508149147, 0.1498267687248035, 0.21862847884278336, 0.1621192651200568, 0.18581145562366297, 0.14905800681967762, 0.14173750063513946, 0.24722471019015535, 0.2611324237767324, 0.25773122359108247, 0.2920869730146538, 0.2561875192965768, 0.25961392461193566, 0.2714809905480686, 0.2674115206576776, 0.26375714833023545, 0.18752072094773098, 0.2050672594562789, 0.22425308137271294, 0.20521584014460337, 0.2032740800768874, 0.21134257604816808, 0.21382130552946554, 0.22611187875994931, 0.23335511984578716, 0.18468418193554903, 0.20544334367753703, 0.21863939097834162, 0.1998334014493396, 0.19504089020182735, 0.1984066375418676, 0.1842436166941338, 0.2010740155225743, 0.19859951138584298, 0.18716318713547841, 0.18648703363063346, 0.17556932624900146, 0.19082307180392644, 0.18051345368944727, 0.18293278234791532, 0.18323764918916052, 0.17855088845240097, 0.18568545977822815, 0.3752534518197864, 0.1681946425801787, 0.5809050662353008, 0.42413200445705634, 0.19345705147921088, 0.4178826493106088, 0.5619034870393869, 0.1645175116218388, 0.1508344295323525, 0.5479121274035316, 0.18718687644399956, 0.4313489850856628, 0.4578227681155158, 0.32223236656909227, 0.20341869476357521, 0.14851136280819155, 0.49364913869069005, 0.48374450649451417, 0.1816659154199569, 0.1748270638647269, 0.1725176718255087, 0.19503442613839583, 0.1876030036362777, 0.20462198566431122, 0.18921725334349626, 0.1746456956047212, 0.18786664538377607, 0.07887595701931949, 0.07523472075395743, 0.07336620975742247, 0.08923873832514162, 0.08217342073212508, 0.07184487277678253, 0.08845482708571506, 0.09141522608861763, 0.0678216243511115]}, "mutation_prompt": null}
{"id": "130da2c2-b206-44ba-b0a0-1045a826187e", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            fitness_variance = np.var(fitness)\n            self.CR = 0.8 + 0.1 * np.cos(2 * np.pi * it / self.iterations) * (1 - fitness_variance / 10)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Improve exploitation by introducing an adaptive crossover rate based on fitness variance and better-guided search using elite solutions.", "configspace": "", "generation": 65, "fitness": 0.1805767605458217, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.14.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.3807073651964654, 0.36008735056646524, 0.3982164489796791, 0.37436572848679406, 0.36679821698041837, 0.3623103896264702, 0.3708106576702581, 0.36109062848240614, 0.3839673497368773, 0.09497316730128547, 0.09089985651044441, 0.11209814894965564, 0.11827282304189413, 0.10485951906692481, 0.11980462891711852, 0.10490648906458266, 0.09944486704822497, 0.12856243246680532, 0.11227797490429603, 0.10086552307947805, 0.09428614984130412, 0.10304140784305926, 0.09289222012947362, 0.10414463870864277, 0.09709407671352799, 0.10825015384048908, 0.10046269289294574, 0.10821697085217474, 0.07715944271837816, 0.08637828027203509, 0.0967422780714371, 0.0827085429929133, 0.08206555782355007, 0.11210466191164137, 0.11034019720272048, 0.08510225054660181, 0.6190614475062044, 0.7709485202067967, 0.8036574168971758, 0.6974491758035922, 0.582899307025221, 0.701937669180468, 0.6621274303747912, 0.6118148942224579, 0.7410549827742607, 0.1806525717264731, 0.12624477796540012, 0.18080030227792865, 0.1408205610618476, 0.13439124985503603, 0.14313772209039, 0.16986006108177298, 0.1432700002473304, 0.17121358263997244, 0.20773066309755184, 0.18721440259426303, 0.18159740525420243, 0.2230483942561643, 0.25029841603105774, 0.2148333788435478, 0.22592071706545114, 0.23413709154820173, 0.20960668281356065, 0.10730374060554182, 0.10905867537177583, 0.09301439869636763, 0.10212418218408326, 0.11530795104308311, 0.10808576954568871, 0.13031387551798745, 0.10978673557385898, 0.11578165661686401, 0.0819769214439744, 0.1218207509309217, 0.09409452937974461, 0.11995910405057453, 0.10288849413069368, 0.10986662223773236, 0.10759798608828008, 0.09991573814563726, 0.1044806246428378, 0.04672094416425787, 0.04063915931855899, 0.038981440599524686, 0.02907583035653538, 0.03653402771518266, 0.03187364224524403, 0.05922525222441177, 0.041991239142090686, 0.04307236564745143, 0.12159669003473705, 0.14518808126066196, 0.14039221150147319, 0.1519152363780054, 0.1649498464926311, 0.12661568619840835, 0.17607961962461138, 0.1262994355735575, 0.14183633916639204, 0.02291215689494308, 0.014531270833199605, 0.010342752751271278, 0.02986101587029244, 0.024927801685100115, 0.026802938510989027, 0.014919857310238482, 0.02218396022283864, 0.007851206563796231, 0.05882927350031475, 0.05429862215081083, 0.05727671225260533, 0.06057672271412118, 0.06178701839956624, 0.060335153662308016, 0.059222754081367235, 0.06366052800023536, 0.07586032369083329, 0.36570786374967, 0.3454068346914142, 0.336057880812735, 0.33661139466224255, 0.311324993513608, 0.33939247843679077, 0.33861956753039635, 0.3337182922279536, 0.3447267923983395, 0.08447114350341167, 0.08874358463052667, 0.08106388651119667, 0.08518050939875466, 0.08915624531580157, 0.08044857449776188, 0.08439056409972345, 0.08510858935019328, 0.07836997432463755, 0.14389762927166683, 0.1509674071622722, 0.2014164707951911, 0.1620765813093722, 0.15793480229742385, 0.14754349393955746, 0.15817358834213624, 0.17094150682847342, 0.16335857133997633, 0.21122526360794713, 0.22238268258101168, 0.22774353321938667, 0.25502813761663135, 0.24667939197249922, 0.23789006208704833, 0.2385357898035826, 0.26089134300865224, 0.2567291959532819, 0.1603729258597001, 0.15526287521865412, 0.15762629765878478, 0.17598345331856013, 0.15144825597639722, 0.16271382845032079, 0.16029166891930635, 0.1739226224250615, 0.1559542838241912, 0.19046463543402004, 0.1911966874170009, 0.19905992011211027, 0.18936668883879504, 0.18166864820755513, 0.22148032914884852, 0.20449708901268093, 0.1856687668566106, 0.19982657795386705, 0.17561977625882097, 0.1687956108199643, 0.17664920286558228, 0.18745942332146004, 0.17366623558508731, 0.1856630753834132, 0.18133853730986904, 0.16882838653287835, 0.17478669094106258, 0.17887876541649972, 0.2773738684731347, 0.3676030265071194, 0.30469355758363426, 0.2402331316691091, 0.2527855395133807, 0.1911523972810345, 0.2620424967108449, 0.28255553181941906, 0.2750235108838156, 0.17008851826020832, 0.18757065160450792, 0.3361775107891962, 0.2058780965985909, 0.2537049137661054, 0.1796503008410607, 0.31227756489069747, 0.17627334089869362, 0.19303976034471648, 0.19022321707488543, 0.1943857539156606, 0.19846894696604045, 0.1883463877526269, 0.19359886584758246, 0.1833954285954259, 0.19938984025706874, 0.19251164688148625, 0.07611184830253792, 0.07757960445955492, 0.07335148944441638, 0.07495527788767453, 0.07547169753702998, 0.07140035387622157, 0.07152728322989499, 0.06829406789569237, 0.07245618385728014]}, "mutation_prompt": null}
{"id": "00a68f5b-0d48-4cf4-89b2-0179e941121b", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.5 + 0.3 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += np.random.uniform(0.01, 0.1)\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive scaling factor and stochastically update the diversity mechanism for improved exploration.", "configspace": "", "generation": 66, "fitness": 0.21349837812771585, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.43672880501913947, 0.38064959108849805, 0.4100410713889706, 0.4513100030131456, 0.42211922997526585, 0.4120932887143133, 0.4220752770486992, 0.43142044696566595, 0.4053377362608752, 0.120841895026648, 0.12488457874742764, 0.10341036193073583, 0.09990502941175106, 0.11940944185479907, 0.11157019253594513, 0.1168633887533661, 0.13616317901767383, 0.09584173098235094, 0.10260173723495913, 0.10441235282298311, 0.10985933601743358, 0.10537899218118651, 0.10988250774255426, 0.10140688293598155, 0.1319865748683562, 0.11580167847616052, 0.09505728018857007, 0.08883063850406248, 0.08806528336586272, 0.08957501201173657, 0.10684587330789141, 0.08943466812753087, 0.08444497157975128, 0.09551642226855905, 0.10063037532256636, 0.08202324609459666, 0.9016899638684235, 0.8795016203878343, 0.7756703475349428, 0.8878491109577139, 0.7679503275739654, 0.7694450347504216, 0.8843749322048059, 0.9321315231905222, 0.7948319453938602, 0.20892225165298572, 0.1985602496026776, 0.23477187436299685, 0.19467550368474218, 0.24368748130568907, 0.22718241207364664, 0.2020808388857317, 0.19190995899340024, 0.19616234978279834, 0.2863837885760451, 0.2937264033585625, 0.3177063312492052, 0.33496107134094233, 0.2649073146412405, 0.3190840342272253, 0.3204315507396537, 0.6049605273517001, 0.27466562214399604, 0.17107670748261683, 0.14730690127206492, 0.1479686550688577, 0.14516021460670803, 0.14429313288939705, 0.10815115671330255, 0.14679832340722465, 0.14542715145767193, 0.14453933806406238, 0.14834719256230777, 0.14285288808136487, 0.13482719608207971, 0.14477665492959435, 0.12792335214577522, 0.15248773574995012, 0.14763373537740865, 0.12530071114382257, 0.13368660280183142, 0.08034352333443806, 0.09063015708746935, 0.0670454427085615, 0.10955617311147892, 0.11601375184193241, 0.07484545580393265, 0.09619415897122385, 0.10609461613758964, 0.05549432471769211, 0.14934659006966466, 0.16818395566289268, 0.19136829983378256, 0.1687395903344695, 0.1938110994219049, 0.13989277471379313, 0.16376303666673464, 0.16146650382513505, 0.16208717018529573, 0.011389034722896763, 0.04020291201732529, 0.0109996329668971, 0.032231597324042016, 0.00034231400600814865, 0.019715672085760305, 0.013528921751125189, 0.007105275646228981, 0.034631560201170974, 0.09381093531109197, 0.09613428415788872, 0.07044171298228508, 0.09932609127700431, 0.08786892693961323, 0.1101993551876993, 0.08018563979285787, 0.10318039761185904, 0.10609840523363001, 0.3727773923289547, 0.36626658175537574, 0.37950319102633834, 0.4109842041758267, 0.38109858872148406, 0.40410772096219716, 0.3909949605608596, 0.3797676910937512, 0.3785535766953575, 0.10572816751863234, 0.09743391232077592, 0.09099404351419704, 0.10469265371934966, 0.09511245629415044, 0.09767972018473958, 0.0954906089864227, 0.10429638233806982, 0.08844928371376193, 0.16985366825970927, 0.17058241368126725, 0.1621731306907308, 0.17500302786341038, 0.18779999030439998, 0.19232283907686765, 0.16534780707751873, 0.19138124411756996, 0.16629220449048376, 0.289968166483735, 0.26384376237470797, 0.2761330111684197, 0.2739972159165893, 0.23750168304546204, 0.25882129084674166, 0.27789198170303764, 0.290479019219107, 0.26975659445229916, 0.21081671008332925, 0.19470077725426083, 0.24714182431170606, 0.19163698871975554, 0.21079931263185547, 0.21058551698728312, 0.20471525340701058, 0.2140275999048159, 0.2084173693605037, 0.1847125248980137, 0.1815435381419267, 0.1909946746535377, 0.2010405136904193, 0.20562852831692258, 0.2356363945642871, 0.2054669659219982, 0.20202660640469117, 0.18817478475590677, 0.1777394602207949, 0.17867765837175087, 0.177278573434278, 0.18382213671169023, 0.19899180493185353, 0.18400775678007686, 0.17686330346373502, 0.1878912962775533, 0.17963299204959726, 0.48328642187467197, 0.14924867822415888, 0.5840943616866385, 0.336570875541076, 0.19058041894228894, 0.14582563931001058, 0.13744461299199884, 0.16723995850260875, 0.1636914631679265, 0.4426168879129587, 0.2032787618684746, 0.4867369687989759, 0.1663287878218509, 0.19334342826030704, 0.19438622027101427, 0.1618707232211023, 0.5788017307203613, 0.30355880529741974, 0.17046095481289136, 0.1872721740439789, 0.18316788094742065, 0.181166651304854, 0.18654518580603852, 0.18481775206652507, 0.1776161472175658, 0.1745023076544845, 0.1887406155067607, 0.08107522951616453, 0.08988156731200325, 0.07751117583583111, 0.07647570137529869, 0.0711917026310781, 0.08005121106290225, 0.07899586903445821, 0.0696734396931954, 0.09007791831831657]}, "mutation_prompt": null}
{"id": "d39fdf79-a8d6-466a-a788-7e911b2a2f34", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "e2319315-ffda-4460-8263-8d168134f015", "solution": "import numpy as np\n\nclass HybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.5 + 0.3 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.7 + 0.25 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.01 if np.random.rand() < 0.1 else 0.03\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA_Improved", "description": "Introduce adaptive crossover and mutation strategies to enhance convergence speed and exploration capability.", "configspace": "", "generation": 68, "fitness": 0.21609897280998702, "feedback": "The algorithm HybridDE_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.4376857247241053, 0.4081892225467827, 0.416071665506783, 0.45790824481576375, 0.4274464254688326, 0.4271267605547613, 0.4345676879903688, 0.4444704919357323, 0.45533038739631937, 0.1306857934807567, 0.13162053146446417, 0.12230699886658236, 0.11249419666804639, 0.11214815219839769, 0.11173417051622436, 0.10146346215263913, 0.09671960757959264, 0.10809379625333237, 0.11898458285792946, 0.10132114434455874, 0.10375392618591728, 0.1075630144844053, 0.10005429899129814, 0.1065386989737035, 0.10867004328817842, 0.12575118743681102, 0.1054226355067911, 0.1056773496374055, 0.09476887926324562, 0.11175435286944779, 0.08508783313367385, 0.09986446069892263, 0.08225845931248188, 0.0907049502924776, 0.09787863518731788, 0.09680280629869753, 0.8785350133313945, 0.8275521842730145, 0.8765066378597537, 0.8904556148345082, 0.7868278691664344, 0.8742394937412702, 0.8711533352245145, 0.731524788950332, 0.7949942697305452, 0.21267989977077428, 0.18888613664669096, 0.2031908707902368, 0.18923441405144814, 0.2609160944914529, 0.24730120231933883, 0.21542953652094465, 0.27372938030829996, 0.1931042600761783, 0.3270243471643822, 0.30003278748927575, 0.31440471569932393, 0.28270934955951976, 0.32063651741413457, 0.3194932649356724, 0.3177745739797342, 0.32068307585925115, 0.2949580476535205, 0.1356763403417255, 0.19182410651317872, 0.13345990462715418, 0.14827082366934718, 0.13794037664477532, 0.1443713063084764, 0.17469458461865361, 0.1427331016065596, 0.146832204948262, 0.10996048405658654, 0.14715519861162885, 0.1440301788158067, 0.1685645002075986, 0.1405783571789594, 0.16954403382011873, 0.1296601557607675, 0.1295467734360065, 0.16413426280645038, 0.0585048923749375, 0.0691268989106606, 0.08428870404277855, 0.08430917814475902, 0.08434343227186403, 0.058162888583974226, 0.02462028182087883, 0.06078930510372116, 0.08639756895869832, 0.16529530175929852, 0.17406564991861906, 0.16913173921775337, 0.12346649999882209, 0.1734627944083117, 0.16983495881987531, 0.19998157162834085, 0.12451139490179464, 0.13897192457473606, 0.041686757476864345, 0.023372912909231824, 0.06488625851351848, 0.03346835177527463, 0.02485895644942515, 0.005798836610697022, 0.0015242922666180991, 0.023196406610665465, 0.011127275230079947, 0.09245256839335014, 0.10333514534291777, 0.11139443798180837, 0.09918647472037412, 0.10301094277773248, 0.10036293886061232, 0.09528468053525008, 0.09707204006575398, 0.10057617434541022, 0.4308987513530871, 0.37574319111583687, 0.42344616413597014, 0.4263510195231095, 0.38668902772705505, 0.4003125455117299, 0.43989083972942467, 0.3963783865342402, 0.3938351019625843, 0.10850007742958168, 0.10847443902436205, 0.10873514263777617, 0.08962374447353705, 0.1029506379855819, 0.10855316997092501, 0.09500714881732697, 0.09478555155320612, 0.0919001254052686, 0.15141543327643903, 0.14810407855179597, 0.14584097414538644, 0.16195927240062225, 0.1726487354286954, 0.13463707135757885, 0.15911156220531886, 0.17728795893983806, 0.13646581615036923, 0.2745667724954337, 0.26411679921860387, 0.271793989080918, 0.272291336417798, 0.26559082601713346, 0.2480206629043652, 0.2849000191718255, 0.27114808659621203, 0.2784845594142449, 0.19801579513646406, 0.22643468778221842, 0.19788621984533405, 0.16993857378806443, 0.1959537471166145, 0.20008560263967146, 0.221401922152198, 0.22439926070206828, 0.21312115096433148, 0.1912276647326191, 0.18683663891779856, 0.2160615908103426, 0.182662821852015, 0.19825336111453895, 0.19453936474072553, 0.23202942067203192, 0.1886915802377247, 0.1969654107720883, 0.18882607171518406, 0.18630405877314737, 0.18406852402611973, 0.20363703790109333, 0.18596698082379226, 0.191160993589651, 0.19118505696804744, 0.19335507059246781, 0.1935582332553336, 0.45302185016015406, 0.494979823986907, 0.18155694100000896, 0.18160951661990377, 0.19346373363769442, 0.3067483686771283, 0.4830355368030719, 0.16225442318478434, 0.14262432676060366, 0.4418252950205792, 0.20545842473381415, 0.4508612256702178, 0.16436137095115833, 0.2274412141501, 0.2846835890299493, 0.3069331102756082, 0.42667221846160597, 0.4546128368731094, 0.19616508724880732, 0.1839098624348472, 0.17555257756128462, 0.18494331934499586, 0.17882808948368856, 0.18553882271941935, 0.18539604582847347, 0.19767787630633216, 0.18629360700735131, 0.0784546193930219, 0.10797603694639635, 0.09377711990825632, 0.07364120020470677, 0.08375854716213105, 0.07913410361666107, 0.07522971047675275, 0.07725090848423588, 0.08494553554640683]}, "mutation_prompt": null}
{"id": "e55d7dda-2e7e-4a33-90f1-4964d4c2b836", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "1978df3b-17ae-46a3-b842-908ed637f400", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "141ac34b-90c7-4c28-9993-8a553f4e07e5", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 15 == 0 and best_fitness in fitness:  # adjust frequency\n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 8 == 0:  # adjust reinitialization frequency\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive mutation scaling and fine-tune reinitialization frequency to enhance convergence stability and performance.", "configspace": "", "generation": 71, "fitness": 0.2250767993014517, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.42882628262659606, 0.43969926875975684, 0.45908153306586663, 0.4341665999129318, 0.4455068142254406, 0.4330145783035293, 0.45723804239096066, 0.41502532929012215, 0.4326215472755863, 0.12892795372850718, 0.1277688328976636, 0.11400844520601205, 0.1420311877207865, 0.10311030566897295, 0.11405243322190273, 0.11481888341151758, 0.07639490379034664, 0.09142591743867556, 0.09742889022302692, 0.0970824211062089, 0.10997990518761691, 0.09979547257233667, 0.10890199918666477, 0.11374298361235802, 0.11083100533165757, 0.13087180191814718, 0.1187459812091809, 0.09978399010834982, 0.09656571233286282, 0.10703714953464172, 0.10227150281082209, 0.08952404984771656, 0.08338091640608514, 0.08792227497031457, 0.08585868536194374, 0.09366834066763863, 0.8737655022225312, 0.8120698702206208, 0.8161379554657865, 0.9513538561519517, 0.6300303605972666, 0.8634336506709247, 0.8245013108530646, 0.9707155819142398, 0.8960684677529571, 0.22887003586060084, 0.24081130754326974, 0.25427468153799293, 0.24202582522050964, 0.18133243019905, 0.2348024278887778, 0.22617527648699964, 0.2096065354921096, 0.22489571681453446, 0.3584515081673303, 0.3599526591674961, 0.30324833965435816, 0.5156641939338924, 0.3524551538110775, 0.3332214010770659, 0.29424885309279514, 0.5932163241825485, 0.34218393575886097, 0.11992632283274651, 0.15018126460854564, 0.13474436373808663, 0.15592675985282733, 0.10174151632965622, 0.14227743454295183, 0.15847241689577019, 0.14694635212057927, 0.19173284323607753, 0.1442120587801422, 0.16639188177426312, 0.12308325970671108, 0.13822916221121118, 0.13633559647562665, 0.16568661754462122, 0.16740788270598272, 0.12362531346303918, 0.17829194463517983, 0.0882691701738646, 0.12508542893329155, 0.06906362465061155, 0.08869600779098785, 0.08229795457577471, 0.07223457000456857, 0.11803029186728331, 0.11682727259502412, 0.07514006904737869, 0.1875038399670511, 0.17777741838601102, 0.22826522652332415, 0.11251643502790354, 0.1571838930358388, 0.15105277264422234, 0.1858055263017636, 0.19429503488296118, 0.17198862983991203, 0.02596260213697954, 0.039951350277110054, 0.06472548859018101, 0.04660956907931957, 0.05175904027651235, 0.01981749180389447, 0.0185770435461714, 0.04014258446883745, 0.04907683303132293, 0.10313922036847123, 0.09060483897856375, 0.07219093808185062, 0.0951609787694142, 0.11728483522062905, 0.12378017702360744, 0.08048058377896417, 0.09655958923804897, 0.12092738100471889, 0.4074221351647579, 0.3811779260773205, 0.42718279323660935, 0.39762062719713775, 0.4172572209185603, 0.3908746626650268, 0.3976990966005792, 0.4026556349101703, 0.37759187714958875, 0.09948893235185219, 0.10289102602774436, 0.10113732429171629, 0.08973431748291771, 0.11387540492158754, 0.1192123814639876, 0.10382771781414735, 0.1128052439966094, 0.09873918675480786, 0.16998502429085072, 0.14694706252275624, 0.15195046254946742, 0.17554873562216067, 0.18526258020685515, 0.16859246348670764, 0.17453416908622243, 0.15452230235025377, 0.18453364395571747, 0.2827818529975967, 0.27656241064280607, 0.26629781393274365, 0.2822178129904831, 0.2876392933313847, 0.2685581938264274, 0.2939103561193479, 0.2994646976529107, 0.2996923776753565, 0.21822814028359838, 0.2006897796101592, 0.21001011813168513, 0.2146741568823166, 0.21109361124809545, 0.2315987632148051, 0.21094043824047393, 0.2367261655568682, 0.2161268993290566, 0.18431869976920057, 0.2416908999490609, 0.21667224819519848, 0.19310628570744592, 0.19121656446462143, 0.19644516449399074, 0.2106139023388086, 0.21493249522825852, 0.2059576552341006, 0.19240002196415829, 0.1856646673149972, 0.1894680840812072, 0.21052702797097578, 0.20002191977155492, 0.19085173531781197, 0.20532513985713696, 0.21756062456116576, 0.18018537812265, 0.5892138502784974, 0.20786817650101785, 0.18623050877312364, 0.6209697192235518, 0.19443143765507276, 0.1610213506727025, 0.5250575759341145, 0.607742728238567, 0.16897176029424243, 0.20554762103118773, 0.20304229504783033, 0.4164135541634323, 0.16791053067318185, 0.2028214681849403, 0.16278702596288497, 0.16480520300376733, 0.5720205150391331, 0.40481089044108065, 0.20134909664213374, 0.17841018359469585, 0.20568903323590026, 0.18060594610529168, 0.18192319627636433, 0.1943940602973978, 0.20557597966512386, 0.1764708437675716, 0.19585990154660204, 0.08126810341819657, 0.07631189871478894, 0.06912576153529937, 0.07959316708264108, 0.08898756250765016, 0.08022592016996055, 0.08613504571083563, 0.0824099388895273, 0.07472364329293124]}, "mutation_prompt": null}
{"id": "c21061f8-7d3d-43b7-b659-e3c69a7e095b", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "f60cf094-2463-402e-b1f9-8ff0a4921eeb", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "94c422e9-24dc-4707-8a31-9cf183febc33", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            adaptive_elitism_rate = 0.3 + 0.2 * np.sin(np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < adaptive_elitism_rate:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance convergence by introducing adaptive elitism and dynamic scaling factors in the differential evolution strategy.", "configspace": "", "generation": 74, "fitness": 0.22426390374401595, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.44083718398263705, 0.43728207419597387, 0.45645026450327364, 0.4295459131189793, 0.45920306132540567, 0.4319912894438198, 0.4026624260283803, 0.4214724092745622, 0.42151564956776355, 0.09233716972105199, 0.11573306652717696, 0.10857462212870905, 0.13283188264944434, 0.12821230357739333, 0.16014354182467017, 0.12890170338269857, 0.09630521796085834, 0.1751645589604064, 0.11721794392930929, 0.1172757046600269, 0.1103822306822071, 0.10568414415384286, 0.1172385379868085, 0.10029416051511286, 0.10685968251779454, 0.12090825023456198, 0.10581616265896043, 0.0936727371550109, 0.08154830344669795, 0.09734108939242159, 0.10333955244717818, 0.08680977837678006, 0.08813201424220984, 0.0865485848920714, 0.0881969648739781, 0.09059021935664457, 0.8825062476020719, 0.7877292494045517, 0.878038624999067, 0.9513538561519517, 0.4844830071862094, 0.8416628760142433, 0.8793702750753141, 0.8751211954567623, 0.8782780291575385, 0.21463510125223184, 0.23300424121919328, 0.26399257964899625, 0.2501585908144973, 0.23224379244718873, 0.23512467035528295, 0.23208799215238884, 0.23588497053869129, 0.23007394520219326, 0.3617932888419715, 0.36105173412018754, 0.3331736634678826, 0.3336036904422921, 0.341272468526959, 0.326699626409896, 0.3438458888832461, 0.32991473294831053, 0.331323196684178, 0.19814780376859664, 0.13887678456608754, 0.19069065391360218, 0.1287127796775427, 0.14262506078392856, 0.15077888138078055, 0.16899904510943708, 0.15026681660748675, 0.15226883565564564, 0.1552493621355523, 0.15790078714118938, 0.13802713198350813, 0.14921876100174158, 0.13172141344805155, 0.17801762841296864, 0.18090451699839816, 0.1210660799594312, 0.12791674279700405, 0.07788812262024036, 0.11562981968778985, 0.07274728377799389, 0.09380837267372422, 0.0753524505015506, 0.10595773857061119, 0.07035266332394163, 0.1381267819343035, 0.11473657011559757, 0.195775289296774, 0.22638649495768348, 0.17125146475417474, 0.15911361805791735, 0.1686522911686399, 0.1953983112414942, 0.1480543946624966, 0.21157449653247817, 0.17306650613509278, 0.05726714591426063, 0.05080868775563574, 0.05039224084599714, 0.06076456584861567, 0.026664118705819972, 0.04754313568708912, 0.03379363179601602, 0.08038526087682707, 0.03244565477129924, 0.11017136605241196, 0.09703523409680459, 0.040919231680829005, 0.09282347394965096, 0.11124792068256262, 0.13708471623003549, 0.09122361268109658, 0.09543528904871468, 0.10938459732361916, 0.3788089199826561, 0.401773818575917, 0.416983723638615, 0.41729661815109453, 0.42965976307814113, 0.38412292146901916, 0.4109378659143612, 0.40422980258416175, 0.40634910742218644, 0.08942031694731944, 0.12775910691121206, 0.10087433039989613, 0.10727271948621342, 0.08958969622611479, 0.10687087158451525, 0.11811843605736105, 0.11860372435253486, 0.08412616526915229, 0.15784340128282526, 0.17291105641567484, 0.22634258045687106, 0.2158185652944915, 0.19997910054756474, 0.1710273848058711, 0.23962329956366535, 0.1926123904583199, 0.15604153007520494, 0.2702385279985414, 0.2675838469301438, 0.27942178102493986, 0.2707997000406046, 0.2867091225601057, 0.2787317047118769, 0.30252664107260463, 0.31194779828824293, 0.2815325984175804, 0.2177878834467759, 0.16553480383771402, 0.2270238677072296, 0.21466064369502413, 0.2071071573019101, 0.2177747411876506, 0.21862116895924966, 0.2255260412298873, 0.22086025181664715, 0.20674591013086796, 0.1867849487219121, 0.21667224819519848, 0.23032760298055366, 0.2017480071225627, 0.2694838845849593, 0.22250110444930182, 0.19783207476793574, 0.20794548016806935, 0.18867049571989913, 0.18338997917629163, 0.19071539568119455, 0.19543016683026082, 0.18191584231269486, 0.20012991189696272, 0.1870387183532567, 0.20083839683092586, 0.17884490093549155, 0.5838233607789938, 0.2068845246950991, 0.18566043093081397, 0.5890580178527242, 0.19470355926474237, 0.17011651849356402, 0.20088194675329596, 0.644763360441611, 0.16921938525669433, 0.2059342625137316, 0.2033409514149619, 0.47676752592363825, 0.1816782499299322, 0.20217180494918874, 0.2261600366556641, 0.16329027654584827, 0.5460231954770224, 0.3503480736377229, 0.20134909664213374, 0.18020303743638766, 0.17390561441622232, 0.17380919302564202, 0.17802614424024776, 0.1811272005012312, 0.18694100227269106, 0.1875722920309275, 0.18059029502058455, 0.07316273583919197, 0.08561283517771168, 0.08430422238754176, 0.0792958445973061, 0.08117568401044539, 0.11554668413379876, 0.07773546185343216, 0.07713899718173411, 0.08018124639007784]}, "mutation_prompt": null}
{"id": "78ff7f7a-ec96-45ee-a851-4f5ea8ba609d", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        if len(self.elite_solutions) < 5:  # Limiting elite solution storage\n                            self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        if len(self.elite_solutions) < 5:  # Limiting elite solution storage\n                            self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance convergence speed by introducing self-adaptive mutation scaling and elite solution preservation mechanisms.", "configspace": "", "generation": 75, "fitness": 0.20318472705745969, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.4187489682086992, 0.38747683165012603, 0.3951730711955227, 0.3868410773700023, 0.39639159000489155, 0.4041001205874123, 0.40840062908483765, 0.38168082008516035, 0.4062998056486442, 0.09690417231378101, 0.08332356572313349, 0.07706721595930954, 0.09940715539410971, 0.07128860009395743, 0.1042620665767221, 0.07545330123518634, 0.1046309924399782, 0.09041359509716662, 0.09458448104061679, 0.1017663231259951, 0.08989517005048075, 0.09455432792023932, 0.09506424844804529, 0.10757430491526554, 0.09651444101122719, 0.10116262825394173, 0.10084368304439195, 0.09604146909532685, 0.08076132455320073, 0.08627155325708757, 0.10297150475006456, 0.08300237046014647, 0.08551266449322759, 0.08923320974393623, 0.09620048425962269, 0.09470685136372081, 0.6971551994370411, 0.8666422041511099, 0.8683112346056214, 0.7881772191919432, 0.5545951141691661, 0.6084461921468929, 0.7812886301061461, 0.9707155819142398, 0.7783749593301136, 0.17468256926156012, 0.16568349199066457, 0.1875713778206496, 0.20580276806154685, 0.16942260648073038, 0.18885112904741452, 0.19179930758139707, 0.16186725871546537, 0.18695903319893437, 0.30775177282343935, 0.3146237715839111, 0.34515878558908786, 0.27263995112196326, 0.26483135353204956, 0.3140331435416962, 0.29723316495652585, 0.2705638801251936, 0.2887251730186787, 0.14522280697842194, 0.1421335944999157, 0.1547364834499686, 0.1241091652151266, 0.12028620360892206, 0.13516145944683267, 0.13233768729760664, 0.13966287184335802, 0.14280807452818267, 0.14717192367825083, 0.14119292080851809, 0.11832065072402309, 0.13504186744707258, 0.12358437579400072, 0.1388220129579245, 0.15920239415536286, 0.11998631756282885, 0.11115442054018987, 0.05674122456161279, 0.07241681948593648, 0.051470455442693686, 0.09054058980354784, 0.09960140402533302, 0.07032542091134275, 0.05360659659909561, 0.09786570618401036, 0.07491055149132264, 0.1803358594398271, 0.16791354029859995, 0.1683258543129108, 0.0842294462506441, 0.1436885095992544, 0.11380504477371722, 0.15455128817751052, 0.17144443282542232, 0.1730533565055664, 0.052595562518729766, 0.03352984555609606, 0.023209613854961786, 0.04649270206404854, 9.999999999998899e-05, 0.0019265659287710513, 0.007640177408797855, 0.008934146925503983, 0.0023395649506113836, 0.08886209571615278, 0.08201609519359043, 0.04384686113864811, 0.06996540643515714, 0.09379204147035103, 0.11834207233106042, 0.08575403603628162, 0.08998815514872949, 0.09021997073453236, 0.3442988662769422, 0.3837253187065578, 0.4015752277171839, 0.39247784950833553, 0.3820403294900723, 0.3855135270367174, 0.3818257446317319, 0.36972895010843077, 0.3744262644967503, 0.08658756483123142, 0.09573584345169006, 0.10404178402846809, 0.10831882846032004, 0.09086146478656065, 0.10241641166633342, 0.09886681218239157, 0.12886185254544325, 0.09437382149980134, 0.1618015920208351, 0.1724903907514136, 0.2357204288675523, 0.16961186116309257, 0.1588190476794421, 0.14173211546997644, 0.1601913514049751, 0.1800028209924056, 0.16741914170646655, 0.2660229291424454, 0.26449165967701294, 0.27352079660868744, 0.2714553249873617, 0.26506710762424057, 0.25810508790027875, 0.2931588311142286, 0.2839720046554133, 0.2601973511562684, 0.21402019923965632, 0.18111434106667135, 0.20432198426129888, 0.22866183364060466, 0.177255980974785, 0.2188096852636452, 0.21516380574363725, 0.2098339329130986, 0.21488611757875165, 0.1884624716354102, 0.19986598609171702, 0.21667224819519848, 0.20058456384075984, 0.22891771266847816, 0.23074135460784695, 0.2058411124388818, 0.20522353498883328, 0.20782239195449692, 0.18111523964463205, 0.17791164670991966, 0.18645959262373368, 0.18593970782956726, 0.19048038291109304, 0.18507436266367916, 0.1969302310256683, 0.1765507110552691, 0.18595307372813763, 0.49202860708997687, 0.20354629440370564, 0.185727380000569, 0.54663955042393, 0.193793317846652, 0.24561546158751757, 0.4470590300844881, 0.5401828892698106, 0.1685446658114479, 0.20453839061074686, 0.19826596880248104, 0.2974870916182275, 0.16795115551490147, 0.18958975114637644, 0.1616528308855315, 0.1597321518266548, 0.4644865597216967, 0.16481909869867073, 0.20134909664213374, 0.17475792144202007, 0.19151630903119343, 0.1942892435178667, 0.1819727864594285, 0.1859132971287658, 0.20557597966512386, 0.19490548187664947, 0.18632567499920538, 0.08093791698669206, 0.08495602228889454, 0.07441687568278443, 0.07762268028209529, 0.0873784044208491, 0.08804131238458979, 0.07393177513761384, 0.07681651956924129, 0.06971530531498737]}, "mutation_prompt": null}
{"id": "c1153b39-d6bc-468d-a64e-1860b4da2506", "solution": "import numpy as np\nfrom scipy.stats import levy\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L_scale=0.1):\n        return levy.rvs(scale=L_scale, size=self.dim)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            for i in range(self.population_size):  # Change: Integrate Levy flights for local search\n                if np.random.rand() < 0.1:  # 10% chance for local exploration\n                    local_search = population[i] + self.levy_flight()\n                    local_search = np.clip(local_search, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_search)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_search\n                        fitness[i] = local_fitness\n                        if local_fitness < best_fitness:\n                            best_solution = local_search\n                            best_fitness = local_fitness\n                            self.elite_solutions.append(local_search)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Incorporate adaptive local search using Levy flights to improve solution refinement and convergence speed.", "configspace": "", "generation": 76, "fitness": 0.22021698466950368, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.4377084790498935, 0.41668958656478894, 0.4289923760348807, 0.4396704163808012, 0.4040557557902853, 0.4579395433025568, 0.414812415955796, 0.4100645964629587, 0.4288126908969445, 0.12361253215073498, 0.11194696838319595, 0.09565875564033921, 0.12579435972162756, 0.15105249928821374, 0.1005442259963546, 0.1454141085316507, 0.1518904963572406, 0.1084474632236544, 0.11194503817520896, 0.10026264973004018, 0.09135298989265417, 0.10262666729282588, 0.10345648206148617, 0.09949270436948299, 0.09328168423468197, 0.12475676306367933, 0.09460207463769543, 0.0941236026864195, 0.08806782472546204, 0.08519025132622338, 0.09034522643139553, 0.09227582299683379, 0.10465832894311278, 0.10131232113796795, 0.10444843116740066, 0.10021253102741923, 0.8662396673707511, 0.8339606389370422, 0.9045590590075318, 0.8782519648062054, 0.7802980213591357, 0.8684680568329777, 0.8129192053609422, 0.880980323133662, 0.8561828887410334, 0.23333227971790638, 0.21862043697753109, 0.23993398973675006, 0.24741915198025943, 0.2441156094058109, 0.2557191230196074, 0.22009056927883053, 0.22048280691711974, 0.20677958734365054, 0.33377995196137034, 0.33968550837652056, 0.36045317285771705, 0.24578419774460714, 0.2865370890706783, 0.34764661232864325, 0.3153993329160859, 0.30064938991003787, 0.3278347403662287, 0.15694869777753107, 0.15068608007249984, 0.18643594268150943, 0.13513365800799126, 0.15390990442803199, 0.16708856530033755, 0.151325446958672, 0.15152404006151332, 0.14400974044514292, 0.14869073999248617, 0.14946773948711467, 0.13518658359263536, 0.15151000280946814, 0.1284489815143206, 0.13337715262563798, 0.12036793064191775, 0.14573897895123866, 0.17391863504435146, 0.09714777099258476, 0.1433901349109361, 0.06383943735947617, 0.09214110661950947, 0.1204601789065608, 0.08221214080388595, 0.06759648950440766, 0.09344662637905166, 0.14185711778239163, 0.19349734257283735, 0.17806801694941077, 0.20896979823497053, 0.10225748917694344, 0.20519093343668005, 0.11720384391920724, 0.19172341862208875, 0.18973245157024632, 0.228031951135936, 0.04048389547885234, 0.03744849386944227, 0.02196796869883988, 0.05511218173244292, 0.020708234722685792, 0.04478427389637729, 0.022372961479916964, 0.008416734577339047, 0.04371321439699527, 0.11545813012378348, 0.08876035325521303, 0.06290622457276318, 0.10528946550558427, 0.10063777579456878, 0.10294568154375505, 0.08697586664767909, 0.10642139655416327, 0.09920077298448282, 0.3904468406846776, 0.393740996077765, 0.4067915583308901, 0.4031301933648479, 0.40353337178468185, 0.40565131337715854, 0.4041504809027352, 0.41147030700126686, 0.39078975546755246, 0.11671133416937896, 0.0814516468663653, 0.10890499895591399, 0.0928754190889104, 0.0992188247383834, 0.11148798329963061, 0.10612298667216824, 0.1031475836634369, 0.10306355483746377, 0.1552910987082865, 0.16308063266189565, 0.15027769090884957, 0.1806511893498589, 0.15497694463617395, 0.15558039005723912, 0.15695404509079058, 0.166130403306325, 0.1499173251598962, 0.2873952369434052, 0.2950376952557634, 0.25619415381270405, 0.27923951934751623, 0.2780845715584659, 0.28635820230954445, 0.2976828018994738, 0.29480486889156376, 0.28954974046971826, 0.204116083162598, 0.1846490646556932, 0.23894300244159838, 0.22431924835947303, 0.22450743377251148, 0.21845422465140985, 0.22848324970300982, 0.22552621371290538, 0.19770343072321517, 0.20434683963224154, 0.2197142736304296, 0.2270873256328193, 0.2716550920241322, 0.2275521620084784, 0.20580181479153992, 0.20228246480754497, 0.21379587133858635, 0.1882272902012101, 0.17224231547438706, 0.18160038117490573, 0.21496478240967043, 0.17886755364286855, 0.20089903525094255, 0.18180928339912472, 0.18249174710327976, 0.17623831562224657, 0.18984462406477676, 0.5759431940163957, 0.2068569770423353, 0.18430350023102138, 0.4352968578217805, 0.19672808201973635, 0.35550718152345695, 0.6277046363123494, 0.16207598948058766, 0.16277214615247815, 0.5114436628379914, 0.1910424115189746, 0.1945920678466726, 0.16804612767743843, 0.24940236635677548, 0.1612784237865975, 0.1650768597473008, 0.5538511685260239, 0.19822981567317732, 0.18559054405078868, 0.18702424684466212, 0.1835182240423896, 0.19448686176382757, 0.1903536728301718, 0.18635663335673303, 0.18142246420174302, 0.18491046417140145, 0.1820009443860967, 0.08317998358674505, 0.08953071218046371, 0.08193807002445008, 0.08176897378489179, 0.0759632831564846, 0.08707441750317646, 0.08129711050837962, 0.09322165319781639, 0.07527944321422164]}, "mutation_prompt": null}
{"id": "e3ff0f63-da9a-4846-8d0a-ee5b6fd737ff", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "ec122961-263b-4602-914e-5730d2b7cd27", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def calculate_diversity(self, population):\n        return np.mean(np.std(population, axis=0))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            population_diversity = self.calculate_diversity(population)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            self.F *= 1 + population_diversity * 0.1  # Adapt F based on diversity\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive parameter update based on population diversity to balance exploration and exploitation dynamically.", "configspace": "", "generation": 78, "fitness": 0.21632898098115286, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.46200789142062415, 0.387928649515911, 0.41876432359803606, 0.41311492796112725, 0.43242355796924803, 0.46286927307242665, 0.4429067284823396, 0.4090657872226514, 0.4140963715079373, 0.1057314940672055, 0.12947165936576222, 0.11700444832061041, 0.1285101423279137, 0.13807144868467913, 0.08874728543809307, 0.1387627126366595, 0.11434994488292083, 0.09281741101644769, 0.09504881634512874, 0.11095500390731339, 0.09888644851842965, 0.1200463187742904, 0.1149767626756375, 0.12105827700199756, 0.1040979033391064, 0.10867862793495131, 0.09625635048948533, 0.08866572156692054, 0.08974652397862903, 0.11049852828354256, 0.09188370409935998, 0.08673864145992105, 0.09506125837271107, 0.08249393044246356, 0.09935276763527912, 0.09476618571480999, 0.8890757003747386, 0.8397393552656023, 0.8745298961566246, 0.8886736285188326, 0.7252123792476077, 0.7594784916682772, 0.8840410540106829, 0.9596111993426223, 0.8851958999788959, 0.23191202412061884, 0.18084797799883123, 0.2171271204936437, 0.24580294447666085, 0.25012103471627567, 0.2269866997079356, 0.22501762864193142, 0.21078298212375857, 0.21835125087924245, 0.318793598392649, 0.34416282259476827, 0.31522552744412, 0.3179180251218394, 0.3078411382601334, 0.2897444494997987, 0.3222087698530862, 0.29980799286247206, 0.3100989292916474, 0.13073072797894125, 0.14366461200903524, 0.19432919143205452, 0.12532721383797674, 0.12855483793645162, 0.12009290415257179, 0.14143874816822244, 0.1524792730898218, 0.15240272509159913, 0.15810441378661577, 0.1357324436693571, 0.1555968407233107, 0.17305272283069062, 0.1435991655194815, 0.1724308644046607, 0.13147281234806052, 0.12328738442834242, 0.13946217084247414, 0.10497182876016908, 0.075766015486469, 0.09684124289338125, 0.07360073739066397, 0.10858371880728024, 0.06970574372185223, 0.06661550309497177, 0.05099091970225256, 0.10316871775717751, 0.17977138513621194, 0.18920990915421987, 0.17290515639018977, 0.17230530157383606, 0.14429579232713619, 0.13767792446638827, 0.17147367428121874, 0.20016958364095594, 0.16180879933488834, 0.019666624324768622, 0.027230005084018738, 0.008928800785571567, 0.052941590194696464, 0.038196529222856546, 0.03629623379843727, 0.04140231366490954, 0.04435579573506787, 0.033552232464975185, 0.1096530917726426, 0.1139965984521174, 0.07163902855937887, 0.08114959747885264, 0.09802285745087702, 0.12132442582810776, 0.08740999068699984, 0.10520147126267387, 0.09534174852589383, 0.3748546571073129, 0.39901990838791057, 0.41286020035089965, 0.4226587893435405, 0.3918883671708352, 0.3848668272041169, 0.4006751006740733, 0.3863617131008835, 0.3798296390975068, 0.09099247643309338, 0.11248429557405104, 0.0979312791011806, 0.09741309926812924, 0.103802900840401, 0.0964571084265563, 0.10831080011206828, 0.09776812585300709, 0.09683351419690056, 0.15068148724000496, 0.16670898254427735, 0.15562491341623552, 0.1587180262649004, 0.14925151653354207, 0.13874700889022007, 0.17817567891306374, 0.20129272361303907, 0.18079105948881702, 0.27683697335659774, 0.2466061452235957, 0.27972943768707004, 0.2846055055717299, 0.2750893503675408, 0.27812473156726314, 0.2846889789442708, 0.2871454399340322, 0.29008212052448146, 0.2092592783327818, 0.217101477397458, 0.20634940234408838, 0.21194534235615015, 0.20382483823675068, 0.21911926068924437, 0.2297041617406118, 0.2108750768640998, 0.21541412527048354, 0.2024016682471237, 0.19959173095389537, 0.21823521890547204, 0.18880227500076452, 0.2060225122437369, 0.2017844621888446, 0.2005909923069601, 0.2152872544563036, 0.19867034312666842, 0.18482938603423593, 0.17900007772396598, 0.1825947392652646, 0.19968478212593865, 0.17482258838476916, 0.17795443735579974, 0.17255290435057813, 0.19733902864035058, 0.17899748029206963, 0.1840575421606392, 0.18877641728758499, 0.6424845716167589, 0.3653663328312713, 0.1918249111966971, 0.14489572588154165, 0.5156959181117268, 0.16545895125411048, 0.297868962510922, 0.27017215438839637, 0.16606500063253404, 0.3440365542913071, 0.16630798596913232, 0.19478999317861556, 0.20463901158393683, 0.157146884455311, 0.549615861988936, 0.382435941142551, 0.18901860260569625, 0.18503020497611555, 0.19045074643290905, 0.17969437956314838, 0.1932135469065548, 0.1960367499293435, 0.18655290333690633, 0.17647871507849866, 0.19061412759913432, 0.08087573894226174, 0.08327340485555323, 0.08169336477520761, 0.07557347579973117, 0.0813760031186026, 0.09242878715442016, 0.07135405683241369, 0.0758479308640646, 0.09315041498327425]}, "mutation_prompt": null}
{"id": "19f1c115-6084-4160-b3d3-f078d87b900b", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            \n            adaptive_factor = 0.5 * (1 - np.tanh(10 * (best_fitness / max(fitness) - 0.5)))\n            self.F = adaptive_factor * self.F + (1 - adaptive_factor) * 0.5\n            self.CR = adaptive_factor * self.CR + (1 - adaptive_factor) * 0.6\n            \n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive scaling and crossover probabilities to enhance convergence speed while maintaining solution diversity.", "configspace": "", "generation": 79, "fitness": 0.2160839008898696, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.3916013728847827, 0.3898141836364095, 0.42937350302696986, 0.40559956731468705, 0.37783430146383656, 0.3924329877917023, 0.3918780002381642, 0.40126980321463224, 0.39107326301104195, 0.1209302505975649, 0.1356092006612536, 0.07583238888883292, 0.09394983172655735, 0.14527124327692276, 0.09826523375296203, 0.14019605033423266, 0.11162924108653205, 0.10449724778841518, 0.10641756128445357, 0.10923034460855874, 0.10562507903000629, 0.11724716408552938, 0.10611724763194885, 0.09484403545467524, 0.1090433025642773, 0.10069422475813661, 0.13401562251471244, 0.10835034964681822, 0.09196258105083377, 0.09647281035257038, 0.09517969448745678, 0.09557466643712964, 0.08847374586893075, 0.108551971107825, 0.1034830780779834, 0.10730890396647552, 0.8811042351367367, 0.8682229676830842, 0.7444652656383076, 0.8614815216135018, 0.8987889285135102, 0.8231353721382688, 0.7971484835092585, 0.9512275662692744, 0.8854029570062706, 0.22768171760760747, 0.2393589615118521, 0.23124487867229448, 0.23648721361859115, 0.2006395990929023, 0.2526203645240932, 0.21068873491299878, 0.22293313087863886, 0.18895200463131478, 0.2740875929726009, 0.2233739915197942, 0.30574479113514785, 0.26342709681995446, 0.3080814562008535, 0.27524627031135973, 0.3255630371835596, 0.3225127785885372, 0.31782531441440265, 0.12779481203284904, 0.1346325468255285, 0.15147858115721924, 0.16223464523188813, 0.1324800819811064, 0.14278564710648511, 0.15818980816691397, 0.15040610740643878, 0.18110171144340825, 0.1638495883341422, 0.19854979082351443, 0.12327501141149333, 0.13610603920551712, 0.13747475822944233, 0.13757779282133775, 0.17228397731531908, 0.1289660307124877, 0.18360785172850724, 0.07385138489823295, 0.11099712944870499, 0.06042579970938955, 0.160421506871267, 0.1250425822896195, 0.10131419164473432, 0.08497794416262627, 0.08861669046954901, 0.07533494866276835, 0.2501306875143273, 0.20582408517307949, 0.19525064417770377, 0.16308446175845348, 0.1849181908491836, 0.22947368902251364, 0.1626795526132533, 0.24952976209243904, 0.20397392684773408, 0.015338297986764005, 0.04267326709743424, 0.03019249701760529, 0.026257816342309392, 0.03822378185762465, 0.0408561471693456, 0.07169938342513582, 0.012510104578353776, 0.023155866509722678, 0.11398496236851607, 0.08149907949488511, 0.07511173306971652, 0.10981772257471034, 0.10933477186170948, 0.12199128298922934, 0.07949122465834624, 0.0772726681332555, 0.09929695798126026, 0.363162432981211, 0.39225032309551766, 0.38524767527052917, 0.37005009146215917, 0.3598370051580637, 0.3612380858888564, 0.39234034454069155, 0.37581336863423853, 0.3664266911115709, 0.07982400033029369, 0.09156420853241032, 0.08730443120045583, 0.10024657218420563, 0.11779429027548771, 0.09636073318702643, 0.11697714673152493, 0.09314101971117195, 0.10259797954459648, 0.1490526395904952, 0.16346834449927194, 0.1560881725285883, 0.16519486980356868, 0.19849785372113016, 0.14723918080474163, 0.16966441810637967, 0.16812200454211668, 0.1469820391218878, 0.2746708857672182, 0.24904607740631513, 0.26787719923496356, 0.24326910971649995, 0.25691513654132103, 0.24818863392608403, 0.2603406480855286, 0.2542658679338733, 0.23990933543829152, 0.22414476850812337, 0.18549632272425964, 0.20192082483161844, 0.20628223825370284, 0.19771246607100834, 0.20601440857391284, 0.20394116853377742, 0.19739191319528204, 0.20350460581811425, 0.1939149620560674, 0.18224635025815428, 0.19612993975001147, 0.18455416231805677, 0.21362995584123923, 0.21589017418206513, 0.20832328134497657, 0.1929769181443458, 0.18974514052942837, 0.19156795458420706, 0.18546844395581064, 0.18771513897553904, 0.1925979801244212, 0.1860575723129282, 0.19046700629394886, 0.19096396772287272, 0.1822484992800656, 0.18804589114110537, 0.39789360764266424, 0.561554820910986, 0.18289363995374175, 0.5354929852173378, 0.19475114314883102, 0.565283616602642, 0.2358847715361636, 0.16832711077085494, 0.22631222519465277, 0.25307440505881573, 0.22412546804886113, 0.27357313340589273, 0.190497160276056, 0.20819699081859033, 0.2877202880041806, 0.16481672930917723, 0.5776416784567824, 0.2414070016166998, 0.19923313721095082, 0.17636400414264786, 0.17913789242143685, 0.19231248339953522, 0.20037841498307907, 0.18861045531371945, 0.19142202683353515, 0.18651556153021487, 0.20016425372347657, 0.0771088188950858, 0.08880703541261992, 0.07729335085916278, 0.0827694840303328, 0.07998081301717941, 0.07271608156678921, 0.09095169121514868, 0.08910845538607759, 0.07143517338093897]}, "mutation_prompt": null}
{"id": "5354f218-d02f-4446-a2ec-93fd6927fcb4", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            diversity = np.mean(np.linalg.norm(population - best_solution, axis=1))\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutation_factor = self.F * (1 + 0.1 * diversity / self.dim)\n                    mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive mutation scaling based on population diversity to enhance convergence efficiency and solution quality.", "configspace": "", "generation": 80, "fitness": 0.2220593160821629, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.40824445166452283, 0.4388830955237075, 0.42764646218848024, 0.41300143626727126, 0.44586416178141974, 0.4999981701813907, 0.413777779114332, 0.41134028404679, 0.46987516021761844, 0.12469155305734148, 0.10999788906721841, 0.13843343584044943, 0.1649915567472201, 0.13733209022630766, 0.1128669454368244, 0.11629427698507788, 0.1173843058712204, 0.06679465335066614, 0.09530844932458915, 0.11679356664172069, 0.10316453697671801, 0.10184665285527195, 0.106565378405869, 0.11263968055020501, 0.09067755858164273, 0.10017435796628082, 0.11337916765664646, 0.08577314127330304, 0.0847859626395151, 0.10218052409921785, 0.09077665756413011, 0.1061075644523024, 0.08821054893723745, 0.10030842022575193, 0.09231109735873433, 0.10427284662950675, 0.7852310508131561, 0.8815052146343413, 0.872750911067872, 0.8897702520462122, 0.6909573884281728, 0.6627304475148845, 0.8977938331742735, 0.9506483506165292, 0.7833062538644477, 0.22288635388113842, 0.15808806345298487, 0.2272288044123133, 0.20880050728497845, 0.24627873991739324, 0.21815213505274, 0.2152583303939447, 0.25193394883151177, 0.2368985839619131, 0.33517000766011273, 0.35186262619306685, 0.341411548281096, 0.3165219932991796, 0.3523368372085648, 0.746842049288361, 0.3386736433635742, 0.3266212957220881, 0.3579493205524221, 0.18136913597279114, 0.17439082909849224, 0.14926142582304125, 0.13925361374931255, 0.17409514549967153, 0.09617555789911891, 0.1675680392372244, 0.139518911585937, 0.19756077457405563, 0.16938035127991313, 0.14904767991392476, 0.15738791180509393, 0.1276479852703264, 0.12300956096525895, 0.1421453606581241, 0.15047850891001913, 0.12191021842522054, 0.14539835154597225, 0.09100861449559794, 0.08569740001810222, 0.09387361057982058, 0.10468011573857838, 0.10503379182999883, 0.10070232888312569, 0.10175826663863496, 0.09781804554733775, 0.11430156929843482, 0.1659921066718527, 0.16384372235917377, 0.15150583301059561, 0.16826600645050316, 0.17891637411986083, 0.13854840443428407, 0.1993889314461038, 0.16630360218165696, 0.2113578288880693, 0.0421278560558942, 0.06999227772224859, 0.0320480547141333, 0.03235024214355331, 0.03478481665459732, 0.009980882466110064, 0.048969778610228776, 0.04515224798374473, 0.041138258321907095, 0.10892064594425444, 0.1103386548943519, 0.07745717561309107, 0.0907537969611858, 0.11255480781101757, 0.10597697773545045, 0.09438983437093196, 0.0874071250789713, 0.09270911601056253, 0.39622139960474323, 0.3906846539986728, 0.4363321740449283, 0.4054240567634534, 0.39142300615542003, 0.40499328455336836, 0.4005875791430611, 0.4071102622612538, 0.38688237653776725, 0.10867087640806583, 0.09418689970921001, 0.10212946398544243, 0.10364170493598446, 0.09758869200461684, 0.1103808104048587, 0.09341369099150798, 0.10010524280099742, 0.10022480159013702, 0.14951347059923792, 0.152076045739987, 0.15983752771746518, 0.16153147408572277, 0.2298906400735542, 0.15085239744666012, 0.2057403936491674, 0.180397524564487, 0.13568221305172878, 0.29754217926172455, 0.2698558531027251, 0.2536713883930606, 0.31142133750624323, 0.2753224667786921, 0.2773533986794098, 0.2889424158700834, 0.2863328391939539, 0.2778578439561976, 0.2223002372076227, 0.1979091662547009, 0.2252466313495769, 0.21817960232014866, 0.21903241463820677, 0.20815424960478635, 0.2286842839719565, 0.24714575097080016, 0.20480362997674728, 0.20035131830420738, 0.21071622530567147, 0.22478782348835846, 0.2166476685828439, 0.19415739911347973, 0.20373664589535978, 0.20996923768601616, 0.18149762091232113, 0.20073021139198932, 0.24871187412253826, 0.1812116696469278, 0.18420416864829559, 0.1864712734250008, 0.19921413324999426, 0.179761381401208, 0.20129785047620208, 0.1951202517098104, 0.1975874345024411, 0.16881794571988207, 0.5995096273522943, 0.18632859179883787, 0.5974662879507215, 0.19663344480627376, 0.19165315111788428, 0.15962023525426106, 0.16534038531013795, 0.16934139916811242, 0.18608452726619584, 0.20525834559779121, 0.5984791794501889, 0.16562617348961117, 0.20617905399317205, 0.2002953927714578, 0.5391735013639225, 0.5409776886911, 0.2074479962518997, 0.19345590893053755, 0.19024991897905952, 0.18851019715247486, 0.17526864823323718, 0.18293242824635358, 0.19024300606531364, 0.1852271456716892, 0.1815001496395382, 0.1788269122144437, 0.09783321853330396, 0.07771959432277875, 0.09100190611992165, 0.08015514354531228, 0.07945886449919037, 0.09505151088690167, 0.07915018025433018, 0.09059775773952095, 0.07999354111749091]}, "mutation_prompt": null}
{"id": "a2c445f4-12a6-474e-a9ec-26a1e2259ce3", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "835d36a3-4fa2-4d2c-a8b1-7d20ed114300", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "7e27beb2-ff06-4e16-b9ae-f5d51c531ff6", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "4fe53304-d4b0-4385-99b5-9ed5c01313f8", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance exploration by integrating a chaotic map for parameter adaptation and increasing diversity through selective reinitialization.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.41028817724029476, 0.44641078224236574, 0.4463558840472881, 0.4290776180462522, 0.4440038207657908, 0.4302676022329145, 0.4270692960007546, 0.4229370342455865, 0.44422144621069615, 0.1347727445151915, 0.1238204153839555, 0.07850800748266684, 0.10526611544362474, 0.14505047293590523, 0.09628191655971385, 0.14153886241534497, 0.09991926119759575, 0.11285072045280264, 0.10996689384771163, 0.11829171517925496, 0.10510092789287395, 0.1003686108369648, 0.10281501027273876, 0.10594376436796882, 0.09724519083196703, 0.10474380230241365, 0.1270406417274138, 0.09872939831719652, 0.07663824844183487, 0.10579289231644562, 0.10339609543506867, 0.08603759983259351, 0.09769602720023973, 0.09212086074621184, 0.09824515398881795, 0.09050497283558345, 0.8188721640498364, 0.7667701787944953, 0.7953784873830796, 0.9513538561519517, 0.578755079691486, 0.7711039162723918, 0.8800052283263726, 0.9707155819142398, 0.871071706382613, 0.23401315206192086, 0.23528960255392317, 0.23431494440197398, 0.2465529052524975, 0.1902613054517347, 0.22230426718278196, 0.21950806192375494, 0.20885017263200967, 0.24452807723209113, 0.3558262121516118, 0.37092295826277377, 0.3485676383787526, 0.34029687981834145, 0.34003651121561773, 0.6750546993047164, 0.3445470193012353, 0.3409694960026335, 0.3413744219986442, 0.15763868603987607, 0.12437905942219663, 0.141978347697439, 0.15889066487819115, 0.0986414579401177, 0.13826049969235354, 0.15098957297751947, 0.1406499351144661, 0.18145609354968129, 0.1435300141340784, 0.1716788029105072, 0.1238277787002866, 0.13331596489290964, 0.1347094192423639, 0.16300045184147205, 0.1641831863769585, 0.12605404002880727, 0.15015001504434244, 0.07154652152291907, 0.10572505209040262, 0.06032339711369894, 0.1035752929686734, 0.09552949810082134, 0.1035511311434606, 0.0893215573813484, 0.07076703518677585, 0.07407487571257043, 0.21269403061108338, 0.2447088935278957, 0.16988929922355323, 0.1224856344149603, 0.2016900146144741, 0.2232429391566927, 0.20637067809783172, 0.2146244457832931, 0.1854742179474953, 0.026583982068435263, 0.04255057293896791, 0.026321623787628368, 0.02635264298518325, 0.029537837382721754, 0.03439271846772862, 0.05635514768025718, 0.028116314624813676, 0.02730946767755682, 0.10526508980475702, 0.07431694496125707, 0.06473704058926721, 0.10037490117747261, 0.10766833250100771, 0.12198631642385516, 0.08815780323003852, 0.09336631043320942, 0.1130931903331811, 0.4123917096741898, 0.4027098279020376, 0.412373095432394, 0.4152746274683793, 0.4239170769494829, 0.3740652549904966, 0.4222980411453374, 0.41286837117165454, 0.3903433177020532, 0.11510494938206195, 0.10390036624429155, 0.07927261646165717, 0.10588612942024789, 0.09317979571786417, 0.11524721327112786, 0.10789950018655614, 0.10438892348054074, 0.09760665476885333, 0.1618015920208351, 0.1724903907514136, 0.23689842198652944, 0.18029257954976297, 0.1588190476794421, 0.14408496961523287, 0.1615021412238653, 0.1795951579748707, 0.16558513731162583, 0.2999244317329597, 0.2800268521381354, 0.29307476136566457, 0.2743400752150589, 0.29005370222070537, 0.2742125842186849, 0.28881197665350833, 0.29323497076009497, 0.2852304686131697, 0.2252027701576763, 0.19277902615500797, 0.2025004871927164, 0.21646822600296323, 0.2161737956872548, 0.2282956226871331, 0.21775748446516496, 0.22427272175602664, 0.21238055401659295, 0.19330661730193854, 0.2416908999490609, 0.21667224819519848, 0.20058456384075984, 0.21033570859095285, 0.2132438625705222, 0.2058411124388818, 0.201718178080166, 0.2052506021678494, 0.18358035879089774, 0.18091067592513532, 0.1895371511558569, 0.1838444778331716, 0.19356613798100386, 0.19467649329328773, 0.18993769862495258, 0.185169298607347, 0.1878304096142025, 0.574091268575496, 0.20724982824620752, 0.18630456646432314, 0.6077335542988815, 0.19473634102740767, 0.4313381998256831, 0.5827064727352769, 0.5711970825166492, 0.16907306231027652, 0.20592282055017808, 0.20258264184149644, 0.422512245876818, 0.16790308172169155, 0.20340758773786194, 0.1628123683437559, 0.16480901574062845, 0.6039057602305885, 0.2949141746446454, 0.20134909664213374, 0.2062497279981832, 0.19151630903119343, 0.18960970555755818, 0.18598515621038958, 0.1852572607291686, 0.20557597966512386, 0.18309760004069553, 0.18853221978151047, 0.08967698118385703, 0.08242342370625955, 0.07665908158187995, 0.10561866513456208, 0.0873784044208491, 0.08554324552543835, 0.07542122590373168, 0.07681651956924129, 0.0730891777742203]}, "mutation_prompt": null}
{"id": "04d2915d-234c-4f3f-a695-bd0eeae658fb", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  # New adaptive mechanism\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Utilize a self-adaptive mechanism to dynamically adjust mutation strategies, enhancing adaptability to diverse problem landscapes.", "configspace": "", "generation": 85, "fitness": 0.2253226377961255, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "f8ff2893-e78a-42ba-af32-6a586a8db6ae", "metadata": {"aucs": [0.43274719454513555, 0.4354563168924749, 0.42845865146587825, 0.4534287455672299, 0.5121197677958338, 0.43945432687548336, 0.4446989870277863, 0.4190723458886906, 0.43127080789367334, 0.1409431687045002, 0.10880616753763184, 0.156099266795233, 0.10901188114027738, 0.12634147805106455, 0.13020268684376735, 0.09568275351041045, 0.15202880593209955, 0.07546749143418297, 0.10161269658227678, 0.1179450052916936, 0.09469198894455544, 0.10767766765657782, 0.11914647338473261, 0.10508031687088826, 0.10052847784157382, 0.11023759531912403, 0.11129504556232828, 0.09143885140050412, 0.09868560238056157, 0.10953314684879822, 0.10782153315827181, 0.11072551653235607, 0.08893620305447147, 0.10200047048505168, 0.10246676599131221, 0.09704598975034551, 0.8780397948847192, 0.8798494791241975, 0.9663224117806187, 0.9707276294931381, 0.8790309996673684, 0.8894184075025874, 0.9143382927241899, 0.8876377891063942, 0.8832736555200573, 0.2325188825996921, 0.18473033264108873, 0.2716589637500437, 0.21988695677474657, 0.2312206518629627, 0.23015955059600457, 0.2221544818118787, 0.20581775928393153, 0.23881905640624457, 0.3380541222264739, 0.32785929890359544, 0.28046874771313446, 0.371295554987328, 0.3121946340562567, 0.3577434795140232, 0.2565797369498253, 0.31152702108315333, 0.2830479510194145, 0.17960404443889, 0.14386479715345946, 0.1537182845683739, 0.157307419328091, 0.13172317702111724, 0.16666666658468277, 0.1710431142366533, 0.1425852180508096, 0.1236383075534554, 0.12800410392956107, 0.20096676639500133, 0.1313679970582844, 0.12990821999120195, 0.1350514720189251, 0.146853944646249, 0.13125424761259186, 0.15365752370471342, 0.11716806761865395, 0.1154928691201359, 0.114632212598482, 0.10259703238209872, 0.04679984124934877, 0.09848928738659946, 0.08504421400567241, 0.08028788374680895, 0.1317397587885205, 0.16864846473923667, 0.18737939529490122, 0.19126039597583344, 0.12312305154164971, 0.12939540484330825, 0.20195316792174156, 0.20883192638232972, 0.19796962951244768, 0.20946264384571456, 0.16814417943457305, 0.0971033471866829, 0.029756961880771593, 0.05312628006016551, 0.06894093814328095, 0.037300708124179294, 0.02024306842371859, 0.07434198929942593, 0.02836828936596736, 0.05763782110996618, 0.11603045136796042, 0.08737998915605893, 0.10041960105555026, 0.0914412862243893, 0.12103601544151532, 0.12179800507607419, 0.0859698857604031, 0.12480817101884045, 0.07428908393911715, 0.4069094655126574, 0.3942029941883348, 0.4324274157869862, 0.4269925333565163, 0.383086316766562, 0.4022597734379497, 0.4091107421266358, 0.4069354367246587, 0.42503090564217194, 0.10029685064679583, 0.12112046293226764, 0.09447424940323257, 0.11762849886295557, 0.09871890052747823, 0.1119323986448153, 0.09843998606217919, 0.08468304325369425, 0.1127855793867093, 0.14674988796462074, 0.15397437787136692, 0.15713400958808776, 0.19255553887281496, 0.15788201198743368, 0.20255103559279408, 0.187959738769353, 0.23872246937197583, 0.16816656069139935, 0.2840702037956936, 0.2995235315700332, 0.2832834811558007, 0.2962483799218788, 0.2763671904400554, 0.2917729378436652, 0.2874528534059535, 0.27147497716180957, 0.29142253409380103, 0.20918786329351724, 0.22807861672720153, 0.24226094131937115, 0.20581920381485974, 0.24100793530624165, 0.23068711708082634, 0.23704162766747805, 0.20239985755791723, 0.22465272137746495, 0.18934361238768904, 0.20533827678683192, 0.20640065802108376, 0.21926309215118667, 0.21027944671347032, 0.1893489712180555, 0.21212162557721093, 0.21157331227293574, 0.1951170891832532, 0.1934258300695192, 0.18798390109019292, 0.17823686981767972, 0.19257049264417536, 0.19452628948892048, 0.1864724517871802, 0.20115721912056583, 0.19318595275924877, 0.19910371315682196, 0.1792369118575332, 0.20812948383288365, 0.18608628290099172, 0.6642764626017937, 0.1950489570169044, 0.6097191377944908, 0.17113050460597656, 0.16877973203165564, 0.5931525446619732, 0.45701520978077836, 0.20659010324625993, 0.20213831192657805, 0.20615036075012239, 0.20742342509394374, 0.3319267353783615, 0.2518080071782264, 0.2020667651603727, 0.20800248315974657, 0.184518086052611, 0.21279050207838646, 0.1913258415576503, 0.18458987743925637, 0.19204463165026586, 0.1789388828282601, 0.17486909173846066, 0.19506863493449622, 0.17637194384473076, 0.07981658614642817, 0.08640105885610538, 0.08183456115056376, 0.08160665048489224, 0.08980499871474967, 0.0813592844190747, 0.07589060666323133, 0.08094936723651813, 0.08373332118276589]}, "mutation_prompt": null}
{"id": "447aea29-e521-46b5-b75e-e38ac8c915cc", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.6 * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.5:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        if len(self.elite_solutions) < 2:  # Limit elite size\n                            self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        if len(self.elite_solutions) < 2:  # Limit elite size\n                            self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce a probabilistic elite retention strategy and adaptive chaos control to enhance exploration and exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.18380422940249266, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "04d2915d-234c-4f3f-a695-bd0eeae658fb", "metadata": {"aucs": [0.3862139986190314, 0.29779103161472686, 0.3509911958219575, 0.3464043085533486, 0.3609620902068885, 0.3235290753558856, 0.4024002318703084, 0.34255204118160887, 0.3213272137159202, 0.045509850635169324, 0.05199094290906103, 0.05724356152270049, 0.06859955687164587, 0.0693099317859589, 0.0650216479116642, 0.05988590825001339, 0.045774753213075, 0.08606445528280326, 0.0901594535099004, 0.0924491644983294, 0.08963261365902686, 0.09421657579543208, 0.09766799547169214, 0.09001356277605466, 0.09766530040189592, 0.096430514342011, 0.09054818603742365, 0.0849152684070168, 0.06690406292111273, 0.06943987365962112, 0.08318755016266355, 0.07306176945408938, 0.07803056608076664, 0.08651749292622624, 0.07526456998066655, 0.07612618841449881, 0.9925885530487492, 0.7758523231658689, 0.7746541596658483, 0.8848328928383117, 0.9898062231993744, 0.989156575481239, 0.7740753668988084, 0.9430770792067084, 0.978205188005466, 0.148513792844867, 0.1270305748419478, 0.11544217220175235, 0.14019203387519807, 0.12763276399527856, 0.13288701217718224, 0.12241372808990603, 0.1312808720103349, 0.13940779969158135, 0.2845363862124639, 0.30564182374118487, 0.20817288138346945, 0.26079289263561867, 0.2616508675738206, 0.21302602752392719, 0.23026862795781744, 0.2689088235455449, 0.2572247619752691, 0.1081739846071259, 0.10382321979096176, 0.11813956113464663, 0.07262445055577593, 0.12210477112469853, 0.11811644880512429, 0.11144106230224082, 0.09556795687201358, 0.12241496917455585, 0.1078275895189239, 0.1003589141543274, 0.061988729017710464, 0.11374096738727424, 0.09355511884950451, 0.11935787520602104, 0.10832285198451441, 0.10413654318630383, 0.07683372059788385, 0.04341939038120768, 0.017259075660839174, 0.0353922656794079, 0.0668293543245656, 0.021577488782395626, 0.033601749808230275, 0.051182847124531694, 0.041541103303813554, 0.014040527336857456, 0.15479163498021697, 0.1803741144108495, 0.15274457488348037, 0.1311837712023084, 0.17853176120958902, 0.11855505442876146, 0.13241518155805165, 0.14171097500343421, 0.1291667888055068, 0.0036774793251767024, 9.999999999998899e-05, 0.00408327554646315, 0.024467411989270493, 9.999999999998899e-05, 9.999999999998899e-05, 0.00608541210999114, 0.00016349791911995926, 9.999999999998899e-05, 0.06422370718006809, 0.0468986074279677, 0.05927550608114396, 0.05203537279794768, 0.0404211212513248, 0.06781071002525241, 0.057844583617559175, 0.07016533745342546, 0.058129238603785605, 0.29785849388319985, 0.3546829963901832, 0.33040837635550835, 0.33407537668709497, 0.32599723964503524, 0.3143600347746577, 0.3516573901934543, 0.3123272977211786, 0.30261742664283, 0.09665249348635074, 0.10640842374666137, 0.09334906194604009, 0.10691039146650361, 0.07647168993628328, 0.09910202679823366, 0.10199567660852804, 0.10350624346956172, 0.0826921625580126, 0.1881118331538557, 0.14345342044518916, 0.24858064982522576, 0.17640156243167837, 0.15797347369438264, 0.18864658177333882, 0.16034131986205535, 0.15255296061999868, 0.2659793170346817, 0.23108046802448623, 0.22861547902497226, 0.2623737724826559, 0.21674171526132935, 0.21464877837685326, 0.22497580539036166, 0.25412419672153796, 0.2504907864266701, 0.23013027379739237, 0.16229832342586703, 0.16363914586387818, 0.18398316692419714, 0.14207845191506152, 0.16905901359287034, 0.17267558834057017, 0.1897199934541508, 0.19679447777448777, 0.17330834597834965, 0.18883052107462495, 0.17906565226574644, 0.2168044873056072, 0.18283032111312747, 0.1960668142701778, 0.22484978930816246, 0.20197189018361006, 0.20051650315569436, 0.20182620278696828, 0.17785545209140907, 0.1714832871933415, 0.17731585251670878, 0.1882686795671622, 0.1776867352871685, 0.18260782994566715, 0.17102986527351072, 0.17751208130083873, 0.17415823697240462, 0.14231400300883434, 0.16594456887111897, 0.39053913991895295, 0.1650333985036173, 0.18990254963929498, 0.18234093553318798, 0.3699702614102105, 0.13439541898633156, 0.16223138485855126, 0.19797498884509224, 0.15803578007832275, 0.31354703033955866, 0.21828440949152872, 0.1881680792852488, 0.15334846102846733, 0.24188776303467652, 0.2960516050600759, 0.22565885791748963, 0.18900313736617036, 0.19938450973878818, 0.19102628893778395, 0.1856287241805168, 0.1936539389114279, 0.21174137212559485, 0.19593365882347513, 0.17774786597479708, 0.18793962335104364, 0.07023152591914317, 0.0836561374918876, 0.08281470776258482, 0.07606479251736342, 0.07532031199922717, 0.08494404666382616, 0.062347815703490794, 0.08876065112673004, 0.06975153890677188]}, "mutation_prompt": null}
{"id": "8f80a0d6-f358-4a7e-a25d-58b683c294a5", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n        self.population_size += int(0.1 * self.population_size)  # Dynamic population size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  # New adaptive mechanism\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n\n                # Adaptive crossover rate based on fitness improvement\n                if trial_fitness < fitness[i]:\n                    self.CR = min(1.0, self.CR + 0.05)\n                else:\n                    self.CR = max(0.1, self.CR - 0.05)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce dynamic population size and adaptive crossover, enhancing search exploration and exploitation balance.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 65 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 65 is out of bounds for axis 0 with size 60')", "parent_id": "04d2915d-234c-4f3f-a695-bd0eeae658fb", "metadata": {}, "mutation_prompt": null}
{"id": "52e68626-6814-4e99-9e82-3043a8159f39", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  # New adaptive mechanism\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Utilize a self-adaptive mechanism to dynamically adjust mutation strategies, enhancing adaptability to diverse problem landscapes.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "04d2915d-234c-4f3f-a695-bd0eeae658fb", "metadata": {"aucs": [0.43274719454513555, 0.4354563168924749, 0.42845865146587825, 0.4534287455672299, 0.5121197677958338, 0.43945432687548336, 0.4446989870277863, 0.4190723458886906, 0.43127080789367334, 0.1409431687045002, 0.10880616753763184, 0.156099266795233, 0.10901188114027738, 0.12634147805106455, 0.13020268684376735, 0.09568275351041045, 0.15202880593209955, 0.07546749143418297, 0.10161269658227678, 0.1179450052916936, 0.09469198894455544, 0.10767766765657782, 0.11914647338473261, 0.10508031687088826, 0.10052847784157382, 0.11023759531912403, 0.11129504556232828, 0.09143885140050412, 0.09868560238056157, 0.10953314684879822, 0.10782153315827181, 0.11072551653235607, 0.08893620305447147, 0.10200047048505168, 0.10246676599131221, 0.09704598975034551, 0.8780397948847192, 0.8798494791241975, 0.9663224117806187, 0.9707276294931381, 0.8790309996673684, 0.8894184075025874, 0.9143382927241899, 0.8876377891063942, 0.8832736555200573, 0.2325188825996921, 0.18473033264108873, 0.2716589637500437, 0.21988695677474657, 0.2312206518629627, 0.23015955059600457, 0.2221544818118787, 0.20581775928393153, 0.23881905640624457, 0.3380541222264739, 0.32785929890359544, 0.28046874771313446, 0.371295554987328, 0.3121946340562567, 0.3577434795140232, 0.2565797369498253, 0.31152702108315333, 0.2830479510194145, 0.17960404443889, 0.14386479715345946, 0.1537182845683739, 0.157307419328091, 0.13172317702111724, 0.16666666658468277, 0.1710431142366533, 0.1425852180508096, 0.1236383075534554, 0.12800410392956107, 0.20096676639500133, 0.1313679970582844, 0.12990821999120195, 0.1350514720189251, 0.146853944646249, 0.13125424761259186, 0.15365752370471342, 0.11716806761865395, 0.1154928691201359, 0.114632212598482, 0.10259703238209872, 0.04679984124934877, 0.09848928738659946, 0.08504421400567241, 0.08028788374680895, 0.1317397587885205, 0.16864846473923667, 0.18737939529490122, 0.19126039597583344, 0.12312305154164971, 0.12939540484330825, 0.20195316792174156, 0.20883192638232972, 0.19796962951244768, 0.20946264384571456, 0.16814417943457305, 0.0971033471866829, 0.029756961880771593, 0.05312628006016551, 0.06894093814328095, 0.037300708124179294, 0.02024306842371859, 0.07434198929942593, 0.02836828936596736, 0.05763782110996618, 0.11603045136796042, 0.08737998915605893, 0.10041960105555026, 0.0914412862243893, 0.12103601544151532, 0.12179800507607419, 0.0859698857604031, 0.12480817101884045, 0.07428908393911715, 0.4069094655126574, 0.3942029941883348, 0.4324274157869862, 0.4269925333565163, 0.383086316766562, 0.4022597734379497, 0.4091107421266358, 0.4069354367246587, 0.42503090564217194, 0.10029685064679583, 0.12112046293226764, 0.09447424940323257, 0.11762849886295557, 0.09871890052747823, 0.1119323986448153, 0.09843998606217919, 0.08468304325369425, 0.1127855793867093, 0.14674988796462074, 0.15397437787136692, 0.15713400958808776, 0.19255553887281496, 0.15788201198743368, 0.20255103559279408, 0.187959738769353, 0.23872246937197583, 0.16816656069139935, 0.2840702037956936, 0.2995235315700332, 0.2832834811558007, 0.2962483799218788, 0.2763671904400554, 0.2917729378436652, 0.2874528534059535, 0.27147497716180957, 0.29142253409380103, 0.20918786329351724, 0.22807861672720153, 0.24226094131937115, 0.20581920381485974, 0.24100793530624165, 0.23068711708082634, 0.23704162766747805, 0.20239985755791723, 0.22465272137746495, 0.18934361238768904, 0.20533827678683192, 0.20640065802108376, 0.21926309215118667, 0.21027944671347032, 0.1893489712180555, 0.21212162557721093, 0.21157331227293574, 0.1951170891832532, 0.1934258300695192, 0.18798390109019292, 0.17823686981767972, 0.19257049264417536, 0.19452628948892048, 0.1864724517871802, 0.20115721912056583, 0.19318595275924877, 0.19910371315682196, 0.1792369118575332, 0.20812948383288365, 0.18608628290099172, 0.6642764626017937, 0.1950489570169044, 0.6097191377944908, 0.17113050460597656, 0.16877973203165564, 0.5931525446619732, 0.45701520978077836, 0.20659010324625993, 0.20213831192657805, 0.20615036075012239, 0.20742342509394374, 0.3319267353783615, 0.2518080071782264, 0.2020667651603727, 0.20800248315974657, 0.184518086052611, 0.21279050207838646, 0.1913258415576503, 0.18458987743925637, 0.19204463165026586, 0.1789388828282601, 0.17486909173846066, 0.19506863493449622, 0.17637194384473076, 0.07981658614642817, 0.08640105885610538, 0.08183456115056376, 0.08160665048489224, 0.08980499871474967, 0.0813592844190747, 0.07589060666323133, 0.08094936723651813, 0.08373332118276589]}, "mutation_prompt": null}
{"id": "fc404221-42a2-4416-b1fd-ce5dc171511f", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        # Lvy flight step\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  # New adaptive mechanism\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant += self.levy_flight()  # Introduce Lvy flight\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance global search ability by introducing Lvy flights and a controlled mutation scaling factor to improve exploration and convergence balance.", "configspace": "", "generation": 89, "fitness": 0.22615600619216014, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "04d2915d-234c-4f3f-a695-bd0eeae658fb", "metadata": {"aucs": [0.4627893584142668, 0.4084568168881515, 0.43915853105206726, 0.44245046361158324, 0.47503250784764406, 0.42183787611280044, 0.43786426936622846, 0.43130256365747077, 0.4648621562582006, 0.14808717704043484, 0.10303741035641034, 0.14067879195054034, 0.07223715949190268, 0.10966885147276739, 0.09386926644211468, 0.09984442511829217, 0.11828697796631427, 0.0740904612615203, 0.10413608723845047, 0.120792555227895, 0.09991996305401007, 0.10770732793806059, 0.11061167644006886, 0.12265545925894639, 0.10606667891298016, 0.11159962172367144, 0.09954069165010004, 0.09152234798900027, 0.09448983619569828, 0.08949707120368489, 0.09540747992532683, 0.09046300247584027, 0.08848797357499627, 0.12242265181867074, 0.11385305832293091, 0.10074948396536454, 0.8673192132197782, 0.7852647019521886, 0.9589199597197752, 0.9693222667273318, 0.8837386850161576, 0.8242041532303936, 0.771972334965889, 0.8829959591054087, 0.9514021631329035, 0.23885128078589069, 0.2500054381748279, 0.19930111103594594, 0.2290258203351121, 0.21975681290685145, 0.23048683778502566, 0.21477945960509082, 0.23885896582450727, 0.21862916995728776, 0.34057642348011463, 0.35990141586294955, 0.8061944289240999, 0.33143665600915895, 0.3259929695264353, 0.32394785575481533, 0.3283257380157757, 0.2691176378521075, 0.33425127356263895, 0.20039856530651223, 0.17720752742838997, 0.15462664844366503, 0.13506486072731605, 0.15768494789943488, 0.12442180439797323, 0.14925369969911184, 0.14691709837147704, 0.18117177014312857, 0.13071220167860542, 0.11011244905948514, 0.1375382403325497, 0.1643339862982368, 0.18642281519848258, 0.14045791971537314, 0.15533754603306693, 0.12796076339685203, 0.15039714519519698, 0.08120452129952205, 0.04479190864905591, 0.02751181976665562, 0.1215018101110612, 0.06597651354581502, 0.0588602065609104, 0.12530035682372764, 0.07713339945450914, 0.07158657841874505, 0.2058371478746972, 0.08447785776469807, 0.12709639111600213, 0.11913851585584923, 0.1440465051690717, 0.16176622597773327, 0.18562193838630447, 0.19273356550574816, 0.07450703885858345, 0.017929185502432166, 0.027001622448551865, 0.019122365966518173, 0.032512040763359784, 0.010063026072692827, 0.0019400252062272694, 0.013635969358496869, 0.01682389202249379, 0.02232041454547784, 0.1147312169606668, 0.09588897883581904, 0.09642278589954534, 0.10625518311824467, 0.10526697345852132, 0.11633106533309401, 0.09703221594956812, 0.11108083111722622, 0.10981639867337367, 0.4588600974382815, 0.4460041367956058, 0.423245713941658, 0.4428456965384783, 0.38495919881838103, 0.4153803929617952, 0.41012783182428647, 0.3935822885429212, 0.39501007229906315, 0.11048502093553692, 0.09354008578314266, 0.09559987156838035, 0.11219634546771362, 0.10337626119229881, 0.09548138881804791, 0.11239870998773549, 0.10869133307560042, 0.09859607798830583, 0.15840984528012692, 0.15050279844189496, 0.1903384394968659, 0.16939187720252324, 0.18179818871598175, 0.1708367184719911, 0.16015258664992593, 0.23206035852639184, 0.1496680270493871, 0.2747962684170152, 0.28083815577901805, 0.290108575530593, 0.3153283448214208, 0.27163719552548227, 0.2899974004373166, 0.2801763581549429, 0.28090416313214805, 0.28718864579725245, 0.19603905268697142, 0.2125055929741838, 0.22594041186438474, 0.21466864302194588, 0.23271663544325383, 0.21282862837092253, 0.17702794518660303, 0.2425602845748015, 0.2371116427673815, 0.20447542104882832, 0.19611720178553083, 0.1957917228194085, 0.19865733326549884, 0.19652870092860875, 0.19928955391698255, 0.20198334218063552, 0.20090997886843043, 0.20932992248698867, 0.19611642706246857, 0.17576994452727268, 0.18411544045772132, 0.19371406446820427, 0.1881529739724751, 0.19699468489568428, 0.1817088052040906, 0.18929381638636056, 0.2037651595716613, 0.18400630161455, 0.6121224616718262, 0.1800426085489305, 0.580163268179276, 0.17203833125508394, 0.48721896857563973, 0.5583086813045641, 0.1689747635283213, 0.5564424172346174, 0.16624695540161794, 0.4782151363517234, 0.484300170203656, 0.20427052147604352, 0.15280511171448674, 0.47201454130148235, 0.165785399012487, 0.434424631004074, 0.1122136616704642, 0.1811050530045214, 0.18632495097896484, 0.18983590616818047, 0.18530517407322145, 0.18105421991198378, 0.1897331465438341, 0.17969503212572657, 0.18070554754232093, 0.18626968507049646, 0.0864815248482822, 0.08894866035397464, 0.08590184218138475, 0.07519797618132129, 0.08075525388962923, 0.08305484613640435, 0.08211652267361247, 0.08115765359562044, 0.07648936464473277]}, "mutation_prompt": null}
{"id": "4df7986d-57e8-46d8-bed1-89b4d09956ae", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        # Lvy flight step\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  # New adaptive mechanism\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant += self.levy_flight()  # Introduce Lvy flight\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance global search ability by introducing Lvy flights and a controlled mutation scaling factor to improve exploration and convergence balance.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fc404221-42a2-4416-b1fd-ce5dc171511f", "metadata": {"aucs": [0.4627893584142668, 0.4084568168881515, 0.43915853105206726, 0.44245046361158324, 0.47503250784764406, 0.42183787611280044, 0.43786426936622846, 0.43130256365747077, 0.4648621562582006, 0.14808717704043484, 0.10303741035641034, 0.14067879195054034, 0.07223715949190268, 0.10966885147276739, 0.09386926644211468, 0.09984442511829217, 0.11828697796631427, 0.0740904612615203, 0.10413608723845047, 0.120792555227895, 0.09991996305401007, 0.10770732793806059, 0.11061167644006886, 0.12265545925894639, 0.10606667891298016, 0.11159962172367144, 0.09954069165010004, 0.09152234798900027, 0.09448983619569828, 0.08949707120368489, 0.09540747992532683, 0.09046300247584027, 0.08848797357499627, 0.12242265181867074, 0.11385305832293091, 0.10074948396536454, 0.8673192132197782, 0.7852647019521886, 0.9589199597197752, 0.9693222667273318, 0.8837386850161576, 0.8242041532303936, 0.771972334965889, 0.8829959591054087, 0.9514021631329035, 0.23885128078589069, 0.2500054381748279, 0.19930111103594594, 0.2290258203351121, 0.21975681290685145, 0.23048683778502566, 0.21477945960509082, 0.23885896582450727, 0.21862916995728776, 0.34057642348011463, 0.35990141586294955, 0.8061944289240999, 0.33143665600915895, 0.3259929695264353, 0.32394785575481533, 0.3283257380157757, 0.2691176378521075, 0.33425127356263895, 0.20039856530651223, 0.17720752742838997, 0.15462664844366503, 0.13506486072731605, 0.15768494789943488, 0.12442180439797323, 0.14925369969911184, 0.14691709837147704, 0.18117177014312857, 0.13071220167860542, 0.11011244905948514, 0.1375382403325497, 0.1643339862982368, 0.18642281519848258, 0.14045791971537314, 0.15533754603306693, 0.12796076339685203, 0.15039714519519698, 0.08120452129952205, 0.04479190864905591, 0.02751181976665562, 0.1215018101110612, 0.06597651354581502, 0.0588602065609104, 0.12530035682372764, 0.07713339945450914, 0.07158657841874505, 0.2058371478746972, 0.08447785776469807, 0.12709639111600213, 0.11913851585584923, 0.1440465051690717, 0.16176622597773327, 0.18562193838630447, 0.19273356550574816, 0.07450703885858345, 0.017929185502432166, 0.027001622448551865, 0.019122365966518173, 0.032512040763359784, 0.010063026072692827, 0.0019400252062272694, 0.013635969358496869, 0.01682389202249379, 0.02232041454547784, 0.1147312169606668, 0.09588897883581904, 0.09642278589954534, 0.10625518311824467, 0.10526697345852132, 0.11633106533309401, 0.09703221594956812, 0.11108083111722622, 0.10981639867337367, 0.4588600974382815, 0.4460041367956058, 0.423245713941658, 0.4428456965384783, 0.38495919881838103, 0.4153803929617952, 0.41012783182428647, 0.3935822885429212, 0.39501007229906315, 0.11048502093553692, 0.09354008578314266, 0.09559987156838035, 0.11219634546771362, 0.10337626119229881, 0.09548138881804791, 0.11239870998773549, 0.10869133307560042, 0.09859607798830583, 0.15840984528012692, 0.15050279844189496, 0.1903384394968659, 0.16939187720252324, 0.18179818871598175, 0.1708367184719911, 0.16015258664992593, 0.23206035852639184, 0.1496680270493871, 0.2747962684170152, 0.28083815577901805, 0.290108575530593, 0.3153283448214208, 0.27163719552548227, 0.2899974004373166, 0.2801763581549429, 0.28090416313214805, 0.28718864579725245, 0.19603905268697142, 0.2125055929741838, 0.22594041186438474, 0.21466864302194588, 0.23271663544325383, 0.21282862837092253, 0.17702794518660303, 0.2425602845748015, 0.2371116427673815, 0.20447542104882832, 0.19611720178553083, 0.1957917228194085, 0.19865733326549884, 0.19652870092860875, 0.19928955391698255, 0.20198334218063552, 0.20090997886843043, 0.20932992248698867, 0.19611642706246857, 0.17576994452727268, 0.18411544045772132, 0.19371406446820427, 0.1881529739724751, 0.19699468489568428, 0.1817088052040906, 0.18929381638636056, 0.2037651595716613, 0.18400630161455, 0.6121224616718262, 0.1800426085489305, 0.580163268179276, 0.17203833125508394, 0.48721896857563973, 0.5583086813045641, 0.1689747635283213, 0.5564424172346174, 0.16624695540161794, 0.4782151363517234, 0.484300170203656, 0.20427052147604352, 0.15280511171448674, 0.47201454130148235, 0.165785399012487, 0.434424631004074, 0.1122136616704642, 0.1811050530045214, 0.18632495097896484, 0.18983590616818047, 0.18530517407322145, 0.18105421991198378, 0.1897331465438341, 0.17969503212572657, 0.18070554754232093, 0.18626968507049646, 0.0864815248482822, 0.08894866035397464, 0.08590184218138475, 0.07519797618132129, 0.08075525388962923, 0.08305484613640435, 0.08211652267361247, 0.08115765359562044, 0.07648936464473277]}, "mutation_prompt": null}
{"id": "7e001367-9ed4-428f-a553-d878e94d8d97", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        # Lvy flight step\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  # New adaptive mechanism\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant += self.levy_flight()  # Introduce Lvy flight\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance global search ability by introducing Lvy flights and a controlled mutation scaling factor to improve exploration and convergence balance.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fc404221-42a2-4416-b1fd-ce5dc171511f", "metadata": {"aucs": [0.4627893584142668, 0.4084568168881515, 0.43915853105206726, 0.44245046361158324, 0.47503250784764406, 0.42183787611280044, 0.43786426936622846, 0.43130256365747077, 0.4648621562582006, 0.14808717704043484, 0.10303741035641034, 0.14067879195054034, 0.07223715949190268, 0.10966885147276739, 0.09386926644211468, 0.09984442511829217, 0.11828697796631427, 0.0740904612615203, 0.10413608723845047, 0.120792555227895, 0.09991996305401007, 0.10770732793806059, 0.11061167644006886, 0.12265545925894639, 0.10606667891298016, 0.11159962172367144, 0.09954069165010004, 0.09152234798900027, 0.09448983619569828, 0.08949707120368489, 0.09540747992532683, 0.09046300247584027, 0.08848797357499627, 0.12242265181867074, 0.11385305832293091, 0.10074948396536454, 0.8673192132197782, 0.7852647019521886, 0.9589199597197752, 0.9693222667273318, 0.8837386850161576, 0.8242041532303936, 0.771972334965889, 0.8829959591054087, 0.9514021631329035, 0.23885128078589069, 0.2500054381748279, 0.19930111103594594, 0.2290258203351121, 0.21975681290685145, 0.23048683778502566, 0.21477945960509082, 0.23885896582450727, 0.21862916995728776, 0.34057642348011463, 0.35990141586294955, 0.8061944289240999, 0.33143665600915895, 0.3259929695264353, 0.32394785575481533, 0.3283257380157757, 0.2691176378521075, 0.33425127356263895, 0.20039856530651223, 0.17720752742838997, 0.15462664844366503, 0.13506486072731605, 0.15768494789943488, 0.12442180439797323, 0.14925369969911184, 0.14691709837147704, 0.18117177014312857, 0.13071220167860542, 0.11011244905948514, 0.1375382403325497, 0.1643339862982368, 0.18642281519848258, 0.14045791971537314, 0.15533754603306693, 0.12796076339685203, 0.15039714519519698, 0.08120452129952205, 0.04479190864905591, 0.02751181976665562, 0.1215018101110612, 0.06597651354581502, 0.0588602065609104, 0.12530035682372764, 0.07713339945450914, 0.07158657841874505, 0.2058371478746972, 0.08447785776469807, 0.12709639111600213, 0.11913851585584923, 0.1440465051690717, 0.16176622597773327, 0.18562193838630447, 0.19273356550574816, 0.07450703885858345, 0.017929185502432166, 0.027001622448551865, 0.019122365966518173, 0.032512040763359784, 0.010063026072692827, 0.0019400252062272694, 0.013635969358496869, 0.01682389202249379, 0.02232041454547784, 0.1147312169606668, 0.09588897883581904, 0.09642278589954534, 0.10625518311824467, 0.10526697345852132, 0.11633106533309401, 0.09703221594956812, 0.11108083111722622, 0.10981639867337367, 0.4588600974382815, 0.4460041367956058, 0.423245713941658, 0.4428456965384783, 0.38495919881838103, 0.4153803929617952, 0.41012783182428647, 0.3935822885429212, 0.39501007229906315, 0.11048502093553692, 0.09354008578314266, 0.09559987156838035, 0.11219634546771362, 0.10337626119229881, 0.09548138881804791, 0.11239870998773549, 0.10869133307560042, 0.09859607798830583, 0.15840984528012692, 0.15050279844189496, 0.1903384394968659, 0.16939187720252324, 0.18179818871598175, 0.1708367184719911, 0.16015258664992593, 0.23206035852639184, 0.1496680270493871, 0.2747962684170152, 0.28083815577901805, 0.290108575530593, 0.3153283448214208, 0.27163719552548227, 0.2899974004373166, 0.2801763581549429, 0.28090416313214805, 0.28718864579725245, 0.19603905268697142, 0.2125055929741838, 0.22594041186438474, 0.21466864302194588, 0.23271663544325383, 0.21282862837092253, 0.17702794518660303, 0.2425602845748015, 0.2371116427673815, 0.20447542104882832, 0.19611720178553083, 0.1957917228194085, 0.19865733326549884, 0.19652870092860875, 0.19928955391698255, 0.20198334218063552, 0.20090997886843043, 0.20932992248698867, 0.19611642706246857, 0.17576994452727268, 0.18411544045772132, 0.19371406446820427, 0.1881529739724751, 0.19699468489568428, 0.1817088052040906, 0.18929381638636056, 0.2037651595716613, 0.18400630161455, 0.6121224616718262, 0.1800426085489305, 0.580163268179276, 0.17203833125508394, 0.48721896857563973, 0.5583086813045641, 0.1689747635283213, 0.5564424172346174, 0.16624695540161794, 0.4782151363517234, 0.484300170203656, 0.20427052147604352, 0.15280511171448674, 0.47201454130148235, 0.165785399012487, 0.434424631004074, 0.1122136616704642, 0.1811050530045214, 0.18632495097896484, 0.18983590616818047, 0.18530517407322145, 0.18105421991198378, 0.1897331465438341, 0.17969503212572657, 0.18070554754232093, 0.18626968507049646, 0.0864815248482822, 0.08894866035397464, 0.08590184218138475, 0.07519797618132129, 0.08075525388962923, 0.08305484613640435, 0.08211652267361247, 0.08115765359562044, 0.07648936464473277]}, "mutation_prompt": null}
{"id": "d3ca9984-d7e2-4b4d-88e5-5439702b3ada", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        # Lvy flight step\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  # New adaptive mechanism\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant += self.levy_flight()  # Introduce Lvy flight\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance global search ability by introducing Lvy flights and a controlled mutation scaling factor to improve exploration and convergence balance.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fc404221-42a2-4416-b1fd-ce5dc171511f", "metadata": {"aucs": [0.4627893584142668, 0.4084568168881515, 0.43915853105206726, 0.44245046361158324, 0.47503250784764406, 0.42183787611280044, 0.43786426936622846, 0.43130256365747077, 0.4648621562582006, 0.14808717704043484, 0.10303741035641034, 0.14067879195054034, 0.07223715949190268, 0.10966885147276739, 0.09386926644211468, 0.09984442511829217, 0.11828697796631427, 0.0740904612615203, 0.10413608723845047, 0.120792555227895, 0.09991996305401007, 0.10770732793806059, 0.11061167644006886, 0.12265545925894639, 0.10606667891298016, 0.11159962172367144, 0.09954069165010004, 0.09152234798900027, 0.09448983619569828, 0.08949707120368489, 0.09540747992532683, 0.09046300247584027, 0.08848797357499627, 0.12242265181867074, 0.11385305832293091, 0.10074948396536454, 0.8673192132197782, 0.7852647019521886, 0.9589199597197752, 0.9693222667273318, 0.8837386850161576, 0.8242041532303936, 0.771972334965889, 0.8829959591054087, 0.9514021631329035, 0.23885128078589069, 0.2500054381748279, 0.19930111103594594, 0.2290258203351121, 0.21975681290685145, 0.23048683778502566, 0.21477945960509082, 0.23885896582450727, 0.21862916995728776, 0.34057642348011463, 0.35990141586294955, 0.8061944289240999, 0.33143665600915895, 0.3259929695264353, 0.32394785575481533, 0.3283257380157757, 0.2691176378521075, 0.33425127356263895, 0.20039856530651223, 0.17720752742838997, 0.15462664844366503, 0.13506486072731605, 0.15768494789943488, 0.12442180439797323, 0.14925369969911184, 0.14691709837147704, 0.18117177014312857, 0.13071220167860542, 0.11011244905948514, 0.1375382403325497, 0.1643339862982368, 0.18642281519848258, 0.14045791971537314, 0.15533754603306693, 0.12796076339685203, 0.15039714519519698, 0.08120452129952205, 0.04479190864905591, 0.02751181976665562, 0.1215018101110612, 0.06597651354581502, 0.0588602065609104, 0.12530035682372764, 0.07713339945450914, 0.07158657841874505, 0.2058371478746972, 0.08447785776469807, 0.12709639111600213, 0.11913851585584923, 0.1440465051690717, 0.16176622597773327, 0.18562193838630447, 0.19273356550574816, 0.07450703885858345, 0.017929185502432166, 0.027001622448551865, 0.019122365966518173, 0.032512040763359784, 0.010063026072692827, 0.0019400252062272694, 0.013635969358496869, 0.01682389202249379, 0.02232041454547784, 0.1147312169606668, 0.09588897883581904, 0.09642278589954534, 0.10625518311824467, 0.10526697345852132, 0.11633106533309401, 0.09703221594956812, 0.11108083111722622, 0.10981639867337367, 0.4588600974382815, 0.4460041367956058, 0.423245713941658, 0.4428456965384783, 0.38495919881838103, 0.4153803929617952, 0.41012783182428647, 0.3935822885429212, 0.39501007229906315, 0.11048502093553692, 0.09354008578314266, 0.09559987156838035, 0.11219634546771362, 0.10337626119229881, 0.09548138881804791, 0.11239870998773549, 0.10869133307560042, 0.09859607798830583, 0.15840984528012692, 0.15050279844189496, 0.1903384394968659, 0.16939187720252324, 0.18179818871598175, 0.1708367184719911, 0.16015258664992593, 0.23206035852639184, 0.1496680270493871, 0.2747962684170152, 0.28083815577901805, 0.290108575530593, 0.3153283448214208, 0.27163719552548227, 0.2899974004373166, 0.2801763581549429, 0.28090416313214805, 0.28718864579725245, 0.19603905268697142, 0.2125055929741838, 0.22594041186438474, 0.21466864302194588, 0.23271663544325383, 0.21282862837092253, 0.17702794518660303, 0.2425602845748015, 0.2371116427673815, 0.20447542104882832, 0.19611720178553083, 0.1957917228194085, 0.19865733326549884, 0.19652870092860875, 0.19928955391698255, 0.20198334218063552, 0.20090997886843043, 0.20932992248698867, 0.19611642706246857, 0.17576994452727268, 0.18411544045772132, 0.19371406446820427, 0.1881529739724751, 0.19699468489568428, 0.1817088052040906, 0.18929381638636056, 0.2037651595716613, 0.18400630161455, 0.6121224616718262, 0.1800426085489305, 0.580163268179276, 0.17203833125508394, 0.48721896857563973, 0.5583086813045641, 0.1689747635283213, 0.5564424172346174, 0.16624695540161794, 0.4782151363517234, 0.484300170203656, 0.20427052147604352, 0.15280511171448674, 0.47201454130148235, 0.165785399012487, 0.434424631004074, 0.1122136616704642, 0.1811050530045214, 0.18632495097896484, 0.18983590616818047, 0.18530517407322145, 0.18105421991198378, 0.1897331465438341, 0.17969503212572657, 0.18070554754232093, 0.18626968507049646, 0.0864815248482822, 0.08894866035397464, 0.08590184218138475, 0.07519797618132129, 0.08075525388962923, 0.08305484613640435, 0.08211652267361247, 0.08115765359562044, 0.07648936464473277]}, "mutation_prompt": null}
{"id": "8f5f26b6-2057-4182-8bdd-ee8fee1ba0d6", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        # Lvy flight step\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  # New adaptive mechanism\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant += self.levy_flight()  # Introduce Lvy flight\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Enhance global search ability by introducing Lvy flights and a controlled mutation scaling factor to improve exploration and convergence balance.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fc404221-42a2-4416-b1fd-ce5dc171511f", "metadata": {"aucs": [0.4627893584142668, 0.4084568168881515, 0.43915853105206726, 0.44245046361158324, 0.47503250784764406, 0.42183787611280044, 0.43786426936622846, 0.43130256365747077, 0.4648621562582006, 0.14808717704043484, 0.10303741035641034, 0.14067879195054034, 0.07223715949190268, 0.10966885147276739, 0.09386926644211468, 0.09984442511829217, 0.11828697796631427, 0.0740904612615203, 0.10413608723845047, 0.120792555227895, 0.09991996305401007, 0.10770732793806059, 0.11061167644006886, 0.12265545925894639, 0.10606667891298016, 0.11159962172367144, 0.09954069165010004, 0.09152234798900027, 0.09448983619569828, 0.08949707120368489, 0.09540747992532683, 0.09046300247584027, 0.08848797357499627, 0.12242265181867074, 0.11385305832293091, 0.10074948396536454, 0.8673192132197782, 0.7852647019521886, 0.9589199597197752, 0.9693222667273318, 0.8837386850161576, 0.8242041532303936, 0.771972334965889, 0.8829959591054087, 0.9514021631329035, 0.23885128078589069, 0.2500054381748279, 0.19930111103594594, 0.2290258203351121, 0.21975681290685145, 0.23048683778502566, 0.21477945960509082, 0.23885896582450727, 0.21862916995728776, 0.34057642348011463, 0.35990141586294955, 0.8061944289240999, 0.33143665600915895, 0.3259929695264353, 0.32394785575481533, 0.3283257380157757, 0.2691176378521075, 0.33425127356263895, 0.20039856530651223, 0.17720752742838997, 0.15462664844366503, 0.13506486072731605, 0.15768494789943488, 0.12442180439797323, 0.14925369969911184, 0.14691709837147704, 0.18117177014312857, 0.13071220167860542, 0.11011244905948514, 0.1375382403325497, 0.1643339862982368, 0.18642281519848258, 0.14045791971537314, 0.15533754603306693, 0.12796076339685203, 0.15039714519519698, 0.08120452129952205, 0.04479190864905591, 0.02751181976665562, 0.1215018101110612, 0.06597651354581502, 0.0588602065609104, 0.12530035682372764, 0.07713339945450914, 0.07158657841874505, 0.2058371478746972, 0.08447785776469807, 0.12709639111600213, 0.11913851585584923, 0.1440465051690717, 0.16176622597773327, 0.18562193838630447, 0.19273356550574816, 0.07450703885858345, 0.017929185502432166, 0.027001622448551865, 0.019122365966518173, 0.032512040763359784, 0.010063026072692827, 0.0019400252062272694, 0.013635969358496869, 0.01682389202249379, 0.02232041454547784, 0.1147312169606668, 0.09588897883581904, 0.09642278589954534, 0.10625518311824467, 0.10526697345852132, 0.11633106533309401, 0.09703221594956812, 0.11108083111722622, 0.10981639867337367, 0.4588600974382815, 0.4460041367956058, 0.423245713941658, 0.4428456965384783, 0.38495919881838103, 0.4153803929617952, 0.41012783182428647, 0.3935822885429212, 0.39501007229906315, 0.11048502093553692, 0.09354008578314266, 0.09559987156838035, 0.11219634546771362, 0.10337626119229881, 0.09548138881804791, 0.11239870998773549, 0.10869133307560042, 0.09859607798830583, 0.15840984528012692, 0.15050279844189496, 0.1903384394968659, 0.16939187720252324, 0.18179818871598175, 0.1708367184719911, 0.16015258664992593, 0.23206035852639184, 0.1496680270493871, 0.2747962684170152, 0.28083815577901805, 0.290108575530593, 0.3153283448214208, 0.27163719552548227, 0.2899974004373166, 0.2801763581549429, 0.28090416313214805, 0.28718864579725245, 0.19603905268697142, 0.2125055929741838, 0.22594041186438474, 0.21466864302194588, 0.23271663544325383, 0.21282862837092253, 0.17702794518660303, 0.2425602845748015, 0.2371116427673815, 0.20447542104882832, 0.19611720178553083, 0.1957917228194085, 0.19865733326549884, 0.19652870092860875, 0.19928955391698255, 0.20198334218063552, 0.20090997886843043, 0.20932992248698867, 0.19611642706246857, 0.17576994452727268, 0.18411544045772132, 0.19371406446820427, 0.1881529739724751, 0.19699468489568428, 0.1817088052040906, 0.18929381638636056, 0.2037651595716613, 0.18400630161455, 0.6121224616718262, 0.1800426085489305, 0.580163268179276, 0.17203833125508394, 0.48721896857563973, 0.5583086813045641, 0.1689747635283213, 0.5564424172346174, 0.16624695540161794, 0.4782151363517234, 0.484300170203656, 0.20427052147604352, 0.15280511171448674, 0.47201454130148235, 0.165785399012487, 0.434424631004074, 0.1122136616704642, 0.1811050530045214, 0.18632495097896484, 0.18983590616818047, 0.18530517407322145, 0.18105421991198378, 0.1897331465438341, 0.17969503212572657, 0.18070554754232093, 0.18626968507049646, 0.0864815248482822, 0.08894866035397464, 0.08590184218138475, 0.07519797618132129, 0.08075525388962923, 0.08305484613640435, 0.08211652267361247, 0.08115765359562044, 0.07648936464473277]}, "mutation_prompt": null}
{"id": "1da921df-18f2-45e7-a773-08a7905754da", "solution": "import numpy as np\n\nclass HybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.7 + 0.3 * np.cos(2 * np.pi * it / self.iterations)  # Modified crossover rate\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant += self.levy_flight()\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA_Improved", "description": "Introduce dynamic crossover rate and adaptive diversification to enhance exploration and exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.22270669211031788, "feedback": "The algorithm HybridDE_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "fc404221-42a2-4416-b1fd-ce5dc171511f", "metadata": {"aucs": [0.42386723809863747, 0.426915587456982, 0.4731626272917202, 0.4951677581324819, 0.446748107468824, 0.40821013296000863, 0.45773455534628094, 0.42773008565268367, 0.43643201524348807, 0.13426606222531268, 0.10921249405714695, 0.10211052122045661, 0.09972826943643709, 0.11519651722274993, 0.12111040327774103, 0.12681972050451984, 0.09432052577527394, 0.08754076407021838, 0.10304959273863501, 0.10749804765492244, 0.10498498800755351, 0.12557316649559636, 0.11818980235728827, 0.11499386913981524, 0.10412519368351791, 0.1081290712203965, 0.11464059895920731, 0.08964322491178356, 0.095310124014641, 0.08793392491413865, 0.08819015050360535, 0.09181030991406902, 0.0882923344015808, 0.09444492284701633, 0.11668578646452443, 0.10227601658597918, 0.8763302843967873, 0.8728533164805187, 0.9589199597197752, 0.9693222667273318, 0.8839528300225868, 0.7507181950313924, 0.7916559784164712, 0.8819308606258123, 0.9514021631329035, 0.23119258736626247, 0.2224196229568558, 0.21422335052559494, 0.2832179651638015, 0.20572930360268038, 0.20758352729231733, 0.2366974423630338, 0.255371637126554, 0.18985201856652378, 0.2786430600962736, 0.3462383399300176, 0.3693502765769763, 0.3802674685036296, 0.312261596471757, 0.3186907180264663, 0.32430413685307546, 0.3261200462117657, 0.3178310675950967, 0.20584649748099537, 0.1341152020002735, 0.14908330973822626, 0.1369065457969868, 0.16866348703338552, 0.12169723545258526, 0.15394653580498818, 0.19421589543794193, 0.17249354647474247, 0.14074600996737385, 0.11628835908483703, 0.1264981269020372, 0.15697623190367327, 0.1690446020103089, 0.14985151609956215, 0.15427633423930442, 0.14002974609731278, 0.1350098793337302, 0.07923830485520866, 0.06029736686780851, 0.013411333047199658, 0.09279162813865771, 0.06279536511840544, 0.026898059703957533, 0.11480698542097345, 0.09126535751936593, 0.06659964675773478, 0.1514781238557592, 0.09004138418989538, 0.14173629851003056, 0.10407897442311098, 0.15303344724003454, 0.1425389564067796, 0.16653157811037456, 0.19036849510065512, 0.09962979512468573, 0.004331453371861027, 0.027970879125388648, 0.002050071059323866, 0.010081926981132305, 0.0050825267751329894, 0.016682803295433035, 0.01158405580762778, 0.015332070123202368, 0.05613274390458989, 0.11182635834002308, 0.09709939634622566, 0.10170599139560854, 0.09773914426067254, 0.10365883631056516, 0.10316665427033511, 0.10239712478892615, 0.11259524761066719, 0.1158242616332642, 0.4105668445497439, 0.4292674144045363, 0.4164430578029442, 0.414237422685769, 0.37512585710722646, 0.3871669698832415, 0.396526563927019, 0.3949596974463604, 0.39307718382142387, 0.093523237825332, 0.11316552293352089, 0.10553248899761947, 0.1070658167183638, 0.10988151519260647, 0.10515031225507532, 0.10955405944462038, 0.12054363682923463, 0.0997617684095421, 0.1455764732174495, 0.1778315611937149, 0.18840623162610814, 0.17492972166287912, 0.1698214667411574, 0.15265852989762096, 0.1627856432520517, 0.20727527427216053, 0.17394904427054259, 0.2959458235929937, 0.2567368829424611, 0.2960604084238708, 0.2838012384367916, 0.29420806910967423, 0.30678008287258485, 0.27637699951488925, 0.28791954418936083, 0.25949843278445917, 0.22378683642343067, 0.21799115418927928, 0.23383951655626678, 0.193807838977056, 0.20068901656510008, 0.21646222636698054, 0.20114963383598783, 0.22910616128399452, 0.2231716547921646, 0.18730566678517802, 0.2095884471098709, 0.20391468775703325, 0.2010499025626874, 0.1932550094011296, 0.19885205689461904, 0.21493847466491456, 0.1976221706600566, 0.2001217887893083, 0.19896600251043395, 0.17682953068602658, 0.18013723205108378, 0.18351170087626312, 0.1828209772523317, 0.19628390850796318, 0.19218388542056097, 0.18595125304199223, 0.1848074733307542, 0.18173932207889387, 0.6231397421319745, 0.18092312873244576, 0.5664424860014223, 0.17233777132242833, 0.4715073535748543, 0.6086440926257709, 0.1689483882581797, 0.5284472019660253, 0.16625214228458784, 0.38885136449689006, 0.4986871939276014, 0.20331963437776357, 0.15272016983610515, 0.4457930966779723, 0.16582050908770585, 0.4536804400214284, 0.11221418695342622, 0.18259580975896283, 0.17476694164831919, 0.20514502064503692, 0.18873015646523494, 0.20777814509304693, 0.1858018881000738, 0.1794393207049192, 0.17468799566966664, 0.17458430069620678, 0.08809815056028181, 0.08251123917759284, 0.08119094255045822, 0.07820983329242048, 0.08503939456784815, 0.09085862832323133, 0.0844625377051963, 0.08630775319004369, 0.07709797111084793]}, "mutation_prompt": null}
{"id": "3e4e88eb-2f1a-4f4e-a0cf-296d7c4c9f09", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            \n            # Adaptive population size decrease\n            self.population_size = max(4, self.population_size - it // (self.iterations // 3))\n            \n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant += self.levy_flight()\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:\n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            # Implement stochastic ranking for diversity\n            if np.random.rand() < 0.1:\n                stoch_idx = np.random.choice(len(fitness), 2, replace=False)\n                if fitness[stoch_idx[0]] > fitness[stoch_idx[1]]:\n                    stoch_idx[0], stoch_idx[1] = stoch_idx[1], stoch_idx[0]\n                fitness[stoch_idx[0]], fitness[stoch_idx[1]] = fitness[stoch_idx[1]], fitness[stoch_idx[0]]\n            \n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:\n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Incorporate adaptive population sizing and stochastic ranking to improve exploration and exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.21844215392044772, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "fc404221-42a2-4416-b1fd-ce5dc171511f", "metadata": {"aucs": [0.4418960777881814, 0.45457091177953024, 0.4221072513288848, 0.45284330266285955, 0.4496215296344034, 0.44365365554896563, 0.47192192564984115, 0.4521450617299445, 0.42668314623410064, 0.07338191377068304, 0.07108714496306023, 0.09964726463478724, 0.04671283154621253, 0.06461825813548772, 0.06739668002459653, 0.09288131820373491, 0.09878077996172596, 0.09057100288444164, 0.1160014145781677, 0.11416650229267367, 0.10394905610921046, 0.10786115525638307, 0.09600304879021626, 0.1057176701265391, 0.10927149966479521, 0.10021090090414708, 0.10605788014262818, 0.10555065703906052, 0.09130564620131265, 0.0879647345463247, 0.08455983544727008, 0.11711362870219477, 0.09063513722550942, 0.10730653387406941, 0.08795791803538355, 0.11847835839263043, 0.87352442829935, 0.786266969400474, 0.9589965127909489, 0.877624789708567, 0.8700809325722421, 0.7746373977293807, 0.8828717015866233, 0.9155793011014658, 0.9302648460120013, 0.24049499140625918, 0.24202503792625274, 0.18739689402979387, 0.21065888856800075, 0.22187922976078123, 0.22088534978501206, 0.22363583017714306, 0.25724095264042157, 0.2454637617288421, 0.3769849930199912, 0.3425807963825739, 0.3426056644538431, 0.27555859644610925, 0.34413378735714806, 0.32261573197423765, 0.2612201511334431, 0.33981197617211445, 0.3279354927553063, 0.16167185769360493, 0.1902942879808428, 0.15791887736011612, 0.13472687906627723, 0.17971922337024027, 0.15927247027653735, 0.14468096941352482, 0.15822739308538147, 0.13345396647798913, 0.1969737349213112, 0.16358903700543392, 0.1368259529259792, 0.15941456774062912, 0.15118806264763585, 0.16065992616049485, 0.16534712410053432, 0.1541422069756181, 0.1591157911749509, 0.0936048416650408, 0.016167527386547365, 9.999999999998899e-05, 0.10079632526553617, 0.05598216506002662, 0.02086031776959385, 0.06351958818081016, 0.055264555714440444, 0.11189932553299564, 0.19777751413224987, 0.10234795936582008, 0.16215347957670434, 0.10182342141499212, 0.12961453997145322, 0.058862667760415044, 0.18144527740838334, 0.15996228102005572, 0.1059251579726781, 0.025795953563654273, 0.013363528736123786, 0.003685275505561525, 0.018795294226123582, 0.010858461234573236, 0.029685564768853867, 0.00487134868295469, 0.04238576209521838, 0.03563523379467226, 0.12011366638690069, 0.11775171315408439, 0.11157794866938853, 0.09973108910439421, 0.10307190500596919, 0.11969460062496351, 0.07799234421244272, 0.13025721030927084, 0.10517819990382415, 0.41023843085127065, 0.41657693742550017, 0.3848342137754973, 0.3994531716624885, 0.39959426866800674, 0.41066079888106555, 0.45273729249144046, 0.39241801893371786, 0.40854782639782417, 0.10051193411293369, 0.1202851812041088, 0.0974505728643762, 0.10412636863789648, 0.10848034828594222, 0.10477335211317618, 0.11610361615404563, 0.11815122934994338, 0.10171759672469183, 0.19080164657666865, 0.15766502433991958, 0.24476690419019653, 0.18019655325635908, 0.19295287554859908, 0.16902636291945705, 0.17981035454341998, 0.15718198679951434, 0.14731869175835943, 0.2848637923244862, 0.27998993971996256, 0.273748895136547, 0.28793310546371154, 0.2800235069665743, 0.2743729941012668, 0.2757273240562075, 0.28765312714201885, 0.28023029232004226, 0.229006055292038, 0.23020876133723367, 0.24142620319923913, 0.21482444991218397, 0.2251792949792314, 0.2286263443587343, 0.17294443518535918, 0.23097985679391553, 0.2316383428372959, 0.2006150823573788, 0.216623550083054, 0.1934932545997794, 0.1922615370067584, 0.1845245308613701, 0.19271730335894877, 0.1925618402692213, 0.19767364721787328, 0.2207042860202445, 0.18746326472184627, 0.20022245419154028, 0.19413658624640007, 0.20000883412652393, 0.18715664863146164, 0.18663608188512848, 0.18766300630974642, 0.18344198019245683, 0.20941267734317326, 0.1598984624626104, 0.6064291186824475, 0.6031819342491738, 0.5439322554218942, 0.19611357107421612, 0.544220379484249, 0.14083505520522865, 0.16892145415534, 0.19911310194698773, 0.16457552209587634, 0.20912865772294476, 0.44584478338787115, 0.2055310806394034, 0.17435712265698655, 0.1522259248466764, 0.16567619238174325, 0.4560513409927832, 0.11222360175373469, 0.17884335908815718, 0.18225395028332558, 0.18953000706808998, 0.19407773482433655, 0.18872935314986894, 0.19035897505670563, 0.17975361644382615, 0.18721500750263254, 0.18805533928739893, 0.0795981469065522, 0.09148389764416498, 0.0830771048625023, 0.08039514449440288, 0.08123877442911775, 0.08160741874185207, 0.08904027181157448, 0.09249200782928291, 0.07503972093527667]}, "mutation_prompt": null}
{"id": "26003866-72f1-4e14-b755-53d5daad8f21", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            diversity = np.std(population) / np.mean(np.abs(population))  # Diversity measure\n            adaptive_F = self.F + 0.2 * (1 - diversity)  # Adaptive factor\n\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + adaptive_F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  \n                        mutant = x1 + adaptive_F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + adaptive_F * (x2 - x3)\n                mutant += self.levy_flight()\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive differential weights and mutation strategies based on population diversity to enhance convergence and exploration.", "configspace": "", "generation": 96, "fitness": 0.2270707707152837, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "fc404221-42a2-4416-b1fd-ce5dc171511f", "metadata": {"aucs": [0.4146595910946226, 0.4506092552516707, 0.47085651990925714, 0.41311829298385816, 0.44312520652272747, 0.4456582211901675, 0.4163780614440885, 0.435754500674158, 0.43490683791435114, 0.080343902137465, 0.07902617656833422, 0.12294023628387929, 0.06846813009796937, 0.11648496717701451, 0.0926732360913547, 0.08225947811278744, 0.09986622559656444, 0.08744693860268604, 0.11187254039108308, 0.1110753678780324, 0.1067184256302981, 0.1147268028624181, 0.0956134341237741, 0.12064190591562807, 0.11640941105234637, 0.11042530175347798, 0.10731457742713413, 0.0911802284838884, 0.11361425959250304, 0.0901215093211234, 0.1006427632689687, 0.08779855180310647, 0.08929350289371818, 0.1066852312351726, 0.09626383495227164, 0.10137474738639252, 0.7141892766089024, 0.7775361032955653, 0.9473569632463678, 0.9690637066150285, 0.8909744422003744, 0.8758793200473618, 0.7685063023814781, 0.879736122098125, 0.952948809227608, 0.28166488910998555, 0.24792011212216714, 0.22941394043331198, 0.23475418701844242, 0.23059178788064705, 0.23769918405520307, 0.24702674115656664, 0.2484846499029557, 0.2755264207567656, 0.3249685172603711, 0.34488356973109346, 0.3149001601079233, 0.33945966729712873, 0.3723915822079148, 0.349689802594891, 0.30993609199297734, 0.3255909255533411, 0.3385396096718962, 0.11691227904666335, 0.1357111815606391, 0.1253450674071349, 0.15125957519013644, 0.15689815230188264, 0.13666152713308366, 0.1654141740448144, 0.18729390230307663, 0.16978486822108552, 0.20094212950913348, 0.12075191425391807, 0.1316477042195584, 0.164828228901442, 0.12464058588436933, 0.1473736205007521, 0.15262337876957077, 0.15695863141820554, 0.13437068156329202, 0.0671495587551566, 0.07605948343909863, 0.08825086325021203, 0.09781051208449532, 0.10075698398816169, 0.06960880560607419, 0.11964823925792867, 0.14526219596017342, 0.0771519515075233, 0.15943899237139103, 0.14675443336307947, 0.1361559798577091, 0.09956976626386493, 0.13943446723809172, 0.06999603708299962, 0.1390118047048884, 0.20928936875795945, 0.13547521035686327, 0.026415281833855664, 0.04166640826208201, 0.017659700020191127, 0.028241019159833347, 0.03838071719373837, 0.017818478019849704, 0.019214340922640294, 0.007946006963666541, 0.0034338087420906493, 0.10378752995363971, 0.10195743708938221, 0.10754158096937028, 0.07378231892375697, 0.09769331775157275, 0.10347559515199989, 0.10259551146359247, 0.13160679256537133, 0.11321296382579671, 0.4322234523035716, 0.40785043336600735, 0.41119471479664504, 0.4007338761051088, 0.40509890954108874, 0.40965324659067603, 0.40749823219174597, 0.3753878268075428, 0.41283735603683935, 0.0992742080618646, 0.0979553623873558, 0.10185694789692112, 0.0935202594395036, 0.10307781683906903, 0.11397644235802706, 0.10704776172857478, 0.08940489873732949, 0.1127687334068489, 0.22800761213671128, 0.1454882818712162, 0.1735991944814752, 0.16136966625447424, 0.15229761668257724, 0.21597604264622683, 0.1559600733829808, 0.1684299244240991, 0.14132625111200237, 0.28129580705679014, 0.27883632197774777, 0.2920110534772733, 0.31866856330087234, 0.2851077430753699, 0.2816779514735678, 0.28346768002748535, 0.2848147730131424, 0.2614317522529499, 0.21736249613889458, 0.21821411255574796, 0.228105025828226, 0.2164987987669369, 0.23837355397627502, 0.2527847642694837, 0.23838038202495093, 0.22725316590073874, 0.23167932320912976, 0.22619223016123136, 0.2122170098655476, 0.2387174731654763, 0.20591840393331706, 0.1895961912366907, 0.21476911942340537, 0.22397172370342433, 0.21636173571877293, 0.20560589668417784, 0.1975358921534509, 0.2063839863447664, 0.1864286819937102, 0.17991617528982207, 0.18856627775824952, 0.1790807175109721, 0.18582985538833396, 0.17654630303295615, 0.19290758326683521, 0.1857359414638916, 0.6339889418681028, 0.5416746115326541, 0.5887615271331295, 0.16592337326002848, 0.587656346535351, 0.5906841374886865, 0.17015720694278147, 0.6259489954510761, 0.7086242492792025, 0.20639018756847705, 0.2479299481698254, 0.20221036672047976, 0.19623500884255796, 0.15304691384520797, 0.16516448531598238, 0.5111099297739828, 0.16370687069908763, 0.19317018516108497, 0.2048429409755146, 0.17833800476225659, 0.1978414646621658, 0.1816679142300306, 0.1822988579557201, 0.1790294047208143, 0.16997723913559226, 0.18046671416930893, 0.09073307952329068, 0.10354615318334703, 0.08352979354036238, 0.08521166833160188, 0.0957226368054187, 0.10084407182423916, 0.08548671580417122, 0.07722024489816592, 0.07743455329893056]}, "mutation_prompt": null}
{"id": "4fc30b8b-0828-4358-8221-bf663715a188", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n        self.dynamic_rate = 0.0\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            \n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + self.F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:\n                        mutant = x1 + self.F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + self.F * (x2 - x3)\n                mutant += self.levy_flight()\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 5 == 0:  \n                improvement_rate = (np.min(fitness) - best_fitness) / np.abs(best_fitness)\n                self.dynamic_rate = max(0.1, 1.0 - np.abs(improvement_rate))\n                self.population_size = int(len(population) * self.dynamic_rate)\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce dynamic population resizing based on fitness improvement to balance exploration and exploitation.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "26003866-72f1-4e14-b755-53d5daad8f21", "metadata": {}, "mutation_prompt": null}
{"id": "ab44bb93-f9cf-4e0e-9c0c-17d33d4ca06d", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            diversity = np.std(population) / np.mean(np.abs(population))  # Diversity measure\n            adaptive_F = self.F + 0.2 * (1 - diversity)  # Adaptive factor\n\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + adaptive_F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  \n                        mutant = x1 + adaptive_F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + adaptive_F * (x2 - x3)\n                mutant += self.levy_flight()\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Introduce adaptive differential weights and mutation strategies based on population diversity to enhance convergence and exploration.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26003866-72f1-4e14-b755-53d5daad8f21", "metadata": {"aucs": [0.4146595910946226, 0.4506092552516707, 0.47085651990925714, 0.41311829298385816, 0.44312520652272747, 0.4456582211901675, 0.4163780614440885, 0.435754500674158, 0.43490683791435114, 0.080343902137465, 0.07902617656833422, 0.12294023628387929, 0.06846813009796937, 0.11648496717701451, 0.0926732360913547, 0.08225947811278744, 0.09986622559656444, 0.08744693860268604, 0.11187254039108308, 0.1110753678780324, 0.1067184256302981, 0.1147268028624181, 0.0956134341237741, 0.12064190591562807, 0.11640941105234637, 0.11042530175347798, 0.10731457742713413, 0.0911802284838884, 0.11361425959250304, 0.0901215093211234, 0.1006427632689687, 0.08779855180310647, 0.08929350289371818, 0.1066852312351726, 0.09626383495227164, 0.10137474738639252, 0.7141892766089024, 0.7775361032955653, 0.9473569632463678, 0.9690637066150285, 0.8909744422003744, 0.8758793200473618, 0.7685063023814781, 0.879736122098125, 0.952948809227608, 0.28166488910998555, 0.24792011212216714, 0.22941394043331198, 0.23475418701844242, 0.23059178788064705, 0.23769918405520307, 0.24702674115656664, 0.2484846499029557, 0.2755264207567656, 0.3249685172603711, 0.34488356973109346, 0.3149001601079233, 0.33945966729712873, 0.3723915822079148, 0.349689802594891, 0.30993609199297734, 0.3255909255533411, 0.3385396096718962, 0.11691227904666335, 0.1357111815606391, 0.1253450674071349, 0.15125957519013644, 0.15689815230188264, 0.13666152713308366, 0.1654141740448144, 0.18729390230307663, 0.16978486822108552, 0.20094212950913348, 0.12075191425391807, 0.1316477042195584, 0.164828228901442, 0.12464058588436933, 0.1473736205007521, 0.15262337876957077, 0.15695863141820554, 0.13437068156329202, 0.0671495587551566, 0.07605948343909863, 0.08825086325021203, 0.09781051208449532, 0.10075698398816169, 0.06960880560607419, 0.11964823925792867, 0.14526219596017342, 0.0771519515075233, 0.15943899237139103, 0.14675443336307947, 0.1361559798577091, 0.09956976626386493, 0.13943446723809172, 0.06999603708299962, 0.1390118047048884, 0.20928936875795945, 0.13547521035686327, 0.026415281833855664, 0.04166640826208201, 0.017659700020191127, 0.028241019159833347, 0.03838071719373837, 0.017818478019849704, 0.019214340922640294, 0.007946006963666541, 0.0034338087420906493, 0.10378752995363971, 0.10195743708938221, 0.10754158096937028, 0.07378231892375697, 0.09769331775157275, 0.10347559515199989, 0.10259551146359247, 0.13160679256537133, 0.11321296382579671, 0.4322234523035716, 0.40785043336600735, 0.41119471479664504, 0.4007338761051088, 0.40509890954108874, 0.40965324659067603, 0.40749823219174597, 0.3753878268075428, 0.41283735603683935, 0.0992742080618646, 0.0979553623873558, 0.10185694789692112, 0.0935202594395036, 0.10307781683906903, 0.11397644235802706, 0.10704776172857478, 0.08940489873732949, 0.1127687334068489, 0.22800761213671128, 0.1454882818712162, 0.1735991944814752, 0.16136966625447424, 0.15229761668257724, 0.21597604264622683, 0.1559600733829808, 0.1684299244240991, 0.14132625111200237, 0.28129580705679014, 0.27883632197774777, 0.2920110534772733, 0.31866856330087234, 0.2851077430753699, 0.2816779514735678, 0.28346768002748535, 0.2848147730131424, 0.2614317522529499, 0.21736249613889458, 0.21821411255574796, 0.228105025828226, 0.2164987987669369, 0.23837355397627502, 0.2527847642694837, 0.23838038202495093, 0.22725316590073874, 0.23167932320912976, 0.22619223016123136, 0.2122170098655476, 0.2387174731654763, 0.20591840393331706, 0.1895961912366907, 0.21476911942340537, 0.22397172370342433, 0.21636173571877293, 0.20560589668417784, 0.1975358921534509, 0.2063839863447664, 0.1864286819937102, 0.17991617528982207, 0.18856627775824952, 0.1790807175109721, 0.18582985538833396, 0.17654630303295615, 0.19290758326683521, 0.1857359414638916, 0.6339889418681028, 0.5416746115326541, 0.5887615271331295, 0.16592337326002848, 0.587656346535351, 0.5906841374886865, 0.17015720694278147, 0.6259489954510761, 0.7086242492792025, 0.20639018756847705, 0.2479299481698254, 0.20221036672047976, 0.19623500884255796, 0.15304691384520797, 0.16516448531598238, 0.5111099297739828, 0.16370687069908763, 0.19317018516108497, 0.2048429409755146, 0.17833800476225659, 0.1978414646621658, 0.1816679142300306, 0.1822988579557201, 0.1790294047208143, 0.16997723913559226, 0.18046671416930893, 0.09073307952329068, 0.10354615318334703, 0.08352979354036238, 0.08521166833160188, 0.0957226368054187, 0.10084407182423916, 0.08548671580417122, 0.07722024489816592, 0.07743455329893056]}, "mutation_prompt": null}
{"id": "77266bc1-3391-4083-b8b8-a74b4fcb86ad", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.T0 = 1000\n        self.alpha = 0.99\n        self.iterations = int(budget / self.population_size)\n        self.elite_solutions = []\n        self.diversity_rate = 0.1\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * 0.01\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1/L))\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, \n                                       (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        T = self.T0\n        chaos_var = 0.7\n\n        evals = self.population_size\n\n        for it in range(self.iterations):\n            chaos_var = self.logistic_map(chaos_var)\n            self.F = 0.4 + 0.5 * np.sin(np.pi * (1 - self.F) * it / self.iterations) * chaos_var\n            self.CR = 0.8 + 0.2 * np.cos(2 * np.pi * it / self.iterations)\n            diversity = np.std(population) / np.mean(np.abs(population))\n            adaptive_F = self.F + 0.2 * (1 - diversity)\n            fitness_var = np.var(fitness)  # Newly added line\n            adaptive_F += 0.1 * np.tanh(fitness_var)  # Newly added line\n\n            for i in range(self.population_size):\n                if self.elite_solutions and np.random.rand() < 0.3:\n                    elite = self.elite_solutions[np.random.randint(len(self.elite_solutions))]\n                    x1, x2 = np.random.choice(self.population_size, 2, replace=False)\n                    mutant = elite + adaptive_F * (population[x1] - population[x2])\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    if best_idx in indices:\n                        indices = np.random.choice(self.population_size, 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    if np.random.rand() < 0.5:  \n                        mutant = x1 + adaptive_F * (x2 - x3) + 0.1 * (best_solution - x1)\n                    else:\n                        mutant = x1 + adaptive_F * (x2 - x3)\n                mutant += self.levy_flight()\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                        self.elite_solutions.append(trial)\n\n            if it % 20 == 0 and best_fitness in fitness:  \n                self.diversity_rate += 0.05\n            else:\n                self.diversity_rate = 0.1\n\n            for i in range(self.population_size):\n                noise_scale = 0.02 if np.random.rand() < 0.1 else 0.05\n                perturbed = population[i] + np.random.normal(0, noise_scale, self.dim)\n                perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n                perturbed_fitness = func(perturbed)\n                evals += 1\n                \n                if perturbed_fitness < fitness[i] or \\\n                   np.random.rand() < np.exp((fitness[i] - perturbed_fitness) / (0.5 * T)):  \n                    population[i] = perturbed\n                    fitness[i] = perturbed_fitness\n                    if perturbed_fitness < best_fitness:\n                        best_solution = perturbed\n                        best_fitness = perturbed_fitness\n                        self.elite_solutions.append(perturbed)\n\n            if it % 10 == 0:  \n                n_reinit = int(self.population_size * (self.diversity_rate + 0.05 * np.sin(2 * np.pi * it / self.iterations)))\n                reinit_indices = np.random.choice(self.population_size, n_reinit, replace=False)\n                population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (n_reinit, self.dim))\n                fitness[reinit_indices] = np.apply_along_axis(func, 1, population[reinit_indices])\n                evals += n_reinit\n\n            T *= self.alpha  \n\n            if evals >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDE_SA", "description": "Incorporating adaptive mutation scale based on fitness variance and dynamically adjusting mutation strategies for enhanced exploration-exploitation trade-off.", "configspace": "", "generation": 99, "fitness": 0.21519976250181255, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "26003866-72f1-4e14-b755-53d5daad8f21", "metadata": {"aucs": [0.45910921844714403, 0.4233227565083809, 0.44734520599783, 0.43069932788609055, 0.404578445268724, 0.4260462801043161, 0.42279201482313533, 0.4604188910372564, 0.40069748273121675, 0.08516560402550277, 0.08296416787339278, 0.09197684416484808, 0.11103451393015984, 0.09996958085839436, 0.09242666544855149, 0.08956551776115707, 0.10510869946440049, 0.06292971193943031, 0.11026289512300558, 0.09978459151864971, 0.09022734128548549, 0.08572126921755863, 0.09427545064560361, 0.11446224531839522, 0.11257488462247622, 0.11972136560485147, 0.10258087566780882, 0.10103396256739905, 0.09204117324175154, 0.08416117613857965, 0.09137729415726992, 0.09216205344809592, 0.0877839536005185, 0.08517153831592672, 0.09623013496093169, 0.0976943992496574, 0.7908971900488313, 0.8692762569476419, 0.9588559690437999, 0.9704420716805612, 0.9418231120363132, 0.7611914155841486, 0.7705715140731676, 0.8798648310250361, 0.8737241833190539, 0.20705182907450737, 0.1670435865291302, 0.23234024412800414, 0.2259338108860034, 0.2504183194636376, 0.19456394206907357, 0.2236492097872269, 0.22342163519873592, 0.21354125886156494, 0.3741592436588288, 0.32339279382528674, 0.31738273662547245, 0.34535210736142063, 0.31275072711506036, 0.3344506477169865, 0.2979165100790413, 0.31940733454299375, 0.3419977837649386, 0.1308619034968992, 0.17168545714756256, 0.15316143876877464, 0.1194003167676565, 0.14572041731820773, 0.11880569415347764, 0.1337696180907909, 0.15286160677983973, 0.14682674834340326, 0.16442353340607974, 0.16852105612526957, 0.14047322405431784, 0.1787059978286223, 0.13257892542550997, 0.17961300769520383, 0.1320437063436335, 0.15301152456075817, 0.13121882613354396, 0.06537651739635197, 0.09443276431153957, 0.0720441440045353, 0.077303743061089, 0.07017847054176019, 0.05187292246016928, 0.08994466711234217, 0.06335967804275533, 0.056331926433061064, 0.1596829131159797, 0.1549312412776701, 0.18315794400429708, 0.11748321312636978, 0.1335909760329792, 0.09742760577105214, 0.1712594594513246, 0.14736525618434748, 0.12326083525671383, 0.005784879784190289, 0.023441461475637526, 0.012179485282171276, 0.030140044719445314, 0.0018978550620486478, 0.03165099322543008, 0.0037275854941848374, 0.058251641678046195, 0.003885243520805659, 0.08586170896017065, 0.1064849362766559, 0.09017749664479302, 0.09154590183341293, 0.11656618875414371, 0.10102941963090484, 0.11906229664877988, 0.09125375175823791, 0.09517685581260427, 0.38952741948117864, 0.40563775048510065, 0.4269757250795112, 0.41130144381854783, 0.4007368370610763, 0.40844475890517085, 0.41106716261396514, 0.3972248080741301, 0.39271650132189817, 0.08769019610948015, 0.09624888437273127, 0.09544138491823684, 0.10927945890527513, 0.09249186890369276, 0.10113827533281561, 0.09765702045122548, 0.09096462180637299, 0.09231111906660594, 0.16024228707042598, 0.15592054604335992, 0.1585257723361232, 0.14769069497623022, 0.1633027293794972, 0.14405572697984503, 0.18283535147506413, 0.15220623059581773, 0.17649751711111317, 0.2749313877325411, 0.26309528498584445, 0.28142062593580985, 0.2801094167652308, 0.2545150149287222, 0.29203914922606167, 0.27641626493973803, 0.26711151935568056, 0.2671500119052109, 0.23459205115887194, 0.2107337660224633, 0.2061826066014546, 0.22767065361209549, 0.21438558107528594, 0.2031952064185084, 0.2144455623223176, 0.21307305848585334, 0.19532338660372084, 0.26356461288333743, 0.20982117988608406, 0.19662571336933765, 0.2200092535168091, 0.19928255041646703, 0.1811962273535097, 0.20258097768892724, 0.20886470551310188, 0.2142699447123022, 0.18578458532056452, 0.20003682836296155, 0.19512907867655527, 0.17770668155188718, 0.21140252883134802, 0.18886368782671092, 0.19780805059352236, 0.18058535461218084, 0.18995587701586658, 0.17906076002396243, 0.2071987541907664, 0.16381959268537993, 0.6233950430784139, 0.16992042601794255, 0.5699787389727786, 0.25202407346909095, 0.16750089873495022, 0.19830780855675334, 0.5574920068941713, 0.42214829881392657, 0.40190799740605265, 0.2069245462835927, 0.19852892116584253, 0.1615716595346457, 0.20513755329751115, 0.49037123155591544, 0.11237993185404282, 0.18897665407794517, 0.17042572584508253, 0.1778514991542659, 0.1890575931172802, 0.1923398663364888, 0.19094655107265768, 0.18883293006908275, 0.18163260990554686, 0.19721693457653833, 0.08535494603095539, 0.08089727120607693, 0.08202074158482808, 0.07599442064652828, 0.08813673089564455, 0.07841287061469271, 0.08762392595678759, 0.08413632783780156, 0.08196955606027745]}, "mutation_prompt": null}
