{"id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "solution": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def __call__(self, func):\n        # Initialize particles\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        pbest_positions = positions.copy()\n        pbest_scores = np.array([func(pos) for pos in pbest_positions])\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            # Adaptive inertia weight\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            # Update velocities\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Update positions\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n\n            # Update personal bests\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "AMPSO", "description": "Adaptive Memory Particle Swarm Optimization (AMPSO) enhances standard PSO by incorporating an adaptive memory mechanism to balance exploration and exploitation dynamically.", "configspace": "", "generation": 0, "fitness": 0.3196362488828236, "feedback": "The algorithm AMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8552678235180731, 0.8489724686297144, 0.8703410679520212, 0.8438327041169379, 0.8366743759474825, 0.8462021328844391, 0.839748185857819, 0.8324245982768375, 0.8455332548655596, 0.6449663660090176, 0.6498821042487153, 0.656956273081859, 0.6375070762021064, 0.6288948968313828, 0.6257790495398654, 0.6344754705142513, 0.6118478140489265, 0.5993902342347512, 0.12049601759348139, 0.1402660069299192, 0.10417505848472175, 0.08229265882145831, 0.1521626768757416, 0.11437870260478067, 0.09088292451073643, 0.15665409759918925, 0.09326055130162092, 0.08181595152424415, 0.1401933775373787, 0.15983576744531425, 0.1548714118419453, 0.10769904549748299, 0.08312608586239512, 0.13166696249819565, 0.14240393344962743, 0.11156597799828383, 0.9096921930444976, 0.8718679350713276, 0.8915565412945516, 0.9069941079608509, 0.8760048147889752, 0.8847714825413129, 0.8994993632892804, 0.861896685931153, 0.8758937900863575, 0.6750648233332082, 0.6942643486514626, 0.5375536826052573, 0.6791246355777045, 0.6694224314461414, 0.6884432726159492, 0.6812518717387552, 0.6162512033590604, 0.6725453275066724, 0.7319658205483247, 0.8843849399762543, 0.22432761497595355, 0.22109674223314102, 0.21133337547461994, 0.27415015025134526, 0.12890133117658187, 0.15046300380823963, 0.24366563161740873, 0.21324939995151915, 0.16671716612375698, 0.17641173601518745, 0.20898562594236292, 0.19685997907371622, 0.23411319434355038, 0.40953873449078626, 0.20622103118824853, 0.21058339367027312, 0.24529459907264772, 0.22788387514466313, 0.1199443670910808, 0.22643818444825614, 0.2518055691558996, 0.13365026521771983, 0.2428614711955147, 0.24496659855957992, 0.20290086690715026, 0.06726412198011911, 0.09319290450527717, 0.05774390869705892, 0.05717224700728618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008202714535873401, 0.16787716555464594, 0.08603322417342674, 0.11488102143835877, 0.10331640287292498, 0.07227567988447159, 0.038668327792763746, 0.11078915189072391, 0.08635421785718533, 0.13379372827080793, 0.14942379551083285, 0.10420394799417732, 0.18757731393590416, 0.09647439546026271, 0.08636537915213682, 0.1860832843007436, 0.09577914073939775, 0.31103338325999297, 0.10281564844650148, 0.264884202690156, 0.05034463287566615, 0.258052070637243, 0.04265079517396175, 0.255778059670014, 0.09401367592368681, 0.12866253735340683, 0.09348700952611799, 0.0824908309065151, 0.5136069445142262, 0.5309357948794611, 0.5482965884688166, 0.5451617051972434, 0.502914082996029, 0.5104422618688986, 0.5531084150871308, 0.592973262673606, 0.5330795008962106, 0.05827446350062471, 0.07822107089248997, 0.08700962728716788, 0.09564257670855536, 0.07565620524203132, 0.14391365059703332, 0.11608176270916881, 0.09241059762763348, 0.09666833054675739, 0.4152773131161168, 0.3123906168378391, 0.1831400956044461, 0.25924029467245535, 0.38709272405736284, 0.3215517841546517, 0.3487413803481153, 0.26113264780740975, 0.19168974953292128, 0.26819677982877477, 0.28307553071745084, 0.5393395288309832, 0.3068923878529336, 0.3041806107271072, 0.3973412809069784, 0.2835834663852411, 0.5876442023508187, 0.26796328232747324, 0.32328329717815685, 0.16093711594681648, 0.19488894076814667, 0.19016796478211417, 0.28184115733151494, 0.31601408095647643, 0.21275125251070515, 0.31762756581003837, 0.1986328610850031, 0.22127475486074233, 0.23621504350349287, 0.26387932282259663, 0.24049891941007673, 0.23578096700846563, 0.41819341075752636, 0.26364333503371373, 0.21086490476157738, 0.2524638458657339, 0.19261569783314136, 0.19123546101635858, 0.20181622733247584, 0.17434277648563634, 0.20824271461300747, 0.22324182281759597, 0.18209148630970273, 0.20769841490697194, 0.2084923604382386, 0.12604253817612265, 0.1757147791188196, 0.1641876889046513, 0.9261060824687294, 0.19949804460375986, 0.906952836151262, 0.1424959401731969, 0.16204792413937064, 0.9056635985605457, 0.6555821147993426, 0.15631283599307078, 0.6142305449823062, 0.6820367593339738, 0.09399085753117797, 0.15416006729254927, 0.7399225283847684, 0.7029500683105028, 0.7432910426651428, 0.1975264832124145, 0.21118427722904531, 0.1843941276108323, 0.22228214031609883, 0.20186621130644167, 0.18644918787864628, 0.24285065044422816, 0.21884420755882306, 0.18715962214820347, 0.09377511467713318, 0.08424772361972577, 0.08006619100150003, 0.0957601638102602, 0.08296455408853176, 0.10989221607215638, 0.11933984419711219, 0.11087394096628866, 0.09381942741476101]}, "mutation_prompt": null}
{"id": "6a033134-1449-4b75-9798-583fbfc7ec95", "solution": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def __call__(self, func):\n        # Initialize particles\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        pbest_positions = positions.copy()\n        pbest_scores = np.array([func(pos) for pos in pbest_positions])\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            # Adaptive inertia weight\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            # Update velocities\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Update positions\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n\n            # Update personal bests\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "AMPSO", "description": "Adaptive Memory Particle Swarm Optimization (AMPSO) enhances standard PSO by incorporating an adaptive memory mechanism to balance exploration and exploitation dynamically.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "metadata": {"aucs": [0.8552678235180731, 0.8489724686297144, 0.8703410679520212, 0.8438327041169379, 0.8366743759474825, 0.8462021328844391, 0.839748185857819, 0.8324245982768375, 0.8455332548655596, 0.6449663660090176, 0.6498821042487153, 0.656956273081859, 0.6375070762021064, 0.6288948968313828, 0.6257790495398654, 0.6344754705142513, 0.6118478140489265, 0.5993902342347512, 0.12049601759348139, 0.1402660069299192, 0.10417505848472175, 0.08229265882145831, 0.1521626768757416, 0.11437870260478067, 0.09088292451073643, 0.15665409759918925, 0.09326055130162092, 0.08181595152424415, 0.1401933775373787, 0.15983576744531425, 0.1548714118419453, 0.10769904549748299, 0.08312608586239512, 0.13166696249819565, 0.14240393344962743, 0.11156597799828383, 0.9096921930444976, 0.8718679350713276, 0.8915565412945516, 0.9069941079608509, 0.8760048147889752, 0.8847714825413129, 0.8994993632892804, 0.861896685931153, 0.8758937900863575, 0.6750648233332082, 0.6942643486514626, 0.5375536826052573, 0.6791246355777045, 0.6694224314461414, 0.6884432726159492, 0.6812518717387552, 0.6162512033590604, 0.6725453275066724, 0.7319658205483247, 0.8843849399762543, 0.22432761497595355, 0.22109674223314102, 0.21133337547461994, 0.27415015025134526, 0.12890133117658187, 0.15046300380823963, 0.24366563161740873, 0.21324939995151915, 0.16671716612375698, 0.17641173601518745, 0.20898562594236292, 0.19685997907371622, 0.23411319434355038, 0.40953873449078626, 0.20622103118824853, 0.21058339367027312, 0.24529459907264772, 0.22788387514466313, 0.1199443670910808, 0.22643818444825614, 0.2518055691558996, 0.13365026521771983, 0.2428614711955147, 0.24496659855957992, 0.20290086690715026, 0.06726412198011911, 0.09319290450527717, 0.05774390869705892, 0.05717224700728618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008202714535873401, 0.16787716555464594, 0.08603322417342674, 0.11488102143835877, 0.10331640287292498, 0.07227567988447159, 0.038668327792763746, 0.11078915189072391, 0.08635421785718533, 0.13379372827080793, 0.14942379551083285, 0.10420394799417732, 0.18757731393590416, 0.09647439546026271, 0.08636537915213682, 0.1860832843007436, 0.09577914073939775, 0.31103338325999297, 0.10281564844650148, 0.264884202690156, 0.05034463287566615, 0.258052070637243, 0.04265079517396175, 0.255778059670014, 0.09401367592368681, 0.12866253735340683, 0.09348700952611799, 0.0824908309065151, 0.5136069445142262, 0.5309357948794611, 0.5482965884688166, 0.5451617051972434, 0.502914082996029, 0.5104422618688986, 0.5531084150871308, 0.592973262673606, 0.5330795008962106, 0.05827446350062471, 0.07822107089248997, 0.08700962728716788, 0.09564257670855536, 0.07565620524203132, 0.14391365059703332, 0.11608176270916881, 0.09241059762763348, 0.09666833054675739, 0.4152773131161168, 0.3123906168378391, 0.1831400956044461, 0.25924029467245535, 0.38709272405736284, 0.3215517841546517, 0.3487413803481153, 0.26113264780740975, 0.19168974953292128, 0.26819677982877477, 0.28307553071745084, 0.5393395288309832, 0.3068923878529336, 0.3041806107271072, 0.3973412809069784, 0.2835834663852411, 0.5876442023508187, 0.26796328232747324, 0.32328329717815685, 0.16093711594681648, 0.19488894076814667, 0.19016796478211417, 0.28184115733151494, 0.31601408095647643, 0.21275125251070515, 0.31762756581003837, 0.1986328610850031, 0.22127475486074233, 0.23621504350349287, 0.26387932282259663, 0.24049891941007673, 0.23578096700846563, 0.41819341075752636, 0.26364333503371373, 0.21086490476157738, 0.2524638458657339, 0.19261569783314136, 0.19123546101635858, 0.20181622733247584, 0.17434277648563634, 0.20824271461300747, 0.22324182281759597, 0.18209148630970273, 0.20769841490697194, 0.2084923604382386, 0.12604253817612265, 0.1757147791188196, 0.1641876889046513, 0.9261060824687294, 0.19949804460375986, 0.906952836151262, 0.1424959401731969, 0.16204792413937064, 0.9056635985605457, 0.6555821147993426, 0.15631283599307078, 0.6142305449823062, 0.6820367593339738, 0.09399085753117797, 0.15416006729254927, 0.7399225283847684, 0.7029500683105028, 0.7432910426651428, 0.1975264832124145, 0.21118427722904531, 0.1843941276108323, 0.22228214031609883, 0.20186621130644167, 0.18644918787864628, 0.24285065044422816, 0.21884420755882306, 0.18715962214820347, 0.09377511467713318, 0.08424772361972577, 0.08006619100150003, 0.0957601638102602, 0.08296455408853176, 0.10989221607215638, 0.11933984419711219, 0.11087394096628866, 0.09381942741476101]}, "mutation_prompt": null}
{"id": "400075ed-df42-424e-98bc-20000efe3e8a", "solution": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def __call__(self, func):\n        # Initialize particles\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        pbest_positions = positions.copy()\n        pbest_scores = np.array([func(pos) for pos in pbest_positions])\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            # Adaptive inertia weight\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            # Update velocities\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Update positions\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n\n            # Update personal bests\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "AMPSO", "description": "Adaptive Memory Particle Swarm Optimization (AMPSO) enhances standard PSO by incorporating an adaptive memory mechanism to balance exploration and exploitation dynamically.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "metadata": {"aucs": [0.8552678235180731, 0.8489724686297144, 0.8703410679520212, 0.8438327041169379, 0.8366743759474825, 0.8462021328844391, 0.839748185857819, 0.8324245982768375, 0.8455332548655596, 0.6449663660090176, 0.6498821042487153, 0.656956273081859, 0.6375070762021064, 0.6288948968313828, 0.6257790495398654, 0.6344754705142513, 0.6118478140489265, 0.5993902342347512, 0.12049601759348139, 0.1402660069299192, 0.10417505848472175, 0.08229265882145831, 0.1521626768757416, 0.11437870260478067, 0.09088292451073643, 0.15665409759918925, 0.09326055130162092, 0.08181595152424415, 0.1401933775373787, 0.15983576744531425, 0.1548714118419453, 0.10769904549748299, 0.08312608586239512, 0.13166696249819565, 0.14240393344962743, 0.11156597799828383, 0.9096921930444976, 0.8718679350713276, 0.8915565412945516, 0.9069941079608509, 0.8760048147889752, 0.8847714825413129, 0.8994993632892804, 0.861896685931153, 0.8758937900863575, 0.6750648233332082, 0.6942643486514626, 0.5375536826052573, 0.6791246355777045, 0.6694224314461414, 0.6884432726159492, 0.6812518717387552, 0.6162512033590604, 0.6725453275066724, 0.7319658205483247, 0.8843849399762543, 0.22432761497595355, 0.22109674223314102, 0.21133337547461994, 0.27415015025134526, 0.12890133117658187, 0.15046300380823963, 0.24366563161740873, 0.21324939995151915, 0.16671716612375698, 0.17641173601518745, 0.20898562594236292, 0.19685997907371622, 0.23411319434355038, 0.40953873449078626, 0.20622103118824853, 0.21058339367027312, 0.24529459907264772, 0.22788387514466313, 0.1199443670910808, 0.22643818444825614, 0.2518055691558996, 0.13365026521771983, 0.2428614711955147, 0.24496659855957992, 0.20290086690715026, 0.06726412198011911, 0.09319290450527717, 0.05774390869705892, 0.05717224700728618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008202714535873401, 0.16787716555464594, 0.08603322417342674, 0.11488102143835877, 0.10331640287292498, 0.07227567988447159, 0.038668327792763746, 0.11078915189072391, 0.08635421785718533, 0.13379372827080793, 0.14942379551083285, 0.10420394799417732, 0.18757731393590416, 0.09647439546026271, 0.08636537915213682, 0.1860832843007436, 0.09577914073939775, 0.31103338325999297, 0.10281564844650148, 0.264884202690156, 0.05034463287566615, 0.258052070637243, 0.04265079517396175, 0.255778059670014, 0.09401367592368681, 0.12866253735340683, 0.09348700952611799, 0.0824908309065151, 0.5136069445142262, 0.5309357948794611, 0.5482965884688166, 0.5451617051972434, 0.502914082996029, 0.5104422618688986, 0.5531084150871308, 0.592973262673606, 0.5330795008962106, 0.05827446350062471, 0.07822107089248997, 0.08700962728716788, 0.09564257670855536, 0.07565620524203132, 0.14391365059703332, 0.11608176270916881, 0.09241059762763348, 0.09666833054675739, 0.4152773131161168, 0.3123906168378391, 0.1831400956044461, 0.25924029467245535, 0.38709272405736284, 0.3215517841546517, 0.3487413803481153, 0.26113264780740975, 0.19168974953292128, 0.26819677982877477, 0.28307553071745084, 0.5393395288309832, 0.3068923878529336, 0.3041806107271072, 0.3973412809069784, 0.2835834663852411, 0.5876442023508187, 0.26796328232747324, 0.32328329717815685, 0.16093711594681648, 0.19488894076814667, 0.19016796478211417, 0.28184115733151494, 0.31601408095647643, 0.21275125251070515, 0.31762756581003837, 0.1986328610850031, 0.22127475486074233, 0.23621504350349287, 0.26387932282259663, 0.24049891941007673, 0.23578096700846563, 0.41819341075752636, 0.26364333503371373, 0.21086490476157738, 0.2524638458657339, 0.19261569783314136, 0.19123546101635858, 0.20181622733247584, 0.17434277648563634, 0.20824271461300747, 0.22324182281759597, 0.18209148630970273, 0.20769841490697194, 0.2084923604382386, 0.12604253817612265, 0.1757147791188196, 0.1641876889046513, 0.9261060824687294, 0.19949804460375986, 0.906952836151262, 0.1424959401731969, 0.16204792413937064, 0.9056635985605457, 0.6555821147993426, 0.15631283599307078, 0.6142305449823062, 0.6820367593339738, 0.09399085753117797, 0.15416006729254927, 0.7399225283847684, 0.7029500683105028, 0.7432910426651428, 0.1975264832124145, 0.21118427722904531, 0.1843941276108323, 0.22228214031609883, 0.20186621130644167, 0.18644918787864628, 0.24285065044422816, 0.21884420755882306, 0.18715962214820347, 0.09377511467713318, 0.08424772361972577, 0.08006619100150003, 0.0957601638102602, 0.08296455408853176, 0.10989221607215638, 0.11933984419711219, 0.11087394096628866, 0.09381942741476101]}, "mutation_prompt": null}
{"id": "8407d086-ba38-41ee-a017-30a1658f4b3a", "solution": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def __call__(self, func):\n        # Initialize particles\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        pbest_positions = positions.copy()\n        pbest_scores = np.array([func(pos) for pos in pbest_positions])\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            # Adaptive inertia weight\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            # Update velocities\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Update positions\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n\n            # Update personal bests\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "AMPSO", "description": "Adaptive Memory Particle Swarm Optimization (AMPSO) enhances standard PSO by incorporating an adaptive memory mechanism to balance exploration and exploitation dynamically.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "metadata": {"aucs": [0.8552678235180731, 0.8489724686297144, 0.8703410679520212, 0.8438327041169379, 0.8366743759474825, 0.8462021328844391, 0.839748185857819, 0.8324245982768375, 0.8455332548655596, 0.6449663660090176, 0.6498821042487153, 0.656956273081859, 0.6375070762021064, 0.6288948968313828, 0.6257790495398654, 0.6344754705142513, 0.6118478140489265, 0.5993902342347512, 0.12049601759348139, 0.1402660069299192, 0.10417505848472175, 0.08229265882145831, 0.1521626768757416, 0.11437870260478067, 0.09088292451073643, 0.15665409759918925, 0.09326055130162092, 0.08181595152424415, 0.1401933775373787, 0.15983576744531425, 0.1548714118419453, 0.10769904549748299, 0.08312608586239512, 0.13166696249819565, 0.14240393344962743, 0.11156597799828383, 0.9096921930444976, 0.8718679350713276, 0.8915565412945516, 0.9069941079608509, 0.8760048147889752, 0.8847714825413129, 0.8994993632892804, 0.861896685931153, 0.8758937900863575, 0.6750648233332082, 0.6942643486514626, 0.5375536826052573, 0.6791246355777045, 0.6694224314461414, 0.6884432726159492, 0.6812518717387552, 0.6162512033590604, 0.6725453275066724, 0.7319658205483247, 0.8843849399762543, 0.22432761497595355, 0.22109674223314102, 0.21133337547461994, 0.27415015025134526, 0.12890133117658187, 0.15046300380823963, 0.24366563161740873, 0.21324939995151915, 0.16671716612375698, 0.17641173601518745, 0.20898562594236292, 0.19685997907371622, 0.23411319434355038, 0.40953873449078626, 0.20622103118824853, 0.21058339367027312, 0.24529459907264772, 0.22788387514466313, 0.1199443670910808, 0.22643818444825614, 0.2518055691558996, 0.13365026521771983, 0.2428614711955147, 0.24496659855957992, 0.20290086690715026, 0.06726412198011911, 0.09319290450527717, 0.05774390869705892, 0.05717224700728618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008202714535873401, 0.16787716555464594, 0.08603322417342674, 0.11488102143835877, 0.10331640287292498, 0.07227567988447159, 0.038668327792763746, 0.11078915189072391, 0.08635421785718533, 0.13379372827080793, 0.14942379551083285, 0.10420394799417732, 0.18757731393590416, 0.09647439546026271, 0.08636537915213682, 0.1860832843007436, 0.09577914073939775, 0.31103338325999297, 0.10281564844650148, 0.264884202690156, 0.05034463287566615, 0.258052070637243, 0.04265079517396175, 0.255778059670014, 0.09401367592368681, 0.12866253735340683, 0.09348700952611799, 0.0824908309065151, 0.5136069445142262, 0.5309357948794611, 0.5482965884688166, 0.5451617051972434, 0.502914082996029, 0.5104422618688986, 0.5531084150871308, 0.592973262673606, 0.5330795008962106, 0.05827446350062471, 0.07822107089248997, 0.08700962728716788, 0.09564257670855536, 0.07565620524203132, 0.14391365059703332, 0.11608176270916881, 0.09241059762763348, 0.09666833054675739, 0.4152773131161168, 0.3123906168378391, 0.1831400956044461, 0.25924029467245535, 0.38709272405736284, 0.3215517841546517, 0.3487413803481153, 0.26113264780740975, 0.19168974953292128, 0.26819677982877477, 0.28307553071745084, 0.5393395288309832, 0.3068923878529336, 0.3041806107271072, 0.3973412809069784, 0.2835834663852411, 0.5876442023508187, 0.26796328232747324, 0.32328329717815685, 0.16093711594681648, 0.19488894076814667, 0.19016796478211417, 0.28184115733151494, 0.31601408095647643, 0.21275125251070515, 0.31762756581003837, 0.1986328610850031, 0.22127475486074233, 0.23621504350349287, 0.26387932282259663, 0.24049891941007673, 0.23578096700846563, 0.41819341075752636, 0.26364333503371373, 0.21086490476157738, 0.2524638458657339, 0.19261569783314136, 0.19123546101635858, 0.20181622733247584, 0.17434277648563634, 0.20824271461300747, 0.22324182281759597, 0.18209148630970273, 0.20769841490697194, 0.2084923604382386, 0.12604253817612265, 0.1757147791188196, 0.1641876889046513, 0.9261060824687294, 0.19949804460375986, 0.906952836151262, 0.1424959401731969, 0.16204792413937064, 0.9056635985605457, 0.6555821147993426, 0.15631283599307078, 0.6142305449823062, 0.6820367593339738, 0.09399085753117797, 0.15416006729254927, 0.7399225283847684, 0.7029500683105028, 0.7432910426651428, 0.1975264832124145, 0.21118427722904531, 0.1843941276108323, 0.22228214031609883, 0.20186621130644167, 0.18644918787864628, 0.24285065044422816, 0.21884420755882306, 0.18715962214820347, 0.09377511467713318, 0.08424772361972577, 0.08006619100150003, 0.0957601638102602, 0.08296455408853176, 0.10989221607215638, 0.11933984419711219, 0.11087394096628866, 0.09381942741476101]}, "mutation_prompt": null}
{"id": "dc3df22b-a968-4e5d-a2f4-d01e0c70be0d", "solution": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def __call__(self, func):\n        # Initialize particles\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        pbest_positions = positions.copy()\n        pbest_scores = np.array([func(pos) for pos in pbest_positions])\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            # Nonlinear time-varying inertia weight\n            inertia_weight = self.inertia * (1 - np.cos(np.pi * _ / self.iterations) * self.memory_rate)\n\n            # Update velocities\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Update positions\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n\n            # Update personal bests\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "AMPSO", "description": "Introducing a nonlinear time-varying inertia weight strategy to enhance convergence dynamics.", "configspace": "", "generation": 4, "fitness": 0.31888827571456957, "feedback": "The algorithm AMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "metadata": {"aucs": [0.8585937726002435, 0.8670022262190842, 0.8819079619505501, 0.8468298016581912, 0.8454378985000769, 0.8701008899043537, 0.8694337088194551, 0.8524131655022513, 0.8599762831288957, 0.6807312413502483, 0.698958530054345, 0.6354497474474219, 0.693614806078154, 0.669282398484751, 0.6976970898042323, 0.6578236173041053, 0.6583039439538889, 0.6864891341618129, 0.10690504665494316, 0.1869270841334616, 0.1172872471881603, 0.11435195280247734, 0.15329211630852735, 0.12734566709789308, 0.10461436043849304, 0.13082308255875907, 0.08989476340481872, 0.09395045870543706, 0.11309944033566899, 0.11263166677364811, 0.10811831161123864, 0.09461215431458403, 0.0930690234916347, 0.141643982781695, 0.09573891638325072, 0.1000371098510826, 0.9025538433920455, 0.8671840830981538, 0.878329531346127, 0.9030774340312876, 0.8709078408219414, 0.8872270725398106, 0.8883380560732713, 0.8349808808071042, 0.8596148682701983, 0.6808407215787357, 0.7122012017896517, 0.5960275535352739, 0.7339276809646103, 0.7023094682277023, 0.6680801373263691, 0.6908823063679215, 0.6118360979560237, 0.6504047835869873, 0.2278038370025619, 0.37429073633175636, 0.2245465598445746, 0.279972179850818, 0.9053815496695163, 0.1903492872352699, 0.1285432950391412, 0.17750280214905456, 0.23395464988243353, 0.2664067810014048, 0.15582280886240696, 0.18248286353738896, 0.29095189771309093, 0.2037322491953374, 0.24973729818581625, 0.36710043827422956, 0.2848412819613171, 0.22769244491045815, 0.3062131647386638, 0.19984191794606032, 0.20316572333604777, 0.2448901743086952, 0.24059757963183892, 0.23400098052864315, 0.2505817645161177, 0.3042379073304614, 0.20637042648298465, 0.017072846559116672, 0.08604216319350488, 0.015715597923964708, 0.04958744449596486, 0.004110643192502317, 9.999999999998899e-05, 0.02766841780346152, 9.999999999998899e-05, 0.0380510630075398, 0.17780126340497682, 0.054819938641003096, 0.10859261737729342, 0.060171506481039305, 0.0512407161211057, 0.03353498982652614, 0.07328397005665743, 0.08893932194966292, 0.06605684892953634, 0.15003437579948053, 0.09576719230812869, 0.22156529698105054, 0.11254902454316285, 0.08968649536871076, 0.25067498398715415, 0.10623859056639973, 0.31168826099856217, 0.0955632731931646, 0.12375927486064009, 0.12610610811475287, 0.2819410111812598, 0.0965743668006469, 0.24432910912950556, 0.344325211590891, 0.24230365512306928, 0.09527884400106434, 0.08294603858243332, 0.6053760153896055, 0.5358504485632276, 0.5585373588028895, 0.6032504848772743, 0.5349193878162268, 0.5691024311805084, 0.63376557873697, 0.5627821187974114, 0.5422884167747033, 0.07602207557799989, 0.02944724202648563, 0.049437346774065416, 0.07964946221998725, 0.08101087734134216, 0.14177190398503248, 0.07857477708258687, 0.13006956724985574, 0.08217262910266199, 0.17722470180678307, 0.1844585273421121, 0.19985940391446022, 0.365006269170965, 0.2927661655385778, 0.2248828546984709, 0.34923168280492856, 0.6144605327223147, 0.2128216011259173, 0.1728605696531924, 0.21358020218095786, 0.312861671355966, 0.24595431227589293, 0.2477255256083326, 0.41563135775342286, 0.3782807212149447, 0.535241675237543, 0.2538375002787512, 0.1918496574403491, 0.24389498640806273, 0.2907834100935178, 0.2051676695444934, 0.20641337746127542, 0.4204531250267646, 0.16251566127255024, 0.31128749298546754, 0.187321158351052, 0.26341353364841547, 0.2223668187073954, 0.21908779068925321, 0.25499541306972173, 0.21559798095069937, 0.2938331189227421, 0.27265168218541114, 0.2565879189051997, 0.21871163009633188, 0.17713346052768064, 0.2503452324901587, 0.20247623379648094, 0.2237183527693537, 0.2496121938019904, 0.1822427331167159, 0.19744058946109222, 0.2038162521623169, 0.17755145521297178, 0.1262741305673426, 0.17579455583995673, 0.16359461182258095, 0.9218753194960817, 0.1995231549034756, 0.9285836956662137, 0.14261004556686763, 0.16140103498664848, 0.8959810066240561, 0.6206910811403099, 0.15593402948825208, 0.387072337896878, 0.74655163395048, 0.09400242684740101, 0.1547190098035962, 0.10371339508475486, 0.746957368825127, 0.7775059795587027, 0.21211317460217383, 0.21052035443179096, 0.20749140782252984, 0.19297769608264637, 0.23460066504695753, 0.20345914296327672, 0.21070541010073818, 0.19598428408693713, 0.24248391624892462, 0.09876518728850892, 0.07273739479538255, 0.08576476242419762, 0.10934492278821528, 0.09639840242442899, 0.09280419810067742, 0.0726914036793096, 0.1036032436433989, 0.10430961863730515]}, "mutation_prompt": null}
{"id": "92503c00-e33e-4a71-961b-2809f91787b2", "solution": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def __call__(self, func):\n        # Initialize particles\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        pbest_positions = positions.copy()\n        pbest_scores = np.array([func(pos) for pos in pbest_positions])\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            # Adaptive inertia weight\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            # Update velocities\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Update positions\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n\n            # Update personal bests\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "AMPSO", "description": "Adaptive Memory Particle Swarm Optimization (AMPSO) enhances standard PSO by incorporating an adaptive memory mechanism to balance exploration and exploitation dynamically.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "metadata": {"aucs": [0.8552678235180731, 0.8489724686297144, 0.8703410679520212, 0.8438327041169379, 0.8366743759474825, 0.8462021328844391, 0.839748185857819, 0.8324245982768375, 0.8455332548655596, 0.6449663660090176, 0.6498821042487153, 0.656956273081859, 0.6375070762021064, 0.6288948968313828, 0.6257790495398654, 0.6344754705142513, 0.6118478140489265, 0.5993902342347512, 0.12049601759348139, 0.1402660069299192, 0.10417505848472175, 0.08229265882145831, 0.1521626768757416, 0.11437870260478067, 0.09088292451073643, 0.15665409759918925, 0.09326055130162092, 0.08181595152424415, 0.1401933775373787, 0.15983576744531425, 0.1548714118419453, 0.10769904549748299, 0.08312608586239512, 0.13166696249819565, 0.14240393344962743, 0.11156597799828383, 0.9096921930444976, 0.8718679350713276, 0.8915565412945516, 0.9069941079608509, 0.8760048147889752, 0.8847714825413129, 0.8994993632892804, 0.861896685931153, 0.8758937900863575, 0.6750648233332082, 0.6942643486514626, 0.5375536826052573, 0.6791246355777045, 0.6694224314461414, 0.6884432726159492, 0.6812518717387552, 0.6162512033590604, 0.6725453275066724, 0.7319658205483247, 0.8843849399762543, 0.22432761497595355, 0.22109674223314102, 0.21133337547461994, 0.27415015025134526, 0.12890133117658187, 0.15046300380823963, 0.24366563161740873, 0.21324939995151915, 0.16671716612375698, 0.17641173601518745, 0.20898562594236292, 0.19685997907371622, 0.23411319434355038, 0.40953873449078626, 0.20622103118824853, 0.21058339367027312, 0.24529459907264772, 0.22788387514466313, 0.1199443670910808, 0.22643818444825614, 0.2518055691558996, 0.13365026521771983, 0.2428614711955147, 0.24496659855957992, 0.20290086690715026, 0.06726412198011911, 0.09319290450527717, 0.05774390869705892, 0.05717224700728618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008202714535873401, 0.16787716555464594, 0.08603322417342674, 0.11488102143835877, 0.10331640287292498, 0.07227567988447159, 0.038668327792763746, 0.11078915189072391, 0.08635421785718533, 0.13379372827080793, 0.14942379551083285, 0.10420394799417732, 0.18757731393590416, 0.09647439546026271, 0.08636537915213682, 0.1860832843007436, 0.09577914073939775, 0.31103338325999297, 0.10281564844650148, 0.264884202690156, 0.05034463287566615, 0.258052070637243, 0.04265079517396175, 0.255778059670014, 0.09401367592368681, 0.12866253735340683, 0.09348700952611799, 0.0824908309065151, 0.5136069445142262, 0.5309357948794611, 0.5482965884688166, 0.5451617051972434, 0.502914082996029, 0.5104422618688986, 0.5531084150871308, 0.592973262673606, 0.5330795008962106, 0.05827446350062471, 0.07822107089248997, 0.08700962728716788, 0.09564257670855536, 0.07565620524203132, 0.14391365059703332, 0.11608176270916881, 0.09241059762763348, 0.09666833054675739, 0.4152773131161168, 0.3123906168378391, 0.1831400956044461, 0.25924029467245535, 0.38709272405736284, 0.3215517841546517, 0.3487413803481153, 0.26113264780740975, 0.19168974953292128, 0.26819677982877477, 0.28307553071745084, 0.5393395288309832, 0.3068923878529336, 0.3041806107271072, 0.3973412809069784, 0.2835834663852411, 0.5876442023508187, 0.26796328232747324, 0.32328329717815685, 0.16093711594681648, 0.19488894076814667, 0.19016796478211417, 0.28184115733151494, 0.31601408095647643, 0.21275125251070515, 0.31762756581003837, 0.1986328610850031, 0.22127475486074233, 0.23621504350349287, 0.26387932282259663, 0.24049891941007673, 0.23578096700846563, 0.41819341075752636, 0.26364333503371373, 0.21086490476157738, 0.2524638458657339, 0.19261569783314136, 0.19123546101635858, 0.20181622733247584, 0.17434277648563634, 0.20824271461300747, 0.22324182281759597, 0.18209148630970273, 0.20769841490697194, 0.2084923604382386, 0.12604253817612265, 0.1757147791188196, 0.1641876889046513, 0.9261060824687294, 0.19949804460375986, 0.906952836151262, 0.1424959401731969, 0.16204792413937064, 0.9056635985605457, 0.6555821147993426, 0.15631283599307078, 0.6142305449823062, 0.6820367593339738, 0.09399085753117797, 0.15416006729254927, 0.7399225283847684, 0.7029500683105028, 0.7432910426651428, 0.1975264832124145, 0.21118427722904531, 0.1843941276108323, 0.22228214031609883, 0.20186621130644167, 0.18644918787864628, 0.24285065044422816, 0.21884420755882306, 0.18715962214820347, 0.09377511467713318, 0.08424772361972577, 0.08006619100150003, 0.0957601638102602, 0.08296455408853176, 0.10989221607215638, 0.11933984419711219, 0.11087394096628866, 0.09381942741476101]}, "mutation_prompt": null}
{"id": "dd35febf-14a7-41db-bb9a-53316f10aeb0", "solution": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def __call__(self, func):\n        # Initialize particles\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        pbest_positions = positions.copy()\n        pbest_scores = np.array([func(pos) for pos in pbest_positions])\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            # Adaptive inertia weight\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            # Update velocities\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Update positions\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n\n            # Update personal bests\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "AMPSO", "description": "Adaptive Memory Particle Swarm Optimization (AMPSO) enhances standard PSO by incorporating an adaptive memory mechanism to balance exploration and exploitation dynamically.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "metadata": {"aucs": [0.8552678235180731, 0.8489724686297144, 0.8703410679520212, 0.8438327041169379, 0.8366743759474825, 0.8462021328844391, 0.839748185857819, 0.8324245982768375, 0.8455332548655596, 0.6449663660090176, 0.6498821042487153, 0.656956273081859, 0.6375070762021064, 0.6288948968313828, 0.6257790495398654, 0.6344754705142513, 0.6118478140489265, 0.5993902342347512, 0.12049601759348139, 0.1402660069299192, 0.10417505848472175, 0.08229265882145831, 0.1521626768757416, 0.11437870260478067, 0.09088292451073643, 0.15665409759918925, 0.09326055130162092, 0.08181595152424415, 0.1401933775373787, 0.15983576744531425, 0.1548714118419453, 0.10769904549748299, 0.08312608586239512, 0.13166696249819565, 0.14240393344962743, 0.11156597799828383, 0.9096921930444976, 0.8718679350713276, 0.8915565412945516, 0.9069941079608509, 0.8760048147889752, 0.8847714825413129, 0.8994993632892804, 0.861896685931153, 0.8758937900863575, 0.6750648233332082, 0.6942643486514626, 0.5375536826052573, 0.6791246355777045, 0.6694224314461414, 0.6884432726159492, 0.6812518717387552, 0.6162512033590604, 0.6725453275066724, 0.7319658205483247, 0.8843849399762543, 0.22432761497595355, 0.22109674223314102, 0.21133337547461994, 0.27415015025134526, 0.12890133117658187, 0.15046300380823963, 0.24366563161740873, 0.21324939995151915, 0.16671716612375698, 0.17641173601518745, 0.20898562594236292, 0.19685997907371622, 0.23411319434355038, 0.40953873449078626, 0.20622103118824853, 0.21058339367027312, 0.24529459907264772, 0.22788387514466313, 0.1199443670910808, 0.22643818444825614, 0.2518055691558996, 0.13365026521771983, 0.2428614711955147, 0.24496659855957992, 0.20290086690715026, 0.06726412198011911, 0.09319290450527717, 0.05774390869705892, 0.05717224700728618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008202714535873401, 0.16787716555464594, 0.08603322417342674, 0.11488102143835877, 0.10331640287292498, 0.07227567988447159, 0.038668327792763746, 0.11078915189072391, 0.08635421785718533, 0.13379372827080793, 0.14942379551083285, 0.10420394799417732, 0.18757731393590416, 0.09647439546026271, 0.08636537915213682, 0.1860832843007436, 0.09577914073939775, 0.31103338325999297, 0.10281564844650148, 0.264884202690156, 0.05034463287566615, 0.258052070637243, 0.04265079517396175, 0.255778059670014, 0.09401367592368681, 0.12866253735340683, 0.09348700952611799, 0.0824908309065151, 0.5136069445142262, 0.5309357948794611, 0.5482965884688166, 0.5451617051972434, 0.502914082996029, 0.5104422618688986, 0.5531084150871308, 0.592973262673606, 0.5330795008962106, 0.05827446350062471, 0.07822107089248997, 0.08700962728716788, 0.09564257670855536, 0.07565620524203132, 0.14391365059703332, 0.11608176270916881, 0.09241059762763348, 0.09666833054675739, 0.4152773131161168, 0.3123906168378391, 0.1831400956044461, 0.25924029467245535, 0.38709272405736284, 0.3215517841546517, 0.3487413803481153, 0.26113264780740975, 0.19168974953292128, 0.26819677982877477, 0.28307553071745084, 0.5393395288309832, 0.3068923878529336, 0.3041806107271072, 0.3973412809069784, 0.2835834663852411, 0.5876442023508187, 0.26796328232747324, 0.32328329717815685, 0.16093711594681648, 0.19488894076814667, 0.19016796478211417, 0.28184115733151494, 0.31601408095647643, 0.21275125251070515, 0.31762756581003837, 0.1986328610850031, 0.22127475486074233, 0.23621504350349287, 0.26387932282259663, 0.24049891941007673, 0.23578096700846563, 0.41819341075752636, 0.26364333503371373, 0.21086490476157738, 0.2524638458657339, 0.19261569783314136, 0.19123546101635858, 0.20181622733247584, 0.17434277648563634, 0.20824271461300747, 0.22324182281759597, 0.18209148630970273, 0.20769841490697194, 0.2084923604382386, 0.12604253817612265, 0.1757147791188196, 0.1641876889046513, 0.9261060824687294, 0.19949804460375986, 0.906952836151262, 0.1424959401731969, 0.16204792413937064, 0.9056635985605457, 0.6555821147993426, 0.15631283599307078, 0.6142305449823062, 0.6820367593339738, 0.09399085753117797, 0.15416006729254927, 0.7399225283847684, 0.7029500683105028, 0.7432910426651428, 0.1975264832124145, 0.21118427722904531, 0.1843941276108323, 0.22228214031609883, 0.20186621130644167, 0.18644918787864628, 0.24285065044422816, 0.21884420755882306, 0.18715962214820347, 0.09377511467713318, 0.08424772361972577, 0.08006619100150003, 0.0957601638102602, 0.08296455408853176, 0.10989221607215638, 0.11933984419711219, 0.11087394096628866, 0.09381942741476101]}, "mutation_prompt": null}
{"id": "e08092d2-6673-4e16-9105-8d13a05a69bd", "solution": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def __call__(self, func):\n        # Initialize particles\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        pbest_positions = positions.copy()\n        pbest_scores = np.array([func(pos) for pos in pbest_positions])\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            # Adaptive inertia weight\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            # Update velocities\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Update positions\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n\n            # Update personal bests\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "AMPSO", "description": "Adaptive Memory Particle Swarm Optimization (AMPSO) enhances standard PSO by incorporating an adaptive memory mechanism to balance exploration and exploitation dynamically.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "metadata": {"aucs": [0.8552678235180731, 0.8489724686297144, 0.8703410679520212, 0.8438327041169379, 0.8366743759474825, 0.8462021328844391, 0.839748185857819, 0.8324245982768375, 0.8455332548655596, 0.6449663660090176, 0.6498821042487153, 0.656956273081859, 0.6375070762021064, 0.6288948968313828, 0.6257790495398654, 0.6344754705142513, 0.6118478140489265, 0.5993902342347512, 0.12049601759348139, 0.1402660069299192, 0.10417505848472175, 0.08229265882145831, 0.1521626768757416, 0.11437870260478067, 0.09088292451073643, 0.15665409759918925, 0.09326055130162092, 0.08181595152424415, 0.1401933775373787, 0.15983576744531425, 0.1548714118419453, 0.10769904549748299, 0.08312608586239512, 0.13166696249819565, 0.14240393344962743, 0.11156597799828383, 0.9096921930444976, 0.8718679350713276, 0.8915565412945516, 0.9069941079608509, 0.8760048147889752, 0.8847714825413129, 0.8994993632892804, 0.861896685931153, 0.8758937900863575, 0.6750648233332082, 0.6942643486514626, 0.5375536826052573, 0.6791246355777045, 0.6694224314461414, 0.6884432726159492, 0.6812518717387552, 0.6162512033590604, 0.6725453275066724, 0.7319658205483247, 0.8843849399762543, 0.22432761497595355, 0.22109674223314102, 0.21133337547461994, 0.27415015025134526, 0.12890133117658187, 0.15046300380823963, 0.24366563161740873, 0.21324939995151915, 0.16671716612375698, 0.17641173601518745, 0.20898562594236292, 0.19685997907371622, 0.23411319434355038, 0.40953873449078626, 0.20622103118824853, 0.21058339367027312, 0.24529459907264772, 0.22788387514466313, 0.1199443670910808, 0.22643818444825614, 0.2518055691558996, 0.13365026521771983, 0.2428614711955147, 0.24496659855957992, 0.20290086690715026, 0.06726412198011911, 0.09319290450527717, 0.05774390869705892, 0.05717224700728618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008202714535873401, 0.16787716555464594, 0.08603322417342674, 0.11488102143835877, 0.10331640287292498, 0.07227567988447159, 0.038668327792763746, 0.11078915189072391, 0.08635421785718533, 0.13379372827080793, 0.14942379551083285, 0.10420394799417732, 0.18757731393590416, 0.09647439546026271, 0.08636537915213682, 0.1860832843007436, 0.09577914073939775, 0.31103338325999297, 0.10281564844650148, 0.264884202690156, 0.05034463287566615, 0.258052070637243, 0.04265079517396175, 0.255778059670014, 0.09401367592368681, 0.12866253735340683, 0.09348700952611799, 0.0824908309065151, 0.5136069445142262, 0.5309357948794611, 0.5482965884688166, 0.5451617051972434, 0.502914082996029, 0.5104422618688986, 0.5531084150871308, 0.592973262673606, 0.5330795008962106, 0.05827446350062471, 0.07822107089248997, 0.08700962728716788, 0.09564257670855536, 0.07565620524203132, 0.14391365059703332, 0.11608176270916881, 0.09241059762763348, 0.09666833054675739, 0.4152773131161168, 0.3123906168378391, 0.1831400956044461, 0.25924029467245535, 0.38709272405736284, 0.3215517841546517, 0.3487413803481153, 0.26113264780740975, 0.19168974953292128, 0.26819677982877477, 0.28307553071745084, 0.5393395288309832, 0.3068923878529336, 0.3041806107271072, 0.3973412809069784, 0.2835834663852411, 0.5876442023508187, 0.26796328232747324, 0.32328329717815685, 0.16093711594681648, 0.19488894076814667, 0.19016796478211417, 0.28184115733151494, 0.31601408095647643, 0.21275125251070515, 0.31762756581003837, 0.1986328610850031, 0.22127475486074233, 0.23621504350349287, 0.26387932282259663, 0.24049891941007673, 0.23578096700846563, 0.41819341075752636, 0.26364333503371373, 0.21086490476157738, 0.2524638458657339, 0.19261569783314136, 0.19123546101635858, 0.20181622733247584, 0.17434277648563634, 0.20824271461300747, 0.22324182281759597, 0.18209148630970273, 0.20769841490697194, 0.2084923604382386, 0.12604253817612265, 0.1757147791188196, 0.1641876889046513, 0.9261060824687294, 0.19949804460375986, 0.906952836151262, 0.1424959401731969, 0.16204792413937064, 0.9056635985605457, 0.6555821147993426, 0.15631283599307078, 0.6142305449823062, 0.6820367593339738, 0.09399085753117797, 0.15416006729254927, 0.7399225283847684, 0.7029500683105028, 0.7432910426651428, 0.1975264832124145, 0.21118427722904531, 0.1843941276108323, 0.22228214031609883, 0.20186621130644167, 0.18644918787864628, 0.24285065044422816, 0.21884420755882306, 0.18715962214820347, 0.09377511467713318, 0.08424772361972577, 0.08006619100150003, 0.0957601638102602, 0.08296455408853176, 0.10989221607215638, 0.11933984419711219, 0.11087394096628866, 0.09381942741476101]}, "mutation_prompt": null}
{"id": "ae110f81-e321-458d-a276-e0b89c6fe167", "solution": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def __call__(self, func):\n        # Initialize particles\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        pbest_positions = positions.copy()\n        pbest_scores = np.array([func(pos) for pos in pbest_positions])\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            # Adaptive inertia weight\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            # Update velocities\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Update positions\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Evaluate function\n            scores = np.array([func(pos) for pos in positions])\n\n            # Update personal bests\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "AMPSO", "description": "Adaptive Memory Particle Swarm Optimization (AMPSO) enhances standard PSO by incorporating an adaptive memory mechanism to balance exploration and exploitation dynamically.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "metadata": {"aucs": [0.8552678235180731, 0.8489724686297144, 0.8703410679520212, 0.8438327041169379, 0.8366743759474825, 0.8462021328844391, 0.839748185857819, 0.8324245982768375, 0.8455332548655596, 0.6449663660090176, 0.6498821042487153, 0.656956273081859, 0.6375070762021064, 0.6288948968313828, 0.6257790495398654, 0.6344754705142513, 0.6118478140489265, 0.5993902342347512, 0.12049601759348139, 0.1402660069299192, 0.10417505848472175, 0.08229265882145831, 0.1521626768757416, 0.11437870260478067, 0.09088292451073643, 0.15665409759918925, 0.09326055130162092, 0.08181595152424415, 0.1401933775373787, 0.15983576744531425, 0.1548714118419453, 0.10769904549748299, 0.08312608586239512, 0.13166696249819565, 0.14240393344962743, 0.11156597799828383, 0.9096921930444976, 0.8718679350713276, 0.8915565412945516, 0.9069941079608509, 0.8760048147889752, 0.8847714825413129, 0.8994993632892804, 0.861896685931153, 0.8758937900863575, 0.6750648233332082, 0.6942643486514626, 0.5375536826052573, 0.6791246355777045, 0.6694224314461414, 0.6884432726159492, 0.6812518717387552, 0.6162512033590604, 0.6725453275066724, 0.7319658205483247, 0.8843849399762543, 0.22432761497595355, 0.22109674223314102, 0.21133337547461994, 0.27415015025134526, 0.12890133117658187, 0.15046300380823963, 0.24366563161740873, 0.21324939995151915, 0.16671716612375698, 0.17641173601518745, 0.20898562594236292, 0.19685997907371622, 0.23411319434355038, 0.40953873449078626, 0.20622103118824853, 0.21058339367027312, 0.24529459907264772, 0.22788387514466313, 0.1199443670910808, 0.22643818444825614, 0.2518055691558996, 0.13365026521771983, 0.2428614711955147, 0.24496659855957992, 0.20290086690715026, 0.06726412198011911, 0.09319290450527717, 0.05774390869705892, 0.05717224700728618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008202714535873401, 0.16787716555464594, 0.08603322417342674, 0.11488102143835877, 0.10331640287292498, 0.07227567988447159, 0.038668327792763746, 0.11078915189072391, 0.08635421785718533, 0.13379372827080793, 0.14942379551083285, 0.10420394799417732, 0.18757731393590416, 0.09647439546026271, 0.08636537915213682, 0.1860832843007436, 0.09577914073939775, 0.31103338325999297, 0.10281564844650148, 0.264884202690156, 0.05034463287566615, 0.258052070637243, 0.04265079517396175, 0.255778059670014, 0.09401367592368681, 0.12866253735340683, 0.09348700952611799, 0.0824908309065151, 0.5136069445142262, 0.5309357948794611, 0.5482965884688166, 0.5451617051972434, 0.502914082996029, 0.5104422618688986, 0.5531084150871308, 0.592973262673606, 0.5330795008962106, 0.05827446350062471, 0.07822107089248997, 0.08700962728716788, 0.09564257670855536, 0.07565620524203132, 0.14391365059703332, 0.11608176270916881, 0.09241059762763348, 0.09666833054675739, 0.4152773131161168, 0.3123906168378391, 0.1831400956044461, 0.25924029467245535, 0.38709272405736284, 0.3215517841546517, 0.3487413803481153, 0.26113264780740975, 0.19168974953292128, 0.26819677982877477, 0.28307553071745084, 0.5393395288309832, 0.3068923878529336, 0.3041806107271072, 0.3973412809069784, 0.2835834663852411, 0.5876442023508187, 0.26796328232747324, 0.32328329717815685, 0.16093711594681648, 0.19488894076814667, 0.19016796478211417, 0.28184115733151494, 0.31601408095647643, 0.21275125251070515, 0.31762756581003837, 0.1986328610850031, 0.22127475486074233, 0.23621504350349287, 0.26387932282259663, 0.24049891941007673, 0.23578096700846563, 0.41819341075752636, 0.26364333503371373, 0.21086490476157738, 0.2524638458657339, 0.19261569783314136, 0.19123546101635858, 0.20181622733247584, 0.17434277648563634, 0.20824271461300747, 0.22324182281759597, 0.18209148630970273, 0.20769841490697194, 0.2084923604382386, 0.12604253817612265, 0.1757147791188196, 0.1641876889046513, 0.9261060824687294, 0.19949804460375986, 0.906952836151262, 0.1424959401731969, 0.16204792413937064, 0.9056635985605457, 0.6555821147993426, 0.15631283599307078, 0.6142305449823062, 0.6820367593339738, 0.09399085753117797, 0.15416006729254927, 0.7399225283847684, 0.7029500683105028, 0.7432910426651428, 0.1975264832124145, 0.21118427722904531, 0.1843941276108323, 0.22228214031609883, 0.20186621130644167, 0.18644918787864628, 0.24285065044422816, 0.21884420755882306, 0.18715962214820347, 0.09377511467713318, 0.08424772361972577, 0.08006619100150003, 0.0957601638102602, 0.08296455408853176, 0.10989221607215638, 0.11933984419711219, 0.11087394096628866, 0.09381942741476101]}, "mutation_prompt": null}
{"id": "cf2c5ed0-9298-4d2b-ab13-3444a1f806ce", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced AMPSO with Oppositional-based Learning for improved exploration and convergence efficiency.", "configspace": "", "generation": 9, "fitness": 0.32272771872625755, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "8d66433e-cd84-449a-ab9d-6eb97e5d935a", "metadata": {"aucs": [0.8520445617264193, 0.8544585591506103, 0.8567086899380282, 0.8373230093128801, 0.8418295981080544, 0.84184426069369, 0.8472525742373771, 0.8451674513922682, 0.8464061895301813, 0.6525482828286753, 0.6200436425369372, 0.6419776608754642, 0.6412932924301149, 0.6442577682002446, 0.667992747301287, 0.6104512068315981, 0.6430391691281692, 0.6250458469984774, 0.11484889242755247, 0.17009289534624183, 0.12946589313026857, 0.0997279031892937, 0.15499128440981091, 0.11518089091820038, 0.11679293601214158, 0.14432368359141423, 0.12170944470083656, 0.11471503550861983, 0.04180646775127317, 0.08988876202380469, 0.1072460501302428, 0.0722814372110806, 0.07631690954246584, 0.11673400085400931, 0.15560134552583882, 0.08622588576510826, 0.90619228553507, 0.9376038511988818, 0.899331384628044, 0.9114883267646458, 0.8993240683427207, 0.8891758906250363, 0.902397563096129, 0.8546524941176863, 0.8931309993721828, 0.6641354238451384, 0.6786638300401984, 0.6858578360173497, 0.6736264793370772, 0.6936375295982014, 0.6819626944189177, 0.6289473982861541, 0.5835468949033662, 0.6185339766695107, 0.39100515823365534, 0.34647554449344076, 0.7964115866587761, 0.2802595202264735, 0.21174163587533945, 0.38078022931671685, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.2064854860519355, 0.12450751163956453, 0.20308012969771638, 0.2241578491445706, 0.37370531416445474, 0.22876840623362893, 0.21925584383827623, 0.20878676957713982, 0.3161570442978969, 0.21221484927848955, 0.2377391436009033, 0.2263375454274762, 0.18048947995196174, 0.18762393729202964, 0.22356521392000528, 0.2406680493414639, 0.24162912828630922, 0.2505742519403227, 0.05388805867543811, 0.03269372951891858, 0.011871264090087097, 0.1151269684059727, 0.09059463456065098, 0.0640821346450251, 0.016482980573376493, 0.00020878692218795347, 0.04965941622571157, 0.11304478688065434, 0.09682971705474974, 0.15775912960129446, 0.10228676558327299, 0.03577461430607787, 0.056308446142960045, 0.10339958107874625, 0.09114603991518999, 0.10321866082996622, 0.2473247642256572, 0.11612576935789132, 0.24848291014820434, 0.17072192049806112, 0.12057222757010677, 0.0856167415250273, 0.1027258680576888, 0.18783129614142924, 0.14893926569913418, 0.10354355778926216, 0.10526950893616671, 0.13601471551595368, 0.030056640342278063, 0.09944217413279244, 0.195866581177919, 0.23404491653404114, 0.08267835946509472, 0.08267343423642959, 0.5335681558903946, 0.5430629285646003, 0.5312609967813171, 0.5388283086957141, 0.6209923608009433, 0.5687700360571665, 0.5641616133542238, 0.598172867410127, 0.583895710259806, 0.0913168555736884, 0.06222650502830451, 0.08798391594914268, 0.10344152272728513, 0.08047947245455611, 0.14368331346998753, 0.1553988071978729, 0.10900875773502561, 0.14502164998326572, 0.2994576865136489, 0.16426782033082166, 0.18316412076134825, 0.2439926598155917, 0.326466119929139, 0.3892162432736721, 0.35669896156497716, 0.2166852956079327, 0.24568552995421677, 0.26599812700766323, 0.43403531904716053, 0.3227085839808991, 0.23480711119945052, 0.44490474154974746, 0.3257552953519103, 0.5228540668491273, 0.5505730839487777, 0.45872888701460457, 0.24209273673068976, 0.3279674430679165, 0.21421765334034382, 0.27749673602299074, 0.18793223709446938, 0.2823146214964206, 0.2107348615155452, 0.29107254336547317, 0.20541774619526965, 0.23618530463014287, 0.20636685635025653, 0.2210952153058231, 0.28554897984780014, 0.2391708749152296, 0.21946095694908563, 0.26608208164785396, 0.19873400104161942, 0.23691622386306688, 0.17913411715692995, 0.20068908905868688, 0.21966194033216302, 0.17609460938118315, 0.20756887889662956, 0.21968498277252912, 0.20706201630228838, 0.18321830052078014, 0.1832644511759991, 0.12245173286919397, 0.8921450011965345, 0.17587874478308552, 0.8976505509546168, 0.8841247805335076, 0.9175035587731778, 0.14174891666923817, 0.16067041022771955, 0.1770844304067143, 0.7628987825368768, 0.15518251167450692, 0.7797863524855165, 0.21227009218498605, 0.7922269430601407, 0.42127997458166355, 0.11108909497350739, 0.7467277474639846, 0.16566482336056598, 0.1890241939889451, 0.20896193255277273, 0.20503089558765175, 0.18802482579374158, 0.1808021380828535, 0.20267806403571853, 0.22248803429882913, 0.2222174437097464, 0.21965936531588226, 0.08790425787056211, 0.11698116912723289, 0.0812681030527026, 0.09165899553044987, 0.09167267646256516, 0.10383339645643463, 0.09966794816991986, 0.08812130299576204, 0.07167213634221548]}, "mutation_prompt": null}
{"id": "bfd08b57-6b1c-44f7-9601-2f67dbb70eb5", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.mutation_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_mutation(self, position, generation, max_generations):\n        mutation_strength = self.mutation_rate * (1 - generation / max_generations)\n        mutation_vector = np.random.normal(0, mutation_strength, self.dim)\n        return np.clip(position + mutation_vector, self.pos_bounds[0], self.pos_bounds[1])\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for gen in range(self.iterations):\n            inertia_weight = self.inertia * (1 - self.memory_rate * (gen / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            # Apply adaptive mutation\n            for i in range(self.population_size):\n                positions[i] = self.adaptive_mutation(positions[i], gen, self.iterations)\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced AMPSO with Adaptive Mutation and Oppositional-based Learning for better exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.23491620481348588, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "cf2c5ed0-9298-4d2b-ab13-3444a1f806ce", "metadata": {"aucs": [0.4773270580219099, 0.45703095151655293, 0.4724435642597199, 0.46048293707027965, 0.479856767343551, 0.456367756643402, 0.4778803363992514, 0.4633872955473196, 0.46090242595771613, 0.05952028782519048, 0.04146781218447382, 0.04695684017882085, 0.008383687797836492, 0.01860573706968649, 0.011608661250778862, 0.005887337983566776, 0.01922355511351581, 0.005329617644148077, 0.0918556304107826, 0.16290311549249925, 0.15254020371393417, 0.10672214438137384, 0.1356009241447539, 0.10943161455999106, 0.08814922036852546, 0.13690141979079706, 0.11299125340543503, 0.10029079729164736, 0.05014191399073187, 0.0972852011653349, 0.10510914814451988, 0.05812664654695476, 0.06796612782285028, 0.12664260944305772, 0.112552982722537, 0.09247942476388293, 0.8668591679390772, 0.8928979416835923, 0.8822635236395797, 0.8630253224894066, 0.889658838407976, 0.8825564472290623, 0.8880139964030089, 0.8733191411524452, 0.873255147823975, 0.34550323213696543, 0.3079868429988153, 0.31903551250598594, 0.31003988379185365, 0.3276405742245796, 0.33787883128009066, 0.31719092925559644, 0.3261710344414972, 0.3261751782146123, 0.21258449749074093, 0.2257841150046186, 0.4961480208505932, 0.2780366737911446, 0.21197037648603012, 0.42060685180282775, 0.17395779584068682, 0.17701011325185412, 0.23428716284330053, 0.1823046527737361, 0.18195544920120543, 0.16831338806835372, 0.1586831206878272, 0.20539671638512913, 0.17910090316411154, 0.1778464503780942, 0.16954910327677175, 0.23773645424328405, 0.17723009954916746, 0.1756980872727688, 0.12759080892144026, 0.16643029075971094, 0.17363747063821133, 0.16883043123539643, 0.1263168404234397, 0.19507564188918392, 0.1843628851941036, 0.002783992371103383, 0.03414724590101359, 0.001315330258668701, 0.03929758189681831, 0.0007512561912601523, 9.999999999998899e-05, 9.999999999998899e-05, 0.052876251626482906, 0.04466101257479238, 0.10055079440046266, 0.15458261020070296, 0.15423470356403668, 0.06818934707082358, 0.03911538943339743, 0.1169461741968848, 0.08995202742335806, 0.11077931554632792, 0.10125206900966022, 0.021369001974535395, 0.007264341214878511, 0.0035863402235456476, 0.0022976516985508955, 0.002093004383272312, 0.002324994411119552, 0.002564462265163825, 0.0030841855767291815, 0.0025584498195783123, 0.09887538734956702, 0.12625296929780672, 0.11741563306879121, 0.07757021153574895, 0.11254028356010282, 0.11209991615014203, 0.12145363847944468, 0.0919966165302063, 0.08899674766196553, 0.4241661002475795, 0.4275063674567373, 0.42300491647422656, 0.41843326318309393, 0.41061679598725564, 0.42369381951787055, 0.4290484495262996, 0.41041529483235983, 0.42201643967599634, 0.08425051061827071, 0.10499701537070016, 0.09911817497019004, 0.1007693067713743, 0.12537709695150845, 0.1271024583717304, 0.1248645502382919, 0.11386561641778703, 0.10072067145329833, 0.2883918528805359, 0.24729727151297343, 0.1686881516971369, 0.2938076972346815, 0.280912194157368, 0.27420630135509827, 0.18663102355503802, 0.16480503329490093, 0.17600657644853668, 0.30694975702557326, 0.2940900796344522, 0.32237348537710564, 0.2967806316730507, 0.29394383957591586, 0.3129872900688444, 0.20685433239404327, 0.31071058282227815, 0.31333432811923567, 0.19786968815399464, 0.25228000341271917, 0.1881646386289333, 0.21405760178347266, 0.19607355388809544, 0.21227231551462045, 0.20951664846043827, 0.2604923810073221, 0.1949039456532322, 0.23069451707937672, 0.24069060851925705, 0.22182991369771576, 0.23331934881454386, 0.22444679411468904, 0.23064170472114442, 0.23182960339472503, 0.21829062698432466, 0.200883295746224, 0.1790282591774558, 0.20043490076124792, 0.21727492234625045, 0.2309220622092918, 0.19151445439921022, 0.20404311335430048, 0.2157521559609159, 0.18865854470434762, 0.26172666676000955, 0.12226060419806695, 0.7180117289600404, 0.16405177333096022, 0.7352184485380322, 0.71854461274425, 0.7170014588318471, 0.14119150380313983, 0.1590369690181609, 0.1752736382600797, 0.6127477766687872, 0.1555229133522653, 0.7458772195568766, 0.2105705386556046, 0.5336097314345714, 0.5591318158176151, 0.5020967466541607, 0.5193751653573394, 0.5067910778172672, 0.17550990505456177, 0.18284243670285882, 0.18619549415216863, 0.192014509989903, 0.19274885829642008, 0.18878255661969856, 0.19715118411176247, 0.18433652605745587, 0.19296725984332708, 0.08083138857267513, 0.0881569203068906, 0.09261040595693126, 0.09176161077631839, 0.09205440844294532, 0.10173159416636612, 0.09241900386752133, 0.10510756583041458, 0.09976744995034093]}, "mutation_prompt": null}
{"id": "6ccca47c-25dc-4f73-9dc8-fd1ca5d6ac32", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for _ in range(self.iterations):\n            inertia_weight = self.inertia * (1 - self.memory_rate * (_ / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced AMPSO with Oppositional-based Learning for improved exploration and convergence efficiency.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf2c5ed0-9298-4d2b-ab13-3444a1f806ce", "metadata": {"aucs": [0.8520445617264193, 0.8544585591506103, 0.8567086899380282, 0.8373230093128801, 0.8418295981080544, 0.84184426069369, 0.8472525742373771, 0.8451674513922682, 0.8464061895301813, 0.6525482828286753, 0.6200436425369372, 0.6419776608754642, 0.6412932924301149, 0.6442577682002446, 0.667992747301287, 0.6104512068315981, 0.6430391691281692, 0.6250458469984774, 0.11484889242755247, 0.17009289534624183, 0.12946589313026857, 0.0997279031892937, 0.15499128440981091, 0.11518089091820038, 0.11679293601214158, 0.14432368359141423, 0.12170944470083656, 0.11471503550861983, 0.04180646775127317, 0.08988876202380469, 0.1072460501302428, 0.0722814372110806, 0.07631690954246584, 0.11673400085400931, 0.15560134552583882, 0.08622588576510826, 0.90619228553507, 0.9376038511988818, 0.899331384628044, 0.9114883267646458, 0.8993240683427207, 0.8891758906250363, 0.902397563096129, 0.8546524941176863, 0.8931309993721828, 0.6641354238451384, 0.6786638300401984, 0.6858578360173497, 0.6736264793370772, 0.6936375295982014, 0.6819626944189177, 0.6289473982861541, 0.5835468949033662, 0.6185339766695107, 0.39100515823365534, 0.34647554449344076, 0.7964115866587761, 0.2802595202264735, 0.21174163587533945, 0.38078022931671685, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.2064854860519355, 0.12450751163956453, 0.20308012969771638, 0.2241578491445706, 0.37370531416445474, 0.22876840623362893, 0.21925584383827623, 0.20878676957713982, 0.3161570442978969, 0.21221484927848955, 0.2377391436009033, 0.2263375454274762, 0.18048947995196174, 0.18762393729202964, 0.22356521392000528, 0.2406680493414639, 0.24162912828630922, 0.2505742519403227, 0.05388805867543811, 0.03269372951891858, 0.011871264090087097, 0.1151269684059727, 0.09059463456065098, 0.0640821346450251, 0.016482980573376493, 0.00020878692218795347, 0.04965941622571157, 0.11304478688065434, 0.09682971705474974, 0.15775912960129446, 0.10228676558327299, 0.03577461430607787, 0.056308446142960045, 0.10339958107874625, 0.09114603991518999, 0.10321866082996622, 0.2473247642256572, 0.11612576935789132, 0.24848291014820434, 0.17072192049806112, 0.12057222757010677, 0.0856167415250273, 0.1027258680576888, 0.18783129614142924, 0.14893926569913418, 0.10354355778926216, 0.10526950893616671, 0.13601471551595368, 0.030056640342278063, 0.09944217413279244, 0.195866581177919, 0.23404491653404114, 0.08267835946509472, 0.08267343423642959, 0.5335681558903946, 0.5430629285646003, 0.5312609967813171, 0.5388283086957141, 0.6209923608009433, 0.5687700360571665, 0.5641616133542238, 0.598172867410127, 0.583895710259806, 0.0913168555736884, 0.06222650502830451, 0.08798391594914268, 0.10344152272728513, 0.08047947245455611, 0.14368331346998753, 0.1553988071978729, 0.10900875773502561, 0.14502164998326572, 0.2994576865136489, 0.16426782033082166, 0.18316412076134825, 0.2439926598155917, 0.326466119929139, 0.3892162432736721, 0.35669896156497716, 0.2166852956079327, 0.24568552995421677, 0.26599812700766323, 0.43403531904716053, 0.3227085839808991, 0.23480711119945052, 0.44490474154974746, 0.3257552953519103, 0.5228540668491273, 0.5505730839487777, 0.45872888701460457, 0.24209273673068976, 0.3279674430679165, 0.21421765334034382, 0.27749673602299074, 0.18793223709446938, 0.2823146214964206, 0.2107348615155452, 0.29107254336547317, 0.20541774619526965, 0.23618530463014287, 0.20636685635025653, 0.2210952153058231, 0.28554897984780014, 0.2391708749152296, 0.21946095694908563, 0.26608208164785396, 0.19873400104161942, 0.23691622386306688, 0.17913411715692995, 0.20068908905868688, 0.21966194033216302, 0.17609460938118315, 0.20756887889662956, 0.21968498277252912, 0.20706201630228838, 0.18321830052078014, 0.1832644511759991, 0.12245173286919397, 0.8921450011965345, 0.17587874478308552, 0.8976505509546168, 0.8841247805335076, 0.9175035587731778, 0.14174891666923817, 0.16067041022771955, 0.1770844304067143, 0.7628987825368768, 0.15518251167450692, 0.7797863524855165, 0.21227009218498605, 0.7922269430601407, 0.42127997458166355, 0.11108909497350739, 0.7467277474639846, 0.16566482336056598, 0.1890241939889451, 0.20896193255277273, 0.20503089558765175, 0.18802482579374158, 0.1808021380828535, 0.20267806403571853, 0.22248803429882913, 0.2222174437097464, 0.21965936531588226, 0.08790425787056211, 0.11698116912723289, 0.0812681030527026, 0.09165899553044987, 0.09167267646256516, 0.10383339645643463, 0.09966794816991986, 0.08812130299576204, 0.07167213634221548]}, "mutation_prompt": null}
{"id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.32469189873348303, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "cf2c5ed0-9298-4d2b-ab13-3444a1f806ce", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "daadb033-ff36-40d6-9beb-ba42cf32b157", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "c9604587-b68e-4a72-bb60-f998bbaedece", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "155d384d-bf9b-4269-856d-d65529c93c68", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "69b28a34-ed79-45ff-a03d-3cf0a4544086", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "7cf59a41-ed73-44c3-a402-1b620a336d8e", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "c508a9cf-c4c8-42dd-9db8-47d7a0e77ffe", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "79a7b642-95b0-4a6c-9783-c7daea369c4e", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "b71bf714-9fa0-46b9-a758-64b80a83862e", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.9  # Adjusted to improve exploration\n        self.cognitive_coef = 2.0  # Increased for better local search\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_parameter_control(self, iteration):\n        # New method to adapt parameters\n        return 0.5 + 0.5 * np.cos((iteration / self.iterations) * np.pi)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = self.adaptive_parameter_control(i)  # Use adaptive control\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced AMPSO with Adaptive Parameter Control and Opposition-based Learning for improved global search.", "configspace": "", "generation": 20, "fitness": 0.3073562184583896, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.7892303236143733, 0.7811548724983464, 0.7947336195774811, 0.7514126521229316, 0.780693021806761, 0.7519492221816984, 0.7907620271106618, 0.7674756432155927, 0.751571774875634, 0.43272829056683215, 0.4765036459688349, 0.4367245272399487, 0.4718640067288936, 0.41742629610116966, 0.4234538781125825, 0.43561751166284635, 0.46086927906089137, 0.4393864153869539, 0.12465950046686614, 0.13948798109186644, 0.46893561270443984, 0.14479728577281026, 0.1578700294609343, 0.14630426979893796, 0.10833861947331935, 0.1409794449270414, 0.14709914714321126, 0.10970764842678304, 0.06670357465831489, 0.08710808351267574, 0.12167678013423922, 0.08922894226134359, 0.07594223331128813, 0.07105972151447604, 0.11727823539670446, 0.10535048840098038, 0.9198055854563731, 0.9527698956817123, 0.9223333340394922, 0.9032014486072323, 0.9108218329810209, 0.9068185090818509, 0.9187190836125537, 0.8847062192296933, 0.9071381683853822, 0.4892041828036482, 0.4963025767213649, 0.45771231038701, 0.4707018558334375, 0.5148530734199139, 0.5331211495752508, 0.4890450152145256, 0.4383889348405321, 0.4864509333582827, 0.8126908241056621, 0.5038156435147514, 0.6096121486796027, 0.2737400446169306, 0.37111679953212606, 0.8281190433452958, 0.17590423858920878, 0.23284146111008186, 0.23315198382714764, 0.18304312260344024, 0.12654812288298067, 0.18588773089213717, 0.18990566326015235, 0.2758060620124807, 0.22189615259720596, 0.19237684123553223, 0.1942855114112848, 0.3965690106007401, 0.18483946324203215, 0.17934427245325057, 0.19404804983831614, 0.13219160667632746, 0.20264832749891526, 0.1746979625495303, 0.212872415794102, 0.22231430500596194, 0.17427296415912918, 0.03752830758833736, 0.07311359895833525, 0.0018864526222199807, 0.014394534576137596, 0.06477004539103126, 0.10234687275982868, 0.017614801925093015, 0.001331205744651176, 0.050613063946228665, 0.19720710907525862, 0.1231584146828767, 0.18381972203875963, 0.1104407535077846, 0.04081005967760043, 0.10671302501006197, 0.12169756315742086, 0.1407243473508656, 0.10879896082463913, 0.11999378217433498, 0.09742581527349281, 0.17450209532466665, 0.09405564424389634, 0.13689092182382978, 0.06789678050534531, 0.07836660389267691, 0.15162556372060265, 0.20398978560599557, 0.1245265132379404, 0.15889448838977982, 0.20857755820913015, 0.08525103462100336, 0.1422060016133524, 0.12622845998963061, 0.11654542648427613, 0.08123887596453483, 0.08111932240418152, 0.5477368959749782, 0.5146449062767764, 0.5242243642898738, 0.5293958741306044, 0.5039673007593616, 0.516162616325204, 0.5156142757221247, 0.5329416366453921, 0.5374483329105146, 0.10816709391281132, 0.08894682035055301, 0.10746573282166405, 0.11415686905400924, 0.10742107731722195, 0.15151933306555165, 0.17294220577297215, 0.5167198413400905, 0.15594281467387572, 0.3774524613170429, 0.1859247613275028, 0.19810110655249646, 0.25485643907143263, 0.1826621809581298, 0.3075859866135292, 0.37542038549313816, 0.44994863213457215, 0.19524703011685218, 0.3934820944422297, 0.4396172411512299, 0.4309331023025982, 0.2939835837634165, 0.3527508729133564, 0.3760590513279549, 0.2919892606327925, 0.42798185695377355, 0.2629344730391725, 0.2174022409585623, 0.2580068464265126, 0.2198969302920477, 0.2541650042860283, 0.26205071882783704, 0.2929837128285362, 0.185456644128285, 0.284596277011972, 0.19123876766078807, 0.22475736592538387, 0.22120825739627448, 0.22503163436745477, 0.2288618670396675, 0.2074840548845993, 0.2192935088982909, 0.21668844937772402, 0.2349754376460801, 0.22549163134238848, 0.19826188390389998, 0.38892698702052997, 0.21150737582051538, 0.21909091903505973, 0.19934688612318563, 0.1976389928458956, 0.2021575973424734, 0.2047153003404334, 0.20471653349787422, 0.122183592399295, 0.8507281157181596, 0.17503996450985726, 0.8755959063962853, 0.8606255324529519, 0.8712763506151854, 0.14211523257971892, 0.1616206515561036, 0.17665983229962057, 0.6212942626455482, 0.15528263902274342, 0.6864659831919149, 0.21123944536585226, 0.5707852662865243, 0.16765897767954663, 0.5746524215999591, 0.6524266346000497, 0.16425201463188077, 0.17528897728691006, 0.17958631095448385, 0.1883968987668594, 0.2058207445912228, 0.18528415156597722, 0.19018848370328856, 0.23750224843344547, 0.23782339768162597, 0.22127275661577184, 0.10351673570415354, 0.10413529885406936, 0.09109003704776675, 0.09991748063294892, 0.09129679947965219, 0.11541909281792273, 0.08961452584790042, 0.09377890918996623, 0.09178517773582151]}, "mutation_prompt": null}
{"id": "c9f9336e-92eb-4b5b-9e5b-db5700821811", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n        self.neighborhood_size = int(self.population_size * 0.2)  # New parameter for neighborhood\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_neighborhood_best(self, positions, scores):\n        neighborhood_bests = np.zeros_like(positions)\n        for i in range(self.population_size):\n            neighbors_indices = np.random.choice(\n                self.population_size, self.neighborhood_size, replace=False\n            )\n            neighborhood_bests[i] = positions[neighbors_indices[np.argmin(scores[neighbors_indices])]]\n        return neighborhood_bests\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            \n            neighborhood_bests = self.adaptive_neighborhood_best(positions, scores)  # Use neighborhood bests\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (neighborhood_bests - positions))  # Update with neighborhood bests\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Adaptive Enhanced AMPSO with Dynamic Neighborhood Learning for improved convergence and diversity.", "configspace": "", "generation": 21, "fitness": 0.2797556285523863, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.7454284138003953, 0.7414878441951174, 0.7575681565226835, 0.7326101737115208, 0.7256730475185067, 0.7423560063350401, 0.7439925154608092, 0.7368502508354455, 0.7549490003857862, 0.528685121695917, 0.5449447604761575, 0.5404083774809454, 0.5294040219484439, 0.5379524896488949, 0.49950700999358755, 0.5198260678468625, 0.5227285791170252, 0.5410369479616555, 0.11846444440357196, 0.12730765666881583, 0.2042183184141042, 0.11350879516224399, 0.11572845968168965, 0.11227994827516197, 0.09061386483952105, 0.1129493182817205, 0.1198255338549763, 0.10079120395943242, 0.07798880999446955, 0.1045458671791526, 0.09739942142163927, 0.07762298447559679, 0.09411909780713523, 0.11869321935312438, 0.10275668555214745, 0.08697626841339134, 0.8834603387856759, 0.8754513365260498, 0.8357968762921614, 0.84493928291221, 0.8642450948140348, 0.8652321803043577, 0.8656048008777518, 0.8429167450305093, 0.86448839111909, 0.49461970441979564, 0.4907954321887641, 0.45451574984780263, 0.4867321906361549, 0.47002384709530876, 0.4947633099779223, 0.4825336319633986, 0.4699182242781783, 0.48201767485343694, 0.2278760631903295, 0.2948317630015236, 0.22399939325290397, 0.8036304753378252, 0.6635117506125399, 0.7191756181158878, 0.22325257372575802, 0.39094386003437587, 0.2296248252866806, 0.18968020582959566, 0.11718500575543223, 0.17607727708279475, 0.17118656139488686, 0.16742191925576078, 0.19418506068178298, 0.17555725039259562, 0.1763798012639365, 0.17647622153692244, 0.1992887235610289, 0.1816154674489351, 0.18502649263409854, 0.15761921478633945, 0.1665162296021141, 0.17751120274786114, 0.1650438763118125, 0.17875062043347767, 0.1944183478062933, 0.00048072800255327675, 0.004583964546258201, 0.03679795459199775, 0.011447616869361799, 0.032236635180209694, 0.013510529386337788, 0.051831563504795675, 0.050810986265759084, 0.018171932649580946, 0.11655248099283455, 0.08078084739968616, 0.0909861460119088, 0.06218297880443535, 0.044697885586963415, 0.05125796333973398, 0.12507931328211452, 0.09072910790636457, 0.10015854286498904, 0.054479216386196794, 0.048185031951704316, 0.07562480262196003, 0.057698745126828044, 0.05690225209939159, 0.03528559088349448, 0.03389696958111654, 0.024119781596302015, 0.03821495654628393, 0.12777927068653638, 0.10052901043468265, 0.11580095901839649, 0.11331459651024489, 0.14506418436432666, 0.11313564607287152, 0.08138143886424165, 0.1170055603432324, 0.08412246918653998, 0.4460925460266508, 0.44779726999859515, 0.4499707778915969, 0.4650226001902784, 0.4548079596109651, 0.45015425983854496, 0.46814111271672254, 0.477450922963917, 0.479926271487109, 0.09277176771339368, 0.09684727026542839, 0.10831001877847046, 0.1285231447014792, 0.13172161889259681, 0.09705303277416677, 0.1247975894509682, 0.11769252569766486, 0.11569225242147807, 0.3592043297697244, 0.31487998933535744, 0.18846636702982622, 0.31697012957425097, 0.27430049828541136, 0.21372886946454162, 0.15576126848057048, 0.20688136250827283, 0.24133238849672078, 0.4042553782112388, 0.38189720783643666, 0.41314946406345077, 0.42211669317413303, 0.40996969294315555, 0.3938363282136601, 0.42088720911186606, 0.24873666333530176, 0.4257795353531709, 0.21595464429799915, 0.2807600088389596, 0.23656590423840862, 0.3107072385476928, 0.21010672120864038, 0.26691006257981764, 0.21457438954240327, 0.2127564814484193, 0.22556371997691504, 0.2248971401766614, 0.21746443924794068, 0.2277445341623957, 0.22133962150447595, 0.22811489194802603, 0.23740871124452856, 0.22572597942161643, 0.2434054969978714, 0.23212070656540673, 0.18813102332901577, 0.17278464075446864, 0.17191534980537904, 0.1758822067161946, 0.2099312777515161, 0.17630195301609497, 0.19715849088576054, 0.18046630084374993, 0.18669358502167266, 0.18648798678781253, 0.18567092171086141, 0.18732318794861058, 0.7624953137825445, 0.215412806982192, 0.8125954253807943, 0.15846877723734265, 0.16362557315870563, 0.16587793413611818, 0.529500378909247, 0.210875781451778, 0.6256961857651189, 0.2214670148518979, 0.20671684006666158, 0.16506798551815705, 0.4463423596962989, 0.4724698327607758, 0.4718492998842341, 0.18783929313487713, 0.17434861712686256, 0.18866220372247033, 0.20632149896609098, 0.18308472931691666, 0.19019887972786076, 0.1956160694180823, 0.1803001735008204, 0.18386545563972534, 0.10101601585052089, 0.09413287044247642, 0.09248494489565928, 0.09864691674236548, 0.1117172196394205, 0.09722206555799062, 0.08813131273673425, 0.10513005094727301, 0.10336505210196867]}, "mutation_prompt": null}
{"id": "7a03e571-5b90-41af-a24b-a5f939a4b4ac", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_velocity(self, velocities, diversity):\n        return velocities * (1 + diversity)\n\n    def calculate_diversity(self, positions):\n        centroid = np.mean(positions, axis=0)\n        diversity = np.mean(np.linalg.norm(positions - centroid, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n            \n            diversity = self.calculate_diversity(positions)\n            velocities = self.adaptive_velocity(velocities, diversity)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Velocity and Swarm Diversity for improved exploration and convergence stability.", "configspace": "", "generation": 22, "fitness": 0.26234534012939925, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.6251108662476696, 0.6143627372114241, 0.6399634031931137, 0.6206754901722756, 0.6129580939631725, 0.6079502983231602, 0.6168277796516085, 0.6232371217391184, 0.6321981899275413, 0.12400948357523067, 0.1624209453508163, 0.25009027914119797, 0.3003131337255509, 0.11101799810624247, 0.037911882916090156, 0.2628327470937608, 0.115938976458973, 0.1945726118630272, 0.11130864364990889, 0.13545103830343563, 0.18491400438287187, 0.10621452193019687, 0.2351692370246592, 0.11985082758302545, 0.12291847143481716, 0.12014368518822849, 0.13856133801906778, 0.10444291568991648, 0.09440295113347397, 0.08865732995457698, 0.20013687436320393, 0.11377933366773452, 0.10094795429444314, 0.11363205100122742, 0.09535306643710117, 0.06305600319747684, 0.9060729047186498, 0.9616488110004842, 0.9463644847173068, 0.917629129215571, 0.900800052145117, 0.9144207411674247, 0.9209624506006634, 0.9209217441909378, 0.9281619348515506, 0.46548786393728125, 0.47184726696770407, 0.4617712854851522, 0.393408342827387, 0.48252584067273463, 0.34306505794889197, 0.3916038288880299, 0.4073912583128425, 0.4488788731550001, 0.5656053707030098, 0.550541568397271, 0.6109094961542747, 0.20791086690630445, 0.5312369210448107, 0.2872641003240225, 0.561895568660195, 0.20929128129279773, 0.22742847652603382, 0.16370301752011218, 0.09537995512478936, 0.1374286847892141, 0.16050875377355645, 0.15433577433059453, 0.11471808581220189, 0.15178929095728433, 0.21215855112051285, 0.1531178215830703, 0.1595403820140886, 0.16152263105969356, 0.17946717271327306, 0.16022375481742657, 0.15942833153212355, 0.163388776494517, 0.15760343180831915, 0.18634715906478583, 0.18891361930856676, 0.005197835832853159, 0.04682664726938224, 0.06563868909850756, 0.041720158168317534, 0.00602921543749968, 0.004906097278020383, 0.041819765638344664, 0.022650423601361602, 0.03442240878183034, 0.11537862545784505, 0.10208648975046342, 0.12819522545786133, 0.06989368984328215, 0.0738465482626598, 0.1480443603041145, 0.0923026739200804, 0.13317355146391952, 0.1770894179795992, 9.999999999998899e-05, 0.048304539601233376, 0.0610242890341306, 0.0470943376695393, 0.053231451769606086, 0.06565937506392128, 0.055650846441914315, 0.11773577445176198, 0.05881505642416718, 0.09074757548882062, 0.08837684203663754, 0.07915710932766307, 0.18443856897699007, 0.13185315631935934, 0.09603299023534018, 0.12069366790500713, 0.14856410240648743, 0.12424023499936843, 0.43795737342885055, 0.4686294578951421, 0.45597338195881865, 0.4149150570921971, 0.4430253913339015, 0.4389718054233881, 0.46246174362282777, 0.4431779213954049, 0.4531711208894442, 0.11736142121608462, 0.0960137485970527, 0.10109216649305197, 0.12320854456298735, 0.13410079618805648, 0.12244396226255849, 0.11675092892276984, 0.11964644403032909, 0.1144906300394356, 0.2728091719440928, 0.21066405930806753, 0.1943725475317658, 0.16881693429625233, 0.20777423841538167, 0.19706918886787483, 0.1843686251492539, 0.19476869921567463, 0.15254137538160628, 0.3605574300049399, 0.314557270820059, 0.36675213952238284, 0.32402156499537493, 0.27595714924241876, 0.30889141312398605, 0.39660361958049106, 0.38204846532266434, 0.34253524083031395, 0.26541007358397073, 0.24466445910060775, 0.23505655262638536, 0.21346437021831866, 0.277626058213712, 0.23110962100679167, 0.2155281351422499, 0.18508592899882403, 0.21443962259054217, 0.23447528918422333, 0.23416968493470947, 0.20055223448746207, 0.22721796826252205, 0.21851220998177012, 0.21443502830860028, 0.2536590955091509, 0.2305682183819443, 0.21419053079106642, 0.44511127078650703, 0.19946225868911072, 0.1943476629860006, 0.20185146329259052, 0.17874817051065728, 0.19662825997963718, 0.18971773404386427, 0.18904721492714383, 0.19214414381901956, 0.18245359194882427, 0.18044642042508985, 0.1605337023477985, 0.6085260869766604, 0.5958250637152718, 0.6079090749158659, 0.5611333716370448, 0.16257655424334194, 0.6106045789814288, 0.5224609518116594, 0.41798973279422946, 0.6054788152197141, 0.575394557842439, 0.5279117188398843, 0.19892674352237993, 0.10904304550011368, 0.33350468286211565, 0.10239954949941699, 0.2246429619295296, 0.17579447925809488, 0.1969005748428767, 0.18305375960084203, 0.1783662159695043, 0.18368611254071543, 0.19012330958690804, 0.16910407522844761, 0.19742599521149085, 0.08701862419828954, 0.08032413857074938, 0.09412423471308973, 0.09116171414492547, 0.09343770257267914, 0.09672237886497115, 0.07989493452117002, 0.09369398975366161, 0.09538099184792515]}, "mutation_prompt": null}
{"id": "07107146-ce94-4305-b904-b65c0c0af015", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "529d85bc-93ec-4381-b6e1-5edab8af1930", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "4229e082-d010-4521-81da-a9b1b3709274", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "10f1a3cb-c513-4c7b-8a4e-be91e20de487", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, -self.memory_rate, self.memory_rate)  # Adaptive Velocity Bound\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Velocity Bound Adjustment for improved adaptability to different problem landscapes.", "configspace": "", "generation": 26, "fitness": 0.2864951092007654, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8115062249798919, 0.8210580691918425, 0.8210263945938312, 0.7608316619422533, 0.7733776204484983, 0.7895129891373552, 0.8145942392470479, 0.8028921307309844, 0.7751343894761087, 0.6749504417039489, 0.6538753931454047, 0.655966948811258, 0.5838933861083644, 0.6708054768045764, 0.592142076696805, 0.6302268567739697, 0.6718312000773479, 0.6024090439598948, 0.13476682773232873, 0.1497391863243196, 0.1362831193184837, 0.13202892798898413, 0.14901602444451678, 0.1163926437480366, 0.11840527915619148, 0.1573934825890999, 0.08979751444855355, 0.08752183892933063, 0.039072662034889794, 0.05651512114091606, 0.09083419122281067, 0.0876886423254819, 0.042448119328556855, 0.09567263036404505, 0.1168692917026678, 0.050264546575117364, 0.7299148537659089, 0.7966532747261724, 0.7414588705662322, 0.7434662854955234, 0.7383204754645338, 0.7201667573369173, 0.7526200270521287, 0.6722028273516798, 0.7326480351642736, 0.636886771139942, 0.586588688993793, 0.639751321364474, 0.60314989973122, 0.6734728757184254, 0.5925554357657059, 0.5961633928429944, 0.5917128705802723, 0.631784223798849, 0.7372258322666758, 0.7842960327081387, 0.14898019214433622, 0.2081905418799994, 0.1668003366003239, 0.18353683400291632, 0.133327755442596, 0.17052257559112383, 0.22717512550552088, 0.24073520417986105, 0.14858802331609966, 0.10899498928759799, 0.20742241643869475, 0.21029757759641565, 0.17829336126410633, 0.18935489857096766, 0.22261571675429548, 0.22629828422677223, 0.19986448825160497, 0.17363125633317544, 0.20301657196550782, 0.19098038994092204, 0.1597565801020553, 0.21675456882636335, 0.18116736725110982, 0.2188265437655338, 0.2245627597826575, 0.01404612638993874, 0.03177817914873482, 9.999999999998899e-05, 0.0519085034653175, 0.08582467319378517, 0.0024756902039194673, 0.011462499843765017, 0.006289492357876458, 0.048775382939505674, 0.07943993196955201, 0.11882388041223513, 0.16918406059338964, 0.07415981748975298, 0.05643369121902819, 0.08545042247459589, 0.11849297205181286, 0.10467130040167083, 0.08630904243857918, 0.11797940585010513, 0.09490303244148801, 0.10392950073752039, 0.10761072275111694, 0.11782919749313259, 0.10414735238060913, 0.10066272733803494, 0.1587441287803173, 0.19003349095511113, 0.12685690515618353, 0.1271264809775584, 0.2310828048174507, 0.09235814794911457, 0.1281833173216339, 0.03990880205910252, 0.18782424902184325, 0.08409145677793817, 0.07751596300895125, 0.5529430793866081, 0.4947016798298236, 0.538183656878688, 0.5007620172611452, 0.5188198665079038, 0.5169940602129992, 0.5611271660852755, 0.531364890405834, 0.5191443236206323, 0.05241672250839746, 0.07745683815264437, 0.08086760396175463, 0.08430881843759586, 0.08439554947499128, 0.10418664165963021, 0.06451150142369277, 0.12324461275769394, 0.09188120151691259, 0.1869282439410157, 0.3500254870314762, 0.196113385426664, 0.30626939777943285, 0.1895124692621062, 0.1559220867706157, 0.17132163908469034, 0.25709723554532615, 0.17200878100684536, 0.26725635910514234, 0.22145915159480445, 0.3697811662104016, 0.2894214042244567, 0.30208109948304107, 0.39807889855125, 0.21927077442967957, 0.28287852524863166, 0.24266701922271527, 0.1237738853679975, 0.2861825920584321, 0.18676850855724525, 0.23141568266643553, 0.1619163344197273, 0.17183917682896466, 0.1814654361291056, 0.2686410767201324, 0.18475278288538788, 0.22221027054023157, 0.2141048446822873, 0.20254607767774746, 0.25552772407113666, 0.203268061864469, 0.1943517447373012, 0.22718621630233815, 0.25434435105075104, 0.2159161927313925, 0.16884613780618696, 0.23731670013824624, 0.2161613286691021, 0.20133829665261493, 0.21134723253481347, 0.19068658384881476, 0.17729223580603826, 0.18718226715181596, 0.19307970933445973, 0.12159604305922078, 0.16749047499563463, 0.18200196986510275, 0.8473652773051951, 0.8296750304873699, 0.8641536600720119, 0.13998844690621115, 0.1631503975854245, 0.1718126042929896, 0.6456463162641062, 0.15003496375079084, 0.5375219632086607, 0.2041319765616476, 0.4594079063909777, 0.15114103903298015, 0.586268633773258, 0.15849495212782805, 0.6480753479412322, 0.22508014426911693, 0.19126203206840287, 0.20519664555606443, 0.22506410497928764, 0.18244300979835226, 0.22054727322048495, 0.21148313711425548, 0.17770269209394662, 0.22915502389502584, 0.07363717973604367, 0.10228350213830217, 0.0810689224909169, 0.0784090914117831, 0.09719152434665634, 0.09945523738931661, 0.0792031603094443, 0.09167037433062619, 0.10537766689415806]}, "mutation_prompt": null}
{"id": "8b7c51a0-ff2f-4fa7-bbb2-f28061426a8c", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            fitness_mean = np.mean(scores)\n            fitness_std = np.std(scores)\n            dynamic_inertia = self.inertia * (1 - (scores - fitness_mean) / (2 * fitness_std))\n            inertia_weight = np.clip(dynamic_inertia, 0.1, self.inertia)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight[:, np.newaxis] * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Adaptive Particle Swarm Optimization with Oppositional Learning and Fitness-based Dynamic Parameters.", "configspace": "", "generation": 27, "fitness": 0.316613746641517, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8586079719337665, 0.8475489364800213, 0.8630463922117116, 0.8389407912037417, 0.8432151498618975, 0.8346715866434586, 0.8558526487786644, 0.8427033167476572, 0.8368493254835185, 0.6446530892689244, 0.5992919655436797, 0.6243502898744758, 0.57695379632767, 0.6290773990749026, 0.6002400815334274, 0.6542674725464956, 0.6374462302461985, 0.6222126283335145, 0.13787792878874516, 0.1225151178723638, 0.15122491630904422, 0.10437738553584675, 0.1822636745253159, 0.11338557906711833, 0.11115512198765576, 0.1585765457003634, 0.12874886122843876, 0.11359120593322691, 0.03985311127168556, 0.07778904340498738, 0.09250709313943861, 0.07294072696563236, 0.10146031701072966, 0.09099088768370234, 0.116528808054977, 0.04129868943402548, 0.9062295931429947, 0.9401822950491295, 0.8992601308409294, 0.9107163341720591, 0.8986291341671222, 0.8798534514172712, 0.905959631817753, 0.8587543150843878, 0.8847709226965264, 0.6463921772751031, 0.6597738033204428, 0.669998140917879, 0.6514863683039647, 0.6425472882093148, 0.6481395106981396, 0.6155935675842358, 0.5549229811164131, 0.6385757776069587, 0.8511407845691307, 0.38281784789376294, 0.24224859363285878, 0.28058408104025967, 0.21172442242637513, 0.9024127524587204, 0.17707437896281664, 0.23384356147320295, 0.2166588715782266, 0.13172318043115228, 0.12412080170693096, 0.12673467684163553, 0.22246921847062562, 0.2796100659931562, 0.18995578564165772, 0.22302842693136382, 0.20782310534044435, 0.3291776540615544, 0.2173549723499023, 0.1277193926233149, 0.21048284364284198, 0.13054457436812916, 0.1753163121350113, 0.2319064155930649, 0.2288389821610357, 0.24561550667473786, 0.2406678541346402, 0.05136742513027148, 9.999999999998899e-05, 0.00925941716300116, 0.047932321190589544, 0.11408243917815575, 0.05255075837940659, 0.014262137276957243, 9.999999999998899e-05, 0.06981731034226746, 0.1680932209986007, 0.09317737268052173, 0.11896955432457468, 0.10131495046729455, 0.04010242336999548, 0.054319337114729804, 0.09836293551559061, 0.14241025760607173, 0.13165206327235368, 0.16421364840989539, 0.11900492005824548, 0.1395356976303017, 0.14303310534393954, 0.12310069844663163, 0.09643477548426926, 0.09783486953133269, 0.16332323326213116, 0.1511525784028892, 0.10446507686214013, 0.12991962039910143, 0.2390469750181221, 0.08115199621443003, 0.1212088529511528, 0.11541722015926026, 0.20573098487076613, 0.08280592733786563, 0.08273758902290407, 0.567929015049134, 0.5332341429781212, 0.5119120408008246, 0.5292461510130656, 0.5524808991193962, 0.5678500532041073, 0.5684380055001748, 0.6084894232854712, 0.6241180416756527, 0.09171820377495588, 0.07608214389949375, 0.0880741005121286, 0.12384718760392921, 0.1088208756559701, 0.1582292126544378, 0.11310491598313621, 0.11649219264781951, 0.14054886679898138, 0.3421614323635588, 0.21316285200599883, 0.21298168315735022, 0.25227791877086847, 0.31806594201941096, 0.19349409273866058, 0.18695360962120355, 0.16285211706081482, 0.2528980934423706, 0.27578994653383826, 0.31857271623838146, 0.2543087624812561, 0.2553794732952578, 0.3149824978709337, 0.3143361240549689, 0.23174108527241677, 0.4420278164830205, 0.520461576217182, 0.22110620712022022, 0.35726561666113776, 0.22908324252775603, 0.24066207296171704, 0.1606340349130333, 0.2823854961569727, 0.20740715115013275, 0.26324492352724616, 0.23278355752758118, 0.25767915519963036, 0.2156410246254863, 0.2380814471469027, 0.25812386293108924, 0.21867524035178432, 0.22864294875841928, 0.29120464216773434, 0.24377646321773816, 0.2875284642053786, 0.17939787247606165, 0.20077289820232358, 0.19981463257940224, 0.17676435971243487, 0.20820696370292002, 0.20760445960369067, 0.19924490924868732, 0.1957331298309003, 0.19661710605193972, 0.12243869835355292, 0.8849513445270174, 0.17575173637262453, 0.9147130987117624, 0.8845115525510523, 0.9032289950964708, 0.1418070743204526, 0.15910750124285222, 0.176473400782438, 0.8872054291009408, 0.15529984477668946, 0.7572590794512706, 0.2111377567835252, 0.6596832938247325, 0.4225815168926118, 0.11113384168414009, 0.7257996816536502, 0.1657544945248577, 0.22724102581358663, 0.21854535929471353, 0.20498207119568868, 0.23203252316289225, 0.19582810261112615, 0.2078941041987339, 0.22728305323937614, 0.21805512984709918, 0.20668975656945998, 0.07729621495553873, 0.0966293223768564, 0.09387650103878042, 0.11159403315815764, 0.09453678876044047, 0.1126876778159085, 0.08800159130402119, 0.11014701044814557, 0.07687930780394092]}, "mutation_prompt": null}
{"id": "32b14b05-b6c9-4121-94a5-ea067c59553c", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "db08cd3e-b62c-462a-9e2f-7a7609074e63", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "cfb67083-c39e-4dac-8647-ca3369ff6d64", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "7420ae3d-ca43-429b-adfc-ee330ccebaf8", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * ((i / self.iterations) ** 2))  # Enhanced convergence factor\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Introduced a convergence-enhancing factor to the inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.3245367765410684, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8484338899399491, 0.8518895015028591, 0.8443988351136258, 0.8343683631355671, 0.8262181328858437, 0.8455913005114523, 0.8514703992482264, 0.8434184903774794, 0.8485172413956246, 0.6573276345051404, 0.6377085532894875, 0.6435840783903222, 0.6145151381725023, 0.6357294544568732, 0.6234434216199715, 0.6254776081268353, 0.6638765554708813, 0.6450231540810685, 0.13772680269078041, 0.11901561772393066, 0.15372176057600595, 0.10384330104323403, 0.20872285673072666, 0.11277338546540827, 0.11676642906815504, 0.15464794803539494, 0.08906339305186428, 0.10770498295371467, 0.045263253873591536, 0.07940146191740782, 0.10002637989314411, 0.1219593484998992, 0.09257846441507045, 0.12102179823542503, 0.15552976778057104, 0.04610079891068286, 0.906052041387494, 0.9401811642021051, 0.8994862539239636, 0.912204293810239, 0.8994749060946678, 0.883822860807386, 0.902264949357296, 0.8552192136074361, 0.8934346729056182, 0.6724318560357848, 0.6719695713155336, 0.672372483717246, 0.6993645673664317, 0.6805463452120051, 0.6679030208943866, 0.6393740339604217, 0.6415113241281865, 0.607349124755894, 0.829468861472485, 0.8596293659684114, 0.8123938581512795, 0.28022296256566237, 0.21174163587533945, 0.3795944142179738, 0.17711366425011965, 0.23391339460948268, 0.23309026175351832, 0.1934422470392485, 0.12458611331756186, 0.2011117199666178, 0.21833116724672097, 0.27141877969120376, 0.2234153984577344, 0.21803393794657855, 0.20507421950443927, 0.31833128581743075, 0.21477148348916153, 0.24257218815477077, 0.219596785383405, 0.16180306856325055, 0.185018483889136, 0.23316472658617204, 0.2273698741726552, 0.24976869481089792, 0.2441012921161818, 0.10482406266629218, 0.06832626029489652, 0.012578791121101829, 0.11910143051647015, 0.08318824209406228, 0.04816024920528417, 0.015016432430995375, 9.999999999998899e-05, 0.06551376165361522, 0.13224782164525317, 0.08914387949419378, 0.1595633829823555, 0.0914845721351728, 0.03250887998234464, 0.05192265642092242, 0.14521690229438733, 0.09708700718261776, 0.13510621295480318, 0.3233499467858074, 0.11328852029676495, 0.2836236393249262, 0.16626321813958134, 0.11669356238973794, 0.08676264534351741, 0.10458366042844791, 0.1888440972527674, 0.14820837318055347, 0.10751258730232238, 0.10726756612306776, 0.12989156959508474, 0.03280087613490301, 0.09809355202533843, 0.14566965756399164, 0.28153560730797567, 0.08272103057532876, 0.08267171495535075, 0.5609279720235709, 0.5238083993191398, 0.5836843557260968, 0.5222544327107732, 0.5552121043706155, 0.5642940720712019, 0.5692269886618944, 0.5875506998434754, 0.5712813532987033, 0.09105762474978163, 0.06532144209787605, 0.08803944326380386, 0.10928705566018193, 0.08062957741531196, 0.14371891827793404, 0.13112775973628032, 0.10900315345033651, 0.14499732296177714, 0.19472501601500602, 0.20931175516027212, 0.1787462462831243, 0.21863912356362947, 0.3179475037447702, 0.15422231833317146, 0.39040890734624534, 0.19035578949011223, 0.1988478400865077, 0.2760368571139332, 0.38504737694129065, 0.38135988594107395, 0.2548282348196397, 0.5165234454865397, 0.30366584310979705, 0.5317160330142208, 0.5776001208599798, 0.21604596215549865, 0.22931998386653263, 0.2600373587837289, 0.23058292925703094, 0.25252333552625816, 0.19005237109409456, 0.30652098709208253, 0.2078361209891908, 0.2824446094359244, 0.22970382289119418, 0.2201657766093501, 0.23543516594660874, 0.18992655488639343, 0.2643740829494614, 0.22265406181577785, 0.22902529246373682, 0.2334065729021283, 0.2202086483973138, 0.22478059890180202, 0.2021158580921688, 0.20069946211186207, 0.2137068839864621, 0.17513105750558167, 0.2076282649154949, 0.20670981120708387, 0.2087127096452035, 0.19567949048061395, 0.17851034091811147, 0.12243845953779187, 0.8828193929378473, 0.1758828077135529, 0.9117589147404086, 0.8846050395875401, 0.9098187734838017, 0.1417381956397077, 0.1603903296376984, 0.17706693325485046, 0.7509613972654252, 0.15517198694546241, 0.7916155465323069, 0.2122517536852928, 0.6570272461376588, 0.4739727848563511, 0.1110773672658164, 0.7983098482286262, 0.16566483962763034, 0.18463564689904222, 0.2107846875747298, 0.21203847727488623, 0.19535181662786005, 0.19703601166890272, 0.19417996886144973, 0.19793855212945421, 0.18418804678523015, 0.21129324259260995, 0.07365711115354445, 0.118645582107064, 0.07811167533036112, 0.08946768173799613, 0.09131346575578714, 0.11051031137896239, 0.09688062906906836, 0.09627463641468625, 0.08794704326811786]}, "mutation_prompt": null}
{"id": "e519c1a9-4dbc-4c7d-a1fd-6ff0b40d3429", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "57d11c56-499d-4f24-bf0c-099ed5d1b9ec", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "bdf609fe-5236-4ff5-b769-fdc13d6b407f", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "6b64bb3f-1c90-4c56-83d0-bc48e313959b", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "e1513d92-1a55-4fb9-96c9-d887f41d6c40", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "837841aa-2feb-4057-a43a-5fc865596367", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined Enhanced AMPSO with Dynamic Memory Rate for adaptable exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8721972259890862, 0.8524720791663025, 0.8625742776806179, 0.8448795835254895, 0.8448080977970738, 0.8431605399124033, 0.8644749708095194, 0.8600558009195579, 0.849362031473309, 0.6736290977087145, 0.6690422727154788, 0.6528793230506522, 0.6507917486697431, 0.6741740954937671, 0.6764032269228826, 0.6220729899438935, 0.678769149854279, 0.6623669800579355, 0.1281145069173628, 0.15820509507101654, 0.1406590087878805, 0.11367690708178146, 0.15496774487566, 0.1098455744961584, 0.11941865865282486, 0.1443409812358405, 0.11931623188350005, 0.12040652721681, 0.041556232484045164, 0.08782657866033328, 0.0869922542355227, 0.09021761127314765, 0.07813423579641277, 0.10018334773560567, 0.1423662228761715, 0.06174401701597165, 0.9061541769497676, 0.9375361085370097, 0.899290897309731, 0.9111818641382197, 0.8992701027913148, 0.8891234673411167, 0.9022535265112686, 0.8546876189897784, 0.8930988823212387, 0.7223464909311461, 0.6938942645653925, 0.6745854143753562, 0.702051200259231, 0.7074709083044968, 0.7105068097892622, 0.642300476727258, 0.622413989388483, 0.6656874471377938, 0.3897453514147996, 0.3849661435020031, 0.23828883844956472, 0.2804748390909476, 0.2747468544623879, 0.37936519265969537, 0.17711366425011965, 0.23391391646191106, 0.23308029453182766, 0.20131710567885253, 0.12428953114865471, 0.19248820485439033, 0.2122910734471205, 0.38496091369524554, 0.22568908298593338, 0.21909864981324112, 0.21806800001790083, 0.2886554456666156, 0.21335820695178886, 0.2376148601126442, 0.22429228647046362, 0.1440039282773028, 0.17445162344891674, 0.22444782338961577, 0.25099833584917464, 0.24850174992660679, 0.2481348213496063, 0.0628106640180276, 0.047896814191651926, 0.0054175673751512, 0.11177517906492462, 0.08697913374242783, 0.039829393057434714, 0.014988082703029648, 9.999999999998899e-05, 0.04956454209461558, 0.12187584013337238, 0.09271431259196306, 0.17208933736111998, 0.09145941657618573, 0.03832601382609824, 0.045506725020642125, 0.1334309308487427, 0.0865049035084916, 0.09095888468410573, 0.2850524537943394, 0.11856535156844694, 0.25187270902086234, 0.17307753696278272, 0.13994960011752833, 0.08696166396975546, 0.10659036624239815, 0.1799283855887528, 0.1521703449852173, 0.10130128987677767, 0.10905527398897852, 0.13991280141869666, 0.12463918017517917, 0.10929399976979637, 0.20696945766587693, 0.254459469109486, 0.08280592097098138, 0.0827620182099259, 0.5603787974364474, 0.5253371559937653, 0.5158725404351873, 0.551117259489599, 0.62146364553073, 0.5324402514874482, 0.5959014834039345, 0.5834734576261914, 0.5689089790619964, 0.0913327037087649, 0.06390241680984599, 0.09171898242859611, 0.09957264897416629, 0.08042833501880997, 0.14386075861650804, 0.15615626486168055, 0.10923944494551086, 0.14506303735605275, 0.43416881342277414, 0.16031422722465227, 0.21608844958773377, 0.26440417684575235, 0.29828942499913513, 0.2723463575323354, 0.7001185781121582, 0.20926521789511543, 0.22116868263793865, 0.27695541581824623, 0.38211233493841024, 0.3315531699589215, 0.2553586451153347, 0.3089987955732162, 0.3274436236912912, 0.6685203800562273, 0.505839569308093, 0.6234505237667608, 0.2244574373260888, 0.36064575660151044, 0.24223439452158368, 0.2585887593952475, 0.19442215345557856, 0.24900931003711635, 0.24181395229267233, 0.257864889032432, 0.20591958412690003, 0.21827759924518564, 0.22058572563709877, 0.22434426229901683, 0.25186006513405845, 0.2222601974504601, 0.21796891074865132, 0.27314451878066714, 0.2206133364168399, 0.2271446534481738, 0.18717308393965737, 0.20071622243028253, 0.19975026762095927, 0.17596189723814737, 0.20756370934697876, 0.21632529239888332, 0.206488744697788, 0.18320412393002605, 0.1783587671361926, 0.12245107833842594, 0.8873293900640401, 0.17587083239059298, 0.9044378656580224, 0.8814263846772347, 0.9131853480939305, 0.1417520947452533, 0.16059830457683566, 0.17709464021382992, 0.7511526591746887, 0.15519990579552867, 0.7563914534075976, 0.21229295507083412, 0.7493134973213981, 0.4395203444207838, 0.11107291743050551, 0.7239194448109115, 0.1656609070221251, 0.19955364366915251, 0.2100681095719662, 0.20862870977614, 0.19329017739408494, 0.18381587611564565, 0.20622799286342075, 0.21017193763312125, 0.19422741213286465, 0.18322822681526418, 0.08862841504267183, 0.11675402848416983, 0.08127012147685686, 0.09590591427956274, 0.09180080531592683, 0.10833152491034392, 0.09954518093682163, 0.09341706866076382, 0.0727616172877853]}, "mutation_prompt": null}
{"id": "e4694d2a-268d-49ea-b249-8a14918bd2b7", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n    \n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        # Oppositional initialization\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)  # Dynamic adjustment\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            # Change 1: Adaptive social coefficient\n            self.social_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Social Coefficient for improved convergence dynamics.", "configspace": "", "generation": 38, "fitness": 0.3210580042694841, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8687412159587298, 0.8530769754899654, 0.8598299210817296, 0.841658933888446, 0.8558832169458117, 0.8481726865665532, 0.845580375481044, 0.858864433864339, 0.8400733573256747, 0.6700611456708008, 0.6594784594361102, 0.6415204577715647, 0.6635982016575901, 0.6862002411526703, 0.6527798454716054, 0.6141809251180556, 0.67436992420568, 0.6721946590956951, 0.13013992622117365, 0.1215405113261131, 0.11934582349991196, 0.11154581461109137, 0.17434104805585593, 0.12273298249322162, 0.1159927799024224, 0.13167539548635265, 0.11176333869870902, 0.10867705897941937, 0.04184234891734506, 0.08063178318414643, 0.095955508220396, 0.1292463495743028, 0.07718458234273184, 0.08385467174180883, 0.10982731931115963, 0.07656026102112878, 0.9058052736164629, 0.9379115455424543, 0.8993736938586561, 0.9115547762256837, 0.8993532827833425, 0.8891450754660618, 0.9023927388570133, 0.8547947018704214, 0.8930921424058037, 0.7075197356413353, 0.6789723852132906, 0.6198550409146227, 0.6709264092355665, 0.7345790536194727, 0.6834463805389894, 0.6571995899689927, 0.6041160459464452, 0.6626079643066407, 0.38847974733684465, 0.3834068488186172, 0.2261437577343649, 0.2803127964531652, 0.21874796031485388, 0.37863125698861455, 0.17712372474384697, 0.17753924731136705, 0.23448840113450264, 0.1290486073394952, 0.12570192055110563, 0.20172628924060132, 0.22726306096784943, 0.3004050876473262, 0.2306158622017529, 0.2142060803559661, 0.2103315993369813, 0.3249653073674723, 0.21689203189378337, 0.2326729826637488, 0.22524958079150137, 0.1776416029644643, 0.19083204024451628, 0.23174418851932865, 0.24669651502630163, 0.2505032371029261, 0.24438474227218354, 0.11468509495074009, 0.055587138871299846, 0.006210700644023404, 0.08257176669657706, 0.12347317335552566, 0.11636780935283009, 9.999999999998899e-05, 0.009426651110556072, 0.0713743755515025, 0.10740724426557713, 0.12331799596564674, 0.17608471075565646, 0.09540933357958692, 0.04694366628120894, 0.06705660755111187, 0.11528690986152756, 0.09874485096762109, 0.09111181010740088, 0.29030948489740926, 0.11938112325849703, 0.24808730906671805, 0.14842326656790028, 0.12620909035906858, 0.08509129381728087, 0.09487419557143895, 0.22835179551140683, 0.15447447375910983, 0.10892662726446378, 0.11274561399305216, 0.12014798141386651, 0.06902033773155525, 0.114540228371378, 0.1444931140078699, 0.23732573205161056, 0.08249023146920009, 0.08240501752521867, 0.5451320415426528, 0.5590352147036735, 0.5746073355012137, 0.5466395772076165, 0.5488569820012433, 0.5558747505032449, 0.5790303296890227, 0.5817771903707339, 0.5591503135663495, 0.09131186950362935, 0.05745462404949542, 0.09141478519108548, 0.09942057999526166, 0.08111295740243518, 0.14402209617884876, 0.1304531300854458, 0.10843474837105571, 0.14505895681657788, 0.2755732613930172, 0.17097397712921325, 0.18092844714956846, 0.18138907093523693, 0.319584329793261, 0.21022504283220722, 0.4036388614589509, 0.19281141650186462, 0.2852156277395288, 0.2759969822136339, 0.48570115370129074, 0.3382269830597877, 0.2544380520347731, 0.4842784619508892, 0.36214021171063093, 0.47616352075504687, 0.6132495874632652, 0.33058659000780877, 0.23026841865012304, 0.2974162898937268, 0.219015748101551, 0.2547592299597987, 0.20005230542977748, 0.2763666150008558, 0.23523237524358553, 0.30012516742383677, 0.22913578065443885, 0.23764549343927832, 0.2055797195118727, 0.23587677016143438, 0.2775131777045966, 0.2007888008108374, 0.20712653228771483, 0.2634941866117181, 0.23210769589977487, 0.22003981932291994, 0.1925603033200829, 0.2007383363923121, 0.196741139577862, 0.1837640054442985, 0.20751097794761175, 0.22026602105887527, 0.20882760888034713, 0.18685946508388807, 0.18183730313485147, 0.12244029969224446, 0.8914158162489213, 0.17506876655582415, 0.8968371934547191, 0.8904141494063862, 0.9071017338727428, 0.14174315110690294, 0.15983264204407532, 0.17709892984388576, 0.7947914485063738, 0.1552955385115905, 0.8257705795676422, 0.2123254956896129, 0.6862554179517983, 0.46243272834550175, 0.11107037307605172, 0.701242272415531, 0.1656193156343414, 0.22539031090286044, 0.20793475794934946, 0.1909315711929348, 0.1867915507399882, 0.22180314940028334, 0.23261703431932768, 0.19919391626051552, 0.1992696184900299, 0.22535942419554744, 0.10152558707029835, 0.09987597640329693, 0.08929403057655294, 0.09714836926872539, 0.10487432606434455, 0.10582779885792626, 0.0973668441604425, 0.09513608179702293, 0.07389482556791227]}, "mutation_prompt": null}
{"id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Neighborhood Topologies for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 39, "fitness": 0.33050612029764487, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "3fbfbb93-30dd-48fd-99e5-d1946bb8a936", "metadata": {"aucs": [0.8566418081359641, 0.8303423264508174, 0.8516183311494232, 0.8321490668123401, 0.8357337160793011, 0.8407005381900351, 0.8392340312331203, 0.8523015807257315, 0.8322739835209731, 0.6711846866405555, 0.6697174051455386, 0.6494660060325723, 0.6528151438749281, 0.6579920851416323, 0.6444384843507236, 0.6280763373090854, 0.6812867923765948, 0.6160562146554801, 0.13998703840760263, 0.16591170355325158, 0.16541732337444903, 0.1410632786920082, 0.15662814128840274, 0.12894422610786493, 0.12060173881079939, 0.11872724786664968, 0.17832162677128804, 0.10471476757269771, 0.0467934901435032, 0.06387815506743777, 0.11042680828397844, 0.07144807690944888, 0.05464704616408911, 0.11603757511106871, 0.11210396198525874, 0.05586191541009233, 0.9096827060287042, 0.9375361085370097, 0.899290897309731, 0.8981832528309829, 0.8974334240891066, 0.8891234673411167, 0.9061378988370403, 0.8851996708887686, 0.8930988823212387, 0.7218045694087009, 0.6676013482114826, 0.6687167832791033, 0.670739460221037, 0.6871121956867032, 0.672686363325045, 0.6405948876983021, 0.657568721845861, 0.6655500245490726, 0.8358714620291631, 0.7971397027078571, 0.22396367284700103, 0.2801709222968203, 0.2118780755221331, 0.8233041867972615, 0.17648849959274016, 0.1743438417566855, 0.23170191416019592, 0.3159684457109474, 0.12299107769257667, 0.19196127956497877, 0.2236045737643978, 0.2832598887996671, 0.2655411022016003, 0.22158130932889208, 0.20683395115752412, 0.3116999629957943, 0.24981532843999044, 0.12091273471976094, 0.22461922197043493, 0.13217939176678506, 0.21315478285890854, 0.21385093963064983, 0.24464617365345143, 0.2455448950859873, 0.12796935601029313, 0.03434053187674013, 0.04377636654386918, 0.09865447423613494, 0.05813807933707971, 0.08756170740461222, 0.07755940004325934, 0.04157510331967895, 9.999999999998899e-05, 0.012067677632501161, 0.17073869284148735, 0.10065680818554956, 0.10102060826934411, 0.05647401159743348, 0.040257879592135004, 0.047530413591438836, 0.08444105876486285, 0.09242596736439102, 0.0917997356530661, 0.1679966066227052, 0.1761204700372233, 0.1133012092557577, 0.086922706659737, 0.08581645916956171, 0.07437809964158992, 0.11295807313236605, 0.2283407610769307, 0.1363264827065488, 0.13303037254987393, 0.1407900888127257, 0.26629609715709945, 0.057334045048600846, 0.10675475432907, 0.13365930814224536, 0.21271486583516108, 0.11548523345865047, 0.08202212010721521, 0.5244320356863881, 0.5692232263763082, 0.5335327129223775, 0.5311687120229605, 0.5521606581702889, 0.5446780070971865, 0.5580426707714887, 0.5564902123707601, 0.5714519748506801, 0.11260056165583487, 0.0857229763372157, 0.09105719263574752, 0.12872523148266268, 0.10459528307834354, 0.13607915843082008, 0.14231623375241909, 0.13425221628835238, 0.16974697491574875, 0.4986462131412278, 0.21156558084087163, 0.20557610613453403, 0.44001594706238856, 0.3169062849689852, 0.28889936315186693, 0.49562373387023795, 0.22007750139182136, 0.32084748230844296, 0.4564882898220388, 0.6437980088135165, 0.4877078496063437, 0.5114375088776402, 0.3894461736543896, 0.5225134835538632, 0.6165249439755066, 0.5677938357799411, 0.2667859165899703, 0.2325802607259675, 0.3983162967842767, 0.36727605161184684, 0.3724311019209292, 0.19405995387539277, 0.2964957318206193, 0.24033720800537817, 0.27326381043809267, 0.24265624148993148, 0.22696670409366093, 0.2168905888608087, 0.20348506443142267, 0.23901389506768633, 0.23249119707153476, 0.23875167226808724, 0.2251576144705828, 0.22848814798947348, 0.22400521227911774, 0.20146551795983625, 0.24362632186584632, 0.220727157052641, 0.18749024675240267, 0.20263527614824084, 0.1825622922932002, 0.17944038701217324, 0.21942018833154786, 0.19105865148204493, 0.12245577689732123, 0.878559883928087, 0.17618516399671902, 0.904025677020762, 0.8757757359953653, 0.9030272801080885, 0.14185725392162019, 0.16774797818763731, 0.16601368514992187, 0.7623060900179983, 0.15544003955641872, 0.694457164682527, 0.2103189567266427, 0.576855365258548, 0.15352408626155412, 0.11120922025008095, 0.16564341341252897, 0.7263286483945359, 0.17889254405497146, 0.197595021042829, 0.19195004639541147, 0.18257414728741994, 0.17568788131008373, 0.18915409171382347, 0.17449222302965717, 0.18332911105416794, 0.18879219215087684, 0.09156703727549398, 0.08999233390067451, 0.0897204008234539, 0.10223194978368388, 0.09849030617251753, 0.1040358698408923, 0.08760725456180607, 0.09426424733333283, 0.08722456748905483]}, "mutation_prompt": null}
{"id": "029c3c11-1ef1-4670-960e-7bcf7e2bcd25", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.9  # Adjusted initial inertia\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def differential_mutation(self, positions):\n        F = 0.8\n        mutant_vectors = np.zeros_like(positions)\n        for i in range(self.population_size):\n            candidates = list(range(self.population_size))\n            candidates.remove(i)\n            a, b, c = np.random.choice(candidates, 3, replace=False)\n            mutant_vectors[i] = positions[a] + F * (positions[b] - positions[c])\n        return mutant_vectors\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia - (self.inertia - 0.4) * (i / self.iterations)  # Dynamic inertia\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            mutant_positions = self.differential_mutation(positions)\n            mutant_positions = np.clip(mutant_positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n            mutant_scores = np.array([func(pos) for pos in mutant_positions])\n\n            better_indices = mutant_scores < scores\n            positions[better_indices] = mutant_positions[better_indices]\n            scores[better_indices] = mutant_scores[better_indices]\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Dynamic Inertia and Differential Evolution-inspired Mutation for improved exploration and convergence.", "configspace": "", "generation": 40, "fitness": 0.23397196044164204, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.5019444787128993, 0.4513847661250443, 0.47527271310983, 0.4615728460743911, 0.4849499504784004, 0.4499369077524896, 0.49359767293815404, 0.45646872005944383, 0.45729999010211064, 0.20936914945002583, 0.18395705148640895, 0.18715665984625562, 0.16387885761425747, 0.17968755896021726, 0.15243851019933552, 0.1895349354059227, 0.16706333570710907, 0.15437621948494484, 0.10179643958874496, 0.1069723447009987, 0.12339778557891645, 0.11934325696097625, 0.10703906887783121, 0.10074569742878359, 0.10455821631849727, 0.10414182955872497, 0.12473026137226895, 0.10132288209873608, 0.09491473092273339, 0.09175369492885244, 0.0976747895548864, 0.08541416075905384, 0.0942795822689606, 0.09529177909949849, 0.09126518544621953, 0.09347967717746342, 0.9103981796598557, 0.9501814350370972, 0.9183509355850888, 0.9183818081285718, 0.8834701230005718, 0.9079806071957167, 0.911203696982513, 0.9005822304787577, 0.9147411516659524, 0.30926245888630544, 0.268914663469933, 0.26703249505946214, 0.2573588275426466, 0.26424920286271747, 0.24792883785438558, 0.2678384582424165, 0.26912163059545924, 0.265116997077966, 0.317081595408371, 0.3235805505616757, 0.3104836381724676, 0.24348756615676248, 0.31190140475299233, 0.3383007443575299, 0.31058827674142586, 0.3565321741992503, 0.7007940891936786, 0.1740279455264535, 0.15010331858668158, 0.14933996607463196, 0.14763572838855743, 0.17389440560030522, 0.14382686025042912, 0.14838735069280773, 0.16421676261256746, 0.14830300282740916, 0.1656070266102424, 0.15630065097345291, 0.16110322563320878, 0.15350352831628877, 0.15127495716956962, 0.14167795833240038, 0.15144486506939903, 0.17510467693086662, 0.1634312796203622, 0.013984540295961079, 9.999999999998899e-05, 0.0018105324034514148, 0.01229888027539161, 0.015355288642209919, 0.03429533319271527, 0.026648958397182065, 9.999999999998899e-05, 9.999999999998899e-05, 0.11013990549478936, 0.08757706784636488, 0.08409568238310294, 0.055927501117766454, 0.0740919658551471, 0.08832167539429026, 0.10606025150671416, 0.09150193324582456, 0.1139473975077595, 0.001549519238187358, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008496529396525565, 0.11279131887412308, 0.09646395288171916, 0.1110727155656478, 0.10184579256996418, 0.09415367800667684, 0.09482287168845416, 0.0856623815538915, 0.09194825378848781, 0.0901351195515917, 0.38665077782391155, 0.3976960944493658, 0.4173663441510206, 0.4033703224743308, 0.3905630895769836, 0.42989893767042886, 0.3997479581473158, 0.3968276742883017, 0.38764184129633306, 0.1127442016652862, 0.10051479505648953, 0.14681649041081946, 0.11232178444259011, 0.09870429714831896, 0.12655417316575535, 0.11565753544078594, 0.10523418984303023, 0.1202616444360528, 0.1696569921502612, 0.1624476814597109, 0.1373802131517674, 0.19541032618295817, 0.15334353279498136, 0.18209836933125412, 0.1486678973643657, 0.15036979907537462, 0.16970116420452286, 0.27501425934014234, 0.27286802592248327, 0.27368061694891854, 0.2766079282046411, 0.28537543762127815, 0.28450890981546306, 0.2898506556129117, 0.27423527940452885, 0.27752351418671783, 0.19832082644599947, 0.20985220568611318, 0.21441109928045876, 0.21660426438989488, 0.23334345587184557, 0.21772737877204895, 0.21354805096097373, 0.22430531969066847, 0.18361354279801556, 0.2245346836120774, 0.215141419745989, 0.2118204559752982, 0.20250099658487997, 0.19991463052043246, 0.24301814296650914, 0.21956726344260247, 0.21503571434309487, 0.21798971303077364, 0.17655298981753353, 0.17516722283484032, 0.18737921589039186, 0.19878670436802526, 0.18866934268295532, 0.17866387701197306, 0.18819007200107607, 0.21436691291797627, 0.20186928105469837, 0.18296991740436286, 0.18288850075802088, 0.6397900294470531, 0.673832574744461, 0.19711433623183272, 0.6522001555226391, 0.5779532291573073, 0.16692514499972877, 0.6608423926421025, 0.5047642878897713, 0.49045879494108846, 0.49072067206658854, 0.2083551719487884, 0.4658980633779015, 0.3098420254224524, 0.4333661532783978, 0.4169008295117086, 0.4993451681208104, 0.1846997788473449, 0.18516626018495563, 0.18631031710689383, 0.19410174565705618, 0.17380300968248052, 0.17158695860211515, 0.18652302463637138, 0.1891509231545292, 0.17603753190463234, 0.08916389459187468, 0.09002530685888999, 0.0920763754521613, 0.09916737184338908, 0.09422800965432321, 0.08790554528673311, 0.08591633348549854, 0.09599534847900648, 0.08329957109320729]}, "mutation_prompt": null}
{"id": "12ea621f-6ec1-4dc4-9b90-0928d88573cc", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def dynamic_parameters(self, iteration):\n        self.inertia = 0.9 - 0.5 * (iteration / self.iterations)\n        self.cognitive_coef = 1.5 + 0.5 * (iteration / self.iterations)\n        self.social_coef = 1.5 - 0.5 * (iteration / self.iterations)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.dynamic_parameters(i)\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Dynamic Parameter Adaptation for improved performance across diverse optimization landscapes.", "configspace": "", "generation": 41, "fitness": 0.31012067512808605, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.7422458981294767, 0.7360391338895691, 0.7447931261640037, 0.7140557122926088, 0.7336963017504242, 0.7141840487071938, 0.7312822992768895, 0.7238884296196821, 0.7356250874335224, 0.48076696922813955, 0.5034018371937414, 0.4547398426670255, 0.48125972798868966, 0.49016655116497354, 0.4811035327456209, 0.484387588050018, 0.47647447065593784, 0.4715831590135059, 0.23147481490009536, 0.13614054030780987, 0.1183129136468789, 0.1600092902673963, 0.16198262702385513, 0.13637159500454632, 0.11760820146394324, 0.12268822897180143, 0.1361977863945183, 0.09363429464192763, 0.07888664451903082, 0.08431439492243553, 0.12298624341388653, 0.10548122994596543, 0.09884029918615866, 0.13887353812498548, 0.10130090142888726, 0.09901640011751855, 0.9228928038380221, 0.9528316469212679, 0.9224384318795088, 0.9067503409492802, 0.9060460961180369, 0.9018515226321108, 0.9155012792328883, 0.9106324676139554, 0.9073784472334256, 0.5525535820351684, 0.5199515252658398, 0.542317333998229, 0.5515770838383687, 0.5305551677047943, 0.5159821797774875, 0.5001136879845152, 0.4939399253357889, 0.5232384760646019, 0.7023390770985185, 0.6473651533854106, 0.2247483978213498, 0.4431677705949757, 0.21649456349331708, 0.7292473531100027, 0.2286693668393076, 0.21895652347521222, 0.7886998646094616, 0.19193684597222582, 0.12930914777833824, 0.18890481087882605, 0.20127098929210985, 0.18215417893961383, 0.2334858176289143, 0.18997763201014206, 0.22961570556688626, 0.2390018182828192, 0.19264098672226715, 0.15669921751325133, 0.18159444999259144, 0.12957662514281132, 0.19072890092898143, 0.19313406832902447, 0.19756671445491547, 0.21534543265974704, 0.21699371733977002, 9.999999999998899e-05, 0.05421266207277531, 0.07864538049675307, 0.03541926954897068, 0.07118163532980071, 0.0004525540331287159, 0.02327968799501745, 9.999999999998899e-05, 0.06593828724632533, 0.15838305584211143, 0.0907092996773674, 0.13581749132443888, 0.06973940890600538, 0.048015092231980305, 0.07956553239047714, 0.10521228115543468, 0.09764076598242122, 0.08877088510876219, 0.08741297621594024, 0.06734205228443191, 0.1939967031018658, 0.03840037059412971, 0.0705876518930072, 0.05678694942672591, 0.06943096640014501, 0.07073877435664111, 0.08873103838097596, 0.14447861648658655, 0.17728262478584078, 0.21185462907123964, 0.07749102505400873, 0.19725947297751756, 0.110490467433634, 0.20895460644984076, 0.15310134343490078, 0.07962342344867845, 0.477220450538241, 0.48959595008819723, 0.47786096693224767, 0.48242659805045174, 0.5057810675828407, 0.47917514219745716, 0.4969371576417563, 0.4968220355509163, 0.5002493045973155, 0.10382089541414807, 0.13337742217163617, 0.0962818801245039, 0.12316382442090468, 0.13054560739571042, 0.1264328723039707, 0.14420503784260874, 0.13155504718177657, 0.11043353365021957, 0.34913086091821643, 0.3062210311701581, 0.4513685074352727, 0.28230113572824056, 0.32982794334736565, 0.3258917362114737, 0.3917856605946394, 0.2915594654399247, 0.3067901804030525, 0.41151862932929184, 0.4497835085938606, 0.44053932721721833, 0.41443640849407515, 0.3579705766124087, 0.4549148990349495, 0.4646901122062159, 0.4398804435702738, 0.4655255452268421, 0.23402711271194543, 0.3478318175756221, 0.333729579005003, 0.29253148728180645, 0.2942036357235872, 0.3148298270229897, 0.23518406425150895, 0.26008771958596777, 0.22497064976400105, 0.23045388333761707, 0.21100106634755256, 0.1993794555478532, 0.21790792955561122, 0.2178577759338145, 0.24516669705340377, 0.22429365466445716, 0.2241955308046336, 0.222031242647722, 0.18337415010130453, 0.17956489649281482, 0.2156587004549998, 0.19862726573837586, 0.21279183566787874, 0.19199929939902438, 0.20937344394106783, 0.18851501031939888, 0.6000140927043871, 0.12230666918392286, 0.1850779634201003, 0.17582894040084307, 0.8409672563276318, 0.7926025409698758, 0.8281476623208923, 0.1417507484926378, 0.16705940338188485, 0.16614135477297964, 0.548129516580319, 0.6367324197394986, 0.7181880131157786, 0.20891870073365892, 0.5810805283795248, 0.15311211161261395, 0.7210487050997074, 0.6104597696788223, 0.6416747892081555, 0.1902141656096179, 0.18521605904833005, 0.17433770241167368, 0.18223554983762835, 0.18239719121403264, 0.18819759623024013, 0.18455290709317262, 0.1804250425878865, 0.19425534927836818, 0.09287574002670407, 0.08891742553257664, 0.10304097744743868, 0.09446413385251617, 0.09694691018631496, 0.0932461865703701, 0.09411505451062052, 0.09078553819827406, 0.09385484608462158]}, "mutation_prompt": null}
{"id": "25eddb12-af71-4496-ab25-7ee4605987ec", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Neighborhood Topologies for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8566418081359641, 0.8303423264508174, 0.8516183311494232, 0.8321490668123401, 0.8357337160793011, 0.8407005381900351, 0.8392340312331203, 0.8523015807257315, 0.8322739835209731, 0.6711846866405555, 0.6697174051455386, 0.6494660060325723, 0.6528151438749281, 0.6579920851416323, 0.6444384843507236, 0.6280763373090854, 0.6812867923765948, 0.6160562146554801, 0.13998703840760263, 0.16591170355325158, 0.16541732337444903, 0.1410632786920082, 0.15662814128840274, 0.12894422610786493, 0.12060173881079939, 0.11872724786664968, 0.17832162677128804, 0.10471476757269771, 0.0467934901435032, 0.06387815506743777, 0.11042680828397844, 0.07144807690944888, 0.05464704616408911, 0.11603757511106871, 0.11210396198525874, 0.05586191541009233, 0.9096827060287042, 0.9375361085370097, 0.899290897309731, 0.8981832528309829, 0.8974334240891066, 0.8891234673411167, 0.9061378988370403, 0.8851996708887686, 0.8930988823212387, 0.7218045694087009, 0.6676013482114826, 0.6687167832791033, 0.670739460221037, 0.6871121956867032, 0.672686363325045, 0.6405948876983021, 0.657568721845861, 0.6655500245490726, 0.8358714620291631, 0.7971397027078571, 0.22396367284700103, 0.2801709222968203, 0.2118780755221331, 0.8233041867972615, 0.17648849959274016, 0.1743438417566855, 0.23170191416019592, 0.3159684457109474, 0.12299107769257667, 0.19196127956497877, 0.2236045737643978, 0.2832598887996671, 0.2655411022016003, 0.22158130932889208, 0.20683395115752412, 0.3116999629957943, 0.24981532843999044, 0.12091273471976094, 0.22461922197043493, 0.13217939176678506, 0.21315478285890854, 0.21385093963064983, 0.24464617365345143, 0.2455448950859873, 0.12796935601029313, 0.03434053187674013, 0.04377636654386918, 0.09865447423613494, 0.05813807933707971, 0.08756170740461222, 0.07755940004325934, 0.04157510331967895, 9.999999999998899e-05, 0.012067677632501161, 0.17073869284148735, 0.10065680818554956, 0.10102060826934411, 0.05647401159743348, 0.040257879592135004, 0.047530413591438836, 0.08444105876486285, 0.09242596736439102, 0.0917997356530661, 0.1679966066227052, 0.1761204700372233, 0.1133012092557577, 0.086922706659737, 0.08581645916956171, 0.07437809964158992, 0.11295807313236605, 0.2283407610769307, 0.1363264827065488, 0.13303037254987393, 0.1407900888127257, 0.26629609715709945, 0.057334045048600846, 0.10675475432907, 0.13365930814224536, 0.21271486583516108, 0.11548523345865047, 0.08202212010721521, 0.5244320356863881, 0.5692232263763082, 0.5335327129223775, 0.5311687120229605, 0.5521606581702889, 0.5446780070971865, 0.5580426707714887, 0.5564902123707601, 0.5714519748506801, 0.11260056165583487, 0.0857229763372157, 0.09105719263574752, 0.12872523148266268, 0.10459528307834354, 0.13607915843082008, 0.14231623375241909, 0.13425221628835238, 0.16974697491574875, 0.4986462131412278, 0.21156558084087163, 0.20557610613453403, 0.44001594706238856, 0.3169062849689852, 0.28889936315186693, 0.49562373387023795, 0.22007750139182136, 0.32084748230844296, 0.4564882898220388, 0.6437980088135165, 0.4877078496063437, 0.5114375088776402, 0.3894461736543896, 0.5225134835538632, 0.6165249439755066, 0.5677938357799411, 0.2667859165899703, 0.2325802607259675, 0.3983162967842767, 0.36727605161184684, 0.3724311019209292, 0.19405995387539277, 0.2964957318206193, 0.24033720800537817, 0.27326381043809267, 0.24265624148993148, 0.22696670409366093, 0.2168905888608087, 0.20348506443142267, 0.23901389506768633, 0.23249119707153476, 0.23875167226808724, 0.2251576144705828, 0.22848814798947348, 0.22400521227911774, 0.20146551795983625, 0.24362632186584632, 0.220727157052641, 0.18749024675240267, 0.20263527614824084, 0.1825622922932002, 0.17944038701217324, 0.21942018833154786, 0.19105865148204493, 0.12245577689732123, 0.878559883928087, 0.17618516399671902, 0.904025677020762, 0.8757757359953653, 0.9030272801080885, 0.14185725392162019, 0.16774797818763731, 0.16601368514992187, 0.7623060900179983, 0.15544003955641872, 0.694457164682527, 0.2103189567266427, 0.576855365258548, 0.15352408626155412, 0.11120922025008095, 0.16564341341252897, 0.7263286483945359, 0.17889254405497146, 0.197595021042829, 0.19195004639541147, 0.18257414728741994, 0.17568788131008373, 0.18915409171382347, 0.17449222302965717, 0.18332911105416794, 0.18879219215087684, 0.09156703727549398, 0.08999233390067451, 0.0897204008234539, 0.10223194978368388, 0.09849030617251753, 0.1040358698408923, 0.08760725456180607, 0.09426424733333283, 0.08722456748905483]}, "mutation_prompt": null}
{"id": "47d7e8fa-09c5-49f8-84f4-5b8cfa3626cb", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Neighborhood Topologies for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8566418081359641, 0.8303423264508174, 0.8516183311494232, 0.8321490668123401, 0.8357337160793011, 0.8407005381900351, 0.8392340312331203, 0.8523015807257315, 0.8322739835209731, 0.6711846866405555, 0.6697174051455386, 0.6494660060325723, 0.6528151438749281, 0.6579920851416323, 0.6444384843507236, 0.6280763373090854, 0.6812867923765948, 0.6160562146554801, 0.13998703840760263, 0.16591170355325158, 0.16541732337444903, 0.1410632786920082, 0.15662814128840274, 0.12894422610786493, 0.12060173881079939, 0.11872724786664968, 0.17832162677128804, 0.10471476757269771, 0.0467934901435032, 0.06387815506743777, 0.11042680828397844, 0.07144807690944888, 0.05464704616408911, 0.11603757511106871, 0.11210396198525874, 0.05586191541009233, 0.9096827060287042, 0.9375361085370097, 0.899290897309731, 0.8981832528309829, 0.8974334240891066, 0.8891234673411167, 0.9061378988370403, 0.8851996708887686, 0.8930988823212387, 0.7218045694087009, 0.6676013482114826, 0.6687167832791033, 0.670739460221037, 0.6871121956867032, 0.672686363325045, 0.6405948876983021, 0.657568721845861, 0.6655500245490726, 0.8358714620291631, 0.7971397027078571, 0.22396367284700103, 0.2801709222968203, 0.2118780755221331, 0.8233041867972615, 0.17648849959274016, 0.1743438417566855, 0.23170191416019592, 0.3159684457109474, 0.12299107769257667, 0.19196127956497877, 0.2236045737643978, 0.2832598887996671, 0.2655411022016003, 0.22158130932889208, 0.20683395115752412, 0.3116999629957943, 0.24981532843999044, 0.12091273471976094, 0.22461922197043493, 0.13217939176678506, 0.21315478285890854, 0.21385093963064983, 0.24464617365345143, 0.2455448950859873, 0.12796935601029313, 0.03434053187674013, 0.04377636654386918, 0.09865447423613494, 0.05813807933707971, 0.08756170740461222, 0.07755940004325934, 0.04157510331967895, 9.999999999998899e-05, 0.012067677632501161, 0.17073869284148735, 0.10065680818554956, 0.10102060826934411, 0.05647401159743348, 0.040257879592135004, 0.047530413591438836, 0.08444105876486285, 0.09242596736439102, 0.0917997356530661, 0.1679966066227052, 0.1761204700372233, 0.1133012092557577, 0.086922706659737, 0.08581645916956171, 0.07437809964158992, 0.11295807313236605, 0.2283407610769307, 0.1363264827065488, 0.13303037254987393, 0.1407900888127257, 0.26629609715709945, 0.057334045048600846, 0.10675475432907, 0.13365930814224536, 0.21271486583516108, 0.11548523345865047, 0.08202212010721521, 0.5244320356863881, 0.5692232263763082, 0.5335327129223775, 0.5311687120229605, 0.5521606581702889, 0.5446780070971865, 0.5580426707714887, 0.5564902123707601, 0.5714519748506801, 0.11260056165583487, 0.0857229763372157, 0.09105719263574752, 0.12872523148266268, 0.10459528307834354, 0.13607915843082008, 0.14231623375241909, 0.13425221628835238, 0.16974697491574875, 0.4986462131412278, 0.21156558084087163, 0.20557610613453403, 0.44001594706238856, 0.3169062849689852, 0.28889936315186693, 0.49562373387023795, 0.22007750139182136, 0.32084748230844296, 0.4564882898220388, 0.6437980088135165, 0.4877078496063437, 0.5114375088776402, 0.3894461736543896, 0.5225134835538632, 0.6165249439755066, 0.5677938357799411, 0.2667859165899703, 0.2325802607259675, 0.3983162967842767, 0.36727605161184684, 0.3724311019209292, 0.19405995387539277, 0.2964957318206193, 0.24033720800537817, 0.27326381043809267, 0.24265624148993148, 0.22696670409366093, 0.2168905888608087, 0.20348506443142267, 0.23901389506768633, 0.23249119707153476, 0.23875167226808724, 0.2251576144705828, 0.22848814798947348, 0.22400521227911774, 0.20146551795983625, 0.24362632186584632, 0.220727157052641, 0.18749024675240267, 0.20263527614824084, 0.1825622922932002, 0.17944038701217324, 0.21942018833154786, 0.19105865148204493, 0.12245577689732123, 0.878559883928087, 0.17618516399671902, 0.904025677020762, 0.8757757359953653, 0.9030272801080885, 0.14185725392162019, 0.16774797818763731, 0.16601368514992187, 0.7623060900179983, 0.15544003955641872, 0.694457164682527, 0.2103189567266427, 0.576855365258548, 0.15352408626155412, 0.11120922025008095, 0.16564341341252897, 0.7263286483945359, 0.17889254405497146, 0.197595021042829, 0.19195004639541147, 0.18257414728741994, 0.17568788131008373, 0.18915409171382347, 0.17449222302965717, 0.18332911105416794, 0.18879219215087684, 0.09156703727549398, 0.08999233390067451, 0.0897204008234539, 0.10223194978368388, 0.09849030617251753, 0.1040358698408923, 0.08760725456180607, 0.09426424733333283, 0.08722456748905483]}, "mutation_prompt": null}
{"id": "3115e9da-b56f-4f70-9faa-a31132fe58de", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.9  # Adjusted from 0.7 for better exploration\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Improved EnhancedAMPSO by adjusting inertia weight for balance between exploration and exploitation.", "configspace": "", "generation": 44, "fitness": 0.2963430848010726, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.6809820913758416, 0.6651036553218492, 0.6693003830840606, 0.659170759332786, 0.693771143278975, 0.683236458219109, 0.6917702325202947, 0.6738770590971714, 0.6689295330293465, 0.43819189573336514, 0.4287402726858278, 0.4196090693879547, 0.46143711296491374, 0.4321136205902899, 0.4159423160672032, 0.4204717121526492, 0.3995542312025827, 0.4444407504589798, 0.1432485379945192, 0.1487327165384288, 0.13584944228783302, 0.13500187440092026, 0.3460463370089959, 0.11596600773045806, 0.1399776745607325, 0.1077163959350892, 0.13287057959177695, 0.10322865936382153, 0.07848866063228721, 0.07702959819490296, 0.1080344324393665, 0.10732531830057324, 0.10172870759781727, 0.11598391887964354, 0.10050345262169613, 0.09626216082226569, 0.9237654372013896, 0.9529366455502313, 0.9225465157938286, 0.9067141234478716, 0.9061375688030386, 0.902362631989115, 0.9180503527341646, 0.9153284397265969, 0.9106766295046141, 0.4742002548106763, 0.5045784048908947, 0.47094439747913397, 0.4720746374884215, 0.5257064173091324, 0.48597087963146346, 0.4718734127861658, 0.4537593799106727, 0.48728930307339846, 0.6434864115665028, 0.6585061061306775, 0.26639947985167756, 0.2164083748473702, 0.27385957354915214, 0.6341827358657899, 0.22835617934715313, 0.2302621551404067, 0.6829930268118471, 0.1862589250346558, 0.1274325287548721, 0.1745419381729778, 0.17772230895793395, 0.19611566027645244, 0.19451949101493848, 0.17809076001932167, 0.19828837186911286, 0.22237856244176468, 0.18819268058856697, 0.1784673463220161, 0.18019993622644292, 0.17309837044101006, 0.18240005307390794, 0.1903778871838614, 0.2010370646508628, 0.2149417308137357, 0.20492567147809426, 0.002465227654064095, 0.0048090551906671, 0.07048524657262079, 0.014800125188640378, 0.0074460938506683005, 0.042151064643334624, 0.031569065810282515, 0.00014500179173249084, 0.058974705171108366, 0.15510066043325532, 0.0973655900306305, 0.13244269954380672, 0.0755778462819886, 0.058668942682639, 0.07691766645182374, 0.09711145944427535, 0.09484660882380447, 0.10546870087043558, 0.0734951433445391, 0.06576649945455448, 0.12709473996767007, 0.04078828369777909, 0.05734598398752755, 0.048354579686343824, 0.06138871474958163, 0.0715152572029456, 0.08814268072371656, 0.15030134149622354, 0.11978614854615555, 0.14067233850862615, 0.12098708285313264, 0.14623693977036656, 0.10864217332827264, 0.13705465767445435, 0.12802001713631395, 0.07559498011225174, 0.4662445200279852, 0.4615699790140254, 0.4679734502061801, 0.4787539763264629, 0.48132995028458103, 0.46722701514225595, 0.47714437635509743, 0.4880813168565856, 0.4707356703531962, 0.13598069029881021, 0.1068229254246369, 0.11098967563572093, 0.12113430629737754, 0.1111337627649891, 0.13480836906031834, 0.13051649804087406, 0.11963140246163606, 0.14081726507648618, 0.4326663811247058, 0.4177239640127218, 0.3010851220619205, 0.24935842577107392, 0.3995576082720118, 0.2909930961114946, 0.3422919426719008, 0.317158054380998, 0.3372893406953775, 0.40835826959773025, 0.39549988740520114, 0.43639650332813684, 0.3958969341016225, 0.4143326332516194, 0.4190723377345926, 0.405639601628465, 0.46357555726921706, 0.4280277585397111, 0.26790357890732186, 0.3122560185831794, 0.2761859005740195, 0.2538093662921982, 0.23684489262360142, 0.34323108604673136, 0.23072393730871454, 0.33437889677808286, 0.23092040898243849, 0.2623759874640458, 0.2604264179915582, 0.2203270956458213, 0.22911795827790715, 0.20223643494859211, 0.23111003829922072, 0.20365913875646968, 0.19703840522504734, 0.20744931726138827, 0.17625461087938443, 0.17865408241196346, 0.2250189092709155, 0.19198944799868178, 0.1974051692094092, 0.1951636215415653, 0.19105711560314653, 0.19205135090830083, 0.18958159913112915, 0.1223129626018935, 0.1851590802390397, 0.1744116413449095, 0.7949464139644296, 0.7601441648517341, 0.8076074855565858, 0.14175350997081715, 0.16706330846350537, 0.16580063814174795, 0.5581891178791438, 0.6727523086686178, 0.6950404906453563, 0.2090889930103531, 0.5766439716617625, 0.1534268586484594, 0.6534221690010547, 0.6013509425721288, 0.6349849709877435, 0.18563262378671086, 0.22964677044351278, 0.19376382017295357, 0.17960674746535243, 0.18471606194594947, 0.1784466727043642, 0.18007532759457645, 0.1859738798086904, 0.18580255840969861, 0.08841642412401629, 0.09621237110521363, 0.0888417339988351, 0.09127252525598561, 0.09267033940996805, 0.09195515240642782, 0.08880583276057818, 0.09804194530411847, 0.09660829097640744]}, "mutation_prompt": null}
{"id": "6d582bc4-783c-491a-9eb4-69954fdcef61", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.9  # Increased inertia for better exploration\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n        self.mutation_prob = 0.2  # Probability of applying differential mutation\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def differential_mutation(self, positions):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = positions[idxs]\n        mutant = a + 0.8 * (b - c)\n        return np.clip(mutant, self.pos_bounds[0], self.pos_bounds[1])\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n\n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            if np.random.rand() < self.mutation_prob:\n                for j in range(self.population_size):\n                    mutant = self.differential_mutation(positions)\n                    if func(mutant) < scores[j]:\n                        positions[j] = mutant\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Dynamic Inertia and Differential Mutation for improved exploration and convergence in diverse optimization landscapes.", "configspace": "", "generation": 45, "fitness": 0.27757066087926036, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.6143437084639989, 0.6005987728554405, 0.6460135782826533, 0.6187157299650969, 0.584908966846076, 0.6580825269947217, 0.6024209420115076, 0.6072776880719848, 0.6199516108548467, 0.32883167361536514, 0.3257760792777554, 0.3305517344545248, 0.3347730379556354, 0.3291673162378671, 0.3798817703241055, 0.3208168201907915, 0.3186901067603327, 0.3065781962671802, 0.1271982055000621, 0.12222207737030621, 0.13406623563023845, 0.11744898364347323, 0.12851727209696273, 0.1198140905498436, 0.09171080456049385, 0.09929532234484195, 0.24596047597773074, 0.10032035070086565, 0.09574102322708877, 0.09973549946241744, 0.09868033187341751, 0.07879543222539453, 0.1003886261449739, 0.11087961696443904, 0.09977136886914884, 0.0933272842863051, 0.9258176628518828, 0.9277980431104456, 0.9191972576579218, 0.9270340624502318, 0.9054142419852077, 0.9285660664329082, 0.9296294633534117, 0.9248418114039343, 0.8978140033408797, 0.3759326337142379, 0.3767586985735556, 0.3894759007429287, 0.38588007704477234, 0.36459606557032764, 0.3980096766702025, 0.36523608992012946, 0.37586061952858085, 0.386630131548631, 0.492252483347997, 0.5517682675308897, 0.4858735617792538, 0.5700721636828996, 0.3202939516574578, 0.6312799103072333, 0.5158084823085365, 0.22740098248849516, 0.5075381746690959, 0.1720699191571251, 0.12374388925128021, 0.17262584036783446, 0.15720387178554318, 0.1780547706240121, 0.25189208472015157, 0.16522739222973104, 0.21118724574969394, 0.18363426010353112, 0.17749907233724516, 0.17882284183043085, 0.1721924445370412, 0.16741416501605433, 0.1724440615663725, 0.15714498082537542, 0.19435302908901408, 0.18332569546670208, 0.18654824839508688, 0.017838209107417957, 0.04717994356247923, 0.03639020263542336, 0.037107358733349805, 0.028881792582545307, 0.03451919554728666, 0.03723300513468397, 0.03726639881610094, 0.002472500585756876, 0.12876967724376698, 0.12722354619796006, 0.14468408835280844, 0.07538055530984733, 0.04499807157884117, 0.09512681115626442, 0.0899800064940568, 0.12783585887404203, 0.11544327824647571, 0.028842295751554614, 0.03651470904184606, 0.11797101339782079, 0.06058603875016155, 0.04261296270502246, 0.03164865896007485, 0.04902496975276194, 0.08193955622178806, 0.05725009035865336, 0.1341309477441609, 0.12338162367339445, 0.10338982564564048, 0.12075331646411469, 0.1526191885102015, 0.19453775256248362, 0.11676235069011542, 0.10545278938945957, 0.07345349950649327, 0.4374076311049533, 0.433748619810022, 0.4537849523679932, 0.43882095626229345, 0.43484917890516106, 0.4321202944598006, 0.4708731084752872, 0.4615856946057709, 0.45355993153269414, 0.11299760311367846, 0.11597305367925514, 0.12522539306530056, 0.11779366355878573, 0.1257142546381358, 0.11769969844731953, 0.10415939540196373, 0.11600310778215939, 0.13741476549660414, 0.28720683743330977, 0.31950928187887206, 0.2435120607020832, 0.24818048122453884, 0.3499158870177256, 0.21750929572161926, 0.2735226971602557, 0.25954085434025087, 0.3362675942822173, 0.3436222956948817, 0.3273384086931014, 0.34837320942934935, 0.34387413692009894, 0.34695335708014363, 0.371901821676361, 0.36001723632899596, 0.3705528754078278, 0.344540498142756, 0.2455054074312123, 0.2741304720180583, 0.23128978762235397, 0.2743128186854845, 0.22368799640039694, 0.27912833198114195, 0.22787105810653152, 0.26998469900527666, 0.21864333171246697, 0.2040694814992502, 0.21821640974369716, 0.23983196224935588, 0.24576308897776233, 0.2253760200210163, 0.19618935187867215, 0.2305197529131756, 0.23384479413748793, 0.21490678977806488, 0.18956420403986618, 0.1805017873271476, 0.1947540226921135, 0.2308186623021522, 0.20207866112702144, 0.18440775490189976, 0.19136584015774072, 0.20913136496882667, 0.21323969520587327, 0.1834794447590089, 0.18502542898272378, 0.15152865088335488, 0.7907812548697104, 0.7440562349601142, 0.8059920025817949, 0.7399025735087554, 0.16672220332813525, 0.15765150859678356, 0.5780992962324978, 0.5712263173545328, 0.6796555711848229, 0.20854812251003962, 0.564638702411492, 0.1548121729071399, 0.11426410286178013, 0.5871141558942392, 0.5817502601737343, 0.18593642324719872, 0.1838361218537261, 0.18035600467717983, 0.18482473004856637, 0.17594919727306046, 0.18126864376369345, 0.19253765211358476, 0.16798991202923685, 0.18816238320716738, 0.10350886553804539, 0.09469630641820659, 0.09943278298883595, 0.0903623079088004, 0.0892812599818189, 0.09164828383400636, 0.08988365496681949, 0.09953359707185061, 0.096983293405145]}, "mutation_prompt": null}
{"id": "1cdd972e-cf57-4e16-9e29-9b1f6288a775", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef_base = 1.5  # Base for cognitive coefficient\n        self.social_coef_base = 1.5  # Base for social coefficient\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n            \n            # Randomize cognitive and social coefficients\n            cognitive_coef = self.cognitive_coef_base * np.random.uniform(0.8, 1.2)\n            social_coef = self.social_coef_base * np.random.uniform(0.8, 1.2)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          cognitive_coef * r1 * (pbest_positions - positions) +\n                          social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Randomized Cognitive and Social Coefficients for improved exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.32674942121443823, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8528872565624099, 0.8424429120536998, 0.852071701042936, 0.8288588107194986, 0.8193172566679259, 0.8380199600139552, 0.8235549077414536, 0.8415138072206512, 0.8248248456238422, 0.6828318066321213, 0.6599527500948956, 0.6726183467805541, 0.6468002917311547, 0.6436494515052739, 0.6803577217656369, 0.649374939668921, 0.647840549144153, 0.6627186045402755, 0.12346400586462025, 0.1458899010519472, 0.1765459971342711, 0.15284791062547043, 0.17531595191395122, 0.17844815626145938, 0.10263615326856435, 0.13957456618946162, 0.10809527813061937, 0.10965420404241233, 0.057625718212194754, 0.08010755891217125, 0.0979751442829443, 0.11428891680675701, 0.0576505988364745, 0.11359391871994484, 0.11378439505382942, 0.07520099778508171, 0.9150020918921028, 0.9140331580270602, 0.8949938735709634, 0.9104768407002578, 0.8973140796909667, 0.909312986103265, 0.8941263026897291, 0.8808676584586438, 0.8758490683872326, 0.6887069299902608, 0.6648276510823701, 0.6748415720863417, 0.6905209608846652, 0.6824946607319664, 0.663569677987269, 0.6416712715781064, 0.6521278424912168, 0.6535954082994639, 0.8116702801202009, 0.8208278384456413, 0.8359559476786038, 0.277048342170237, 0.21068913057100536, 0.2781476116340247, 0.17583878432248945, 0.2343306840964875, 0.23336838055419762, 0.24461978377122617, 0.13094783869103643, 0.20265834695436902, 0.2034732880141027, 0.2036525590651065, 0.24550958965444636, 0.20752837473486618, 0.2494730732049102, 0.26875106425136597, 0.21474175691951192, 0.11470341707995979, 0.22978860168901694, 0.3030568205291049, 0.13047031196527947, 0.2415255223270315, 0.2586476947152607, 0.24086052879368391, 0.25003269023755936, 0.007284690978433539, 0.04629983858878661, 0.00863480901653313, 0.024974240443343065, 0.06648111223848063, 0.0018287187198288146, 0.053911838666581335, 0.00883874918272154, 0.06732950437885488, 0.12039571858138043, 0.0922462822407879, 0.10067326077480487, 0.0514994107334924, 0.039296247597954026, 0.05845598399629304, 0.17497901269101745, 0.1016876456792779, 0.0937982498187695, 0.09163025268395508, 0.06630607080126816, 0.12686557285686828, 0.09417129691545434, 0.0870314397792401, 0.08713336094618862, 0.09192271939261665, 0.14698321722274055, 0.10845658060352648, 0.1521944219794017, 0.1323173732611702, 0.3184691249691187, 0.09521262924038143, 0.2253457416751421, 0.15132406030929724, 0.11984855937332572, 0.08157257530456175, 0.08157646915869776, 0.5448257175567414, 0.5393856337774802, 0.5316960290819215, 0.5606899860338788, 0.5233106348150893, 0.550223241216546, 0.5567508947236781, 0.5513395530542233, 0.56652241148977, 0.08481724909779076, 0.062204548205107346, 0.14847685564061175, 0.13421849772140415, 0.09080977098478638, 0.138641310605348, 0.1068780300512504, 0.13366401274039452, 0.13501258910944414, 0.587630333443739, 0.1899142005205272, 0.2751222237053792, 0.43096400936314083, 0.31680743166534764, 0.26462998179151986, 0.4670088344893827, 0.42224625187581233, 0.3772448634326184, 0.5370850470790562, 0.5655803590655726, 0.5577803694842381, 0.5558442901201374, 0.46491743455733436, 0.5780640706548352, 0.42854734608011336, 0.5155591173061531, 0.2647847352868945, 0.23097163061344317, 0.33778669085500146, 0.22881972505928305, 0.2889471978794179, 0.1720374691156239, 0.26248229584108884, 0.24023938726596183, 0.45669163046499484, 0.24137425587753558, 0.24277311314239292, 0.22100492013525197, 0.21352635510067874, 0.23196398032141485, 0.2244490789231779, 0.22736412271322648, 0.2400012734425021, 0.22803663980990518, 0.19850183522384268, 0.21692098737434085, 0.17110641075831812, 0.2035756875576561, 0.17844964057568136, 0.19888574963573802, 0.1991712537432222, 0.17554422216558163, 0.19580521558797426, 0.19746504748805116, 0.12214103484752736, 0.17656220355872942, 0.17639357044828663, 0.9037030855753306, 0.8643619533532613, 0.9194597345173061, 0.14149292754874554, 0.1658138015993067, 0.16713882692882798, 0.8367754284463045, 0.21049471325273827, 0.6011486601455907, 0.21181912950595438, 0.53307494934883, 0.1552273431523139, 0.11061677665660286, 0.7381216445337397, 0.10350523552571067, 0.199475154763602, 0.20054131012626752, 0.2099244103165574, 0.18787881100560877, 0.17684055203529425, 0.1901377580511655, 0.18586418899883828, 0.1786313197706395, 0.19014675455747287, 0.08320324756184672, 0.08996701133616258, 0.09255785768933855, 0.10344094371197954, 0.09152998315923888, 0.10065873559139327, 0.09257619894950964, 0.08865234517357279, 0.10294132783205934]}, "mutation_prompt": null}
{"id": "5f605da7-27ca-4b7e-a47d-80d9b6f811eb", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.7  # Slightly adjusted for improved exploration-exploitation\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with improved parameter tuning for better exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.32605218044035417, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.83293091613207, 0.8234431285261881, 0.8299274511475239, 0.8160545769386958, 0.8245705440753739, 0.8344759850916039, 0.8314256014685606, 0.8365261908024314, 0.825067396423006, 0.6522849744080278, 0.6285077340219034, 0.6558806788094194, 0.6109321141580355, 0.6125050469614597, 0.6344100866047881, 0.6161494946279038, 0.6384199265517669, 0.6452013892032706, 0.16337793230357545, 0.14500700887681794, 0.1463990111152651, 0.14829428391741117, 0.5024491321336548, 0.11405085583340746, 0.130761060404064, 0.14704170966991892, 0.14019112026839575, 0.11325990729918645, 0.06736575841604586, 0.06315428368384945, 0.12116417474938934, 0.11223456897775541, 0.05941409868604863, 0.10060348756458293, 0.11396577122718476, 0.046070871334759955, 0.9062204729079238, 0.9375361085370097, 0.899290897309731, 0.8981848450905807, 0.8975848931992246, 0.8834555311296277, 0.9064034781453705, 0.885199834526996, 0.8930983420789096, 0.6201480660172403, 0.6468300466036632, 0.633396299166394, 0.6561989178014211, 0.6577107785265623, 0.6415107381774965, 0.6043755548344368, 0.6210605852700763, 0.5575207307369974, 0.7737536081521563, 0.7860619162276724, 0.6298758903947277, 0.2799593642774938, 0.21351655872546849, 0.27951296114953417, 0.17572238155110753, 0.17583362706681804, 0.22843619766925205, 0.40812069745715296, 0.12761548944319367, 0.12814756946874695, 0.22314924602790165, 0.2534133871470292, 0.24906057429182382, 0.2040340896339441, 0.2026591597280495, 0.39576416267816317, 0.242394780059905, 0.12697725580654273, 0.21346513852820004, 0.14606298312521593, 0.22144586072738015, 0.22927496463111985, 0.23889754774117156, 0.23605994606524416, 0.2437285987703608, 0.017399269990529542, 0.050965835710555574, 0.025540346121895374, 0.058519855352623384, 0.05475795394553751, 0.0018380277676119938, 0.04236862279094, 9.999999999998899e-05, 0.011013120729405634, 0.20721219841681027, 0.0989548781422871, 0.09976845274878521, 0.06824429068638294, 0.03791309985150948, 0.046890368752816936, 0.11346803497712066, 0.09593943295729168, 0.0954465356322316, 0.14296732830392866, 0.14146051620929478, 0.09031465895563884, 0.08476087716699165, 0.08597648824170834, 0.07414880366552479, 0.08641145227027136, 0.19120683499442126, 0.15511679446686233, 0.13193017960397935, 0.13862113819636634, 0.15733219607364646, 0.05519704598486608, 0.10175865700009057, 0.2891722735247244, 0.23838215458237777, 0.15584213450233309, 0.08226927519106941, 0.5296660530746753, 0.5089454785896517, 0.5276028968240203, 0.5508820647474574, 0.5425495426197482, 0.5329579711068723, 0.5377143770879251, 0.5670859409598952, 0.5343929619949424, 0.0936339092192926, 0.07684698855717598, 0.11106815708095397, 0.09275504690803571, 0.11208496263570866, 0.10887278935360734, 0.12749140780882795, 0.1518380377371643, 0.15485517403574345, 0.26588538870013745, 0.2744278343301839, 0.3629722302638877, 0.22476802030466858, 0.3971740230240043, 0.42932290823158925, 0.6028661014652632, 0.5298248563034789, 0.2704539418327878, 0.4241916619743753, 0.5231355389389336, 0.47105791106106876, 0.521116375893839, 0.2774177079988702, 0.49219462785786594, 0.5505082039650954, 0.5475023998462865, 0.49024633769510306, 0.24597491884393075, 0.31116472600614886, 0.255934553335322, 0.35846810831810283, 0.26226106374723945, 0.25242960842256557, 0.20873422065408553, 0.2556780505598142, 0.24036235890834146, 0.22159180208326734, 0.2141613934908868, 0.20598892756795373, 0.2338201257503788, 0.221496849056127, 0.2047300054549147, 0.2228968359033654, 0.2114578147985453, 0.23732186918761555, 0.20157217276941286, 0.19295543709459329, 0.19570397714189436, 0.1867991060923262, 0.20472319493940616, 0.2052713786650967, 0.19455762143144362, 0.20739109037214998, 0.190673972607861, 0.12232425846205752, 0.18434772667748733, 0.17609617600768124, 0.8972446495018148, 0.8553584827751829, 0.9038995178952686, 0.14178090174917213, 0.16769061336952673, 0.16644208587606046, 0.6044515606644743, 0.6205451787574499, 0.7164632778571491, 0.21022062176212064, 0.7569986775255595, 0.15380094030021374, 0.11077912439339166, 0.16556897991534136, 0.7389410083002474, 0.21365377692017762, 0.18063110887003675, 0.18726558022931172, 0.17623269423813814, 0.17399958568902663, 0.19456441534963187, 0.18469533697545748, 0.1738695901240337, 0.23612367809642487, 0.08759644181683002, 0.10025567476056663, 0.09834770395374492, 0.09930651967070558, 0.09244002521858874, 0.09397598725958944, 0.08967423176798361, 0.10156872832782904, 0.09828761829949018]}, "mutation_prompt": null}
{"id": "4f220fe0-b845-4f43-a3a7-8094af31b5bb", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Neighborhood Topologies for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8566418081359641, 0.8303423264508174, 0.8516183311494232, 0.8321490668123401, 0.8357337160793011, 0.8407005381900351, 0.8392340312331203, 0.8523015807257315, 0.8322739835209731, 0.6711846866405555, 0.6697174051455386, 0.6494660060325723, 0.6528151438749281, 0.6579920851416323, 0.6444384843507236, 0.6280763373090854, 0.6812867923765948, 0.6160562146554801, 0.13998703840760263, 0.16591170355325158, 0.16541732337444903, 0.1410632786920082, 0.15662814128840274, 0.12894422610786493, 0.12060173881079939, 0.11872724786664968, 0.17832162677128804, 0.10471476757269771, 0.0467934901435032, 0.06387815506743777, 0.11042680828397844, 0.07144807690944888, 0.05464704616408911, 0.11603757511106871, 0.11210396198525874, 0.05586191541009233, 0.9096827060287042, 0.9375361085370097, 0.899290897309731, 0.8981832528309829, 0.8974334240891066, 0.8891234673411167, 0.9061378988370403, 0.8851996708887686, 0.8930988823212387, 0.7218045694087009, 0.6676013482114826, 0.6687167832791033, 0.670739460221037, 0.6871121956867032, 0.672686363325045, 0.6405948876983021, 0.657568721845861, 0.6655500245490726, 0.8358714620291631, 0.7971397027078571, 0.22396367284700103, 0.2801709222968203, 0.2118780755221331, 0.8233041867972615, 0.17648849959274016, 0.1743438417566855, 0.23170191416019592, 0.3159684457109474, 0.12299107769257667, 0.19196127956497877, 0.2236045737643978, 0.2832598887996671, 0.2655411022016003, 0.22158130932889208, 0.20683395115752412, 0.3116999629957943, 0.24981532843999044, 0.12091273471976094, 0.22461922197043493, 0.13217939176678506, 0.21315478285890854, 0.21385093963064983, 0.24464617365345143, 0.2455448950859873, 0.12796935601029313, 0.03434053187674013, 0.04377636654386918, 0.09865447423613494, 0.05813807933707971, 0.08756170740461222, 0.07755940004325934, 0.04157510331967895, 9.999999999998899e-05, 0.012067677632501161, 0.17073869284148735, 0.10065680818554956, 0.10102060826934411, 0.05647401159743348, 0.040257879592135004, 0.047530413591438836, 0.08444105876486285, 0.09242596736439102, 0.0917997356530661, 0.1679966066227052, 0.1761204700372233, 0.1133012092557577, 0.086922706659737, 0.08581645916956171, 0.07437809964158992, 0.11295807313236605, 0.2283407610769307, 0.1363264827065488, 0.13303037254987393, 0.1407900888127257, 0.26629609715709945, 0.057334045048600846, 0.10675475432907, 0.13365930814224536, 0.21271486583516108, 0.11548523345865047, 0.08202212010721521, 0.5244320356863881, 0.5692232263763082, 0.5335327129223775, 0.5311687120229605, 0.5521606581702889, 0.5446780070971865, 0.5580426707714887, 0.5564902123707601, 0.5714519748506801, 0.11260056165583487, 0.0857229763372157, 0.09105719263574752, 0.12872523148266268, 0.10459528307834354, 0.13607915843082008, 0.14231623375241909, 0.13425221628835238, 0.16974697491574875, 0.4986462131412278, 0.21156558084087163, 0.20557610613453403, 0.44001594706238856, 0.3169062849689852, 0.28889936315186693, 0.49562373387023795, 0.22007750139182136, 0.32084748230844296, 0.4564882898220388, 0.6437980088135165, 0.4877078496063437, 0.5114375088776402, 0.3894461736543896, 0.5225134835538632, 0.6165249439755066, 0.5677938357799411, 0.2667859165899703, 0.2325802607259675, 0.3983162967842767, 0.36727605161184684, 0.3724311019209292, 0.19405995387539277, 0.2964957318206193, 0.24033720800537817, 0.27326381043809267, 0.24265624148993148, 0.22696670409366093, 0.2168905888608087, 0.20348506443142267, 0.23901389506768633, 0.23249119707153476, 0.23875167226808724, 0.2251576144705828, 0.22848814798947348, 0.22400521227911774, 0.20146551795983625, 0.24362632186584632, 0.220727157052641, 0.18749024675240267, 0.20263527614824084, 0.1825622922932002, 0.17944038701217324, 0.21942018833154786, 0.19105865148204493, 0.12245577689732123, 0.878559883928087, 0.17618516399671902, 0.904025677020762, 0.8757757359953653, 0.9030272801080885, 0.14185725392162019, 0.16774797818763731, 0.16601368514992187, 0.7623060900179983, 0.15544003955641872, 0.694457164682527, 0.2103189567266427, 0.576855365258548, 0.15352408626155412, 0.11120922025008095, 0.16564341341252897, 0.7263286483945359, 0.17889254405497146, 0.197595021042829, 0.19195004639541147, 0.18257414728741994, 0.17568788131008373, 0.18915409171382347, 0.17449222302965717, 0.18332911105416794, 0.18879219215087684, 0.09156703727549398, 0.08999233390067451, 0.0897204008234539, 0.10223194978368388, 0.09849030617251753, 0.1040358698408923, 0.08760725456180607, 0.09426424733333283, 0.08722456748905483]}, "mutation_prompt": null}
{"id": "4f768bd8-6166-4043-8ed3-7a5bf597f8c0", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.7  # Increased social influence coefficient\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Increased Social Influence for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 49, "fitness": 0.32920814029174156, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8200848852152893, 0.8151963949545518, 0.809925525460185, 0.8111298776214959, 0.8187304500814543, 0.8079106689927283, 0.8197207017278201, 0.8267718147718552, 0.8160275461147519, 0.6404965380021364, 0.6127611065314175, 0.6449433157628298, 0.6363649724157995, 0.6347068125286213, 0.6244540197469338, 0.6406264659243879, 0.652573040617078, 0.6141732944047604, 0.13857262964169326, 0.15268635949837228, 0.1490460681984236, 0.1759010616588541, 0.23866111226046727, 0.12679234244661297, 0.11622219312192772, 0.12917336384889366, 0.16404276637549975, 0.08668019597613197, 0.04299841895142331, 0.07142805973236932, 0.09923285754728894, 0.11261933484755193, 0.052858998972984184, 0.11275068948971545, 0.10838839925136579, 0.07061220353122388, 0.9094823712340911, 0.9423786230469939, 0.8868599712575607, 0.8983867667480642, 0.9018061282431218, 0.889494698856791, 0.9062438593380198, 0.8809377670624111, 0.8971183812714103, 0.6251236283901047, 0.6397980660179283, 0.628351209012636, 0.6465695342090456, 0.629802965927267, 0.6562877267329712, 0.6084563826198373, 0.6343143313498067, 0.6583411552210705, 0.8149716299327698, 0.7395584374829031, 0.8350752876681988, 0.2785818819635911, 0.19269264384094908, 0.7992010623001284, 0.17268568242812743, 0.17647835607281137, 0.21770715569242172, 0.3722027987779677, 0.12727427369948185, 0.19181078543123953, 0.19189118705543973, 0.2639819934714529, 0.2563257392232421, 0.21250036483256296, 0.23403296870287338, 0.25604782915514246, 0.25374468674917583, 0.2101120587625921, 0.22607694451591165, 0.21394994166553338, 0.19358221388875496, 0.23847751651553595, 0.1319123729525663, 0.2410382318507459, 0.24503554616137158, 0.05433488628494887, 0.0545209878390589, 0.022192630886123887, 0.06079094025233356, 0.09087436570849006, 0.008958790836421704, 0.030596064169367443, 9.999999999998899e-05, 0.0695864780444081, 0.20122937477483727, 0.09343530342378725, 0.11660038472552825, 0.1048285903761802, 0.04916523548660279, 0.045451087911099974, 0.10312343878629304, 0.08579704166415081, 0.09670628636579115, 0.0969759563495618, 0.13023478080445872, 0.14207716945717153, 0.0865516771540289, 0.09468057398195484, 0.06866997657929275, 0.0815716703831102, 0.12260777794426014, 0.08140806028896586, 0.15919512246742562, 0.21918470529544642, 0.15765913758866357, 0.04141217032368183, 0.18268491241480156, 0.19194861894558812, 0.12695584464885123, 0.13165424604891562, 0.11869780679546671, 0.505560075530557, 0.5457116759514732, 0.5093685686084825, 0.5439069229443181, 0.5101751054744306, 0.5122424808530428, 0.5352675310749969, 0.5386530098801119, 0.5529702059156907, 0.07526979101116671, 0.13953663271792538, 0.10792617799915716, 0.08972467809425322, 0.1097822964350873, 0.14632484988062666, 0.14075737063279248, 0.17528509934078196, 0.12687437803033186, 0.38315114498673875, 0.541139796381038, 0.5041908912943445, 0.30712632688418917, 0.5455223687145877, 0.47249672051249625, 0.5383433870226049, 0.4717721160407342, 0.5334974494275804, 0.4427808166922572, 0.42554983021811976, 0.3868422433270442, 0.43142909523885653, 0.523973702321308, 0.4502009270869062, 0.5303793952393568, 0.5547891295993639, 0.5686795424727163, 0.22283162192599015, 0.2591481448339247, 0.22185035099708672, 0.20865807031767547, 0.22992529518566585, 0.2920271633164845, 0.2552726745437013, 0.24401613479480977, 0.24408300711773034, 0.21894681514124836, 0.2327757815510174, 0.22797021484269142, 0.21846967263619832, 0.24486246982854487, 0.21792958850924438, 0.26217548217437825, 0.22460848964228264, 0.21678671503598412, 0.176496524169921, 0.1949597386127604, 0.19485303763456063, 0.2252055419747665, 0.2072476888150635, 0.19742861777093745, 0.1770655484772653, 0.18895900206555283, 0.2048106459450968, 0.12241450007713861, 0.18480664623012422, 0.1755504293017437, 0.8852623381487305, 0.8806105415304395, 0.8976480916962845, 0.14146829135017502, 0.1607195559203607, 0.16589431251786335, 0.7057718961497225, 0.15541048531745294, 0.7364449447001087, 0.21023134742396155, 0.6920851063761873, 0.1534308498306427, 0.11140683440118004, 0.16573042356207934, 0.6999627743248589, 0.1799781750789352, 0.19124836226938136, 0.20420950370672264, 0.1759431213269791, 0.18199699652889345, 0.18738682838193266, 0.18294122348694464, 0.18817143791394808, 0.19477591573444697, 0.09856200226238165, 0.08818324490990015, 0.09104469075761878, 0.09695645666755359, 0.0935733549033737, 0.09022964970760272, 0.08693000425687658, 0.10296968552494945, 0.0980127704780469]}, "mutation_prompt": null}
{"id": "55f4926e-433d-490f-8f0d-52071f6cc905", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.9  # Updated inertia value\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n        self.exploration_factor = 0.5  # New attribute for hybrid search\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def hybrid_search(self, positions, scores):  # New method for hybrid search\n        best_idx = np.argmin(scores)\n        exploration = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        exploration_scores = np.array([func(pos) for pos in exploration])\n        exploration[exploration_scores < scores] = positions[exploration_scores < scores]\n        return exploration\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            inertia_weight = self.inertia - 0.5 * (i / self.iterations)  # Dynamic inertia\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            if i % 10 == 0:  # Hybrid search periodically\n                positions = self.hybrid_search(positions, scores)\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Dynamic Inertia and Hybrid Search for improved adaptation and exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {}, "mutation_prompt": null}
{"id": "9463b2e3-c577-4a36-a337-00ae27c2b64e", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def dual_oppositional_learning(self, positions):\n        opposite_positions = self.oppositional_learning(positions)\n        quasi_opposite_positions = self.pos_bounds[0] + (self.pos_bounds[1] - positions) / 2\n        return np.where(np.random.rand(*positions.shape) < 0.5, opposite_positions, quasi_opposite_positions)\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.dual_oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            # Introduce dynamic coefficients\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n            self.social_coef = 1.5 + 0.5 * (self.iterations - i) / self.iterations\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced AMPSO with Dual Oppositional Strategy and Adaptive Parameters for improved exploration and exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.2999385091447851, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.790519969493533, 0.7800553906313066, 0.7851227932223398, 0.7872358985754038, 0.791543376933628, 0.7712909727837534, 0.7584747061897328, 0.7658452255785414, 0.787645887011057, 0.5767053980690695, 0.5777688351874454, 0.6109474409704649, 0.5424378741815027, 0.5749097230195421, 0.5510921453235463, 0.5877190876539158, 0.5820146748448347, 0.5761331743535631, 0.1077385531380427, 0.10318861744082153, 0.14540702777464343, 0.11495059647147465, 0.1392180680563817, 0.10878790817891626, 0.10716321077410995, 0.1476488189763281, 0.16161082329966392, 0.08045842935492853, 0.11065971873015445, 0.08421556803291497, 0.09190259145224844, 0.0918894040831596, 0.08606049472488653, 0.0851679168320898, 0.11094221314537567, 0.1034325641738546, 0.8951545125672715, 0.883129876340636, 0.8994887206921804, 0.8984073389745095, 0.8780026538852973, 0.8831286079650765, 0.9143054652743516, 0.9166659086213518, 0.8740925707583078, 0.5852917620409205, 0.5737810592516845, 0.561151919752233, 0.5558975991947734, 0.5462381978978254, 0.5358496740288627, 0.5429082335201353, 0.5611978972458869, 0.5052056947317427, 0.7664433988195173, 0.6272212772561278, 0.681879719632623, 0.213245147023575, 0.24044256111732787, 0.2095588711116314, 0.18982540577130314, 0.21388996071212962, 0.17734434100475827, 0.1921787464316167, 0.18761213247401043, 0.19163127221328113, 0.19393702643527222, 0.19805931745737904, 0.18305548917631898, 0.1869307372386685, 0.20592681519038525, 0.19347463699456813, 0.2001607489019025, 0.18159792753840287, 0.19586144868249833, 0.21090371318071843, 0.19421015747171388, 0.19960915223088949, 0.21833430118761588, 0.2280302790897547, 0.3517487815019785, 0.004650008285266294, 0.05193744290930935, 9.999999999998899e-05, 0.04502251306917282, 9.999999999998899e-05, 0.04508998706590861, 0.04083801403066645, 0.0016358472299973226, 9.999999999998899e-05, 0.11119648270835891, 0.1022557802177344, 0.10941578240718608, 0.051722622163080434, 0.026277520037248148, 0.04891707205724616, 0.07561913868670977, 0.06367368972431431, 0.1237360409769186, 0.05312231519545185, 0.06424781188349649, 0.08325838450848244, 0.06700376340220116, 0.05894908317532077, 0.10976188696505562, 0.12308749610338332, 0.17128903669249684, 0.06376834470781123, 0.22898544306050217, 0.21562647500590915, 0.14953310109048312, 0.14328117750703384, 0.09818833301519769, 0.1629999639432399, 0.10924926744320018, 0.08107592275856401, 0.08182371109757647, 0.5044113783140938, 0.497039982471588, 0.501741950238416, 0.48695252181488213, 0.4936546911664611, 0.48038490056251726, 0.5084803171966197, 0.5061738185536435, 0.5212845025595834, 0.0871965894142559, 0.07365686403592553, 0.10233272192137899, 0.10862970846703535, 0.10060437512001585, 0.09789534414648571, 0.13433580551374602, 0.1332101125313091, 0.14306799878449095, 0.3295566469105037, 0.4175593985579412, 0.21195451232076656, 0.43816986423810544, 0.39472371936537887, 0.3816300075811395, 0.4615949909683713, 0.32363713449543574, 0.35669023566535674, 0.44992669059133883, 0.3244473636097005, 0.4065611133977497, 0.4441821061036445, 0.4519673244433777, 0.3782920219618383, 0.5147918094109942, 0.43663807888433126, 0.24779458294694912, 0.31503540366356364, 0.24012423314077402, 0.27112905763856365, 0.17816085320556596, 0.25528142128371956, 0.3256145640194611, 0.24668296198619633, 0.33214190744483696, 0.24218162121718045, 0.24292468234112308, 0.22928581595579256, 0.23286223688601837, 0.2517303948120161, 0.2646668375425837, 0.23605795930580553, 0.23351309780769003, 0.22181334405926345, 0.2350472125729891, 0.20211291826695454, 0.18189672249046107, 0.20542135724911714, 0.2053293382148056, 0.18779551140590567, 0.2311658785289573, 0.1888099931447792, 0.18520479167652237, 0.20318771683921455, 0.84844523655057, 0.20896546408162542, 0.18570389061472525, 0.16777115707552726, 0.833491495175945, 0.8549162208363794, 0.1406465042149011, 0.16572309802166307, 0.11412582272606397, 0.6778625172501254, 0.6580992992692869, 0.07329788131134829, 0.21031137647681208, 0.2065435352709818, 0.15228677768128251, 0.6088990121705554, 0.08230751485278709, 0.10338246668357065, 0.1786744693285629, 0.17529993271063582, 0.17469190266465995, 0.17960054804663828, 0.18017229714403782, 0.1846900642645054, 0.18983542808067566, 0.20206953856991883, 0.19146567920249502, 0.09607823914623137, 0.08805543595835574, 0.0951280517583114, 0.11441449581462915, 0.093855490139784, 0.08810760870954659, 0.09632184447144887, 0.10147079731382913, 0.07920224834321177]}, "mutation_prompt": null}
{"id": "5b142205-f1db-46d3-8a9c-8d54723bc097", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Neighborhood Topologies for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8566418081359641, 0.8303423264508174, 0.8516183311494232, 0.8321490668123401, 0.8357337160793011, 0.8407005381900351, 0.8392340312331203, 0.8523015807257315, 0.8322739835209731, 0.6711846866405555, 0.6697174051455386, 0.6494660060325723, 0.6528151438749281, 0.6579920851416323, 0.6444384843507236, 0.6280763373090854, 0.6812867923765948, 0.6160562146554801, 0.13998703840760263, 0.16591170355325158, 0.16541732337444903, 0.1410632786920082, 0.15662814128840274, 0.12894422610786493, 0.12060173881079939, 0.11872724786664968, 0.17832162677128804, 0.10471476757269771, 0.0467934901435032, 0.06387815506743777, 0.11042680828397844, 0.07144807690944888, 0.05464704616408911, 0.11603757511106871, 0.11210396198525874, 0.05586191541009233, 0.9096827060287042, 0.9375361085370097, 0.899290897309731, 0.8981832528309829, 0.8974334240891066, 0.8891234673411167, 0.9061378988370403, 0.8851996708887686, 0.8930988823212387, 0.7218045694087009, 0.6676013482114826, 0.6687167832791033, 0.670739460221037, 0.6871121956867032, 0.672686363325045, 0.6405948876983021, 0.657568721845861, 0.6655500245490726, 0.8358714620291631, 0.7971397027078571, 0.22396367284700103, 0.2801709222968203, 0.2118780755221331, 0.8233041867972615, 0.17648849959274016, 0.1743438417566855, 0.23170191416019592, 0.3159684457109474, 0.12299107769257667, 0.19196127956497877, 0.2236045737643978, 0.2832598887996671, 0.2655411022016003, 0.22158130932889208, 0.20683395115752412, 0.3116999629957943, 0.24981532843999044, 0.12091273471976094, 0.22461922197043493, 0.13217939176678506, 0.21315478285890854, 0.21385093963064983, 0.24464617365345143, 0.2455448950859873, 0.12796935601029313, 0.03434053187674013, 0.04377636654386918, 0.09865447423613494, 0.05813807933707971, 0.08756170740461222, 0.07755940004325934, 0.04157510331967895, 9.999999999998899e-05, 0.012067677632501161, 0.17073869284148735, 0.10065680818554956, 0.10102060826934411, 0.05647401159743348, 0.040257879592135004, 0.047530413591438836, 0.08444105876486285, 0.09242596736439102, 0.0917997356530661, 0.1679966066227052, 0.1761204700372233, 0.1133012092557577, 0.086922706659737, 0.08581645916956171, 0.07437809964158992, 0.11295807313236605, 0.2283407610769307, 0.1363264827065488, 0.13303037254987393, 0.1407900888127257, 0.26629609715709945, 0.057334045048600846, 0.10675475432907, 0.13365930814224536, 0.21271486583516108, 0.11548523345865047, 0.08202212010721521, 0.5244320356863881, 0.5692232263763082, 0.5335327129223775, 0.5311687120229605, 0.5521606581702889, 0.5446780070971865, 0.5580426707714887, 0.5564902123707601, 0.5714519748506801, 0.11260056165583487, 0.0857229763372157, 0.09105719263574752, 0.12872523148266268, 0.10459528307834354, 0.13607915843082008, 0.14231623375241909, 0.13425221628835238, 0.16974697491574875, 0.4986462131412278, 0.21156558084087163, 0.20557610613453403, 0.44001594706238856, 0.3169062849689852, 0.28889936315186693, 0.49562373387023795, 0.22007750139182136, 0.32084748230844296, 0.4564882898220388, 0.6437980088135165, 0.4877078496063437, 0.5114375088776402, 0.3894461736543896, 0.5225134835538632, 0.6165249439755066, 0.5677938357799411, 0.2667859165899703, 0.2325802607259675, 0.3983162967842767, 0.36727605161184684, 0.3724311019209292, 0.19405995387539277, 0.2964957318206193, 0.24033720800537817, 0.27326381043809267, 0.24265624148993148, 0.22696670409366093, 0.2168905888608087, 0.20348506443142267, 0.23901389506768633, 0.23249119707153476, 0.23875167226808724, 0.2251576144705828, 0.22848814798947348, 0.22400521227911774, 0.20146551795983625, 0.24362632186584632, 0.220727157052641, 0.18749024675240267, 0.20263527614824084, 0.1825622922932002, 0.17944038701217324, 0.21942018833154786, 0.19105865148204493, 0.12245577689732123, 0.878559883928087, 0.17618516399671902, 0.904025677020762, 0.8757757359953653, 0.9030272801080885, 0.14185725392162019, 0.16774797818763731, 0.16601368514992187, 0.7623060900179983, 0.15544003955641872, 0.694457164682527, 0.2103189567266427, 0.576855365258548, 0.15352408626155412, 0.11120922025008095, 0.16564341341252897, 0.7263286483945359, 0.17889254405497146, 0.197595021042829, 0.19195004639541147, 0.18257414728741994, 0.17568788131008373, 0.18915409171382347, 0.17449222302965717, 0.18332911105416794, 0.18879219215087684, 0.09156703727549398, 0.08999233390067451, 0.0897204008234539, 0.10223194978368388, 0.09849030617251753, 0.1040358698408923, 0.08760725456180607, 0.09426424733333283, 0.08722456748905483]}, "mutation_prompt": null}
{"id": "910864af-37a2-4c2e-90d1-92d43405e6b1", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.7  # Changed from 1.5 to 1.7\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.15))  # Changed from 0.1 to 0.15\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Oppositional Based Learning and Adaptive Topology for enriched exploration-exploitation balance in optimization.", "configspace": "", "generation": 53, "fitness": 0.32920814029174156, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8200848852152893, 0.8151963949545518, 0.809925525460185, 0.8111298776214959, 0.8187304500814543, 0.8079106689927283, 0.8197207017278201, 0.8267718147718552, 0.8160275461147519, 0.6404965380021364, 0.6127611065314175, 0.6449433157628298, 0.6363649724157995, 0.6347068125286213, 0.6244540197469338, 0.6406264659243879, 0.652573040617078, 0.6141732944047604, 0.13857262964169326, 0.15268635949837228, 0.1490460681984236, 0.1759010616588541, 0.23866111226046727, 0.12679234244661297, 0.11622219312192772, 0.12917336384889366, 0.16404276637549975, 0.08668019597613197, 0.04299841895142331, 0.07142805973236932, 0.09923285754728894, 0.11261933484755193, 0.052858998972984184, 0.11275068948971545, 0.10838839925136579, 0.07061220353122388, 0.9094823712340911, 0.9423786230469939, 0.8868599712575607, 0.8983867667480642, 0.9018061282431218, 0.889494698856791, 0.9062438593380198, 0.8809377670624111, 0.8971183812714103, 0.6251236283901047, 0.6397980660179283, 0.628351209012636, 0.6465695342090456, 0.629802965927267, 0.6562877267329712, 0.6084563826198373, 0.6343143313498067, 0.6583411552210705, 0.8149716299327698, 0.7395584374829031, 0.8350752876681988, 0.2785818819635911, 0.19269264384094908, 0.7992010623001284, 0.17268568242812743, 0.17647835607281137, 0.21770715569242172, 0.3722027987779677, 0.12727427369948185, 0.19181078543123953, 0.19189118705543973, 0.2639819934714529, 0.2563257392232421, 0.21250036483256296, 0.23403296870287338, 0.25604782915514246, 0.25374468674917583, 0.2101120587625921, 0.22607694451591165, 0.21394994166553338, 0.19358221388875496, 0.23847751651553595, 0.1319123729525663, 0.2410382318507459, 0.24503554616137158, 0.05433488628494887, 0.0545209878390589, 0.022192630886123887, 0.06079094025233356, 0.09087436570849006, 0.008958790836421704, 0.030596064169367443, 9.999999999998899e-05, 0.0695864780444081, 0.20122937477483727, 0.09343530342378725, 0.11660038472552825, 0.1048285903761802, 0.04916523548660279, 0.045451087911099974, 0.10312343878629304, 0.08579704166415081, 0.09670628636579115, 0.0969759563495618, 0.13023478080445872, 0.14207716945717153, 0.0865516771540289, 0.09468057398195484, 0.06866997657929275, 0.0815716703831102, 0.12260777794426014, 0.08140806028896586, 0.15919512246742562, 0.21918470529544642, 0.15765913758866357, 0.04141217032368183, 0.18268491241480156, 0.19194861894558812, 0.12695584464885123, 0.13165424604891562, 0.11869780679546671, 0.505560075530557, 0.5457116759514732, 0.5093685686084825, 0.5439069229443181, 0.5101751054744306, 0.5122424808530428, 0.5352675310749969, 0.5386530098801119, 0.5529702059156907, 0.07526979101116671, 0.13953663271792538, 0.10792617799915716, 0.08972467809425322, 0.1097822964350873, 0.14632484988062666, 0.14075737063279248, 0.17528509934078196, 0.12687437803033186, 0.38315114498673875, 0.541139796381038, 0.5041908912943445, 0.30712632688418917, 0.5455223687145877, 0.47249672051249625, 0.5383433870226049, 0.4717721160407342, 0.5334974494275804, 0.4427808166922572, 0.42554983021811976, 0.3868422433270442, 0.43142909523885653, 0.523973702321308, 0.4502009270869062, 0.5303793952393568, 0.5547891295993639, 0.5686795424727163, 0.22283162192599015, 0.2591481448339247, 0.22185035099708672, 0.20865807031767547, 0.22992529518566585, 0.2920271633164845, 0.2552726745437013, 0.24401613479480977, 0.24408300711773034, 0.21894681514124836, 0.2327757815510174, 0.22797021484269142, 0.21846967263619832, 0.24486246982854487, 0.21792958850924438, 0.26217548217437825, 0.22460848964228264, 0.21678671503598412, 0.176496524169921, 0.1949597386127604, 0.19485303763456063, 0.2252055419747665, 0.2072476888150635, 0.19742861777093745, 0.1770655484772653, 0.18895900206555283, 0.2048106459450968, 0.12241450007713861, 0.18480664623012422, 0.1755504293017437, 0.8852623381487305, 0.8806105415304395, 0.8976480916962845, 0.14146829135017502, 0.1607195559203607, 0.16589431251786335, 0.7057718961497225, 0.15541048531745294, 0.7364449447001087, 0.21023134742396155, 0.6920851063761873, 0.1534308498306427, 0.11140683440118004, 0.16573042356207934, 0.6999627743248589, 0.1799781750789352, 0.19124836226938136, 0.20420950370672264, 0.1759431213269791, 0.18199699652889345, 0.18738682838193266, 0.18294122348694464, 0.18817143791394808, 0.19477591573444697, 0.09856200226238165, 0.08818324490990015, 0.09104469075761878, 0.09695645666755359, 0.0935733549033737, 0.09022964970760272, 0.08693000425687658, 0.10296968552494945, 0.0980127704780469]}, "mutation_prompt": null}
{"id": "9442cae2-e2d2-4398-a025-6dda1a0c0e20", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.9  # increase initial inertia for exploration\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = np.random.randint(1, self.population_size // 2)\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def dynamic_inertia(self, iteration):\n        return 0.9 - 0.5 * (iteration / self.iterations)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            inertia_weight = self.dynamic_inertia(i)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Dynamic Parameter Tuning and Randomized Neighborhood Strategies for more robust convergence in diverse landscapes.", "configspace": "", "generation": 54, "fitness": 0.3027619290526122, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.709249029120377, 0.7623563924379746, 0.7296216383087992, 0.706082724246268, 0.7294428772376815, 0.7312929398440124, 0.7334236330532626, 0.7342967394336845, 0.7105191784554967, 0.4683714755912377, 0.46901117223921207, 0.4763856946237458, 0.4841012243838132, 0.4698507721944536, 0.4721034133675587, 0.4545980544843238, 0.4629677912940571, 0.43484345599881047, 0.14040599566913692, 0.13089330905478636, 0.1293577552656816, 0.15509290206228943, 0.1269740180415998, 0.1344632148847692, 0.1055770869751459, 0.1067682765614143, 0.2730753127662391, 0.1118806220840124, 0.054530382905488506, 0.10325001841224313, 0.10281049892085814, 0.09342119380860092, 0.097122891140212, 0.10479174053192675, 0.09994595859984035, 0.0818578665257984, 0.9161803353132704, 0.9424622009252017, 0.9229623628614505, 0.9036327650591491, 0.9100560572736901, 0.8749475522009441, 0.9150077414475697, 0.9152907133378612, 0.9017363925489167, 0.5360980930957815, 0.512149377400813, 0.499876789485605, 0.550460700487723, 0.5157211599533665, 0.5179173801710484, 0.49046036016440564, 0.5234760259160165, 0.46612773405066743, 0.6746319285115179, 0.6132505729411413, 0.5210523255478219, 0.6053493672838991, 0.5965754851736331, 0.333130485929649, 0.22857201045462283, 0.5133951374758151, 0.6944086245022469, 0.19525584101918603, 0.12766971404876482, 0.19336704396765214, 0.18794275363818613, 0.23657082122540718, 0.3234294544397054, 0.18158530970352027, 0.1999284081666426, 0.12825933430586578, 0.20774524967093644, 0.20621013067562266, 0.20070957018833657, 0.19812261542761367, 0.21224690390033596, 0.19091825114666172, 0.22847740887462642, 0.22126433873917806, 0.2169725467766611, 0.05059344126020826, 0.05279037430828559, 0.03277190450279033, 0.04943786200931499, 0.04143602247936273, 0.008092567704012787, 0.049787405709652566, 0.0035926136597635994, 0.07085371103441251, 0.12793162161104532, 0.1192578225351899, 0.09714530942227306, 0.06474447630052182, 0.053212863180262526, 0.03560281616944416, 0.11780348746520086, 0.0834609806384442, 0.08902793691902333, 0.03265060337412229, 0.06636209824536987, 0.09090052678909555, 0.09530101069088925, 0.058538799357446214, 0.05165940136298175, 0.07216829626446308, 0.04874926327998197, 0.10076669941844307, 0.1340636214683385, 0.14526071080132552, 0.15114866301408547, 0.15030199716962256, 0.15175166420228048, 0.20678800427136934, 0.1360485249822092, 0.10285609159474152, 0.08011965060719362, 0.45317514857086794, 0.4518833558640807, 0.5033804374311166, 0.49748775491305885, 0.4906120492347904, 0.49325818484309625, 0.4929831786793508, 0.4875845870411185, 0.4883518808072771, 0.12080300208085137, 0.12739310024825645, 0.09980852502428095, 0.14257871557494495, 0.09889764319725614, 0.12331228560369345, 0.12551059145762689, 0.12830047198907701, 0.1333897621038026, 0.43156465174714265, 0.43798980896540884, 0.46550998310129, 0.3842568169019861, 0.30450603929564257, 0.35124199151083313, 0.18928971390047267, 0.43252974437838865, 0.30436310637782205, 0.3740346352255287, 0.4251344813624406, 0.43210779943026534, 0.43598688359729587, 0.41604210020369436, 0.4155770796957037, 0.440371795025283, 0.40191670290601145, 0.42799468912328165, 0.2096549431255289, 0.27492250505036087, 0.24038651187654048, 0.27748799447328576, 0.24156745869102247, 0.2685273688283566, 0.2213473396215112, 0.3007262748034022, 0.21041233703172824, 0.21073015731545575, 0.2096255930050902, 0.2339294103163938, 0.22892828138586374, 0.22113234644472657, 0.22961998656519766, 0.23726307227450216, 0.22918959883028378, 0.23758838030232, 0.1837132807070292, 0.19039759221336228, 0.18647927519089158, 0.5904275190601862, 0.20333183936582422, 0.18451615487606754, 0.1922055286940495, 0.23740993831502133, 0.19859116074819327, 0.18606494519596795, 0.17444832504000551, 0.18622116791414933, 0.8162445957402023, 0.19930666582744905, 0.8402601766724455, 0.14107401627852956, 0.1663636927942691, 0.1660951307675428, 0.5692496346245113, 0.2093496318329685, 0.5531324727962741, 0.2106262982297834, 0.6022119909848953, 0.20609818950703873, 0.16444804081895958, 0.671013951299775, 0.6646053405374356, 0.19756129887140628, 0.1981099042090424, 0.19205165291876436, 0.18838713601495383, 0.18662369368301823, 0.18055258645908512, 0.18819524116928443, 0.1824647055415155, 0.1820838173709729, 0.07868586555167645, 0.09589735953651868, 0.09114105829356389, 0.08715925231911592, 0.09418731099238054, 0.094365471170899, 0.08821978096552352, 0.09895744695297704, 0.10055681019939255]}, "mutation_prompt": null}
{"id": "335e547d-8eeb-4a29-86ea-621d87b628bb", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.social_coef = 1.5 + 0.5 * (i / self.iterations)  # Adjust social coefficient over iterations\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with adaptive social coefficient for improved global exploration in diverse optimization landscapes.", "configspace": "", "generation": 55, "fitness": 0.32984833396713314, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8492154857688221, 0.8247262330671603, 0.8386483237199593, 0.8280296546120841, 0.835041158893427, 0.8406028659950777, 0.821910726434087, 0.8308825261183692, 0.8246839703268364, 0.6509436704642938, 0.6378354981325831, 0.6271606821698248, 0.6415896059178232, 0.6185605655356556, 0.6282947997962467, 0.5883801105153705, 0.6297209853212615, 0.6078104082614625, 0.11546690637119772, 0.17928922822087157, 0.15453644743475636, 0.11539654346405603, 0.12472009917127946, 0.1452653906794148, 0.11443946224222001, 0.11704267953446412, 0.18355402367792328, 0.11905811423402668, 0.0437455391724525, 0.06141401768847832, 0.1250076950506418, 0.08215298823223005, 0.08122622986687766, 0.11795069686117965, 0.10841594935687515, 0.08780164043062455, 0.9097430236923173, 0.9379115455424543, 0.8993736938586561, 0.8981796848894602, 0.8991723721685494, 0.8891450754660618, 0.9061453067143206, 0.885374246346641, 0.8930921424058037, 0.6588919656573466, 0.6426655831799835, 0.6328992739362109, 0.6298109544700207, 0.6286414754081844, 0.6362999668767826, 0.6026269526452852, 0.6213940843600776, 0.6333996224365113, 0.7719820324974045, 0.655559301240354, 0.22472427013863372, 0.28012777080769125, 0.27637223059406446, 0.891519972014495, 0.17609698024693876, 0.17673941853717912, 0.17691127037625176, 0.2990862869566724, 0.12208034957383063, 0.18750004720710278, 0.21649309687240548, 0.29353341560336166, 0.2760038833216605, 0.21007191657986413, 0.20637044809984073, 0.3084582589032556, 0.2382476551550501, 0.12546310437397334, 0.2207954533857196, 0.13216890438963058, 0.21578105523676772, 0.22836590024967296, 0.2525605813563955, 0.2496046082573885, 0.2125688821932349, 0.02523585345564372, 0.033913409356255975, 0.004593318798875923, 0.08346748470277854, 0.03916867056571205, 0.014451329370994026, 0.042553662347774246, 9.999999999998899e-05, 0.01253897450717778, 0.17615186738494382, 0.09171418947631116, 0.09887542274524042, 0.058750462573295636, 0.05405516505257002, 0.06064229375147279, 0.0880938528872659, 0.08806275327607005, 0.11582923191076533, 0.250200809762553, 0.12419015108392484, 0.15654656399702804, 0.09254064678309093, 0.09046368407340377, 0.0826162637822847, 0.1011434325087428, 0.1880935554135461, 0.12655213549008715, 0.14419764088167197, 0.16382528138044072, 0.19082766774943927, 0.056836991909314016, 0.12573753384580943, 0.16204482749528182, 0.22632375054176734, 0.13785773120744416, 0.08192461011861052, 0.5514672301442822, 0.4988850965209578, 0.5173656353450365, 0.5468521089188063, 0.5257510208213294, 0.5497221763350166, 0.5554404867013634, 0.5418734195169346, 0.5677176009229403, 0.10196283757918823, 0.0848294405513712, 0.0937844369569173, 0.1268899035037666, 0.09471647353713541, 0.15402097179047725, 0.12720155333763705, 0.12991963231544346, 0.15125601012920464, 0.6078498882669308, 0.5094444781862756, 0.5429161285043104, 0.4082085437134396, 0.5280879454878418, 0.2068231109908375, 0.5325783802060997, 0.34045225910631305, 0.5036188731005056, 0.41440750085346667, 0.48027187459868914, 0.5171408183016588, 0.5243159926925587, 0.48334575100826926, 0.5226749319779858, 0.5300430470731827, 0.514252485687517, 0.26624971943766895, 0.17814323631847162, 0.35424161320290537, 0.2866738132638703, 0.3831285764130664, 0.19731432114857905, 0.3193250165497862, 0.23700879012553722, 0.2804181203409296, 0.2572818972647256, 0.20999157778270394, 0.21654973470194738, 0.22487030956935827, 0.2074479092586592, 0.2212520256462217, 0.2056619116389543, 0.23235196251951795, 0.2221441081197384, 0.21408179395357652, 0.183536318419808, 0.19532065829338652, 0.2265548890250736, 0.18742192899764742, 0.1877913666572324, 0.18876303730597965, 0.1931377242289436, 0.1878495639818204, 0.19078993739667072, 0.1224503512043078, 0.8616892642629697, 0.17589039146202212, 0.8913845750265993, 0.8660082850378384, 0.8922887039455214, 0.14185428664460775, 0.16774667028885049, 0.16601121388426276, 0.8115600785212667, 0.15543432260393297, 0.683937881253339, 0.21016226013740402, 0.6497778957131342, 0.1539644311826478, 0.11118683902284143, 0.16558600444367166, 0.6831072758813682, 0.20037010769855035, 0.1845255836747891, 0.19409057886181436, 0.195658290547024, 0.19227010619942864, 0.1898352222287919, 0.18623859335086246, 0.1753128239681484, 0.19542683574165742, 0.08925546239195614, 0.09800384081143254, 0.09600794869263951, 0.09199142121056614, 0.09696966298109888, 0.099395231063646, 0.08656944360870167, 0.10793074829460547, 0.09536139166097202]}, "mutation_prompt": null}
{"id": "8f1202e6-e2c1-488a-ab04-4cf016980ad2", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.9  # Increased initial inertia for better exploration\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        diversity_factor = np.std(positions, axis=0)  # New: calculate diversity\n        neighborhood_size = max(1, int(self.population_size * 0.1 * (1 + diversity_factor.mean())))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations)) * (1 - (gbest_score / np.sum(scores)))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Improved EnhancedAMPSO with dynamic inertia adjustment and neighborhood diversity for better exploration-exploitation balance.", "configspace": "", "generation": 56, "fitness": 0.296448629713203, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.7136084275091799, 0.6955705723736296, 0.6739013677857806, 0.6865787898761739, 0.6771832387409809, 0.6991962921379677, 0.7017274813647241, 0.7234936055881396, 0.6676614327296394, 0.4420495470004717, 0.38126812384839814, 0.3870909600917263, 0.46301012028942645, 0.416007142478944, 0.42006187594055977, 0.4203677364626206, 0.4088076473093839, 0.4275680356948133, 0.14952216099837246, 0.16285484989825127, 0.11197274898858978, 0.11431331412253876, 0.26492664354395534, 0.11978016931881486, 0.10515088189612876, 0.1381518914494091, 0.1271086569052975, 0.10955303730510846, 0.06679690109223013, 0.09648052962635045, 0.10996394618743055, 0.10514605430949908, 0.09178091733058569, 0.12854783071669718, 0.10329688053764419, 0.08987869377072621, 0.9191786094688863, 0.9529220703702729, 0.9222058876245115, 0.9035653760492888, 0.9062048215726348, 0.9022468023928287, 0.9155839148771149, 0.9113810989164869, 0.9073150774249338, 0.4890085203752389, 0.4692568202997872, 0.504804059347081, 0.5236192236434656, 0.48993968978659086, 0.4911958509430454, 0.4675605476242295, 0.4879522702216629, 0.5125648384663828, 0.6550417832508375, 0.5894712686612824, 0.2243696074763124, 0.2582272020336711, 0.2700276411484178, 0.6245916106522775, 0.2261749367199254, 0.21364496445841363, 0.6796342030317899, 0.1912784772913797, 0.12695392803751127, 0.1782602748916886, 0.19049258715446027, 0.268207558140367, 0.22620665563699316, 0.19501877483901153, 0.2177615646951636, 0.2037089373777352, 0.1849549212172784, 0.19021992124979514, 0.18762381982973564, 0.1737927188081565, 0.1902572061784692, 0.1928527819795257, 0.2097185129311766, 0.20374675761907313, 0.20346202298035765, 0.002629452083205086, 0.015017442557257121, 0.07849389385202121, 0.01581876172672836, 0.007046917841489586, 0.007124521451374877, 0.02278939011882508, 0.002198145531602358, 0.05283051844426845, 0.15125341952777638, 0.0799179623698788, 0.13228072699812743, 0.07770253418664275, 0.058520532673356995, 0.07600931336581929, 0.09733458855326482, 0.10177217514364656, 0.10552603194917809, 0.061754490752201296, 0.051347220584539666, 0.08209653233948133, 0.04753033296689191, 0.059074607573843974, 0.04803385658430592, 0.06104956945834272, 0.07485866718667744, 0.06803550067849196, 0.13235040875285264, 0.1302982842844096, 0.20892170640486396, 0.10725523295208039, 0.18727482010020613, 0.10920906912158701, 0.0845366432107898, 0.15576997816361549, 0.07901384613718188, 0.5010616969760101, 0.4802301760505935, 0.5043297026172543, 0.4968127289797851, 0.48644522899973475, 0.480212164188381, 0.48879587061801477, 0.49642551164688065, 0.49535553641955266, 0.11621423885408622, 0.09963967976659782, 0.1025924644889874, 0.11470280709664749, 0.11046308977664376, 0.13576915252941324, 0.12770646526034724, 0.12920234620588322, 0.10916481914472242, 0.3006592879407669, 0.3704700477762679, 0.4631083425130196, 0.22507593691778982, 0.3319695369731591, 0.34540526786632986, 0.18295391327301613, 0.3159675369922157, 0.4047968256610752, 0.4340339211078773, 0.40670065674318456, 0.3830922398922044, 0.38352660804097893, 0.4380436872451572, 0.3782158881911136, 0.43049543043302985, 0.3940623271068361, 0.44804996198264846, 0.30829336902722937, 0.2878653552261855, 0.2951576403433086, 0.323980654615316, 0.21461434201618634, 0.3128644216430527, 0.22846904820010783, 0.27668792712466383, 0.22620825142762802, 0.23303752551431645, 0.23771339605627284, 0.20281313278873725, 0.1987749151847269, 0.20700435322720168, 0.21603145200643303, 0.23831554939966282, 0.26838628020509503, 0.2327751700010784, 0.20973611417141702, 0.1866166079448357, 0.2383786398203882, 0.19922460998713176, 0.19376743825952125, 0.20584042365187705, 0.20114111348689012, 0.19018458455022547, 0.22329055522714603, 0.12232150141332132, 0.18487460936118083, 0.17505081224358598, 0.7685382946297816, 0.7926369766585021, 0.8166280985279069, 0.14175416472232427, 0.1670624907698457, 0.16595186463636458, 0.5512363951090514, 0.587778006503067, 0.7015649398073993, 0.20845601359624866, 0.6856371078831824, 0.1536990724008549, 0.5812093070246351, 0.6409697353547277, 0.649593685661155, 0.19739783554665624, 0.19727184998510472, 0.19179500145277817, 0.1804712854285816, 0.1726493836173184, 0.17563665396496364, 0.17346398212575842, 0.18176052966499834, 0.17282425528877798, 0.0938664909170649, 0.09149332806553079, 0.08583776153853817, 0.09091254500679857, 0.09690780915792563, 0.09712577345022688, 0.08778102146695488, 0.09725594922768865, 0.09930379991794802]}, "mutation_prompt": null}
{"id": "1b265b7c-0531-4f0a-bef0-0fb541d49c3e", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_initial = 0.9\n        self.inertia_final = 0.4\n        self.cognitive_coef = 2.0\n        self.social_coef = 2.0\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.2))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            inertia_weight = self.inertia_initial - (self.inertia_initial - self.inertia_final) * (i / self.iterations)\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities *= np.random.rand(self.population_size, self.dim)  # Stochastic velocity clamping\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Dynamic Inertia and Stochastic Velocity Clamping for better exploration and exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.2927840945383103, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.9041027007415074, 0.9015849390104154, 0.9063530083889488, 0.867746597863097, 0.8655745056879458, 0.8792559603378285, 0.9083442017424651, 0.8955907460942565, 0.8842012176596389, 0.8182841903331959, 0.8003353766922623, 0.7813048947522314, 0.7461947986114713, 0.8108117827241781, 0.6750688241285097, 0.773684508186937, 0.7814022989275247, 0.7361577298918716, 0.14685231753213301, 0.1547796599621879, 0.18564435809134172, 0.18955261895169528, 0.15843944984085878, 0.11634815459095915, 0.12288316006404254, 0.1437211797293696, 0.12437888906328065, 0.11952653100847, 0.03507718645791624, 0.07135871493631385, 0.10864634524289662, 0.06201921246803832, 0.04345869651432732, 0.1141151022501381, 0.14180624301912936, 0.07280574237921356, 0.8418153839602956, 0.888857684079291, 0.7622305049164625, 0.8439093946933004, 0.8318539956316133, 0.7196077134647909, 0.8338022528970516, 0.7700658430789387, 0.7302324436001106, 0.5355924454967518, 0.29487800370518547, 0.763562715952709, 0.3758873151912847, 0.49846412388643735, 0.6358707503755381, 0.2123110636637503, 0.14183296329080863, 0.6519935062071741, 0.21804772227969416, 0.35577235976593624, 0.16367526220405415, 0.2733616865883366, 0.19125057126826484, 0.2713992505638394, 0.15067699594386819, 0.1511031320491536, 0.19440299893815982, 0.5095709489684889, 0.13310274635843256, 0.125229111657163, 0.16862841663899109, 0.19864594676342995, 0.18667157784591815, 0.17096758538501233, 0.2554971669414622, 0.23503222135767554, 0.17724716352452508, 0.15545836276764136, 0.13100931377661051, 0.15330446482589377, 0.13155819255370638, 0.15299427665773568, 0.12725907314192186, 0.1537585615905549, 0.1550126119373978, 0.0006360926363208064, 0.011367315750321128, 9.999999999998899e-05, 0.04623726449487853, 0.10017709694794008, 0.0020984266941864727, 9.999999999998899e-05, 9.999999999998899e-05, 0.05556393071910404, 0.09784442399612325, 0.08685932791509643, 0.11195258220439497, 0.06462738742229934, 0.04907491136809439, 0.0393241133926604, 0.1253066898272085, 0.09829889038608253, 0.108374183429374, 0.07617583837683739, 0.09021193216626255, 0.12227283319849103, 0.13515401664287052, 0.19214513575844305, 0.11871350305385664, 0.11948182561325271, 0.18381521100123233, 0.12427792157018791, 0.11276033290538601, 0.2342419692569806, 0.10762579246591608, 0.034167850586248494, 0.16416998437192165, 0.14420699421107586, 0.19818443354174853, 0.14234078514502346, 0.13816007412161413, 0.5584175209380793, 0.5308047992673399, 0.5554724693483459, 0.5569055519207248, 0.5094342234052598, 0.47061811798386866, 0.594485157655364, 0.5476702229149322, 0.590580447943617, 0.060528127753490146, 0.078303682085207, 0.09564294317145217, 0.10141820657649858, 0.0905329015113241, 0.1091730569254763, 0.1554664370074419, 0.15755978619803823, 0.12397294044108476, 0.22901894820023094, 0.18637766341045026, 0.2532520894280442, 0.22371848209061307, 0.2023608532306168, 0.18085719000516354, 0.20646425462326123, 0.16766989178073233, 0.1511053442406819, 0.260717024208303, 0.3045920185445147, 0.3796063365579667, 0.29122896055043535, 0.3749020755597101, 0.2626109804366702, 0.31113899521394184, 0.29105932804881407, 0.6052083720399459, 0.1502172966129829, 0.2531924537895166, 0.22968319978635132, 0.2762497069757861, 0.16461608174904507, 0.2250335726368139, 0.24493736083823026, 0.2611740423480119, 0.2365895653296003, 0.22656599557427282, 0.23092666299305753, 0.22438948280281945, 0.2141361904398973, 0.1885637754614612, 0.221971634099983, 0.2297231613115731, 0.24944956815854125, 0.2180352787682428, 0.19000033904524183, 0.1835613164088109, 0.18043474085276356, 0.19909545644619142, 0.21390972631641791, 0.17561866516612212, 0.1878863249093018, 0.17115700412137935, 0.1783840856790483, 0.18527267890424926, 0.8736640883822385, 0.17389233592274833, 0.9102844563765998, 0.8647662323770212, 0.9075921526129392, 0.16089964273476964, 0.15695387815591533, 0.17610130980221927, 0.38405665345127027, 0.15554612753028485, 0.36875525168503753, 0.21013138043715585, 0.40014158199774263, 0.16707265077232514, 0.4711341289539863, 0.1676672098093246, 0.31676844029459095, 0.19723467148681717, 0.18033754466555307, 0.18805972709237195, 0.1854981596855768, 0.22177772623830183, 0.18638695068838518, 0.20706224054503108, 0.18208505747961268, 0.18943380328767756, 0.09188837512534631, 0.09462368220962802, 0.0879008387434993, 0.09648756317211338, 0.10363421403171358, 0.09358809710631777, 0.07920990320007515, 0.10237358954034992, 0.10173724450373434]}, "mutation_prompt": null}
{"id": "ffbda28f-83f6-4b94-a5d2-17c6bb6fc638", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n            self.social_coef = 1.5 + 0.5 * (i / self.iterations)  # Adjusting social coefficient dynamically\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Introduced dynamic social coefficient adjustment for EnhancedAMPSO to better balance exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.32984833396713314, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8492154857688221, 0.8247262330671603, 0.8386483237199593, 0.8280296546120841, 0.835041158893427, 0.8406028659950777, 0.821910726434087, 0.8308825261183692, 0.8246839703268364, 0.6509436704642938, 0.6378354981325831, 0.6271606821698248, 0.6415896059178232, 0.6185605655356556, 0.6282947997962467, 0.5883801105153705, 0.6297209853212615, 0.6078104082614625, 0.11546690637119772, 0.17928922822087157, 0.15453644743475636, 0.11539654346405603, 0.12472009917127946, 0.1452653906794148, 0.11443946224222001, 0.11704267953446412, 0.18355402367792328, 0.11905811423402668, 0.0437455391724525, 0.06141401768847832, 0.1250076950506418, 0.08215298823223005, 0.08122622986687766, 0.11795069686117965, 0.10841594935687515, 0.08780164043062455, 0.9097430236923173, 0.9379115455424543, 0.8993736938586561, 0.8981796848894602, 0.8991723721685494, 0.8891450754660618, 0.9061453067143206, 0.885374246346641, 0.8930921424058037, 0.6588919656573466, 0.6426655831799835, 0.6328992739362109, 0.6298109544700207, 0.6286414754081844, 0.6362999668767826, 0.6026269526452852, 0.6213940843600776, 0.6333996224365113, 0.7719820324974045, 0.655559301240354, 0.22472427013863372, 0.28012777080769125, 0.27637223059406446, 0.891519972014495, 0.17609698024693876, 0.17673941853717912, 0.17691127037625176, 0.2990862869566724, 0.12208034957383063, 0.18750004720710278, 0.21649309687240548, 0.29353341560336166, 0.2760038833216605, 0.21007191657986413, 0.20637044809984073, 0.3084582589032556, 0.2382476551550501, 0.12546310437397334, 0.2207954533857196, 0.13216890438963058, 0.21578105523676772, 0.22836590024967296, 0.2525605813563955, 0.2496046082573885, 0.2125688821932349, 0.02523585345564372, 0.033913409356255975, 0.004593318798875923, 0.08346748470277854, 0.03916867056571205, 0.014451329370994026, 0.042553662347774246, 9.999999999998899e-05, 0.01253897450717778, 0.17615186738494382, 0.09171418947631116, 0.09887542274524042, 0.058750462573295636, 0.05405516505257002, 0.06064229375147279, 0.0880938528872659, 0.08806275327607005, 0.11582923191076533, 0.250200809762553, 0.12419015108392484, 0.15654656399702804, 0.09254064678309093, 0.09046368407340377, 0.0826162637822847, 0.1011434325087428, 0.1880935554135461, 0.12655213549008715, 0.14419764088167197, 0.16382528138044072, 0.19082766774943927, 0.056836991909314016, 0.12573753384580943, 0.16204482749528182, 0.22632375054176734, 0.13785773120744416, 0.08192461011861052, 0.5514672301442822, 0.4988850965209578, 0.5173656353450365, 0.5468521089188063, 0.5257510208213294, 0.5497221763350166, 0.5554404867013634, 0.5418734195169346, 0.5677176009229403, 0.10196283757918823, 0.0848294405513712, 0.0937844369569173, 0.1268899035037666, 0.09471647353713541, 0.15402097179047725, 0.12720155333763705, 0.12991963231544346, 0.15125601012920464, 0.6078498882669308, 0.5094444781862756, 0.5429161285043104, 0.4082085437134396, 0.5280879454878418, 0.2068231109908375, 0.5325783802060997, 0.34045225910631305, 0.5036188731005056, 0.41440750085346667, 0.48027187459868914, 0.5171408183016588, 0.5243159926925587, 0.48334575100826926, 0.5226749319779858, 0.5300430470731827, 0.514252485687517, 0.26624971943766895, 0.17814323631847162, 0.35424161320290537, 0.2866738132638703, 0.3831285764130664, 0.19731432114857905, 0.3193250165497862, 0.23700879012553722, 0.2804181203409296, 0.2572818972647256, 0.20999157778270394, 0.21654973470194738, 0.22487030956935827, 0.2074479092586592, 0.2212520256462217, 0.2056619116389543, 0.23235196251951795, 0.2221441081197384, 0.21408179395357652, 0.183536318419808, 0.19532065829338652, 0.2265548890250736, 0.18742192899764742, 0.1877913666572324, 0.18876303730597965, 0.1931377242289436, 0.1878495639818204, 0.19078993739667072, 0.1224503512043078, 0.8616892642629697, 0.17589039146202212, 0.8913845750265993, 0.8660082850378384, 0.8922887039455214, 0.14185428664460775, 0.16774667028885049, 0.16601121388426276, 0.8115600785212667, 0.15543432260393297, 0.683937881253339, 0.21016226013740402, 0.6497778957131342, 0.1539644311826478, 0.11118683902284143, 0.16558600444367166, 0.6831072758813682, 0.20037010769855035, 0.1845255836747891, 0.19409057886181436, 0.195658290547024, 0.19227010619942864, 0.1898352222287919, 0.18623859335086246, 0.1753128239681484, 0.19542683574165742, 0.08925546239195614, 0.09800384081143254, 0.09600794869263951, 0.09199142121056614, 0.09696966298109888, 0.099395231063646, 0.08656944360870167, 0.10793074829460547, 0.09536139166097202]}, "mutation_prompt": null}
{"id": "d33e8835-d2f7-4c35-8d94-c60c696cd89d", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def quantum_exploration(self, positions):\n        quantum_positions = positions + np.random.normal(0, 0.1, positions.shape)\n        return np.clip(quantum_positions, self.pos_bounds[0], self.pos_bounds[1])\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            inertia_weight = 0.4 + (0.9 - 0.4) * ((self.iterations - i) / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = self.quantum_exploration(positions)\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Dynamic Inertia and Quantum-inspired Exploration for accelerated convergence and exploration balance.", "configspace": "", "generation": 59, "fitness": 0.21364984306434762, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.4122431290589105, 0.41724742743168386, 0.41485032917170706, 0.39370150413025007, 0.39801409344331184, 0.4058630580007473, 0.4009571296318645, 0.39418316938595, 0.4161284153797131, 0.0283319782773348, 0.01667378905223793, 0.010557985373921497, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11698450468961652, 0.11734359288282248, 0.11129472213586256, 0.10523326404374944, 0.11897265549352087, 0.11005965412867214, 0.08474599997959098, 0.09470304677427299, 0.10979314516481942, 0.10571801745533904, 0.0799217327996865, 0.08967397270699295, 0.09500225895474945, 0.08704492794694596, 0.08617195543395861, 0.09129928935768272, 0.10013801674607725, 0.08944431013584175, 0.9183780902232901, 0.9364883993823142, 0.904094761366523, 0.9165347050987861, 0.9234913217951901, 0.8975411348652834, 0.9156708868474004, 0.9044683794395928, 0.9114303430447943, 0.2634325183974172, 0.2767561111495246, 0.29127650869019195, 0.2623873933876981, 0.2819612934332367, 0.27346656849845663, 0.2602699227645583, 0.25428847477905314, 0.2723214064600026, 0.3152161584443782, 0.3369907561217428, 0.237912208857462, 0.28280735296912685, 0.24991723398336263, 0.36551300259452224, 0.2644758154410177, 0.24721006529545897, 0.293103841624491, 0.15277529582610883, 0.17040747091015584, 0.15165723606888437, 0.1491841859501355, 0.1522390287007407, 0.1671819765340371, 0.16171900575996356, 0.17672745453207117, 0.14352221239278584, 0.15155136988140927, 0.14783753374956232, 0.16352134011316588, 0.15047426288004895, 0.16408859454374747, 0.14083997446136798, 0.1479564933247013, 0.14020048041040123, 0.1556281456725903, 0.03299963590518595, 9.999999999998899e-05, 0.008772855027262771, 0.018337102730590416, 0.007996488789090317, 0.0020113880582816046, 0.021607809917930765, 9.999999999998899e-05, 0.015763678854955665, 0.1162711128142504, 0.07843028289980425, 0.10565391558891968, 0.052377333939084725, 0.05353501848813813, 0.029983221210097, 0.09527526770143901, 0.09198170906453396, 0.0966440460315946, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10838444409452763, 0.08374520384882256, 0.08968912051692679, 0.080807038427549, 0.10169878562788659, 0.08835543287109993, 0.09132688100502562, 0.09198831863059076, 0.06324235868427353, 0.3906108301307486, 0.39593489710651253, 0.39924360115748736, 0.4089082428946583, 0.3923430659867764, 0.39776987960578547, 0.39635238355197056, 0.3820031331848922, 0.39399165007549664, 0.10947497177635923, 0.09948853029614035, 0.09437665996269429, 0.08996951365391903, 0.1217410443428888, 0.0843919215701755, 0.11219816350202749, 0.12670338374581003, 0.11357019512401845, 0.20424981558298916, 0.2361838849086485, 0.20853906840880854, 0.20461028142839144, 0.16952740860150006, 0.21983603898054316, 0.21096225569268667, 0.19568726920025414, 0.200864572488743, 0.271083848803935, 0.27448825043738423, 0.2778421816075035, 0.2847792914975593, 0.2786395813627901, 0.2871424765014622, 0.2743243888351984, 0.2807229866808183, 0.2819855672694195, 0.22318642797123878, 0.21640262384963593, 0.21486359316407855, 0.21441145141465245, 0.19048096229095512, 0.21331108186763792, 0.18870547402653604, 0.22399608664934245, 0.20406687460040707, 0.21118245643022104, 0.263459628670356, 0.20319312362404773, 0.20865877495580576, 0.20339496539456126, 0.24608691335922328, 0.21111040261046587, 0.21298314469709423, 0.20214597011837343, 0.18466211731686022, 0.18983439703998406, 0.19858012869551311, 0.2425609156073174, 0.1780094367751297, 0.18430632641358113, 0.23811237113299233, 0.1798113161520487, 0.1866023574536413, 0.12203284993081376, 0.1850460634328891, 0.173969871865865, 0.6196328565577062, 0.5599848890882646, 0.5922175491817558, 0.14095740843988402, 0.5685482346697235, 0.1647847751116568, 0.5378420385578013, 0.2096382378181112, 0.526693897604085, 0.20940646463770773, 0.3879156017259193, 0.20338789616044906, 0.16492611563072934, 0.16586000513275334, 0.3906758249745106, 0.18070762283997266, 0.18041775992051867, 0.19972855711503612, 0.1760399035540875, 0.1890312700373582, 0.1946469753533896, 0.21408156130772438, 0.191918669712841, 0.17315948675523596, 0.08425247206250375, 0.09267741523501749, 0.08813241816214323, 0.09215100482009386, 0.09494547465688008, 0.10379987638605981, 0.09679704825940116, 0.09702108745701188, 0.09488411694204024]}, "mutation_prompt": null}
{"id": "5584b15b-f963-4d56-aa20-1ec36fa35bc9", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions, factor=0.5):\n        center = (self.pos_bounds[0] + self.pos_bounds[1]) / 2\n        opposite_positions = center + factor * (center - positions)\n        return opposite_positions\n\n    def dynamic_adaptive_topology(self, scores):\n        sorted_indices = np.argsort(scores)\n        diversity = np.std(scores)\n        dynamic_size = max(1, int(self.population_size * (0.1 + diversity / 10)))\n        return sorted_indices[:dynamic_size]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n\n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n\n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.2 + 0.8 * np.exp(-0.05 * i)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_indices = self.dynamic_adaptive_topology(scores)\n            local_best_position = positions[local_indices[np.argmin(scores[local_indices])]]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Improved EnhancedAMPSO with Dynamic Oppositional Learning and Adaptive Memory Rate for robust performance across diverse landscapes.", "configspace": "", "generation": 60, "fitness": 0.3279535552346413, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8631843726189716, 0.8664329345983688, 0.8694398639317625, 0.845425785026859, 0.8363293590632157, 0.834883914544922, 0.8514297674805225, 0.850321313190567, 0.8419045628900872, 0.6391308000839866, 0.6679949871392885, 0.6792099985999454, 0.6248256390530582, 0.6656561581034783, 0.6464302302726803, 0.6456806538256059, 0.6413589881329287, 0.6429396409812886, 0.10266051651616104, 0.10529361769046686, 0.08995459023952956, 0.11699370987155311, 0.14302502251257543, 0.11639811664476296, 0.0923620538007186, 0.14883205649318276, 0.14289442498208904, 0.10090778239708453, 0.11066051395980536, 0.11306080369846516, 0.10933837367798227, 0.08255268204867117, 0.07894871944226212, 0.12812091312002793, 0.15153802711919473, 0.09221858783162062, 0.9003610225098504, 0.8836573992637874, 0.903724406862198, 0.9020576422029069, 0.8797287454765222, 0.8878333124565351, 0.8685516189134913, 0.8599179517369602, 0.8713159221072209, 0.6484041290467761, 0.645996155045493, 0.6098911045317945, 0.6600464602643117, 0.6608647113233873, 0.6860960588908058, 0.6352074009856361, 0.6358211851495716, 0.649947577741099, 0.2292658883253308, 0.22883046701541343, 0.22743075318771788, 0.8350070445644617, 0.3832751410991947, 0.7948223655376534, 0.14403266899280132, 0.17567568733165606, 0.5849107815438117, 0.24928622764865183, 0.29489872373545845, 0.24082893999634536, 0.20414176463827083, 0.22488631554064353, 0.2382066715227299, 0.21452881213757413, 0.4115616065324522, 0.2123818676978524, 0.2925694099774444, 0.23186346286800807, 0.23042248379442198, 0.23510934306901965, 0.2708119799005323, 0.22856257488132237, 0.255534861193375, 0.24088601555393274, 0.2596053319198349, 0.02938486617518976, 0.09065909380595405, 0.08558302064986967, 0.03428089780724297, 0.01114096633787709, 9.999999999998899e-05, 9.999999999998899e-05, 0.00625583791721418, 0.05583342578156114, 0.11897261013455751, 0.07511483447039502, 0.12329536312604594, 0.06929624155361946, 0.09665762743117956, 0.0494917243427857, 0.10644604662193324, 0.11515048664866845, 0.09954553860123361, 0.14975101491444098, 0.14229472624650574, 0.15850511042462345, 0.1328379124240937, 0.1235060651515203, 0.15231623401129857, 0.09230025159429112, 0.12979438530928977, 0.11308471243877827, 0.18773729508611825, 0.06812294459519797, 0.10392359249588712, 0.10925583594567578, 0.1392637209420975, 0.08724836901958766, 0.08867244797067309, 0.2644363801298134, 0.08525827864517177, 0.5361274083706584, 0.5133054863673442, 0.5466799986264215, 0.525493771719481, 0.5211150325199803, 0.5381887216445451, 0.5043888589120447, 0.5262097116069515, 0.5456481787863032, 0.08233695735566382, 0.11656727862278915, 0.0524131535042196, 0.08174196248064014, 0.06307905135112446, 0.10682461890549999, 0.12184341526648801, 0.08552750387707309, 0.11114647872946393, 0.34767484419749406, 0.3937631625607556, 0.601384357740465, 0.4628990156414178, 0.4618792114400746, 0.224299858349569, 0.4029416046477491, 0.5111276240412547, 0.6064667660778147, 0.523116247140094, 0.5052798502314411, 0.34156706460744135, 0.5887151997428887, 0.5722964941401208, 0.5238422799298444, 0.504142011354801, 0.5576130456925612, 0.277496477326417, 0.3082239953906043, 0.26972826851490384, 0.2867014453634501, 0.28302717786975085, 0.2448232372127861, 0.39308796816823055, 0.23252867624544482, 0.2555114495726568, 0.23897108313843785, 0.22557199431981234, 0.271137600344901, 0.26428002973163844, 0.24941425801002226, 0.24390483929481033, 0.2589790295154698, 0.27814077358238987, 0.23903870326065202, 0.2600236174345463, 0.19085755931189796, 0.17265803483772213, 0.19195749502213122, 0.18686770852436763, 0.18814589743401144, 0.18302850173036733, 0.18187683084359907, 0.18762614484988105, 0.18166562927245966, 0.18832145836120207, 0.18854006029120662, 0.18771296935005022, 0.8827292532886775, 0.199714469702026, 0.14829176732715843, 0.14178736648066803, 0.16822450049709858, 0.8998092293265685, 0.7738439048565772, 0.7617772710817605, 0.6529882512956495, 0.21074050201225414, 0.20839893649838637, 0.15356545379314246, 0.7665636366997455, 0.16930718398458666, 0.16641654320083654, 0.19020018590849652, 0.17234707434464747, 0.17473115100661074, 0.18137885767820439, 0.18966683191991962, 0.1770199324560755, 0.18820771795202818, 0.1876629637641214, 0.17347563165989943, 0.10270617638785406, 0.12129522705223494, 0.09097197384831202, 0.0757480786632585, 0.130935986443237, 0.095220751167301, 0.08380447026357052, 0.12073630287912196, 0.09748787188585883]}, "mutation_prompt": null}
{"id": "77224991-4412-405f-b157-7125ebaa99ed", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.9  # Adjusted inertia for better exploration-exploitation balance\n        self.cognitive_coef = 1.7  # Modified for enhanced personal learning\n        self.social_coef = 1.3  # Adjusted to reduce social influence\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n        self.damping = 0.99  # Added damping factor to gradually decrease velocity impact\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.05))  # Reduced neighborhood size for local refinement\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities *= self.damping  # Apply damping to velocities\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Neighborhood Topologies and Dynamic Parameter Control for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.289091693510441, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.6907921874331735, 0.708369781074008, 0.7182404518598013, 0.6998667636553728, 0.7018641675576964, 0.6959184720689455, 0.7170005705665119, 0.7088200416504563, 0.7098539672548081, 0.4675463392226734, 0.46569234365113843, 0.4289648677081148, 0.4548959750357535, 0.4269752239876362, 0.4710283746136108, 0.4258629879373256, 0.43389958965948494, 0.4074866833552866, 0.13897741483941206, 0.1402115788794276, 0.2558987068349273, 0.11301297201181237, 0.23019265462249616, 0.11998033069699554, 0.106001303927869, 0.14164512076090363, 0.14646955401483774, 0.10018458240576655, 0.06534324508962452, 0.09704433196601969, 0.11204096602172486, 0.1105045619447772, 0.09809020796563195, 0.10507697208526023, 0.10697851001202341, 0.0836105318460515, 0.9025229980411864, 0.9526882377098321, 0.9105338434747204, 0.9049105552056853, 0.9051285483225044, 0.907497091980224, 0.913948900173071, 0.9109559830084889, 0.906466050549324, 0.5033751209618692, 0.5250878847757758, 0.4971249320423776, 0.5125353033396941, 0.5098920879884589, 0.5582391193956935, 0.4720789831486778, 0.5090362636426556, 0.45371748055562056, 0.6554120194745527, 0.3358600443660832, 0.31993380431883267, 0.6889981980902455, 0.21004040710776395, 0.7255758498667656, 0.3381983657577906, 0.22972271863993743, 0.23236254145892044, 0.18037666510418182, 0.12255964091348015, 0.23896059567078742, 0.18210096597110237, 0.23076560425254855, 0.2018492491906102, 0.1887457788796324, 0.1789695479412241, 0.2008481241417167, 0.19581080465797462, 0.12593598706366904, 0.19882940821070405, 0.18578889048238034, 0.19819364818735008, 0.1858262384611783, 0.1329975619185545, 0.20760127843962994, 0.19334026316967112, 0.006420016479888324, 0.032368511425735824, 0.0500120732595396, 0.06830538028387056, 0.09436984803913984, 0.037469132716878684, 0.00971495182482196, 0.0304656780509045, 0.046339677280891944, 0.24948280725102723, 0.0909820689564369, 0.10548802973603066, 0.07890939195946922, 0.044883064236797554, 0.05299403692235716, 0.11663883373171136, 0.09129127232364209, 0.10273217580532112, 0.05415908268728886, 0.058930994613970666, 0.13752354637937314, 0.08077777952406795, 0.05870989616051592, 0.05408289423648982, 0.07231147172355545, 0.06814944178067595, 0.08062142960128782, 0.1405499132143585, 0.1330011435665609, 0.15370445540694544, 0.10303452499646792, 0.1541348311761227, 0.10860494062533776, 0.14766115881428743, 0.1862554569750574, 0.07882068158576017, 0.4848495279340689, 0.48651810108950666, 0.5161334932469412, 0.4913002678299806, 0.4855653706253793, 0.4894315302686273, 0.49364156572805673, 0.5163420264845389, 0.48824198653231377, 0.11963493483046006, 0.10342503059428254, 0.08475132828148668, 0.11244965813629282, 0.11156842652105747, 0.115556689943908, 0.13177037575876815, 0.12105430367793546, 0.1439244082818646, 0.35849537552488353, 0.2519716914166643, 0.34080929212940547, 0.26873918697266985, 0.25820826252048323, 0.32476898652684083, 0.3616353755971151, 0.2904558109453479, 0.31435855997101825, 0.394912271711213, 0.42052397675145814, 0.38798160279815375, 0.4778185261076635, 0.41917441743898387, 0.3790463956245309, 0.4489919869678851, 0.4820097284548104, 0.24470065439185262, 0.2775099038368214, 0.28832355059011916, 0.32392692985986715, 0.33429704282071915, 0.25271191916822955, 0.28426850750752386, 0.23294342230500698, 0.20391093477592503, 0.22612403453903462, 0.2235290734783666, 0.2532011428556825, 0.20647948700124386, 0.21772093022148076, 0.21770086973439728, 0.24134590822337587, 0.22024689402214248, 0.23148613818951247, 0.2100250676931963, 0.18268215333634608, 0.2070774923991482, 0.20287842150970314, 0.5510479626684166, 0.1903506903855373, 0.1831734641651377, 0.18326814872381358, 0.20096778005558436, 0.20063488454903355, 0.12203360208571978, 0.17418218469364488, 0.1742900724411618, 0.8024972473920585, 0.19950649606470716, 0.8071901302897182, 0.14157899915890104, 0.16635670561902427, 0.16583570291347638, 0.6058053837691263, 0.49308317423790826, 0.6551500045284525, 0.16849841501771823, 0.5410621668939426, 0.16761331216021313, 0.11073878247272273, 0.16554980790750984, 0.1641928623308866, 0.17798144848834307, 0.18382835029483746, 0.18311724803865748, 0.18054834163850975, 0.2014944452484917, 0.18297665681966935, 0.18659808760031993, 0.19440218717466518, 0.18067383432703465, 0.08947455841410523, 0.08826908184558357, 0.08900392829838255, 0.09257958971137781, 0.09637653660116574, 0.10007544115849776, 0.09532783630133634, 0.09967338065105469, 0.10205939981141798]}, "mutation_prompt": null}
{"id": "78aa971e-a85c-4a09-b1de-5ce3c9b3d6d1", "solution": "import numpy as np\n\nclass APC_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.pressure_control = 0.05\n        self.memory_decay = lambda i: 0.1 + 0.9 * (1 - i / self.iterations)\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.15))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def adapt_pressure(self, scores):\n        self.pressure_control = 0.05 + 0.45 * (1 - np.min(scores) / np.max(scores))\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            inertia_weight = self.inertia * self.memory_decay(i)\n            self.adapt_pressure(scores)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          (self.cognitive_coef + self.pressure_control) * r1 * (pbest_positions - positions) +\n                          (self.social_coef + self.pressure_control) * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "APC_PSO", "description": "Adaptive Pressure Control Particle Swarm Optimization (APC-PSO) with Memory Linear Decay for enhanced dynamic adaptability.", "configspace": "", "generation": 62, "fitness": 0.30459816354518066, "feedback": "The algorithm APC_PSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8697840990295368, 0.8635960231410162, 0.867492864244519, 0.8427041362364212, 0.860992311555828, 0.8593506431503083, 0.8615006046046433, 0.863545274162696, 0.8479304634467488, 0.5470821855171578, 0.4956329689996454, 0.6020300930236482, 0.5128270193424361, 0.5376330256923186, 0.585917630772941, 0.5223339993604317, 0.515033682090561, 0.5286823643340672, 0.08422610969869437, 0.09039624690369419, 0.3229413099478693, 0.13217640554959975, 0.12047490290655438, 0.15467289219990743, 0.11638164081372893, 0.17427180171661927, 0.14793676678054146, 0.09031135732621043, 0.04716524627461982, 0.07345998147625743, 0.10661969736852239, 0.07703570215606015, 0.060908014010139455, 0.11829037728081204, 0.11340205230166156, 0.08628468322988514, 0.9139882218024197, 0.9369516709215879, 0.8950267086995903, 0.8941535409246611, 0.9016207336960663, 0.880975088706428, 0.9019833131334561, 0.8773638763291791, 0.8890125769101337, 0.5021020702997312, 0.4817543894987608, 0.43193618692475255, 0.48702519771438546, 0.5082863087660265, 0.4918309908528711, 0.30941209061234254, 0.30564810083358873, 0.30301356610746755, 0.8436454246756637, 0.22420909875562112, 0.22575340434555702, 0.2764011712801554, 0.19264233395746921, 0.7961464528825426, 0.1760775348493735, 0.23257726965446568, 0.23455390012735966, 0.426036737418258, 0.13190137241306288, 0.128902153806024, 0.2323880886937688, 0.22590946323486405, 0.31245057731063575, 0.20502183730408985, 0.20405216706263374, 0.2883024730863093, 0.22795631515244508, 0.20668505651299385, 0.22557783261361564, 0.13213353302225173, 0.1420475001623034, 0.2001208393218039, 0.22901084305097086, 0.24200134427636488, 0.22963160917053882, 9.999999999998899e-05, 0.03955652648840735, 0.021863462287529334, 0.0638590724100977, 0.04784344833586274, 0.05363827073428473, 0.030052186383545787, 9.999999999998899e-05, 0.07073058218051775, 0.1297717352604716, 0.07315481715483907, 0.1367752788554779, 0.0661023503945698, 0.06239517808705464, 0.04074062046887428, 0.11333941923399793, 0.0976854189894879, 0.08454952144297545, 0.0636266220514623, 0.06724171441673732, 0.10689037350333075, 0.06205233921204889, 0.07916764167800228, 0.06305424936606563, 0.08163777323363208, 0.11615106256135566, 0.1040892387292135, 0.1270635863128422, 0.15522705720968788, 0.1842549931657893, 0.1234340618110562, 0.16038526755126425, 0.15439370365694471, 0.19415574359392207, 0.1649298144369159, 0.0807791158578699, 0.5672486413212502, 0.5273778177998669, 0.5433942394973273, 0.5728186739098062, 0.5826778748921932, 0.5508159602967634, 0.5665256153945952, 0.5654555351327615, 0.5635293119299165, 0.09272597910460534, 0.0959159159874311, 0.06528504580022987, 0.13660694341377588, 0.14442114465760514, 0.09734228791621358, 0.12472301757629523, 0.13887994410361082, 0.11497979484376031, 0.4958104787418347, 0.3107858758935288, 0.3186347422025537, 0.2557335277357361, 0.22089413451212858, 0.18527772580905044, 0.4345605832740336, 0.44897214710379374, 0.35532283267711817, 0.47975865962350284, 0.2619150367557572, 0.4778183088203517, 0.43701545968229927, 0.5241909735740069, 0.4324615728953277, 0.434558454445386, 0.5689310481174986, 0.2584038090116012, 0.24007245352703055, 0.35852643413937235, 0.27768528794970027, 0.33527966542047194, 0.18731704515060132, 0.3100654014781242, 0.23480124259858837, 0.26199665365194413, 0.24280688025320774, 0.20421761537400784, 0.21596910485967868, 0.21067311396373167, 0.23226078215565937, 0.22411375404417544, 0.22871991711646467, 0.23953481109895125, 0.22731862319042606, 0.23377351397506352, 0.1822135589841981, 0.18146702080528843, 0.22479054960237133, 0.24918892921435676, 0.20727090516620572, 0.18895347823766484, 0.17807900157531875, 0.19422632321354627, 0.18925140037553867, 0.12249052315356279, 0.1848793079193265, 0.176442291421395, 0.8589217579140371, 0.8569597503040951, 0.8575458421317407, 0.14183479188729908, 0.16668461790255718, 0.1659489731792737, 0.6329928586211897, 0.15571476554717334, 0.7379950243282243, 0.21001582899529214, 0.6476945018939559, 0.15373825094299032, 0.4471313012321334, 0.16557604372883927, 0.3834531893237686, 0.18008580222153325, 0.1856611851363974, 0.17675340027607622, 0.18548097728441182, 0.18705957380509475, 0.1784972495040099, 0.18879369065587503, 0.17024025805531562, 0.18538474924083248, 0.09241243178904768, 0.10093533382383502, 0.09299753208470951, 0.09641376434511018, 0.10024896124220428, 0.08946216757078185, 0.08718261914053982, 0.08851121781753168, 0.10268241918663112]}, "mutation_prompt": null}
{"id": "1daefc70-9322-4bdb-bb22-876b34d80bdb", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Neighborhood Topologies for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8566418081359641, 0.8303423264508174, 0.8516183311494232, 0.8321490668123401, 0.8357337160793011, 0.8407005381900351, 0.8392340312331203, 0.8523015807257315, 0.8322739835209731, 0.6711846866405555, 0.6697174051455386, 0.6494660060325723, 0.6528151438749281, 0.6579920851416323, 0.6444384843507236, 0.6280763373090854, 0.6812867923765948, 0.6160562146554801, 0.13998703840760263, 0.16591170355325158, 0.16541732337444903, 0.1410632786920082, 0.15662814128840274, 0.12894422610786493, 0.12060173881079939, 0.11872724786664968, 0.17832162677128804, 0.10471476757269771, 0.0467934901435032, 0.06387815506743777, 0.11042680828397844, 0.07144807690944888, 0.05464704616408911, 0.11603757511106871, 0.11210396198525874, 0.05586191541009233, 0.9096827060287042, 0.9375361085370097, 0.899290897309731, 0.8981832528309829, 0.8974334240891066, 0.8891234673411167, 0.9061378988370403, 0.8851996708887686, 0.8930988823212387, 0.7218045694087009, 0.6676013482114826, 0.6687167832791033, 0.670739460221037, 0.6871121956867032, 0.672686363325045, 0.6405948876983021, 0.657568721845861, 0.6655500245490726, 0.8358714620291631, 0.7971397027078571, 0.22396367284700103, 0.2801709222968203, 0.2118780755221331, 0.8233041867972615, 0.17648849959274016, 0.1743438417566855, 0.23170191416019592, 0.3159684457109474, 0.12299107769257667, 0.19196127956497877, 0.2236045737643978, 0.2832598887996671, 0.2655411022016003, 0.22158130932889208, 0.20683395115752412, 0.3116999629957943, 0.24981532843999044, 0.12091273471976094, 0.22461922197043493, 0.13217939176678506, 0.21315478285890854, 0.21385093963064983, 0.24464617365345143, 0.2455448950859873, 0.12796935601029313, 0.03434053187674013, 0.04377636654386918, 0.09865447423613494, 0.05813807933707971, 0.08756170740461222, 0.07755940004325934, 0.04157510331967895, 9.999999999998899e-05, 0.012067677632501161, 0.17073869284148735, 0.10065680818554956, 0.10102060826934411, 0.05647401159743348, 0.040257879592135004, 0.047530413591438836, 0.08444105876486285, 0.09242596736439102, 0.0917997356530661, 0.1679966066227052, 0.1761204700372233, 0.1133012092557577, 0.086922706659737, 0.08581645916956171, 0.07437809964158992, 0.11295807313236605, 0.2283407610769307, 0.1363264827065488, 0.13303037254987393, 0.1407900888127257, 0.26629609715709945, 0.057334045048600846, 0.10675475432907, 0.13365930814224536, 0.21271486583516108, 0.11548523345865047, 0.08202212010721521, 0.5244320356863881, 0.5692232263763082, 0.5335327129223775, 0.5311687120229605, 0.5521606581702889, 0.5446780070971865, 0.5580426707714887, 0.5564902123707601, 0.5714519748506801, 0.11260056165583487, 0.0857229763372157, 0.09105719263574752, 0.12872523148266268, 0.10459528307834354, 0.13607915843082008, 0.14231623375241909, 0.13425221628835238, 0.16974697491574875, 0.4986462131412278, 0.21156558084087163, 0.20557610613453403, 0.44001594706238856, 0.3169062849689852, 0.28889936315186693, 0.49562373387023795, 0.22007750139182136, 0.32084748230844296, 0.4564882898220388, 0.6437980088135165, 0.4877078496063437, 0.5114375088776402, 0.3894461736543896, 0.5225134835538632, 0.6165249439755066, 0.5677938357799411, 0.2667859165899703, 0.2325802607259675, 0.3983162967842767, 0.36727605161184684, 0.3724311019209292, 0.19405995387539277, 0.2964957318206193, 0.24033720800537817, 0.27326381043809267, 0.24265624148993148, 0.22696670409366093, 0.2168905888608087, 0.20348506443142267, 0.23901389506768633, 0.23249119707153476, 0.23875167226808724, 0.2251576144705828, 0.22848814798947348, 0.22400521227911774, 0.20146551795983625, 0.24362632186584632, 0.220727157052641, 0.18749024675240267, 0.20263527614824084, 0.1825622922932002, 0.17944038701217324, 0.21942018833154786, 0.19105865148204493, 0.12245577689732123, 0.878559883928087, 0.17618516399671902, 0.904025677020762, 0.8757757359953653, 0.9030272801080885, 0.14185725392162019, 0.16774797818763731, 0.16601368514992187, 0.7623060900179983, 0.15544003955641872, 0.694457164682527, 0.2103189567266427, 0.576855365258548, 0.15352408626155412, 0.11120922025008095, 0.16564341341252897, 0.7263286483945359, 0.17889254405497146, 0.197595021042829, 0.19195004639541147, 0.18257414728741994, 0.17568788131008373, 0.18915409171382347, 0.17449222302965717, 0.18332911105416794, 0.18879219215087684, 0.09156703727549398, 0.08999233390067451, 0.0897204008234539, 0.10223194978368388, 0.09849030617251753, 0.1040358698408923, 0.08760725456180607, 0.09426424733333283, 0.08722456748905483]}, "mutation_prompt": null}
{"id": "585305dc-c500-49cc-93ba-4f1107406cb1", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            learning_rate = 0.5 + 0.5 * np.min([1, 1 - gbest_score / np.max(scores)])  # Dynamically adjusted learning rate\n            positions += learning_rate * velocities  # Use the adaptive learning rate\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Learning Rate to dynamically balance exploration and exploitation for improved convergence in diverse landscapes.", "configspace": "", "generation": 64, "fitness": 0.278306590351054, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8854535403156271, 0.8860239479352643, 0.8905104893856632, 0.8232253555672405, 0.8514644544583467, 0.8451919096853364, 0.8387686943676214, 0.8096495241412394, 0.7969476289278349, 0.6968565063429644, 0.33029614621687453, 0.6135579632769534, 0.657136576736506, 0.5727993400163948, 0.6190399260847512, 0.6238544452117303, 0.6749455283704863, 0.6351346753971258, 0.02536289999400998, 0.06502680447006737, 0.023070879011223067, 0.15604270999731018, 0.15040720648372952, 0.13980380188576236, 0.11742545763440337, 0.1332950218286767, 0.10904716255596614, 0.041018940620702105, 0.0365142196286623, 0.02292883440337956, 0.1085870297950623, 0.09567505423681011, 0.0570295862044331, 0.07710070329710528, 0.10934773406253262, 0.06387184835437876, 0.8779206460077107, 0.9324826763491404, 0.7729113928346025, 0.15132128221795393, 0.1901902632382173, 0.13857443986391027, 0.6957717361043543, 0.7230878942811527, 0.16191284202185474, 0.6862480255406979, 0.5917726647038339, 0.5551492188441192, 0.5668139675171513, 0.5460165237087767, 0.6368518298177284, 0.35962475683568595, 0.4254213804500214, 0.4279452543034107, 0.8914073510607448, 0.34626832781630423, 0.2136492465210813, 0.21384517094853195, 0.21170054753768508, 0.3816149683355271, 0.23417748327129162, 0.17702058503771678, 0.23148730027733233, 0.29044439226899044, 0.1227117578003799, 0.1256531485345881, 0.18425327161329963, 0.27004464743052714, 0.24373927212974067, 0.21233597765549717, 0.1918658692502988, 0.46476934647906687, 0.22159919244467774, 0.12656719768323033, 0.20400671327999842, 0.1277780147846468, 0.13368513274420568, 0.13062026344960342, 0.20556190592721502, 0.18862140971346375, 0.1835009684273814, 0.04370324791115632, 0.008384756141545435, 0.0681617719356451, 0.05290811345638047, 0.10481454853224181, 0.07183455370931402, 0.043119501427071216, 9.999999999998899e-05, 0.009960900241884563, 0.18637527925128328, 0.11767491686967946, 0.11361193154755533, 0.05217029697573694, 0.03974772144213401, 0.04758355768249345, 0.09005503991026331, 0.09082644159897268, 0.1073784024029566, 0.06977783753549138, 0.25758620280255873, 0.23530455032011732, 0.08078982787129574, 0.09034035509927685, 0.0776824491683934, 0.09127895097396688, 0.23588268537635826, 0.21192366070195945, 0.1013614471307912, 0.2853627926831217, 0.2574557931945832, 0.08130142598427537, 0.12701611283801317, 0.16900530184824292, 0.1121799617978615, 0.16338742555367314, 0.07354759323634885, 0.34508744437626016, 0.4923367023294555, 0.4557088445697183, 0.4375999913801405, 0.4266882897549633, 0.3798499745946712, 0.523017617636768, 0.5125255998451225, 0.5169252656985639, 0.06343534350715596, 0.0703964489150316, 0.09527967568630957, 0.09154944637100593, 0.08242823806855759, 0.1315692253056875, 0.14269215335958418, 0.132684365349497, 0.6296757124615023, 0.2648314507543371, 0.27652489532140345, 0.18275936732606002, 0.11254712526466559, 0.1325633505040873, 0.12045069320722102, 0.2459618984013503, 0.31549925971893156, 0.5782589889154417, 0.20735579391374437, 0.23922978965349273, 0.23408045124466037, 0.42621362971032384, 0.5109515159712876, 0.40449548802914315, 0.3181040108602524, 0.26130838350670604, 0.32763829137203504, 0.22160298258575695, 0.24100634888888894, 0.2276021378538532, 0.21391247872806707, 0.17720043145434006, 0.40909822621053404, 0.19287516990406328, 0.29367532083762937, 0.19487725132552214, 0.13370348851050362, 0.14527710757456447, 0.13676437384004347, 0.20627718720464705, 0.22032320130630234, 0.1994465448270426, 0.2252624939386615, 0.24265217097068348, 0.23086585128184411, 0.1684233582787198, 0.1672687715961727, 0.18485084840364785, 0.1764304687777405, 0.17483897375616053, 0.18291048129233223, 0.1903397179748253, 0.16604973370542742, 0.18660219548759505, 0.18507214875527445, 0.1743966786856861, 0.17669141506915598, 0.8965411687487712, 0.8728224559290465, 0.9118416526209102, 0.13975084487811584, 0.15140872401758898, 0.1656371685499789, 0.8003610706985859, 0.1514960262504006, 0.5139307187842865, 0.20893482872133096, 0.3650058355417979, 0.15011682723198594, 0.11120922025008095, 0.16564341341252897, 0.7263286483945359, 0.1890021826901498, 0.19314526767952878, 0.17547193328387456, 0.19740775392740528, 0.19017300542248072, 0.18454288233021754, 0.1885036658881699, 0.18505199445110643, 0.17160870223708646, 0.08303522669019081, 0.10600431662384868, 0.09293565782947644, 0.10027505557750482, 0.09822385660160493, 0.10064242817839242, 0.08932178270778024, 0.0921658843737847, 0.0902068742761214]}, "mutation_prompt": null}
{"id": "a53a043f-4973-48c4-9419-eeae45f48a33", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with Adaptive Neighborhood Topologies for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8566418081359641, 0.8303423264508174, 0.8516183311494232, 0.8321490668123401, 0.8357337160793011, 0.8407005381900351, 0.8392340312331203, 0.8523015807257315, 0.8322739835209731, 0.6711846866405555, 0.6697174051455386, 0.6494660060325723, 0.6528151438749281, 0.6579920851416323, 0.6444384843507236, 0.6280763373090854, 0.6812867923765948, 0.6160562146554801, 0.13998703840760263, 0.16591170355325158, 0.16541732337444903, 0.1410632786920082, 0.15662814128840274, 0.12894422610786493, 0.12060173881079939, 0.11872724786664968, 0.17832162677128804, 0.10471476757269771, 0.0467934901435032, 0.06387815506743777, 0.11042680828397844, 0.07144807690944888, 0.05464704616408911, 0.11603757511106871, 0.11210396198525874, 0.05586191541009233, 0.9096827060287042, 0.9375361085370097, 0.899290897309731, 0.8981832528309829, 0.8974334240891066, 0.8891234673411167, 0.9061378988370403, 0.8851996708887686, 0.8930988823212387, 0.7218045694087009, 0.6676013482114826, 0.6687167832791033, 0.670739460221037, 0.6871121956867032, 0.672686363325045, 0.6405948876983021, 0.657568721845861, 0.6655500245490726, 0.8358714620291631, 0.7971397027078571, 0.22396367284700103, 0.2801709222968203, 0.2118780755221331, 0.8233041867972615, 0.17648849959274016, 0.1743438417566855, 0.23170191416019592, 0.3159684457109474, 0.12299107769257667, 0.19196127956497877, 0.2236045737643978, 0.2832598887996671, 0.2655411022016003, 0.22158130932889208, 0.20683395115752412, 0.3116999629957943, 0.24981532843999044, 0.12091273471976094, 0.22461922197043493, 0.13217939176678506, 0.21315478285890854, 0.21385093963064983, 0.24464617365345143, 0.2455448950859873, 0.12796935601029313, 0.03434053187674013, 0.04377636654386918, 0.09865447423613494, 0.05813807933707971, 0.08756170740461222, 0.07755940004325934, 0.04157510331967895, 9.999999999998899e-05, 0.012067677632501161, 0.17073869284148735, 0.10065680818554956, 0.10102060826934411, 0.05647401159743348, 0.040257879592135004, 0.047530413591438836, 0.08444105876486285, 0.09242596736439102, 0.0917997356530661, 0.1679966066227052, 0.1761204700372233, 0.1133012092557577, 0.086922706659737, 0.08581645916956171, 0.07437809964158992, 0.11295807313236605, 0.2283407610769307, 0.1363264827065488, 0.13303037254987393, 0.1407900888127257, 0.26629609715709945, 0.057334045048600846, 0.10675475432907, 0.13365930814224536, 0.21271486583516108, 0.11548523345865047, 0.08202212010721521, 0.5244320356863881, 0.5692232263763082, 0.5335327129223775, 0.5311687120229605, 0.5521606581702889, 0.5446780070971865, 0.5580426707714887, 0.5564902123707601, 0.5714519748506801, 0.11260056165583487, 0.0857229763372157, 0.09105719263574752, 0.12872523148266268, 0.10459528307834354, 0.13607915843082008, 0.14231623375241909, 0.13425221628835238, 0.16974697491574875, 0.4986462131412278, 0.21156558084087163, 0.20557610613453403, 0.44001594706238856, 0.3169062849689852, 0.28889936315186693, 0.49562373387023795, 0.22007750139182136, 0.32084748230844296, 0.4564882898220388, 0.6437980088135165, 0.4877078496063437, 0.5114375088776402, 0.3894461736543896, 0.5225134835538632, 0.6165249439755066, 0.5677938357799411, 0.2667859165899703, 0.2325802607259675, 0.3983162967842767, 0.36727605161184684, 0.3724311019209292, 0.19405995387539277, 0.2964957318206193, 0.24033720800537817, 0.27326381043809267, 0.24265624148993148, 0.22696670409366093, 0.2168905888608087, 0.20348506443142267, 0.23901389506768633, 0.23249119707153476, 0.23875167226808724, 0.2251576144705828, 0.22848814798947348, 0.22400521227911774, 0.20146551795983625, 0.24362632186584632, 0.220727157052641, 0.18749024675240267, 0.20263527614824084, 0.1825622922932002, 0.17944038701217324, 0.21942018833154786, 0.19105865148204493, 0.12245577689732123, 0.878559883928087, 0.17618516399671902, 0.904025677020762, 0.8757757359953653, 0.9030272801080885, 0.14185725392162019, 0.16774797818763731, 0.16601368514992187, 0.7623060900179983, 0.15544003955641872, 0.694457164682527, 0.2103189567266427, 0.576855365258548, 0.15352408626155412, 0.11120922025008095, 0.16564341341252897, 0.7263286483945359, 0.17889254405497146, 0.197595021042829, 0.19195004639541147, 0.18257414728741994, 0.17568788131008373, 0.18915409171382347, 0.17449222302965717, 0.18332911105416794, 0.18879219215087684, 0.09156703727549398, 0.08999233390067451, 0.0897204008234539, 0.10223194978368388, 0.09849030617251753, 0.1040358698408923, 0.08760725456180607, 0.09426424733333283, 0.08722456748905483]}, "mutation_prompt": null}
{"id": "90269c77-5a29-477a-aac0-7fcead551f06", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            # Changed line: Introduce dynamic cognitive coefficient\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Introduced a dynamic cognitive coefficient to balance exploration and exploitation in EnhancedAMPSO.", "configspace": "", "generation": 66, "fitness": 0.33104272854572503, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "8bbd8a35-c748-45c4-bd4e-3d61a2513e84", "metadata": {"aucs": [0.8515670692617725, 0.8352344862827039, 0.8461358580851485, 0.8253067658789471, 0.8225153960582627, 0.8424324683075497, 0.831757051202323, 0.8450694218565951, 0.8343428719374454, 0.6526385492947745, 0.6694602666925882, 0.651732092285318, 0.6462147576234696, 0.6561819441840677, 0.6467953543486802, 0.6243045227682962, 0.6497543218474506, 0.6323719240338344, 0.14264667156662958, 0.16798365114421576, 0.16960346055907483, 0.11344341253443457, 0.1724719537256031, 0.12635070023443018, 0.11235926184530198, 0.12327506348736839, 0.1750534235389568, 0.1161399574686156, 0.050694139557537876, 0.06220446869184393, 0.13740883193149167, 0.06375531815828672, 0.05275667988225763, 0.13279615790625754, 0.12270084288765215, 0.0566321180601157, 0.9096772956902495, 0.9375361085370097, 0.899290897309731, 0.8981832651659639, 0.897433560430936, 0.8891232590202517, 0.9061375813838345, 0.8851996765879143, 0.8930986599730136, 0.6657970739167285, 0.6396221037820107, 0.6561421787606669, 0.6541823489698263, 0.6630689709175097, 0.6483444721599074, 0.578728094996966, 0.6309128172873946, 0.6311223341960813, 0.8242535858027014, 0.8642651847857004, 0.7651130724907843, 0.2795361361692602, 0.21190308525337576, 0.27876321587030584, 0.17635588934770907, 0.17673941853717912, 0.23076375655980041, 0.31345278816694655, 0.1231292341096154, 0.19450756785347256, 0.21506413605270613, 0.286567084817976, 0.23940124512003935, 0.20889207645910723, 0.21264766786367495, 0.31703373559503356, 0.2283130247604067, 0.12222006230821969, 0.22399892793960585, 0.1318017394022154, 0.21464513141559372, 0.2186719106134527, 0.23443085224558746, 0.2390049448930115, 0.14985637126013485, 0.020926152575880264, 0.01081210523483156, 0.05605079988800021, 0.08712830000009164, 0.10013385095262894, 0.04106325548222045, 0.01637807134828706, 0.00957458133080269, 0.04689813272034715, 0.16345932330058754, 0.10230042495009606, 0.10055365594712418, 0.05531951599138207, 0.060826371620155806, 0.053392709215863254, 0.08814122413270398, 0.10386219225949467, 0.08106556622330097, 0.17900014333696457, 0.14030877723254742, 0.13998467014078197, 0.08669387301361398, 0.1025837930678275, 0.07012863911204881, 0.09634583752393533, 0.4031781219134374, 0.13555622272457202, 0.12863633064476365, 0.19001186777151768, 0.18280406840977026, 0.0950342752716713, 0.13090692990256358, 0.20019537108122487, 0.11621910025090787, 0.13479628174709202, 0.0815561221306772, 0.5558721437802605, 0.5211483977629894, 0.5195964062308205, 0.5127691497360023, 0.5544028242409688, 0.5571429334796143, 0.5728722578406011, 0.555308208773041, 0.5863283317860504, 0.07794360203194517, 0.08193485186164529, 0.09388709114023763, 0.12239345156975379, 0.11791871890194394, 0.1228460631451348, 0.15387184852597635, 0.13650487043389725, 0.12474977217903693, 0.3047670743637191, 0.48558529649593574, 0.5525494209449346, 0.30889640632545, 0.3482307648633093, 0.18985480463954751, 0.6301006782422622, 0.44970559284365996, 0.5844056288246171, 0.5205424934132703, 0.5981351468994377, 0.5333660802133943, 0.5485700806680487, 0.46939629733199184, 0.46594099785950416, 0.5571699019272409, 0.27160127854613403, 0.2533228378810446, 0.17834513707863986, 0.37247020361813477, 0.35875687075698137, 0.3357002951602699, 0.2502295813041927, 0.27207259902389147, 0.19048892139074625, 0.283634687460532, 0.24416040279661388, 0.21095375944727934, 0.2341859003309822, 0.23817093114375976, 0.22946101267520247, 0.23789082692664554, 0.2101152341112421, 0.23384057957849502, 0.2374996681544298, 0.22255868249177357, 0.1910577830495862, 0.20372121798903942, 0.22389603731217966, 0.18686987379502906, 0.19067209065437207, 0.19199777374032279, 0.1827021204881355, 0.1959032725870834, 0.19714092694178909, 0.1224569545855253, 0.8703585278426798, 0.17600451306725517, 0.8961324862181148, 0.8595088069918166, 0.9095188745319063, 0.14185968143814676, 0.16774259298003102, 0.1660030117170319, 0.7198222533517751, 0.1554389225077808, 0.7177222182881544, 0.2101571214822585, 0.5862221835692585, 0.15363231567456315, 0.11119125778284378, 0.1656284633751013, 0.7214500740543157, 0.17567347161654012, 0.19089537378724086, 0.1939657887566505, 0.19067409439075822, 0.1770440059455346, 0.18253504471745352, 0.16890407350533987, 0.17958446719544063, 0.17824527187337935, 0.07958609056365384, 0.09817342717689104, 0.0925607931929946, 0.09189715309593716, 0.0992579117662008, 0.0922560189225482, 0.09858713471984559, 0.09291180248016684, 0.0886486486420679]}, "mutation_prompt": null}
{"id": "58d0e11e-ab23-4b06-8bda-8d31b2c515fa", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.2))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            inertia_weight = (0.9 - 0.4 * (i / self.iterations))\n            self.social_coef = 2.0 - 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "EnhancedAMPSO with adaptive inertia and social coefficients for improved convergence dynamics.", "configspace": "", "generation": 67, "fitness": 0.2801417512474519, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "90269c77-5a29-477a-aac0-7fcead551f06", "metadata": {"aucs": [0.5931150963011402, 0.6221776735633499, 0.6407880365790907, 0.6010740965132003, 0.6116963309472642, 0.6284383739553474, 0.6507585277968668, 0.6115064384780767, 0.6171523310007916, 0.3397872205094964, 0.326704368769678, 0.35867256521011504, 0.34295335017758466, 0.3485418783059502, 0.3368514679647835, 0.30384333276749875, 0.32619579386215236, 0.2955939304869416, 0.12262715199581797, 0.1474606465578936, 0.13886136385341108, 0.12701945305276496, 0.12580458164576958, 0.11627883835975628, 0.1005067153948963, 0.12556158666173722, 0.1454740198502501, 0.09802011591154058, 0.08953094067294298, 0.09746767300105896, 0.12124939007862046, 0.10376495182282852, 0.10138427236741354, 0.10222059065753508, 0.1012136163030829, 0.09897660337009806, 0.9312183115031838, 0.9428268610847064, 0.9275254917557072, 0.9112212767428653, 0.9104580961098342, 0.9025958585361492, 0.9146985776154226, 0.9151372826715714, 0.885382197437685, 0.39644854285047837, 0.3685015969705646, 0.3910583217661552, 0.3882708277098641, 0.39386239551225855, 0.373983826836235, 0.38607273914802887, 0.3716115927436946, 0.3866954745349239, 0.6443380036335609, 0.565488080001683, 0.4904601449470618, 0.5369183161235391, 0.3365284711193107, 0.58104036188238, 0.2261070589473173, 0.4896759159726658, 0.6182783591145886, 0.18926208048134607, 0.15709537016523756, 0.16952195503801393, 0.17976513996549215, 0.19359012713432977, 0.17678866292648876, 0.18645940261968164, 0.17872448753586123, 0.20237761933331944, 0.17948778455399583, 0.17975459528256088, 0.17127835993967377, 0.16930426597903114, 0.19357567285725596, 0.1788507526557791, 0.1788012564709619, 0.2009177767268776, 0.19502123101386293, 0.016407775891126408, 0.07092615435571548, 0.03139438312717502, 0.038345736498881844, 0.054308753422319556, 9.999999999998899e-05, 0.045539459198681964, 9.999999999998899e-05, 0.053681114493862925, 0.14861802243595834, 0.12304639393737138, 0.09541691766112037, 0.04987195354818463, 0.05123690354399335, 0.07600931336581929, 0.10543889886497526, 0.0944143356313869, 0.12369615666027733, 0.014419216415712088, 0.04298390882440306, 0.05315826885155206, 0.02987645910862935, 0.04863864574611487, 0.021590767264007438, 0.047972170964079686, 0.048586618824101646, 0.050861708109552484, 0.1331446563306965, 0.1162583828081657, 0.12447547385594404, 0.14370769103965453, 0.12889779737816576, 0.13666555487260923, 0.12753682637496955, 0.11951987652130769, 0.07388822976118004, 0.43014826075137924, 0.43262011684482793, 0.4410822864078834, 0.4492990280774044, 0.4536977431704883, 0.42954874058730064, 0.4706167856247657, 0.445512327109709, 0.45645097625535247, 0.10610357299351003, 0.09488028495611323, 0.11171571283303783, 0.11261897470583282, 0.10211885665451481, 0.11466153850009664, 0.1346360985964964, 0.13085837816855506, 0.11702092862967473, 0.25567260397730984, 0.2952376299524544, 0.29473297068651727, 0.2711725447547575, 0.24882738871809895, 0.26550325253111307, 0.33067774791185667, 0.2645554843497776, 0.3434920482611318, 0.3238749347549178, 0.3146483782494094, 0.31495518722863736, 0.33735896235717566, 0.36038761990336254, 0.32167130004293576, 0.362011941381269, 0.35474152566986383, 0.29304630656526653, 0.23274386273619607, 0.25125789238131324, 0.24458999486019994, 0.3074923994693872, 0.2501928525415582, 0.2665187635590458, 0.2507898402414861, 0.2881449495000705, 0.19986737881393835, 0.23058667425205148, 0.22517643753710204, 0.24970313707939573, 0.2037495327894394, 0.2280807993500733, 0.22913205444684948, 0.25361326059337475, 0.23682115991097918, 0.2174684520327298, 0.18275564316489634, 0.34870206362125655, 0.18405837624493981, 0.46406575911132675, 0.18723723551291838, 0.1791447348050701, 0.19736668911537403, 0.20405535542240905, 0.19890122325941284, 0.12224584499646063, 0.7198960639018257, 0.17598696397120273, 0.7708075005938935, 0.7620739481620703, 0.7792010846906376, 0.14142929563102113, 0.108485784380836, 0.16659603219022612, 0.6669478193639582, 0.5987546381152989, 0.580262051634808, 0.20912040982226154, 0.5270615005860217, 0.15375604368135976, 0.6694812961435044, 0.5056261168498004, 0.5560435557282721, 0.17000846162811523, 0.1805024443659391, 0.17020968079171084, 0.17973408437843608, 0.2041601305101497, 0.17898151748512137, 0.1796902946445953, 0.19199891544489345, 0.1868254778226035, 0.08893214548829786, 0.09500578066072629, 0.08161116310458782, 0.09402343348763775, 0.10643238931200272, 0.08350496983134725, 0.09552672781514371, 0.09149111683275646, 0.09284025050084643]}, "mutation_prompt": null}
{"id": "8a91d3ee-3e91-4009-9503-c26c8b777344", "solution": "import numpy as np\n\nclass HyPePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def hierarchical_perturbation(self, positions):\n        perturbation_strength = np.random.uniform(0.9, 1.1, positions.shape)\n        return positions * perturbation_strength\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.2))  # Changed from 0.1 to 0.2\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - self.memory_rate * (i / self.iterations))\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n            if i % 5 == 0:\n                positions = self.hierarchical_perturbation(positions)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "HyPePSO", "description": "HyPePSO employs hierarchical perturbation strategies with dynamic neighborhood formations to enhance convergence and exploration.", "configspace": "", "generation": 68, "fitness": 0.24685915482043294, "feedback": "The algorithm HyPePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "90269c77-5a29-477a-aac0-7fcead551f06", "metadata": {"aucs": [0.5140405380832793, 0.5250353884435095, 0.5261178492132084, 0.44293740541698556, 0.46086977987569366, 0.47335542960474974, 0.483595029740263, 0.49412796867980135, 0.4719280863040235, 0.02788652126787783, 0.03308829107443778, 0.04341475583930188, 0.15759335467413016, 0.12584019321069373, 0.11837624282850556, 9.999999999998899e-05, 0.0018922965860005414, 9.999999999998899e-05, 0.14643063493276354, 0.1403043597872835, 0.15182154040912843, 0.11229370118994253, 0.14361041747515668, 0.1309033042889538, 0.08952357919106724, 0.10748004888666074, 0.12122755308065858, 0.10725013893020208, 0.07210097798374027, 0.10474116902958996, 0.10298410436897065, 0.1129443030594568, 0.07045495550841041, 0.13136659892835578, 0.10533380502901868, 0.0757990182740359, 0.8886481018184123, 0.9164223290914464, 0.8931200231357975, 0.8887607145359991, 0.8955262979737019, 0.8457895606896929, 0.8763098107033755, 0.8330563527467781, 0.8674486509334178, 0.3329631279226586, 0.3168379702729648, 0.3102063066865507, 0.3112881726102378, 0.3400183862430036, 0.3127724350211222, 0.3156222215634389, 0.30967769284448865, 0.30781327974254413, 0.6473866326752017, 0.7379282079649309, 0.882371489140767, 0.2493317108940628, 0.3966740573808959, 0.5603103074030412, 0.17493396029067843, 0.16908339445614473, 0.27025490568485966, 0.19945040712769257, 0.27360344034829454, 0.12877161311729068, 0.18840744158190703, 0.2220739284322487, 0.1894821458540098, 0.17402825290235502, 0.1964950968195226, 0.26456265663476897, 0.19559211046163505, 0.1162884044234026, 0.20806314605547527, 0.2129476919625557, 0.20047199703104446, 0.15873759505415908, 0.1295919556499614, 0.20502162757236542, 0.21181241765579617, 9.999999999998899e-05, 0.03380755923697598, 0.028067454857944152, 0.056895502099174156, 0.036996631060497, 0.007831980527111537, 0.046176377904035504, 0.006106647315353042, 0.04634069648571837, 0.10206117500173784, 0.07444420897761339, 0.122186634306652, 0.07552095645324375, 0.046900211114607404, 0.06050375688413645, 0.12917458387533276, 0.11475566222034395, 0.11189595050589707, 0.0022186397998983365, 0.005486115990413598, 0.001407189988357982, 0.0016975010941028268, 0.014299160244548137, 0.014059210549988155, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10513951431764657, 0.08168779509284341, 0.10812488535630349, 0.11912475605269335, 0.12933182405809207, 0.0975960959848462, 0.09232184735767446, 0.07675873194967353, 0.09700258565423481, 0.4289121890242411, 0.4324407752752921, 0.43860560753452815, 0.4166118788765718, 0.45667273368618866, 0.4236933926557903, 0.4625947821267541, 0.4537307193981376, 0.446212084742038, 0.1055400363815101, 0.0792915498323471, 0.13164212850961543, 0.09077925949990806, 0.13655071117406825, 0.14736059244281463, 0.10747070290324412, 0.12409357516094277, 0.09994543497598862, 0.27232419443953304, 0.2705448126328781, 0.21706250233743063, 0.2881522912550394, 0.25465335368156294, 0.293392269122872, 0.1823551030599464, 0.2670873135974441, 0.2705498201981471, 0.31186768126300235, 0.29458031078975455, 0.3084161099008804, 0.33038827231349477, 0.33740862878558486, 0.3390189591540942, 0.23265476200356916, 0.3275185245841069, 0.3031417747089664, 0.21433802974928295, 0.25525254937459907, 0.21143152420978362, 0.22644579839472123, 0.20670476262984294, 0.26851345872125554, 0.20824345140377565, 0.2517299348813875, 0.20253132996888423, 0.2053040451807413, 0.2161066280389543, 0.19435748194157088, 0.21039046818315843, 0.21599978290979382, 0.23083214430393717, 0.22149434232623777, 0.23836334633928669, 0.22612741521690605, 0.19412777110072355, 0.19844181593231325, 0.21300691815280037, 0.18412521202921217, 0.19674087645351768, 0.18180489895580443, 0.1911227837610583, 0.2418677256022883, 0.19396851577987195, 0.18526877347495585, 0.725576878758974, 0.1866642845826868, 0.711714963870776, 0.7240671872206148, 0.7462810639524236, 0.16111595985834226, 0.17478165540642054, 0.16489805249071343, 0.6100222050326318, 0.5407233178670195, 0.6024977372450281, 0.2106710826022995, 0.5329310602322974, 0.26976867409342264, 0.47956273716838227, 0.16543482854345426, 0.4293490456719177, 0.19447441212374172, 0.18129162756718742, 0.18831136961890693, 0.19395900222855467, 0.18153215181265958, 0.19182987990016676, 0.1786429563371219, 0.17469821648319017, 0.17871191097479655, 0.09634598945121631, 0.09216577571289741, 0.08749160088906827, 0.1010585723631604, 0.10104774618347478, 0.08957733146493574, 0.08821942903569702, 0.09338093405083125, 0.10572196474929896]}, "mutation_prompt": null}
{"id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 69, "fitness": 0.3321430193401539, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "90269c77-5a29-477a-aac0-7fcead551f06", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "a3a09a6c-01f8-4968-b8b7-9c73abf1b7fe", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "f0033bc8-76f1-490c-a3f6-f4603d091af7", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        # Changed line: Add randomness to neighborhood_size for stochastic adaptation\n        neighborhood_size = np.random.randint(1, max(1, int(self.population_size * 0.1)) + 1)\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Improved the exploration capabilities by introducing stochastic topology adaptation.", "configspace": "", "generation": 71, "fitness": 0.32357042786353596, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8350491669648193, 0.84759568267928, 0.8512100627697932, 0.8173970140594259, 0.8385179330208052, 0.8291010030521466, 0.8375864716926948, 0.8164248791010317, 0.8220299090187531, 0.657522703614047, 0.6354318323339013, 0.6221979182466272, 0.6232498722562057, 0.6183239843863384, 0.62823394958632, 0.6306149999372692, 0.6696546030623283, 0.5889565683054407, 0.17980988981279367, 0.2891658808776436, 0.19807824812592567, 0.11994626701237154, 0.1689961173887734, 0.17025632661452672, 0.09293910044405074, 0.11587461663759568, 0.15838337569880423, 0.08965874389802753, 0.0550660344282734, 0.06338311685042752, 0.13830678924922413, 0.0910560970851586, 0.10731900516238113, 0.10913712298946121, 0.1126442200862302, 0.06918086579574134, 0.9074087770401877, 0.9269838132201114, 0.8860122510990662, 0.901661297828367, 0.8759139074577363, 0.8716206505629003, 0.8893441533661637, 0.872045423793095, 0.8718029783366816, 0.6499165081572176, 0.6462211093917216, 0.6575156769587374, 0.5327071284034033, 0.6679806210090351, 0.6190581482250213, 0.6053837723719566, 0.6260620414190708, 0.601608966325315, 0.6363490542174223, 0.897674575191522, 0.22589610229516655, 0.26926833559386054, 0.21278370379424194, 0.3616905952773345, 0.17594402701662926, 0.22898674938309382, 0.2355101409960656, 0.3625191233590086, 0.19389547626442427, 0.1989183023681499, 0.21342303024663123, 0.2708188112074478, 0.18780565572428853, 0.20818211965643463, 0.20891065244363805, 0.13310406043288636, 0.22111972412111403, 0.1491638223758035, 0.2106654700429803, 0.2411656515384082, 0.1277789185901136, 0.22874608581017697, 0.22975436765592416, 0.2312405901583897, 0.22688809560741507, 0.019628363349235234, 0.10869015015633887, 0.11690000008258483, 0.04576130706010628, 0.05130235178969833, 0.0013878567887515292, 0.015260406266832227, 9.999999999998899e-05, 0.09873463246870018, 0.10901455485760603, 0.09010649188171305, 0.109294580735395, 0.06116340890041394, 0.06433173300965378, 0.04843580870303699, 0.12742573517030453, 0.07622530991736365, 0.09435225339579612, 0.25560991393193866, 0.053645794637755206, 0.25721707539337024, 0.33133626646527214, 0.1788334330217305, 0.06560667001627463, 0.09226406194171322, 0.12660068429988824, 0.17461415367785738, 0.12974876975481842, 0.1018650498171757, 0.28092001328495986, 0.09394041366327477, 0.22532229599497433, 0.09687407581161356, 0.121090379884214, 0.08150683208648246, 0.1337506779786528, 0.5237290583206353, 0.515149390610818, 0.5157323282278943, 0.5381521259043628, 0.5239124136460511, 0.5173219984061511, 0.5413204407776936, 0.5565079960935264, 0.5360980300846956, 0.11506039724309103, 0.10783737483267264, 0.09078146612760318, 0.13297356294303353, 0.11254986809172496, 0.10471428741204691, 0.12111065503039331, 0.13291256507556737, 0.12695772675058103, 0.44747084859928343, 0.23198700734143252, 0.22102446151100452, 0.24074313918543688, 0.35813821064703466, 0.46912210942939836, 0.20559218702312787, 0.32311739343154944, 0.41596578453712874, 0.50291895922352, 0.4869835076101462, 0.4024437829481865, 0.3512734286170487, 0.45840331841180215, 0.5076368447922064, 0.2516449070219192, 0.5243379319184436, 0.274000794756297, 0.23865340427534099, 0.2657293433945078, 0.2923214330966091, 0.2898637951736176, 0.17797648791694232, 0.2760579838374905, 0.27378557771222145, 0.2624523190956064, 0.42969962729932276, 0.2507207519610607, 0.23922646423336613, 0.20731037646102202, 0.2173776625254772, 0.2084490449922548, 0.23847424194701838, 0.2204415471208656, 0.2288059584509109, 0.24615187501755376, 0.17787525734937792, 0.2124700952023857, 0.20054656353804756, 0.1965965365648341, 0.19268170873142176, 0.19269542204497758, 0.18326344803858652, 0.2218536331993507, 0.2131080917021101, 0.12246398502430511, 0.18610203637667155, 0.14740635800554902, 0.9251723286247355, 0.8672466745405506, 0.8962082648212522, 0.14182719628337837, 0.17652980220824133, 0.16561083473004512, 0.7340319071851794, 0.15629209310763237, 0.7725868208896036, 0.21194991591598278, 0.6759370105646354, 0.6111918699246341, 0.7166982660211885, 0.7230078797364046, 0.09351273901053214, 0.19209208488066754, 0.19741827943304358, 0.18436940060535867, 0.1910243399381204, 0.1890088991696286, 0.18595834458072935, 0.1758220772494451, 0.18277216745895963, 0.18135171047345233, 0.08077574841552926, 0.0940869443699226, 0.08859956496011268, 0.08459822659732108, 0.09378958176339636, 0.09073564150060498, 0.09124161635724326, 0.09824416521374824, 0.09072034434567244]}, "mutation_prompt": null}
{"id": "0f1710dc-953b-4997-918a-a39bb8b6f675", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "362d1cfa-be59-42b7-a928-b3bb3d73f8c3", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce sinusoidal dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (np.sin(np.pi * i / self.iterations) + 1) / 2\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Refined dynamic inertia weight to follow a sinusoidal pattern for adaptive exploration and exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.3060152974060126, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.9105696143058708, 0.8991363843212671, 0.9179544641522533, 0.8615679775186112, 0.8940163165545887, 0.891107783648919, 0.9077458548802377, 0.8946815454346239, 0.8634800671990943, 0.7973754783033621, 0.6343573477337946, 0.7684284234952693, 0.627796065779065, 0.7898706111180058, 0.7333167989110965, 0.7025042497319136, 0.7561255304887664, 0.6123529108718861, 0.13024463658404417, 0.11643336719321684, 0.16699613190185414, 0.1587161325536275, 0.16095990096146284, 0.14618685170917978, 0.12250609930047462, 0.1366345941620335, 0.1433939604553247, 0.10981828619028078, 0.03208952451089464, 0.06476731086679699, 0.09576563798226345, 0.09807944097373744, 0.05011936928838767, 0.1110285323726744, 0.1615349242408065, 0.05223598728910617, 0.8001438908008702, 0.8789775251836065, 0.7149442804194266, 0.7682473538540597, 0.7948271836095622, 0.6200405232943297, 0.8232982639127204, 0.7105980895643096, 0.7552396423037644, 0.48757806066230747, 0.39345000150415455, 0.5530723659657812, 0.560032221061959, 0.6583206091039391, 0.7129492490602247, 0.5101180546038633, 0.49678514477737157, 0.46469712417893816, 0.22256235607855213, 0.7164766415461382, 0.2247320558118615, 0.2764796367022305, 0.27650314416305566, 0.3738433208541583, 0.15126577774793737, 0.17743032794860647, 0.2345052711351303, 0.2632157666405497, 0.12111767110283966, 0.17977605577410227, 0.2286684669092074, 0.2142020491375919, 0.2042789232611717, 0.21127436525522558, 0.291102915238835, 0.29317558750810635, 0.20351916818161375, 0.12342202710597172, 0.21388240273114534, 0.2033103174138965, 0.22741296293416424, 0.23997572616173635, 0.21426162197518206, 0.2374216015411943, 0.21843547318959322, 0.012449558282735085, 0.028162682801803895, 0.001478974207582362, 0.07224477671470908, 0.08540890835595782, 0.041189695276427685, 9.999999999998899e-05, 9.999999999998899e-05, 0.1078951029599472, 0.15728123943174976, 0.09104596400723608, 0.13711615328561766, 0.07906432174432265, 0.043223272393341006, 0.042130928543358426, 0.10637722713003606, 0.08922841361415412, 0.10996598458764506, 0.06973422449768985, 0.1119775363735831, 0.16441466895816825, 0.12781031516115304, 0.13453016722361189, 0.09598910851977904, 0.10108319269704147, 0.28565305516171435, 0.20870523537764885, 0.10084734172243648, 0.1132144071900466, 0.26534838855572485, 0.0914109655903268, 0.1327910022894112, 0.10925463982947348, 0.16809086426888575, 0.09646670320094564, 0.09640259459729661, 0.5642482863496942, 0.5684914845459418, 0.5712796607019626, 0.5289245688156966, 0.560419844661193, 0.5236020055157414, 0.5589924456895959, 0.560518618508955, 0.5751958599044862, 0.08439919897740167, 0.06700056904821561, 0.09299467202416711, 0.09711064641992395, 0.07845363505302083, 0.0881863195233289, 0.09516679426781682, 0.11300919717948799, 0.12567254819022633, 0.2237680455129949, 0.35866632494186756, 0.180908654776044, 0.1946134341014526, 0.19202673025914863, 0.23857130006566651, 0.228813242722961, 0.26475946816595963, 0.30639494289632885, 0.3571790034121404, 0.2293367302224778, 0.3494204558700975, 0.4461756289847283, 0.5080153724885723, 0.3248375709796363, 0.19758250903464147, 0.5584629422802252, 0.21431217052720186, 0.245643583640628, 0.2484916056141505, 0.2943472592831281, 0.21897750111749248, 0.1825290185985885, 0.2742962725068774, 0.19881529479273652, 0.3372891485685613, 0.21575860932635094, 0.24753776840388486, 0.23182991111760176, 0.20004502160012694, 0.2112343559548827, 0.2449406635532161, 0.2467626505941436, 0.2262214946201635, 0.2090114246288547, 0.23677344310243253, 0.17455123222000113, 0.17328280248523276, 0.18365377340015843, 0.16697541896695534, 0.17766275138391996, 0.17479754838465378, 0.18378795711497087, 0.22329098493160704, 0.18532953878743919, 0.12249301345292063, 0.8960079561178992, 0.1771417986640228, 0.9318784728345805, 0.9009261931421633, 0.9459364328852566, 0.14123886953621734, 0.15903023229044755, 0.17772680291580167, 0.8618660833854965, 0.15480480004418073, 0.7068404825501955, 0.2107087170937163, 0.5931614562480589, 0.16709128454109723, 0.11040110484828924, 0.16632213469291057, 0.6292901529085491, 0.18161599668373396, 0.19391253873491443, 0.18730255768119664, 0.1813978873669131, 0.17536618358860545, 0.17328153877149566, 0.1919135304791666, 0.17700878820820998, 0.18232541517380163, 0.08454806899388312, 0.09743736082916543, 0.08734533157132318, 0.09168560921012903, 0.09322202202925323, 0.0878887584327307, 0.08879563326850892, 0.09437287644125991, 0.09201329131752811]}, "mutation_prompt": null}
{"id": "21eb4b26-896a-496a-a53e-02b84381e5a4", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "51292df2-b79a-4e8b-bca7-86d946dad737", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            # Changed line: Introduce adaptive velocity bounds\n            velocity_bound_factor = 0.5 + 0.5 * (i / self.iterations)\n            self.vel_bounds = (-0.5 * velocity_bound_factor, 0.5 * velocity_bound_factor)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced exploration by incorporating adaptive velocity bounds based on iteration progress.", "configspace": "", "generation": 75, "fitness": 0.3045387500350601, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8370046023480245, 0.8232093123121347, 0.8235623066758152, 0.7949358366630475, 0.803274020790175, 0.7955630190734387, 0.83243788887098, 0.8231137906830027, 0.8164549261147486, 0.622733937986653, 0.6185449872681725, 0.6481949048685369, 0.6418624172946739, 0.6239689181026784, 0.6124970880184758, 0.6424673070456366, 0.6171993225211181, 0.6256535730045493, 0.14904340833252427, 0.15312490079021568, 0.1721551631732846, 0.1502606909554759, 0.13238639846517164, 0.1187189023349351, 0.09066725797571928, 0.14952991426942297, 0.11347379456490403, 0.09207166584163429, 0.03822447919931349, 0.05701121529030295, 0.08798183126480141, 0.0651584132252192, 0.049470789596887665, 0.1286603476621413, 0.09665259522362046, 0.05980338579557609, 0.8465936273389634, 0.8480621296047622, 0.8179591604797722, 0.8063822776991685, 0.8328816923037305, 0.7863156994604618, 0.8123129062310923, 0.8048977742660598, 0.7923431389554131, 0.6559515737325418, 0.6134825611041981, 0.6496670835491964, 0.6496104275027244, 0.6855322558721186, 0.6514230443008306, 0.5639967104150168, 0.6197684451867822, 0.6006078973029858, 0.8224961342912376, 0.8468504710371906, 0.2174071217131296, 0.2120152542037268, 0.1969464302278625, 0.27084742312591314, 0.17286194907153263, 0.1496412920265635, 0.19334464239663762, 0.3228606690263425, 0.16863809223341175, 0.11960007718910382, 0.20099087062071108, 0.31238005878559616, 0.18844924817828512, 0.1958338296277936, 0.3488347420718302, 0.24530803897514364, 0.2060653503424391, 0.2060968617110458, 0.19405229837034454, 0.16382823936496604, 0.22355824975311456, 0.21308611136040445, 0.20397699368796085, 0.23024678021574285, 0.2208003296424097, 0.011483466948952081, 0.013511385062949355, 0.05676886698986272, 0.05032411223526356, 0.08903237255379359, 0.04733429673723988, 0.017852614988231985, 0.008889858346432633, 0.11717379572104092, 0.09286965912511225, 0.07708612082323729, 0.12673716234626586, 0.07577283247176003, 0.04994844804170684, 0.08012958800896364, 0.08259019788795685, 0.10779069312833345, 0.10560837534673306, 0.10110887933622159, 0.06213625130273903, 0.11984428571821903, 0.1261437541879179, 0.14084717038917438, 0.07040195213757794, 0.09157647086309806, 0.15336703119465533, 0.18603313409623468, 0.12414162372640658, 0.07181617620182856, 0.2458137489233304, 0.0704290339300806, 0.12108613548347125, 0.1440025977511623, 0.18127054685618382, 0.13406215791120635, 0.08109439015168995, 0.5329191531046775, 0.5543916418425507, 0.5192970429261157, 0.49878341897853307, 0.5210517595483491, 0.49808024983185495, 0.5204761503605387, 0.5423289882114728, 0.518624961183159, 0.06185035206756462, 0.07771469287305699, 0.09309405553474992, 0.11094845381923857, 0.08755164107203695, 0.09836031912109011, 0.11197419776439477, 0.0851889598656631, 0.12238495788354709, 0.24015907492050137, 0.20759902871080416, 0.3562676312722244, 0.2822671900865398, 0.33269394038580047, 0.28184950064531955, 0.1964786358884365, 0.507719432956657, 0.2656478619985363, 0.2681463361084938, 0.2325480254451412, 0.3889105626073449, 0.4961981313961351, 0.43548836558706694, 0.27341215970032107, 0.562803338347299, 0.2356336839611589, 0.24452571892687158, 0.22848671571927237, 0.2556098425695883, 0.28549308278472396, 0.23968994673860322, 0.1768359653036221, 0.25011889190410697, 0.21156621809736031, 0.3695483641070003, 0.228418089307323, 0.2141352286315532, 0.23403353331218324, 0.2038136351854004, 0.1937148201899238, 0.21550475160806082, 0.21381365315266299, 0.2239792628031796, 0.2385478465411328, 0.2261981886104355, 0.1751626388443991, 0.19194722765761696, 0.17746196910462442, 0.19581842900449797, 0.1799419541733307, 0.17609069873741334, 0.19239598663834256, 0.24685012571455267, 0.18397464547736142, 0.1823000803563416, 0.17075616214310974, 0.1488531325442909, 0.901040706380266, 0.8353617609034432, 0.8943384142225222, 0.1410003857667792, 0.16340248973678606, 0.17503460161758377, 0.7941335932972298, 0.15517054505914096, 0.5670436065996793, 0.20975037357590898, 0.5658406700362703, 0.1510473025215373, 0.10806351330284147, 0.6972509165001763, 0.6920461564845062, 0.17965969286234706, 0.19730841491080608, 0.19885550546654485, 0.17902950454644018, 0.18050584486306176, 0.1792222451467964, 0.19064061034934898, 0.18773081897363053, 0.1843514112806276, 0.08416078424858875, 0.09457710746252268, 0.09063113892401742, 0.09096807922479189, 0.08892894321265754, 0.09280524478855279, 0.09721330960051366, 0.09987257920068882, 0.09099456952680796]}, "mutation_prompt": null}
{"id": "2c5013f4-90d2-4fd5-8cef-28034a412c6f", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def chaos_initialization(self):\n        chaos_sequence = np.random.rand(self.population_size, self.dim)\n        return self.pos_bounds[0] + chaos_sequence * (self.pos_bounds[1] - self.pos_bounds[0])\n\n    def nonlinear_learning_rate(self, iteration):\n        return 0.5 * (1 + np.cos(np.pi * iteration / self.iterations))\n\n    def __call__(self, func):\n        positions = self.chaos_initialization()\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n\n        scores = np.array([func(pos) for pos in positions])\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            learning_rate = self.nonlinear_learning_rate(i)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (learning_rate * inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Introduces nonlinear learning rate adaptation and chaos-based initialization to enhance exploration and convergence balance.", "configspace": "", "generation": 76, "fitness": 0.32474900556220426, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8622101522292727, 0.8559466313871945, 0.8640613381559547, 0.8548814087964848, 0.846305185293482, 0.8548412022223276, 0.8633771751150245, 0.8565302623020187, 0.850319009653435, 0.7036700693120086, 0.7296674543952515, 0.6952400846794002, 0.6858835671398676, 0.6952448890124454, 0.7014240158154577, 0.6780330001868864, 0.6898090070552453, 0.6969377201886402, 0.09386150433645468, 0.13406746542222736, 0.11393495506502549, 0.0906783622216133, 0.13975099057094498, 0.11551828785000451, 0.08011365631405531, 0.15115145531734908, 0.09378535493465878, 0.0942749331831636, 0.141509233457914, 0.17753398658924346, 0.1401025052254954, 0.1319742350942985, 0.08518512727469119, 0.14110633355028623, 0.15149617645788438, 0.08047833866191267, 0.9096114382987595, 0.8715321836482308, 0.8898603604843786, 0.9069103684681554, 0.8753673481909128, 0.8834893405257029, 0.8992245329042788, 0.8612920723884844, 0.8762791802120063, 0.5653507758357077, 0.7715163950792405, 0.6120976372666052, 0.6513080990974915, 0.6576314652288792, 0.6207885657063195, 0.6542294338569545, 0.6534992632461673, 0.7515889765694369, 0.2387296056561501, 0.8837139664635874, 0.22416941183930084, 0.2210596752056101, 0.2114211530294502, 0.2102665051941931, 0.12890133117658187, 0.15051072479361005, 0.8722793985651934, 0.2108674949753584, 0.1482297226360988, 0.16649274231171962, 0.20741421585939834, 0.17969064129722245, 0.22565403253591432, 0.4068375761714974, 0.20350210166762006, 0.17860026767079729, 0.22887278087435503, 0.23823654112963555, 0.1209929637651237, 0.22576335213126508, 0.24627167735745548, 0.13359412011703442, 0.24383800392336574, 0.24081341814951251, 0.19880369359820305, 0.12907296996183026, 0.05863471576080226, 0.054682860075999096, 0.05550034346648114, 9.999999999998899e-05, 9.999999999998899e-05, 0.001431230418087237, 9.999999999998899e-05, 0.013748147033373459, 0.14224364052048877, 0.09113512338557361, 0.12172254233461899, 0.09633839005217593, 0.05872215182357288, 0.03315788775625239, 0.1449789390405425, 0.0883401895675322, 0.12190204330468091, 0.14449003448657438, 0.10449973582298477, 0.2034053971271793, 0.09093030817902437, 0.08724254718378577, 0.22074311218459075, 0.098108568275454, 0.26573303148336, 0.10591887157782498, 0.3040527148544063, 0.07043886742659855, 0.28529680172954863, 0.05065205409942175, 0.21976243104277382, 0.09942760733278777, 0.12622068104884643, 0.08082100521750091, 0.08273725461086867, 0.5630601376623392, 0.5413298947761482, 0.5632992051197376, 0.5747095372491264, 0.5799909287449176, 0.5061434928789431, 0.5740408578519098, 0.5343839858514878, 0.590733868027972, 0.058201271059576176, 0.05543703203765726, 0.08749484010566544, 0.09382066656232457, 0.07063925202163446, 0.1441411669218422, 0.1160683678417399, 0.10742348475555286, 0.08212535450488945, 0.5160571548163084, 0.4418006760290627, 0.19471069048032463, 0.2262450043718892, 0.3306720529097137, 0.3538932567147297, 0.3251569277518037, 0.30532250095834623, 0.16859245748183294, 0.21627872219082123, 0.2853567721339346, 0.45838320902662566, 0.3207666458695807, 0.2642497123279284, 0.33974528916280755, 0.5802676908400441, 0.5420034641221689, 0.2766297451395392, 0.24171752674866875, 0.30623826591270076, 0.21285816945317027, 0.21458277359257882, 0.2383306958697543, 0.27912966479860746, 0.29795866726783193, 0.2804079948760835, 0.17110694432821238, 0.22455072392036757, 0.21297299272296122, 0.2512913362361592, 0.2760119147918998, 0.23960201564990102, 0.22831836899303315, 0.30499268183296313, 0.2137956773015237, 0.2073079131896708, 0.18840270238500245, 0.20565763010727656, 0.20770438121582913, 0.1793565446387967, 0.20830491340013324, 0.22303594141279626, 0.19519803538412306, 0.21970052989037725, 0.20583225771950975, 0.12608334061168602, 0.17524344842438822, 0.16386974466160986, 0.9142356356711321, 0.19951095556718057, 0.9112569497076946, 0.14251190135926428, 0.16114160332387362, 0.9138251819102334, 0.7008098171150698, 0.15634112544171297, 0.5810979863580181, 0.678578995109932, 0.09390762796398844, 0.15462174078185764, 0.7568036631501194, 0.8064081919196918, 0.7880449891781627, 0.18784839256768915, 0.19318308252069494, 0.23510977964410185, 0.2100826088121065, 0.1940366317957597, 0.18421118976641881, 0.21104085443930864, 0.185818894368042, 0.1851189443610156, 0.07950290420288453, 0.09388099374864234, 0.08084052366173256, 0.09631601668766421, 0.09950885018197275, 0.10027872628102064, 0.11640835212701373, 0.10734179630557761, 0.08701935401187677]}, "mutation_prompt": null}
{"id": "8defd95b-83fd-4772-a457-9901206e5747", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            # Changed line: Integrate Levy flights for exploration\n            positions += velocities + 0.01 * np.random.standard_cauchy((self.population_size, self.dim))\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Improved convergence by integrating Levy flights for enhanced exploration.", "configspace": "", "generation": 77, "fitness": 0.2136037045147059, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.47880661349112785, 0.47153035221892026, 0.46201825034349653, 0.46254173093107953, 0.44138769799470634, 0.4768905691509765, 0.4416900236463115, 0.45234319520642696, 0.48453616716622705, 0.052252152441554456, 0.052568902158038555, 0.029257072875620405, 0.050985148785132384, 0.055207809150043974, 0.0426748646540156, 0.036350626086606774, 0.07212677845134918, 0.04518935084531861, 0.09719616969003642, 0.092102590095959, 0.09818206098172211, 0.0884592834943867, 0.09087612894116792, 0.10461193053717088, 0.08977721497035274, 0.11140412707820413, 0.10375907832603082, 0.09130535703199472, 0.10108096188030868, 0.08330237809357277, 0.08271498664868837, 0.09004254853108684, 0.09872644093928629, 0.08933515113804502, 0.08542211058241322, 0.08119948740951821, 0.9802795052819564, 0.9815846792051796, 0.9789603618155183, 0.9726312226762177, 0.976522174377206, 0.9675668431196434, 0.9818432616337653, 0.9805893649958853, 0.972356472817121, 0.2762906969356044, 0.28506325207113037, 0.2816022097734239, 0.27358991550750367, 0.26532571241482716, 0.2576251882252907, 0.2887253866899354, 0.2645076274121696, 0.2621956665363354, 0.2728285351898029, 0.20884429962483908, 0.21815716324378465, 0.2310248985700979, 0.2624260903831388, 0.43357268959058126, 0.5427285862029512, 0.44550475252221455, 0.3884416039799439, 0.1687423152948091, 0.1581406940077521, 0.15453613854605663, 0.14544489872564625, 0.1520605040205668, 0.15263295074660677, 0.15378002256180967, 0.150131748611934, 0.16382565127268534, 0.14456572882008933, 0.1471675035297907, 0.13525573654107448, 0.1580614961233645, 0.14662713808550543, 0.15172654378985606, 0.14707378356098777, 0.15370137317746446, 0.15303434262564874, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03266832752017912, 0.02812574588100869, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0651478887257575, 0.03999687222420745, 0.06475509414493974, 0.031657231412292486, 0.08316219190803309, 0.0182269830744064, 0.07327349739134426, 0.06364064436194783, 0.07582069731960106, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003363420448127874, 9.999999999998899e-05, 0.0009577026458580384, 9.999999999998899e-05, 9.999999999998899e-05, 0.1024774460074328, 0.09544953831348335, 0.11020622248001077, 0.07760673134907248, 0.10937041499679712, 0.11619430561684896, 0.0491223360659826, 0.05080352074454009, 0.08296788155262169, 0.4058073715157551, 0.398819639612211, 0.4311648131999758, 0.3964093417354544, 0.3916239143035337, 0.40103554263932906, 0.3989580736724755, 0.3891723205521359, 0.3908958761408362, 0.11853648616895551, 0.09999506981104223, 0.10432628597720539, 0.09144468023391017, 0.08847346062537365, 0.10010119616264057, 0.0944677271423332, 0.08247642081382378, 0.08986067178904, 0.1540452541847509, 0.24622881138681718, 0.14207821535073906, 0.15488580106984395, 0.17214689873286393, 0.20874188098071178, 0.1769137955560225, 0.17259493903058154, 0.12696838676014544, 0.2965520450062551, 0.28271939611518104, 0.28412757512513775, 0.2815790664871952, 0.2887646806143509, 0.27602980163461466, 0.28820597723438224, 0.2893290359507871, 0.3263821024749882, 0.15013429472875905, 0.2297386980002325, 0.21382643033376436, 0.2298321290475014, 0.21802418861358697, 0.22457197941983031, 0.23985984241760183, 0.2254416718083445, 0.22618022587488917, 0.19258053909553474, 0.1812869218067411, 0.19285734125720377, 0.1749117800686969, 0.22095407285600854, 0.1807377458839068, 0.19603554271780677, 0.2005557347795931, 0.18779965106091767, 0.18958311125527416, 0.18456356677904062, 0.18584099811009325, 0.17930250186216967, 0.17959403140149277, 0.18090854850705063, 0.18183884734051536, 0.19142754745554136, 0.17950564607592312, 0.1850913464109607, 0.43403694342941845, 0.15326017753016263, 0.6281907503810893, 0.19822963065166566, 0.6918433947581282, 0.14210004812707588, 0.16070168875175317, 0.1842741981004865, 0.46954901463946486, 0.21018890296586, 0.16629757694165748, 0.20924622465322984, 0.3027907986264663, 0.16868010986656645, 0.16115827807685146, 0.18595289545908933, 0.5088376011648372, 0.17255599349949247, 0.18192989883784316, 0.17625887675198626, 0.1770079772544927, 0.19370503452062804, 0.19266771354517842, 0.17969904642321677, 0.182908212322356, 0.18392330707240034, 0.06982370473786503, 0.08702031987954484, 0.07922874634806865, 0.07123825625556068, 0.07808567782639075, 0.08694100681149952, 0.07710206001326736, 0.07720931963366418, 0.07936256156972321]}, "mutation_prompt": null}
{"id": "5e86ffbe-5d44-46e9-9a63-171a68f69ad0", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            # Changed line: Adjust inertia weight dynamically using exponential decay\n            inertia_weight = self.inertia * np.exp(-0.005 * i**2)\n\n            # Changed line: Make social and cognitive coefficients adaptive\n            self.cognitive_coef = 1.5 + 0.5 * np.cos(i * np.pi / self.iterations)\n            self.social_coef = 1.5 - 0.5 * np.sin(i * np.pi / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            # Changed line: Introduce elitist local best position selection\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence through adaptive inertia and neighborhood-based elitism.", "configspace": "", "generation": 78, "fitness": 0.21342531007370874, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8387258406213778, 0.6473877625063857, 0.7625109470356081, 0.8054224693450791, 0.749195816106685, 0.7029686497883938, 0.8940394233375965, 0.7160896788782498, 0.5281063710189495, 0.20414371319530922, 0.06630281549006978, 0.1235132560133867, 9.999999999998899e-05, 0.06894173108796842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1329095110672679, 0.1785226144548986, 0.15716229235871904, 0.11634943342258375, 0.15930930510764352, 0.11587757568300183, 0.16521455383148043, 0.15397068105912404, 0.13970360332943288, 0.11154972765759208, 0.03577781061129515, 0.0675079859783746, 0.09130527642546671, 0.09721421754700643, 0.060996857115195646, 0.10511189552030609, 0.0995612859105155, 0.057888857327704324, 0.1065357297971059, 0.9163355584334842, 0.09045366934697618, 0.11678907985125297, 0.11184722141289116, 0.11355465137222143, 0.11777913906486737, 0.11216371407382608, 0.11373304311040178, 0.31314040250163633, 0.1122675161643294, 0.16061228072773392, 0.1771108494523893, 0.20362689970482395, 0.17820817544791456, 0.13105203542542876, 0.08912063061458597, 0.11668429585120266, 0.2275102556113966, 0.3831697629205494, 0.8989972922085631, 0.2793426768462446, 0.1925896355549398, 0.28012687217253696, 0.1755780323560988, 0.17600749326886744, 0.19547283946412308, 0.3579197532105167, 0.13214893135960593, 0.12692734249504434, 0.17399359970381523, 0.215359089255293, 0.23712851783408073, 0.17396419250318773, 0.1633690472828343, 0.2347607143085314, 0.173776243416923, 0.16101577998033167, 0.1413313767650819, 0.12692664562056366, 0.12716438052587742, 0.14347863906006064, 0.12995628180133512, 0.16225197722812368, 0.15908502663757806, 0.012610212761008155, 9.999999999998899e-05, 0.014465791347827661, 9.999999999998899e-05, 0.016594074611994802, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05794610683323831, 0.15201483259939363, 0.14700563860856908, 0.11114484811459335, 0.051675971717998204, 0.04911282951191842, 0.041750736144820944, 0.12473067049340747, 0.09666446053620859, 0.16091109678540816, 0.13122680733769143, 0.18296541605902306, 0.18623580499948966, 0.11575692140697247, 0.09941464240877307, 0.08117788785344471, 0.10533239877079481, 0.25026347284978545, 0.2330000770682633, 0.10994904251061344, 0.14973308507256156, 0.15964293790436546, 0.04010611566647315, 0.1352606270265171, 0.15072007430554546, 0.2060168492152189, 0.14172672870671232, 0.08315574989328467, 0.4973350547490377, 0.4166840306367713, 0.5838197821020401, 0.44988850667743796, 0.44288899550508354, 0.4124849537914578, 0.5646899895502404, 0.5071551470886801, 0.5026925629632861, 0.07612416459665217, 0.08089138739560509, 0.08488046910708003, 0.10825575189047665, 0.0949233021738799, 0.1044692426656969, 0.1483714645103581, 0.18762945240813889, 0.16043256085377722, 0.18787521969509657, 0.2357114840681248, 0.14389250790247365, 0.23970172386787358, 0.16007179383614167, 0.33001314253781233, 0.24107140890831114, 0.16007862118515626, 0.2204602546506923, 0.3422233592257675, 0.3908869784316523, 0.2622637911494027, 0.40164967048266076, 0.2844433194568805, 0.4328337747663199, 0.2171005758542608, 0.3635597050017568, 0.2320148669757326, 0.2120909334416995, 0.21239026441360742, 0.30630669345166883, 0.2303948157588932, 0.1444361336940192, 0.24158162859401622, 0.2299117921523396, 0.24102761816777885, 0.20897521515265882, 0.21639443935816116, 0.21983179755082738, 0.24774548687390452, 0.24598718297661915, 0.22149506229043714, 0.2294219602478138, 0.2623411622364471, 0.22678324920368054, 0.22513868916423463, 0.19461970905709958, 0.19451868281236762, 0.18487520664238233, 0.1846390163737026, 0.18950017048484158, 0.19180504648854524, 0.19149880033461508, 0.18353169238705258, 0.18863583114710958, 0.12249378625470309, 0.18432070272699208, 0.17218105272653628, 0.48427759235179013, 0.7841642461092448, 0.7147933928516688, 0.14225331393712326, 0.16741343069882386, 0.1625553443489378, 0.3980974161672157, 0.4809504179749696, 0.4255209545783265, 0.20907806238438753, 0.3319275860099178, 0.16758672592739243, 0.09487224412197648, 0.16487296453300226, 0.23714102816748095, 0.19699905345512803, 0.18496787060454578, 0.18623417847761103, 0.2053082358876105, 0.1801909628510583, 0.2117835372249106, 0.18179219858652385, 0.17978390770904062, 0.18503764218437968, 0.09072283427725325, 0.10053867860799748, 0.10152047187716218, 0.10272527507461493, 0.09177995289382068, 0.08935373603365315, 0.09225320434666484, 0.09844995832546433, 0.09761655881506337]}, "mutation_prompt": null}
{"id": "bda2dd65-d5d7-4909-8715-bf1cbdd276d9", "solution": "import numpy as np\n\nclass EnhancedMemoryAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n        \n        # Adding historical memory for diversity enhancement\n        self.historical_positions = []\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.15))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def adapt_historical_positions(self, positions):\n        if len(self.historical_positions) < self.population_size:\n            self.historical_positions.extend(positions)\n        else:\n            self.historical_positions = self.historical_positions[-self.population_size//2:] + positions.tolist()\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (0.5 + 0.5 * np.cos(np.pi * i / self.iterations))\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            self.adapt_historical_positions(positions)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedMemoryAMPSO", "description": "Enhanced memory and adaptive learning strategy for improved convergence and solution diversity.", "configspace": "", "generation": 79, "fitness": 0.33000325583548257, "feedback": "The algorithm EnhancedMemoryAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8482494869933666, 0.8561672678108586, 0.8510883521644523, 0.8342754694164771, 0.838355581752064, 0.8454070815096408, 0.8387164035832054, 0.8584491283391096, 0.831894192417477, 0.6947359034285803, 0.6977221172793924, 0.6652806912188653, 0.683046424664183, 0.6780892020517997, 0.6701629906908113, 0.6479176480122046, 0.6681454199013177, 0.6536215587835899, 0.14457071789565556, 0.17322428229638098, 0.15702866272953853, 0.11183887854399077, 0.1780619063229535, 0.12320415673754592, 0.11904835423192073, 0.11188533048222526, 0.183022448702859, 0.11018094393563949, 0.044036451180955005, 0.06396346491263227, 0.1295561253865426, 0.09206127313424273, 0.05414407224281126, 0.11200826250104634, 0.11495097314543457, 0.05723245674328081, 0.909698421561701, 0.9376256894600468, 0.8993073576139659, 0.8982221943073503, 0.8974286277559606, 0.8891099051121283, 0.9061401795894731, 0.8851917663810285, 0.8930863704032059, 0.7207182420538385, 0.6788659863490188, 0.6270488114244326, 0.6447361598987671, 0.6832563022470691, 0.7099786577841036, 0.677464704011759, 0.6853520041185467, 0.6472330572256784, 0.863080612605962, 0.762831580248108, 0.8375543244761565, 0.28012940611269044, 0.21193267013050499, 0.3744641920267463, 0.17643850945691064, 0.17673941853717912, 0.22421232045158235, 0.3479414784014584, 0.12397384806049283, 0.1917176781340949, 0.2028299710748429, 0.27638437279673334, 0.23901796964563915, 0.20255365153279337, 0.21309405726360087, 0.3304512334305446, 0.234728188747925, 0.12082868121753432, 0.21534831236057383, 0.13210200988589094, 0.20571265263047467, 0.204586124148881, 0.23755423106521834, 0.2312294513224772, 0.23070101081301286, 0.041425273937158225, 0.04647239400308367, 0.05983290904353655, 0.05726253179240792, 0.0881225620150684, 0.06757081921952335, 0.03177293756227595, 0.013151601801664081, 0.011221598801862132, 0.1619518405589937, 0.09438527280849118, 0.10024522929895141, 0.05772615011786786, 0.051322701475674304, 0.048634319335884135, 0.0861877926996687, 0.09531396668940872, 0.0873842185330932, 0.3595217156275352, 0.13560618092920818, 0.1385573324012268, 0.08839257236791309, 0.09005862141039289, 0.07795991648672884, 0.09947451977662791, 0.2090643300614442, 0.1279410967307666, 0.1270279381685665, 0.19248625280833953, 0.14860779478425024, 0.10002001258303883, 0.13184791642438742, 0.1332396505559711, 0.19179342560974733, 0.14735870241373428, 0.08215351552279737, 0.5716613810464903, 0.5561751477342103, 0.5546890954569346, 0.5541786587438461, 0.5529337569615194, 0.5543876537838404, 0.5893732782871733, 0.5841271743332663, 0.584991348112606, 0.1006817925775717, 0.09025758237712034, 0.09454252473670222, 0.12557343648058505, 0.11200180688170336, 0.14970507292941637, 0.16036417649430823, 0.1496152788535855, 0.17203818434825102, 0.2566316664524355, 0.2166154059163663, 0.3414986847058602, 0.40965836116581944, 0.23383992845247026, 0.34891753812591486, 0.32340268999382793, 0.41859804270594403, 0.3944159752613009, 0.5353293514018953, 0.5004359898355022, 0.48859335688235705, 0.5651421167702204, 0.293424472802023, 0.5241374256566492, 0.48075120789351145, 0.28058280758099996, 0.2545302427607513, 0.21577954534095345, 0.40877409267336484, 0.29595483828274816, 0.2693388076461396, 0.2414968938882337, 0.286400672149586, 0.1953344976645386, 0.33722758561311417, 0.24655043820091638, 0.222268229214156, 0.2043518075974261, 0.23262122407323726, 0.23127473843998114, 0.22399349769688348, 0.2292941118524593, 0.23756441443458787, 0.23486879185707432, 0.20744311977400498, 0.19133043307696063, 0.19488088541230164, 0.22189621655316083, 0.17680536612176712, 0.19157805444124765, 0.1887114992759148, 0.2044017695174376, 0.20528958386384033, 0.20611814118848126, 0.12245474449726046, 0.8772368504318793, 0.17583056497763738, 0.8885891470878613, 0.8674146317646794, 0.9050006073888465, 0.14186086863527614, 0.16774299893787525, 0.16604592057949452, 0.7585051002964928, 0.15543561266846573, 0.6296369438134738, 0.21016021551008413, 0.6863601133864634, 0.15363086921299218, 0.11120819618447475, 0.16563813100311076, 0.6275320979653384, 0.1925341038088123, 0.19482047296114147, 0.18500295676428002, 0.19386650154957374, 0.18143900376202549, 0.17903949030028965, 0.18333920389987757, 0.1860588138762489, 0.18314360552545372, 0.08046150429103005, 0.09179984945772646, 0.08273927706376871, 0.0987444720017906, 0.09182524115109025, 0.09555983429310366, 0.08705170866518819, 0.09055412378025263, 0.08604592324094484]}, "mutation_prompt": null}
{"id": "6326d6c8-edc5-4394-9e74-2650383e1ac9", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def dynamic_population_size(self, iteration, max_iterations):\n        # Dynamic adjustment of population size\n        return int(self.population_size * (1 - iteration / max_iterations))\n\n    def dimension_reduction(self, positions, iteration):\n        # Reduce dimensionality over iterations\n        if iteration % 10 == 0:\n            cutoff_dim = max(1, int(self.dim * (1 - iteration / self.iterations)))\n            positions[:, cutoff_dim:] = 0\n        return positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            current_population_size = self.dynamic_population_size(i, self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions[:current_population_size], scores[:current_population_size])\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(current_population_size, self.dim), np.random.rand(current_population_size, self.dim)\n            velocities = (inertia_weight * velocities[:current_population_size] +\n                          self.cognitive_coef * r1 * (pbest_positions[:current_population_size] - positions[:current_population_size]) +\n                          self.social_coef * r2 * (local_best_position - positions[:current_population_size]))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions[:current_population_size] += velocities\n            positions[:current_population_size] = np.clip(positions[:current_population_size], self.pos_bounds[0], self.pos_bounds[1])\n\n            positions = self.dimension_reduction(positions, i)\n\n            scores[:current_population_size] = np.array([func(pos) for pos in positions[:current_population_size]])\n\n            better_indices = scores[:current_population_size] < pbest_scores[:current_population_size]\n            pbest_positions[:current_population_size][better_indices] = positions[:current_population_size][better_indices]\n            pbest_scores[:current_population_size][better_indices] = scores[:current_population_size][better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by introducing dynamic swarm size adjustment and dimension reduction techniques.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('attempt to get argmin of an empty sequence').", "error": "ValueError('attempt to get argmin of an empty sequence')", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {}, "mutation_prompt": null}
{"id": "2fee294e-1475-4cc5-aadd-f3c491f07a39", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            # Changed line: Introduce non-linear scaling for social coefficient\n            self.social_coef = 1.5 + 0.5 * ((i / self.iterations) ** 2)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Improved EnhancedAMPSO by utilizing non-linear social coefficient scaling for better exploration-exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.32936547571619773, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.836123569507735, 0.8347262843447523, 0.8370694960467534, 0.8233652044755005, 0.8272622631277357, 0.8565683611391378, 0.8257466760091983, 0.8371170000383996, 0.8223564479567433, 0.6699211883531141, 0.6534043067157654, 0.6420556478031666, 0.6497811063600609, 0.6670482036617538, 0.6261379767674433, 0.6199885911092744, 0.6501212362209143, 0.6250216898858529, 0.11306967971577508, 0.5557157359396011, 0.1520183624232797, 0.10393557376143014, 0.15839924571373065, 0.14806626155789238, 0.11213749361593894, 0.1385609426058918, 0.1742466187012609, 0.10692525360673777, 0.041133578092332757, 0.05917262652108424, 0.1102338211194609, 0.06236046477012902, 0.052432582052044596, 0.11421497736923925, 0.11535301173959145, 0.05640928318296723, 0.9098334349443475, 0.9378965960547562, 0.8993853106950765, 0.8983996276302862, 0.8976779059286697, 0.8834970277668933, 0.9065287679727523, 0.8852215042111211, 0.8931490661976824, 0.6877771181959328, 0.6452081553070148, 0.6274555103875679, 0.6733372484071167, 0.6871129811383383, 0.6153973169404863, 0.6182434954994724, 0.6410055901124893, 0.6718727930853132, 0.837940843844133, 0.8394437223871701, 0.22290684567816865, 0.37371153978647886, 0.21188864969908172, 0.8663497293992939, 0.2080823544690562, 0.17646241701987309, 0.29334100285028053, 0.3211008871871206, 0.12113793682753626, 0.19376161330075758, 0.2142342273903961, 0.2924548838171046, 0.2619515358328529, 0.22750351937203528, 0.2140827722474432, 0.3315778914457971, 0.2388310037245952, 0.11315028758047496, 0.21810062489205084, 0.13222247054288783, 0.21889283716214802, 0.21698769034154097, 0.25579472783426405, 0.25155282471163964, 0.23437420039868817, 0.030377292284180846, 0.07151877489731451, 0.07035157288910887, 0.06345434484245727, 0.08408650986326938, 0.04667016225701559, 0.04062710685904947, 9.999999999998899e-05, 0.013498940034673446, 0.17130943084142636, 0.1181888872501724, 0.10079251268400025, 0.06842336159970441, 0.038118005717173054, 0.049956836478877054, 0.09459515233909044, 0.088499230126731, 0.08294863133412111, 0.17890121733422581, 0.14553051521663873, 0.11029645495934015, 0.08742027841054367, 0.08731639650995326, 0.07549433395714844, 0.10911532425220116, 0.17024579623966352, 0.13980657695707954, 0.11808647934389427, 0.1371361629674679, 0.21354413180258047, 0.03563176392311618, 0.10891876545425494, 0.14226739942639144, 0.3227517808265966, 0.11255366719107118, 0.08214146240597442, 0.48547210420171805, 0.5068006257170372, 0.5443128129258484, 0.52986035649631, 0.5217319638038997, 0.5377754464864708, 0.5639388791677551, 0.5633071360800528, 0.5383405551355771, 0.11074534780717127, 0.06962991487117887, 0.09125477933305814, 0.1275523187212495, 0.10352080910815353, 0.12955728865455185, 0.14367552366462444, 0.12731958669682863, 0.14498443180364173, 0.46558521127434105, 0.4690535725073558, 0.2065448436468772, 0.38266134477758873, 0.1853331231598786, 0.42445905744792845, 0.45246073059695113, 0.34248185476852755, 0.49699246795067864, 0.4954268355803537, 0.48402293283779296, 0.5081975032836614, 0.48755755894960606, 0.31969824204584163, 0.44340965888351125, 0.5521545534643442, 0.42316676475335424, 0.27211950199001056, 0.24203280011075745, 0.29584850108060756, 0.2678639597063187, 0.35695080028493564, 0.19208695651391217, 0.27901705503425367, 0.23671882748216244, 0.2552646923345394, 0.23654218847971642, 0.23461242651385272, 0.20307398646215646, 0.21927869492101593, 0.21374123642667775, 0.2160920004671244, 0.22192600486555325, 0.2371860498534748, 0.20812809736323445, 0.22394767654389391, 0.18290290329491565, 0.21055998468035408, 0.22573257013103376, 0.18753422692906097, 0.19157529724444589, 0.19364610694082052, 0.1897743876508602, 0.19608426432126302, 0.20306319752456647, 0.12245315573284699, 0.8735577662777262, 0.17621903589423205, 0.8918823077791428, 0.8699490502844985, 0.905922415414611, 0.141859795753976, 0.16774907887738666, 0.1659822990573916, 0.8050091254418998, 0.15541765248276718, 0.6279473584554285, 0.21019827864352236, 0.6983739292760185, 0.15334023192476287, 0.11121758690404826, 0.16561810417317668, 0.6774639570235583, 0.20136550873252312, 0.1775751158740091, 0.19028325388001055, 0.1864755572040423, 0.18406316047232385, 0.1769523211386459, 0.18113193933574923, 0.17917733162906846, 0.17960437153551434, 0.08789230456132813, 0.09784881725118755, 0.10201467617083815, 0.093748173181596, 0.09276785533138332, 0.08993866639123294, 0.08884514288408096, 0.09039590525521013, 0.09469648101135131]}, "mutation_prompt": null}
{"id": "e2314864-6d95-444a-a426-c73aa9bf591d", "solution": "import numpy as np\n\nclass EnhancedAMPSO_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.2)) # Increased neighborhood\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def adaptive_memory_randomization(self, scores, current_score):\n        prob = np.exp(-(scores - current_score))\n        return np.random.choice([True, False], p=[prob, 1-prob])\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (0.5 + 0.5*np.sin(np.pi*i/self.iterations)) # Dynamic inertia based on sine wave\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n            \n            if self.adaptive_memory_randomization(scores, gbest_score):\n                random_positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n                positions = np.where(np.random.rand(self.population_size, 1) < 0.1, random_positions, positions)\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO_v2", "description": "Incorporating adaptive memory and diversity maintenance to enhance convergence and escape local minima.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'p' must be 1-dimensional\").", "error": "ValueError(\"'p' must be 1-dimensional\")", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {}, "mutation_prompt": null}
{"id": "4e312a3d-3a73-47ca-86d4-c8786bacca9d", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Changed line: Reinitialize velocities if no improvement\n            if i > 0 and np.min(pbest_scores) == gbest_score:\n                velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n                \n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Introduce velocity reinitialization based on stagnation to avoid local optima.", "configspace": "", "generation": 83, "fitness": 0.09036714575655468, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.18348555413843537, 0.1523852653749984, 0.1876850527689503, 0.13856182523335625, 0.12270475409075476, 0.2010342688200083, 0.1554968732071378, 0.1556530070644192, 0.11923247688977512, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040260690298027146, 0.049363195146649774, 0.057165256353835736, 0.05585512009290883, 0.04528479784926598, 0.055663089341995486, 0.0758367112604732, 0.054295201152043004, 0.06842684487661388, 0.03715119284951729, 0.025083014033903228, 0.01869140433667149, 0.03584889362454213, 0.03929336084382795, 0.03121679188662363, 0.05312160242353181, 0.04104012781110289, 0.0313764500745356, 0.0700022698449928, 0.084099033098467, 0.07158045922065759, 0.07456596412157446, 0.07933684557477083, 0.08360043474677237, 0.07978355730933162, 0.07049182787684127, 0.07901637503383119, 0.08317621135080022, 0.06277454639949431, 0.0780116874985528, 0.09796692327884726, 0.08210483225596488, 0.07994214640719366, 0.0268701521386171, 0.05829246719421077, 0.11269280517456104, 0.10009559488654463, 0.1346531629816634, 0.13167562668160537, 0.13313144961469248, 0.10123185006699953, 0.13501367942226916, 0.12034671222904403, 0.12664062877957116, 0.12806943803737647, 0.038380186384530446, 0.020867799757798622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01516980309052851, 9.999999999998899e-05, 0.00030735498260270333, 9.999999999998899e-05, 9.999999999998899e-05, 0.00028748065930883637, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.055935004832811, 0.050234710298549756, 0.06682270152120506, 0.04887743206144801, 0.03904054462702666, 0.08631510350800053, 0.04950997208604435, 0.08067585689106471, 0.06415058705699994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015983312440818187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015451913531083772, 0.16958667114174875, 0.2068754129933661, 0.18731309503975557, 0.17164138829426012, 0.19295855133268325, 0.19723321229070845, 0.24679029424400323, 0.19089982392660498, 0.1909394671531085, 0.051071616269803055, 0.04274353408371612, 0.04883492532564904, 0.04028796101823884, 0.046193115345722235, 0.046746549183264485, 0.04786687850923721, 0.07522755232425482, 0.06987992509747942, 0.14554124321440254, 0.1409152192062113, 0.172501354974809, 0.11849951034505979, 0.1590874175604189, 0.11834563233430095, 0.12770167701948865, 0.17308090933139209, 0.1383957661198585, 0.15572865057518115, 0.1641015034654738, 0.16587936106073753, 0.16746810635655962, 0.15310896039681554, 0.1745491805029049, 0.15234306023944788, 0.18268255034393965, 0.19093476763308415, 0.09850148166579187, 0.10812321894558263, 0.10454650297305979, 0.1417452593484051, 0.1073282504253249, 0.10845703585662725, 0.10513556299804183, 0.11924278254259912, 0.12674456034601478, 0.1726722162367772, 0.14602055011126935, 0.16491257848757868, 0.177148522420167, 0.1586976952161946, 0.1559752040652076, 0.16825228802447267, 0.1503810629679352, 0.1590722027833006, 0.15180417636153853, 0.14512518209838055, 0.1526114998792858, 0.1443098270847165, 0.13765157984440757, 0.15711913756600715, 0.1317757472982144, 0.146682886294212, 0.15516520785910448, 0.1637258363322458, 0.14020657908960132, 0.16825790999735002, 0.16614608803667508, 0.15495255549592968, 0.22941144878574615, 0.202846903761984, 0.1450783801694262, 0.19669702710445658, 0.18649433896118894, 0.18315831664980042, 0.2533186968166754, 0.25264543325483624, 0.12234483987152911, 0.14004241038468646, 0.15041849783504635, 0.186248712799836, 0.1584317902121828, 0.1805391494364953, 0.19545634912012888, 0.18760635222071298, 0.17802262672419367, 0.18550781756090406, 0.1804753264712321, 0.1872572878343307, 0.17805101831057835, 0.18110282590950588, 0.044152682583688874, 0.05607296382515847, 0.053803941730056426, 0.05512615704936086, 0.06968649706746732, 0.05527743454043743, 0.06249843427499946, 0.05409918811890779, 0.054187037700285656]}, "mutation_prompt": null}
{"id": "28b56b83-a9a2-4023-959b-20d65edccd21", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "bc312407-bb07-44f7-8af8-2db1c03ed46b", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            # Changed line: Introduce diversity-based scaling for coefficients\n            diversity = np.mean(np.std(positions, axis=0))\n            self.cognitive_coef = 1.5 + 0.5 * diversity\n            self.social_coef = 1.5 + 0.5 * diversity\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence with dynamically scaled social and cognitive coefficients based on population diversity.", "configspace": "", "generation": 85, "fitness": 0.32525768519150916, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8348494770417153, 0.8119321468990199, 0.8368502999949727, 0.8237524137442684, 0.8237895531609717, 0.801888637215277, 0.8281258556331873, 0.816045534137094, 0.8334905340118146, 0.6671856089823621, 0.6323182899764646, 0.6332368706812892, 0.6222129202785132, 0.6094639666057825, 0.6370332504842524, 0.6180868470599233, 0.637946125344683, 0.612603590511519, 0.16017724936366684, 0.13681293746817047, 0.10137769601217228, 0.15485487826548017, 0.1573403544115929, 0.12133565384446265, 0.105023607462992, 0.17160179401529563, 0.17070063796171164, 0.1155011892352541, 0.0656218929621718, 0.08577857403830236, 0.13394113573845623, 0.08083079059722587, 0.07589338903283604, 0.14669236827140375, 0.10673275047284292, 0.0912558670388327, 0.9026966536315921, 0.933103409469622, 0.9094493705562925, 0.9150970602337074, 0.9149766711999713, 0.8807764321704113, 0.9054593820140895, 0.8767476564323232, 0.8969626621761609, 0.6740892850990376, 0.6567906187118753, 0.677232850912214, 0.6876383812788329, 0.6583890651439143, 0.6458384566655038, 0.6307752347630569, 0.6155617687932476, 0.6329336346264831, 0.7757789732575691, 0.7698653251562317, 0.2258670226409304, 0.27946940942584153, 0.21264619404423601, 0.27835476113536106, 0.17664518105420612, 0.17305754847049026, 0.23464374220046869, 0.324334156830259, 0.12942350659544355, 0.195063510251285, 0.21730730365609663, 0.3563534045668204, 0.21935066346873466, 0.21022081496522493, 0.2067357038742813, 0.3513333471921969, 0.21874739540176025, 0.21832965751114974, 0.22318922655310625, 0.20753647490682692, 0.23863898443049103, 0.213544946595001, 0.22414895678832703, 0.24998053154713107, 0.22411218904120456, 9.999999999998899e-05, 0.009400401010431936, 0.03794162263817202, 0.03564310039698537, 0.03921827135540712, 0.029593498336940915, 0.02775170147849715, 9.999999999998899e-05, 0.040378358989674235, 0.11166140063184826, 0.11162191905359065, 0.08031523062270085, 0.06592292878090089, 0.04018044952482924, 0.0689533850356242, 0.08864768507228948, 0.08176987699947968, 0.1145588935881453, 0.17266077214587772, 0.15019994131618064, 0.1470261642613574, 0.11172362074175257, 0.08894883404187781, 0.07639595687499046, 0.08750864508064282, 0.14729478617609715, 0.13159398986009996, 0.1967182440282711, 0.15516515818242183, 0.11281989063550968, 0.11264017702534734, 0.1333232944101299, 0.2736221451517614, 0.11816657370743, 0.08225870320087048, 0.0819756738634364, 0.5266731896947157, 0.5464928899011712, 0.5407174642337754, 0.5494504947453673, 0.5327551560954511, 0.5467505034671131, 0.5748830442186649, 0.5340490912009992, 0.555457725426761, 0.09907724409073526, 0.07726904024604542, 0.10733028058040328, 0.10758781545280327, 0.1133482217491032, 0.11809244226530213, 0.16730555055199314, 0.1280401536374195, 0.13851560627292236, 0.26914313487122976, 0.3186054169714835, 0.3198261136582733, 0.31816876187836174, 0.2956808011386025, 0.32862433368750943, 0.37441478487898894, 0.3449323751612906, 0.37280039936711895, 0.5786831174247928, 0.46274412727331504, 0.5499851984844726, 0.4348538948805942, 0.4985229297851461, 0.5147031627902194, 0.5342750905077742, 0.5466478387550918, 0.5350163653079845, 0.23231280888717065, 0.28239892702529734, 0.34031266979948893, 0.3660068743183499, 0.23212429000456292, 0.26258351930020485, 0.24678270817616288, 0.24013345233611416, 0.2355992646069608, 0.2200242289394092, 0.23708245654311688, 0.21089139366933085, 0.25467155784290463, 0.20998021782054432, 0.25108624579170724, 0.20996576954255675, 0.25828699519115506, 0.22663972177478675, 0.205810977065902, 0.17693654424210947, 0.20284934003596922, 0.20626225020803945, 0.19564287494807842, 0.19407108243522508, 0.1781474480323233, 0.24297360118954858, 0.1999023453456582, 0.12260077833328864, 0.7975672694640096, 0.18614222644591938, 0.8406321368077307, 0.8170647313193045, 0.852556069955008, 0.14174347131379506, 0.1650751159846785, 0.15240178788166903, 0.599219203768631, 0.6123979750522297, 0.6700120125565948, 0.21072222762448878, 0.5677221421681893, 0.1676564699808969, 0.7238448070891655, 0.16565799031273343, 0.09326396845565721, 0.18402449826728418, 0.20095925384228486, 0.18051602606698725, 0.17746934764692357, 0.17840886378009968, 0.17655143909743398, 0.18060415586125655, 0.17882639412306178, 0.19241841342898225, 0.108970476824925, 0.08871702448811325, 0.08252938064171955, 0.10121548874271025, 0.09402773261624497, 0.09189523036411706, 0.08399593511092063, 0.09831726512662475, 0.09374585748205522]}, "mutation_prompt": null}
{"id": "b26b1a76-d57b-4f27-affb-f691817ff2b6", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "f2822aff-a3c0-4fd2-a432-3188889f10a7", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            # Changed line: Introduce dynamic social coefficient adjustment\n            self.social_coef = 1.5 + 0.5 * (1 - i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Introduce adaptive social coefficient adjustment to balance exploration and exploitation.", "configspace": "", "generation": 87, "fitness": 0.3115505837723744, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.7705620464078875, 0.7898567804824612, 0.7947965194117278, 0.7542717230713557, 0.7612731376782128, 0.7897739807860613, 0.7723086348129833, 0.7736805330552426, 0.7747373155240189, 0.6046695968174605, 0.5841759638351274, 0.5883886755155285, 0.5834800155350973, 0.5912153474653377, 0.5611164949156299, 0.6148167120768595, 0.5981081591507602, 0.5803289171806898, 0.14123523025692408, 0.16656547812462574, 0.1445765047764468, 0.1585978920794323, 0.18439472118106492, 0.12339761039513797, 0.1158654365406494, 0.13375867427310983, 0.15204959421374298, 0.10880211650121019, 0.04461021148540223, 0.11625856843096682, 0.11681860529857568, 0.08520037450633355, 0.08253449422080283, 0.1095533572832772, 0.11391618627963451, 0.0937481537307322, 0.9108538167431011, 0.937464247019672, 0.903773171972178, 0.9155459919224553, 0.9059368734035103, 0.885402695411961, 0.9062695431520994, 0.8930122316173968, 0.8933148265456253, 0.5904189076383655, 0.53456281646063, 0.5695784897021727, 0.5921288530353452, 0.5508796300594272, 0.5607860904936954, 0.5766593829415148, 0.5677537522921814, 0.5327647464879468, 0.6939913405817149, 0.8476821854019263, 0.7198258951033367, 0.2176671110629621, 0.25370692888021174, 0.3135176222279644, 0.1719622919329069, 0.22074181379335434, 0.2337388255870506, 0.3044688861924576, 0.12617009412827684, 0.19744100554665656, 0.19530710704355603, 0.2643938966963759, 0.24726961290222393, 0.20140714748434363, 0.20204585502862915, 0.3529612246768653, 0.22125925709348393, 0.22121516457203227, 0.20417053086821857, 0.1275350898218488, 0.19674743797768512, 0.2084246494737243, 0.2092926782854504, 0.2598472121295635, 0.2247436498868728, 0.00739664611425106, 0.04540930983466329, 0.01822706849655953, 0.05065216269977957, 0.0059213787882598234, 0.05165832627079603, 0.01943147295511949, 9.999999999998899e-05, 0.0694604952269392, 0.14228872896708167, 0.09111363751465684, 0.13285339880103053, 0.05424835875174472, 0.03884102877178741, 0.03284118357275534, 0.09989992689953431, 0.10763237084252597, 0.0884598017235112, 0.07452856814424891, 0.06558582817133807, 0.0805091719712715, 0.049921851321195976, 0.07998918181776227, 0.06954019308051484, 0.08492699647488244, 0.13270068578532646, 0.2073346383661031, 0.09932161467898826, 0.17206599469389716, 0.19915386045924321, 0.18352915169594686, 0.19363297875371255, 0.1670053511640619, 0.10563229147565889, 0.07827009073853863, 0.08124342461379874, 0.49403433570075383, 0.5150470292307266, 0.4923464469098283, 0.49627839169344357, 0.5075073963439558, 0.5349398936278212, 0.5203525592186398, 0.543178158193711, 0.5082684948005969, 0.10655045380946593, 0.10330579435569875, 0.0848001998848702, 0.11297731112418419, 0.11434921347936977, 0.10701791445019537, 0.13599842052659683, 0.16221149625075437, 0.12360640508845577, 0.3520556109941321, 0.3887393421929354, 0.21296326120434184, 0.2998101706747336, 0.322947767917244, 0.19946139573981536, 0.42554100394705197, 0.177368147973188, 0.5554584699852294, 0.4730207693190901, 0.44127415705257567, 0.40716545240442836, 0.4283177050771191, 0.4404195412313171, 0.45750854580044065, 0.4740009038623375, 0.4665395721901363, 0.4578746848730302, 0.23376929779163436, 0.3087358157425467, 0.2889450353724873, 0.24089982938982335, 0.2677761705489843, 0.29160474203673126, 0.20434020251839147, 0.23980958634777272, 0.24658322450211934, 0.21358720637407058, 0.20361166989967328, 0.18751520464562854, 0.22015791160225306, 0.22689473702104523, 0.23250697112635266, 0.23134476652872005, 0.21713085864727721, 0.20812316154459642, 0.17654765913853698, 0.19818635332726475, 0.22128972585310713, 0.23446565463972857, 0.19140523741486937, 0.19277177961990433, 0.18626541722235845, 0.18617201945127926, 0.18219450043645347, 0.12251423911099113, 0.18491243892607523, 0.17644262465439498, 0.8750929887733322, 0.8289744456316254, 0.8718984830700353, 0.14156468281698775, 0.10993332045700155, 0.1665868360086712, 0.7863665073114674, 0.1552849742028506, 0.6772815616051185, 0.20991904204047018, 0.6552818675608845, 0.16753052467007934, 0.11139471596794104, 0.6488584362228352, 0.6993958270998197, 0.18525426385432076, 0.17812918010683132, 0.18813246783839543, 0.20346325911913343, 0.17789750745147426, 0.19230980172702383, 0.1733465763581027, 0.18180472269444092, 0.1712821666840333, 0.08440198317241243, 0.09673226140181346, 0.09054415803386906, 0.10395184942599389, 0.09425345170829313, 0.09460213529159334, 0.09366889736262962, 0.09922196993958665, 0.0954132564435396]}, "mutation_prompt": null}
{"id": "9f853495-be8b-4a90-a099-c20f5852a8cb", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "7eaebb98-1c07-4288-b64b-9fd89f63ff14", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "3654e155-9173-4b9c-b13c-ca3fc5872059", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            # Changed line: Introduce small random perturbation\n            positions += velocities + np.random.normal(0, 0.01, positions.shape)\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Improved global exploration by introducing a small random perturbation in position updates.", "configspace": "", "generation": 90, "fitness": 0.26941713906220116, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.5754530839256546, 0.5716447924464516, 0.5831760001639013, 0.5808036126882443, 0.5821204258836554, 0.5518560140762594, 0.5761828700559233, 0.5672333121366079, 0.5894775521486637, 0.16024382791267888, 0.12950085156491165, 0.13809844146573702, 0.12739975509404433, 0.15910413156891845, 0.12863318802372847, 0.1627580988847228, 0.17787631992930986, 0.16071289314879345, 0.15288547325766721, 0.17395988984719823, 0.14270207683488678, 0.10688266194329521, 0.20879169288278754, 0.14356788486236927, 0.10722198303818986, 0.16413571680420358, 0.13069477417801478, 0.09016416040069686, 0.05461761132098186, 0.06157745716060181, 0.10757294820822394, 0.11770335549804456, 0.07123178140566866, 0.10420248497828688, 0.1335086124005591, 0.07009475415271627, 0.8939339410170174, 0.926799138705221, 0.8942519738186734, 0.8857873934542697, 0.9021274882352408, 0.8849443385581622, 0.9067380066051302, 0.888272628089522, 0.8717849656925364, 0.4170425770982227, 0.3975460780990586, 0.3967585781671833, 0.3907834459037023, 0.3856437887912162, 0.4031536011443869, 0.3886542093403369, 0.3867830233727042, 0.39026715057582284, 0.7404492849653707, 0.7943902068796719, 0.22608635601287552, 0.27940954297708553, 0.21167865207284242, 0.8479901586050822, 0.2141941184501296, 0.2323395710674515, 0.7156609563301335, 0.22014785391948555, 0.27258558197453997, 0.19944176176315054, 0.1916329024087432, 0.34594563454036786, 0.2244206409873558, 0.21222423487979591, 0.22254915830708255, 0.24517978354761494, 0.18412111391424657, 0.1270248320259214, 0.20738677335951994, 0.1954609869174735, 0.1880009171689493, 0.20723419469746096, 0.21772132228408658, 0.21779661579608622, 0.23395083078781176, 0.001828637227780372, 0.0750630190178665, 0.015396733749234004, 0.05730142499551949, 0.05170412269483882, 0.04791052274077334, 9.999999999998899e-05, 0.028927612652447143, 0.007450934551726851, 0.11383250931264521, 0.0773369139865474, 0.11888823090606293, 0.05028058246386735, 0.0535860723212902, 0.04634447762752969, 0.11072534374484455, 0.09734416419000713, 0.10690746031222098, 0.03886398513982714, 0.030986826986755145, 0.034712301667849665, 0.033920810325806294, 0.03153043035702974, 0.03586857999727455, 0.018258724652088665, 0.027851078211865388, 0.08576421013026192, 0.12638088694989968, 0.13564842496612728, 0.16231317212029095, 0.10207042645449471, 0.1387308888057176, 0.11395433374993047, 0.11398493322998726, 0.11278098397432879, 0.14554722035342416, 0.4838539686069655, 0.4662287819757872, 0.48897177476161047, 0.48445851291964226, 0.48098443422267934, 0.49191852529684144, 0.5034612771593157, 0.48116688842945354, 0.4948824949892511, 0.11476625387675743, 0.11096778592556633, 0.0884714999948254, 0.07984027226225221, 0.11458415539910038, 0.09749409834031775, 0.14090766752237183, 0.14374675554348737, 0.15133579012981058, 0.3417164932129857, 0.3260777948933157, 0.3225889319045814, 0.34865829057084297, 0.29024496027809776, 0.315608848560039, 0.30860446269655206, 0.35197898610667977, 0.3255316562110071, 0.3685688051497946, 0.3537183712915487, 0.3483728954759595, 0.33978447521736144, 0.3516206993332377, 0.353861683351409, 0.3519050824161378, 0.3441044673757917, 0.25569506186124, 0.22878418757372032, 0.27216850633059075, 0.2156007177376239, 0.24575891136264305, 0.20350254022619008, 0.22901725763303904, 0.22275181042730363, 0.21512962546266723, 0.22073903691009078, 0.23567329662431113, 0.21549888755168278, 0.198271978569442, 0.21942746911700717, 0.22578396549193935, 0.23616590767171608, 0.23645816347307014, 0.22708381029324232, 0.2258066482442429, 0.222254868592763, 0.18378092726089512, 0.20528990082316967, 0.2189199794658081, 0.1981572834502685, 0.2035964545779868, 0.18046561202195643, 0.20105100543867283, 0.20757841218360074, 0.12218638628889944, 0.1721907976860293, 0.17688502547062124, 0.8724752442884871, 0.8716918585931427, 0.8905693166228827, 0.17580786248527203, 0.16093063517112038, 0.16613427708457418, 0.6542811194447216, 0.1560071444880592, 0.66496644088638, 0.21121112709458567, 0.4960064898606056, 0.1540073382138899, 0.5606499716965656, 0.16652447365562295, 0.6527986489104948, 0.1769488950813073, 0.18481210034471685, 0.19076221896421275, 0.18751246539887478, 0.20964213430099599, 0.18155840159891945, 0.1972739630524929, 0.21304924911838874, 0.18210142626135373, 0.08913220354399187, 0.10301622819488332, 0.09558710141495574, 0.08388215296393842, 0.10087992845453986, 0.09401886328207565, 0.0853200429201324, 0.08909782425640278, 0.09259882839355227]}, "mutation_prompt": null}
{"id": "5816d5db-b301-4b5f-8d4f-051261a2a4bd", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**0.5)  # Lowered power for stable inertia\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities + self.levy_flight(positions.shape) * 0.1  # Added Levy flight\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Improved exploration by integrating Lvy flight and enhanced stability with adaptive momentum control.", "configspace": "", "generation": 91, "fitness": 0.21872622663394511, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.4173267024923474, 0.4157832560918773, 0.42532152670358325, 0.40584113266923383, 0.46486618313899863, 0.42279882926611667, 0.4288153465944926, 0.4411782518109545, 0.4126829722730295, 0.03973858843705036, 9.999999999998899e-05, 0.03882115496734373, 9.999999999998899e-05, 0.07726710450233953, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002546442577724517, 0.1060260543242646, 0.12803307981275425, 0.13496794440344562, 0.10773187747349366, 0.11629228521093449, 0.14255086052595556, 0.09607392623342148, 0.11093419755544998, 0.14311640056648134, 0.07599961911051067, 0.0806269109889588, 0.09536237026018313, 0.10524971663236082, 0.09326326453039568, 0.08515588317009792, 0.11003189770050537, 0.10142341352754669, 0.08972125893136695, 0.8918107709248921, 0.9214759392702037, 0.8638162573243309, 0.8593514579937983, 0.8786889998345161, 0.9045261503108635, 0.8844661605561315, 0.8952414325134795, 0.908753425274697, 0.3036229521232854, 0.2722365459417674, 0.28488815224939035, 0.26936688859336266, 0.28925860103106704, 0.2911805198297013, 0.27723254967952193, 0.26777698931931215, 0.26340744491737944, 0.23162375334546992, 0.29693415071571594, 0.21486170051123987, 0.21923498772291272, 0.26028753391373416, 0.346455828563093, 0.2274328619586623, 0.23590179226286356, 0.23919328203083512, 0.15800453747864995, 0.16521859457037158, 0.15064981185589155, 0.15978301453018262, 0.12381993557375337, 0.12339131152574845, 0.1545427023572078, 0.20093514023076686, 0.21199484846667915, 0.1282266005355548, 0.1396455204582704, 0.1421905737213467, 0.15535308847140783, 0.15210889775028213, 0.14235961770199157, 0.16738300807827622, 0.15293644788614802, 0.14337085683954587, 0.00018247521670511357, 0.007081967993720184, 0.021276274257987504, 0.047607029559952885, 0.044454264468578364, 0.0013823127255003786, 0.04539894054188043, 9.999999999998899e-05, 0.04779175822915749, 0.11389752808487319, 0.11763213029783359, 0.1012494529048259, 0.08223182005788188, 0.053605910289060366, 0.03773222733571113, 0.18158282875215725, 0.1094461767126984, 0.10143472934960229, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08322099525636661, 0.11513181963048025, 0.09892523368843975, 0.08473736649439867, 0.10544762534992225, 0.0965433354819295, 0.09338460414687866, 0.11116449630689784, 0.08178815691780095, 0.40726109429258406, 0.39952628950162505, 0.3910511120828811, 0.43849093913077275, 0.38871364773106754, 0.39862173747944174, 0.3964175611643622, 0.4076542727072622, 0.4069077659059843, 0.0970691397194029, 0.09420725979131672, 0.09433611073279902, 0.12242137802530173, 0.1079529450018768, 0.10437606215792605, 0.09723261030129993, 0.10194519009426206, 0.12151712929900627, 0.2616607454212361, 0.2105031721252384, 0.1912245638205431, 0.19411339835034747, 0.16065620244586987, 0.17460249886945656, 0.19242849829038688, 0.21569275206639382, 0.18160043049968877, 0.28330526591410554, 0.29306663816848966, 0.28931603811093987, 0.29575083662997925, 0.29098114319536206, 0.3153455678631598, 0.27293484560830195, 0.29701179550671764, 0.2962770913277075, 0.18389851820146064, 0.22821819726418957, 0.23226769625088795, 0.2180847817636845, 0.20191651255136212, 0.22833283976105, 0.19785812648039836, 0.19921712036425698, 0.23547515323226198, 0.2220609900780004, 0.221972442261116, 0.2045531479728585, 0.22753752982219244, 0.2163283927516524, 0.22545200228161733, 0.21145025476400747, 0.2312734220393763, 0.2054867880205502, 0.1859561065607963, 0.19405072738275175, 0.1975379452505024, 0.20860814265078087, 0.17898818085243406, 0.1930262980071915, 0.17647171071531287, 0.19103326099134887, 0.20483832599576768, 0.18588543087018283, 0.1844921407922414, 0.18608748743830383, 0.6575657065617129, 0.6058391227313176, 0.6441017571542729, 0.173214976250459, 0.16713554784269347, 0.16701598060209222, 0.557943035937134, 0.5448630034986142, 0.5864962131629763, 0.20996753974603155, 0.1674037368444784, 0.5680353220572785, 0.3519072466098966, 0.3800125763494909, 0.3201414351563939, 0.20352877948229853, 0.17841642697272453, 0.1755591986234344, 0.182837830664624, 0.1757219879623939, 0.18077536222022372, 0.19050758090789188, 0.21064038084916814, 0.18972412440610587, 0.0839815179634621, 0.08328357991576318, 0.08992640477167047, 0.085910418094717, 0.10125762917261749, 0.0937894063637299, 0.09051891452145555, 0.09397278347630111, 0.09001447407833074]}, "mutation_prompt": null}
{"id": "b0580788-b0e1-48ea-883b-1d25da0ae731", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "ab33be68-4035-4bf7-b211-23bbf7453d98", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "ccf1eddf-3131-485d-81b9-50b118d5fa4b", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            # Changed line: Introduce adaptive velocity clamping\n            velocities = np.clip(velocities, inertia_weight * self.vel_bounds[0], inertia_weight * self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by introducing an adaptive velocity clamping mechanism.", "configspace": "", "generation": 94, "fitness": 0.31822860258116953, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8373792905609346, 0.825768287813698, 0.8320438478412262, 0.805669591930971, 0.8308509700316132, 0.8205002648255608, 0.8345092946158897, 0.8224326684223674, 0.8266676606415978, 0.6376742658917968, 0.6608055466187379, 0.6109662252359949, 0.6327815570881787, 0.6504457425152876, 0.6444108893887887, 0.6594163089207742, 0.6548547321195901, 0.6082945852820261, 0.153141989035522, 0.14032891655581858, 0.13764900809695246, 0.1581687597362872, 0.11894371379379864, 0.13188551830576434, 0.09381958238839305, 0.14963798939422357, 0.12123445393196786, 0.09176666246253773, 0.04786410181581491, 0.06429707153313047, 0.09309518332526823, 0.057543078575918116, 0.056688376077503544, 0.1388968370363074, 0.10555592262127778, 0.05285767434669175, 0.8744637077353552, 0.8819604252230999, 0.8636821380476861, 0.8332169648469129, 0.8668152826347797, 0.8279321238311139, 0.8662169944089068, 0.817999457082498, 0.8396055177580086, 0.615662761758682, 0.6296950845229832, 0.6420993808020075, 0.6355931727818716, 0.6799381699351977, 0.6268422339714308, 0.5648323541658058, 0.6202139510561665, 0.5875590433607811, 0.22655517347722842, 0.7762456180508944, 0.2222545904088048, 0.2192537026019976, 0.21674834483947492, 0.7880208864661026, 0.15070423936850186, 0.17701970431770497, 0.17606450399479212, 0.28514591047225735, 0.11787049495000812, 0.20409522115759648, 0.20300403090854902, 0.48717386810025365, 0.22465607275413435, 0.20635740340384245, 0.24138813236629753, 0.3482577866884974, 0.21357297686219556, 0.21149651532869285, 0.2205630031940755, 0.19987089899478483, 0.22175655753839996, 0.2144049485584918, 0.20755216081351135, 0.23812398532599177, 0.2360797399955089, 0.014981571613378986, 0.02773932225021547, 0.08247348997378634, 0.06006868602721893, 0.0763560294965846, 0.047841153209682075, 0.05161127648692787, 9.999999999998899e-05, 0.08999618903138873, 0.14462181631363602, 0.08227178091407328, 0.11093940216576736, 0.08761490039770692, 0.07943422912001186, 0.05680206320684322, 0.12337536197229526, 0.07441883135994554, 0.08255385590675601, 0.13526311115091938, 0.11061418056554795, 0.10606696192279219, 0.114053876602916, 0.1438528659600653, 0.07231482548606294, 0.08778822924497454, 0.28877129566291837, 0.14140670987878734, 0.12179448997359299, 0.07136366046090648, 0.17575536136993464, 0.07869735676311207, 0.180638375552988, 0.13357688664253653, 0.15870956707837613, 0.09363934687271869, 0.08165900774005419, 0.5342862206670167, 0.5389412368266292, 0.5190252650604827, 0.5377238123421331, 0.5359844928357013, 0.5038460223387853, 0.5559171153702012, 0.5458592235282258, 0.5371156607876262, 0.08039396717935765, 0.07588748255526412, 0.08257960127751407, 0.11238747835156793, 0.11700264144767991, 0.12070448279290669, 0.1470683966785309, 0.12581185097657543, 0.12134182743254074, 0.5823282405184058, 0.42461159605539656, 0.20814868433088285, 0.388756720911135, 0.30771301282222674, 0.3611882343266658, 0.5690685095213958, 0.25147567272150795, 0.19583785010737487, 0.485132355199659, 0.45946278673004803, 0.29457573508391555, 0.521853414119358, 0.4580807419268047, 0.48386405686177314, 0.521847190936237, 0.2476318891319631, 0.2709806571183263, 0.2193053713103411, 0.311457117130461, 0.23355214902016086, 0.23856586075180675, 0.17899698159567778, 0.27738579558169363, 0.2500901109347947, 0.2794779574602706, 0.2376948572732699, 0.21479600947544775, 0.21358162516232904, 0.21042256264627435, 0.21231371772519902, 0.2243068985362887, 0.26570097827095174, 0.23667813484405065, 0.21912734664667666, 0.243777515624383, 0.1816019091955764, 0.17735475706560955, 0.17350251061738908, 0.17885867036083292, 0.2075863732572366, 0.18201286224529434, 0.17447198612176418, 0.20661680649726955, 0.19724698564590404, 0.12218640809264436, 0.17346645416043627, 0.17667399976784304, 0.8873590124827166, 0.8782955955028845, 0.9131956265599648, 0.14147108003751163, 0.1652037285359924, 0.17629872056746987, 0.6936228768712027, 0.15592153323598124, 0.8175436976350651, 0.20960224586748522, 0.734658392650015, 0.4980560290284941, 0.11031796838482133, 0.7250869939268445, 0.6825707262794718, 0.17838184777885258, 0.1829791327523821, 0.18234349845743336, 0.17394217745695872, 0.19467715645362882, 0.18448345117372456, 0.18130857898218045, 0.17900702735078355, 0.1799748714135485, 0.08900698876937496, 0.10090334364890585, 0.092246513152065, 0.09470282763705695, 0.10264803426810754, 0.10128552161717108, 0.09944234266993912, 0.09129766037487208, 0.0897202441044932]}, "mutation_prompt": null}
{"id": "db2a9645-040f-43bb-970a-877790cc21c1", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "5d95885e-9c5d-4366-9d18-5d3ba72ff854", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            # Changed line: Introduce dynamic inertia weight adjustment\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence by adjusting inertia dynamically based on iteration progress.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "b65c109d-221c-4ba4-878b-c4bcfc8ddcd6", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores, iteration):\n        # Changed line: Dynamically adjust neighborhood size based on iteration\n        neighborhood_size = max(1, int(self.population_size * (0.1 + 0.4 * (iteration / self.iterations))))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            # Changed line: Pass the iteration index to adaptive_topology\n            local_positions, local_scores = self.adaptive_topology(positions, scores, i)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Improved adaptive topology by dynamically adjusting neighborhood size based on iteration progress.", "configspace": "", "generation": 97, "fitness": 0.3321430193401539, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.8326876281001153, 0.8379370044640173, 0.8408126558460561, 0.8319526937371424, 0.8232029255249889, 0.8414347411489307, 0.8159998929164114, 0.8398510340943635, 0.8175854398343322, 0.6569783378497448, 0.6460227659857607, 0.6439800439863242, 0.6534687151748816, 0.6398997460062756, 0.639470869571076, 0.6010017984741345, 0.6425576145683543, 0.5873491095635153, 0.15283550953282554, 0.4283565625279043, 0.1581493863052147, 0.11440470795122726, 0.18091874902732663, 0.13335605804557038, 0.12215695196511622, 0.13832588481460995, 0.17540896603504408, 0.10878825892275967, 0.053506549093666034, 0.06347302257021825, 0.11011398340986123, 0.10510204062635053, 0.05365978730858256, 0.11268889634726509, 0.1121967092832179, 0.05903173627729286, 0.9098118081344903, 0.9378629450551719, 0.8993787886822153, 0.8983939212627211, 0.8976715873321232, 0.8834904561112805, 0.9065228382331582, 0.8852099410264063, 0.8931466583368801, 0.6366824935706825, 0.6425563985689666, 0.6022320170707081, 0.6437650012510298, 0.6360234102301858, 0.6412963365329649, 0.6142098704789805, 0.640284031789284, 0.6321753021660055, 0.8430298775836129, 0.7263738160259721, 0.5507345033183948, 0.2800875135214257, 0.21196109223447712, 0.8359014505547188, 0.17643850945691064, 0.17673941853717912, 0.22962423108090557, 0.31996575241485736, 0.12269972475623259, 0.19320068999695816, 0.21424516444500752, 0.2860902939370249, 0.24327259501279364, 0.2089066084972272, 0.20225606643485672, 0.28330453560191793, 0.2294143657456943, 0.11724865394923001, 0.2123639786044672, 0.13166630388373346, 0.2241197154440958, 0.21855039210261962, 0.24325393926930317, 0.24785327889499054, 0.23236599724544016, 0.09749902815929468, 0.051449510303281376, 0.06280178188730656, 0.09443670627630485, 0.047712192614853155, 0.021576860554051946, 0.017275911672046784, 9.999999999998899e-05, 0.012196971545540669, 0.1612502070990407, 0.1255588419739817, 0.11141757901713989, 0.06405752452016622, 0.05146478102342111, 0.04779693549592301, 0.08595057488484148, 0.10462568186940402, 0.08974751108576584, 0.2857543567593751, 0.13450754679631205, 0.14014643979355312, 0.08417878835848247, 0.08790938544193683, 0.07650580440919619, 0.10333488676620672, 0.36421211170795964, 0.12367794965224943, 0.12031494109646779, 0.14163211435515644, 0.2153470323130907, 0.1075876462439912, 0.137235353095433, 0.11468073896842501, 0.336134207921041, 0.12860240995074002, 0.08165366530175, 0.541169591892936, 0.5176806577193613, 0.5275039302916527, 0.5269525164528248, 0.5485598633689144, 0.537855723057828, 0.5317200883265367, 0.538999917612723, 0.541008205446966, 0.09992204946569361, 0.08466389211477021, 0.0921956089726289, 0.12332040330972982, 0.10545576606910434, 0.14595922107969395, 0.14268060810630123, 0.12147766351408262, 0.1372691498677674, 0.4500289323073099, 0.4063545232551239, 0.47839861783052573, 0.38294443730803696, 0.19557049017521988, 0.2002179535491434, 0.47522958932086967, 0.3409433269815242, 0.550509286947998, 0.5030005030365631, 0.5524759326257229, 0.4164096603957246, 0.5345913429656368, 0.284741931596187, 0.540246895585718, 0.5698425123642691, 0.5316164428575352, 0.2662408230876486, 0.17636041734472818, 0.343891636088982, 0.3328354290744152, 0.40359021042293053, 0.23134822413737222, 0.2875767543473844, 0.24799048631263299, 0.270386360850304, 0.23134455569380252, 0.23840264574580283, 0.24479675620213026, 0.2157808455405198, 0.21798934602652809, 0.20250581169301463, 0.21650824671309155, 0.22316261413519078, 0.2336822602148131, 0.2273571120432364, 0.1918401314739283, 0.1944919169583984, 0.2233808989495476, 0.18706735787591222, 0.20127453535598228, 0.18997213086149223, 0.19631197573533254, 0.20418492784023978, 0.20522552601409405, 0.12244662688333008, 0.867691943772887, 0.17568346635699528, 0.8937454576070764, 0.8710271066848044, 0.904674408337256, 0.1418606876646762, 0.16774648310273255, 0.16601221476264616, 0.8284371469672076, 0.15540275298277995, 0.7079856129458847, 0.21016980155096354, 0.6691002356362594, 0.15361834491059667, 0.11120687785724181, 0.16562886808021737, 0.7142238779415453, 0.19047224295680276, 0.17819634598951195, 0.1857885804829993, 0.19010034942825726, 0.18779411914860056, 0.17650366834112752, 0.1823308756778762, 0.18586479717089255, 0.18096227253314123, 0.0861994826556245, 0.0880563448457704, 0.08601020456687436, 0.09492942886360922, 0.09075598222079917, 0.09193038123386754, 0.08292094113508941, 0.0851263711934982, 0.1018876722841997]}, "mutation_prompt": null}
{"id": "6e02b40c-aa17-4ada-8c10-2a0138228e77", "solution": "import numpy as np\n\nclass QuantumAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n        self.restart_threshold = 0.1  # new parameter for random restart\n\n    def oppositional_learning(self, positions):\n        return self.pos_bounds[0] + self.pos_bounds[1] - positions\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            if np.random.rand() < self.restart_threshold:  # Random Restart Mechanism\n                velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n                positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (gbest_position - positions))  # improved global influence\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "QuantumAMPSO", "description": "Integrate quantum-inspired principles and random restart mechanism for enhanced exploration and convergence speed.", "configspace": "", "generation": 98, "fitness": 0.23569398948242337, "feedback": "The algorithm QuantumAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.5638880654315801, 0.49293037832624487, 0.53206864435642, 0.5046394592073071, 0.4375173184833602, 0.5278430630403865, 0.5522285915759028, 0.46764432205667916, 0.5274618999084675, 0.040384575450644666, 0.03921129931212053, 0.11465157449476993, 0.13638200769263353, 0.056401032361552805, 0.15312468655842426, 0.0957519923279353, 0.005183845497971351, 0.0384409721372545, 0.12107304097869542, 0.12422053447889136, 0.12330434426449033, 0.11078387569861348, 0.10926500606949463, 0.13170596731587425, 0.11203469687619894, 0.09396603573944518, 0.10475223389263844, 0.1137299492460212, 0.09078617442378911, 0.08245115998923247, 0.12896726562008132, 0.08884243478324694, 0.09972000910380852, 0.09997515409619517, 0.0971838208157546, 0.09992175261925074, 0.907780322178798, 0.8684437832203258, 0.7940945216210331, 0.8894499604040486, 0.4775126671848431, 0.8217267476687108, 0.687515154395531, 0.5494139637815525, 0.8053000175941794, 0.31293167696999913, 0.2842161461112983, 0.3550883453607254, 0.300894422434712, 0.27744568087477606, 0.31055152150716026, 0.24807695469232716, 0.2502427449713486, 0.2870786543436673, 0.22809501554874156, 0.31704312592807316, 0.22453475746018858, 0.3400132017973527, 0.20711712292167372, 0.8163056368867283, 0.2130474610113502, 0.20571500404112808, 0.23559578926579516, 0.2599541378879443, 0.1375975012548255, 0.15757049374729415, 0.24228429016387532, 0.17288277999090018, 0.2303715767992195, 0.14831872313113637, 0.15667211652868007, 0.266394497099686, 0.12776199161344703, 0.1732331177966816, 0.18592742580959953, 0.1623541189608242, 0.1527879585456693, 0.16662122147306635, 0.18110658074595243, 0.13084773189223964, 0.1669690582592087, 0.004412520408343834, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016094321271339362, 0.003339880760674152, 0.0031371321625142112, 0.00038776645504745577, 0.07783712974666646, 0.07617302526375369, 0.13343804825685746, 0.10473191219822842, 0.11735994342683675, 0.06846600630426825, 0.09567017932667365, 0.10795876622763845, 0.09629606052650819, 0.12990494465220548, 0.05383198481651286, 0.002118223423806409, 0.017965417298756226, 0.02519169437533797, 0.012642243809864673, 0.02962510629720816, 0.07102362513790772, 0.015443572245750659, 0.031986739170494216, 0.11598059179136289, 0.12337968172854052, 0.13062607526100456, 0.08972286411220354, 0.09056065801837299, 0.06115399346850503, 0.10952731090072954, 0.0711334302179022, 0.07427051342036994, 0.44323219967215943, 0.4168151846448963, 0.42799126521022357, 0.4297181251736685, 0.42188172323668316, 0.4494927141029058, 0.47601398921139804, 0.40435689601204916, 0.4609409540769599, 0.08058595123623913, 0.056334975539852006, 0.09403647543996341, 0.07697640191785537, 0.1060613453793332, 0.10896467706649526, 0.10412372552660076, 0.10141359068406619, 0.12894061047596184, 0.26153808460367967, 0.18157239834006045, 0.1645886977956902, 0.239990619409846, 0.17883152124350765, 0.18886388744171378, 0.17463435789474646, 0.16036476414623835, 0.14542579080912332, 0.2730136443116056, 0.2997907120616561, 0.318282710227362, 0.3092671650480495, 0.21390748992306197, 0.3253971698654826, 0.25843521219583776, 0.2830748716490715, 0.3274407087412302, 0.20873107009702863, 0.20283347161308307, 0.25261665328383764, 0.2694337512556536, 0.17144110886363784, 0.2326536656026471, 0.22193277336162032, 0.22116325482196486, 0.2027269138579577, 0.23352246405061428, 0.19355453884765195, 0.25526201551724215, 0.2396080863007818, 0.2179784665937916, 0.19404203807891207, 0.21962105551380695, 0.20086866272700454, 0.20650832788788953, 0.18743508260315234, 0.18670032141431625, 0.17999944418556768, 0.19481250108652481, 0.1811076242209444, 0.17991298008397338, 0.21970708870276723, 0.1992486618158682, 0.21655525247876872, 0.662492963217266, 0.4359031183930593, 0.3723497583306544, 0.7298005220968622, 0.2611621269124843, 0.8134592521710594, 0.3620817686763391, 0.7085710700640309, 0.17377763697957616, 0.449360158299108, 0.5331373303293381, 0.5463773101678657, 0.4395914459658402, 0.51339877960494, 0.5529478847558977, 0.49206335835735204, 0.37747732174502846, 0.426029552016987, 0.19222198566823323, 0.20376819104762522, 0.1796551494650519, 0.1724215671535625, 0.18568169800900614, 0.18596505185293377, 0.21070469844926354, 0.1795499736323265, 0.184688069349906, 0.08243495115750643, 0.08532871486905624, 0.07988238914798329, 0.07915254546096162, 0.09112376181787529, 0.08104322470814718, 0.10598886870790503, 0.08448445039629204, 0.09301781459816649]}, "mutation_prompt": null}
{"id": "745abfc6-897d-4c4a-9ed3-f66636928636", "solution": "import numpy as np\n\nclass EnhancedAMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.vel_bounds = (-0.5, 0.5)\n        self.pos_bounds = (-5.0, 5.0)\n        self.memory_rate = 0.1\n        self.iterations = self.budget // self.population_size\n        self.mutation_rate = 0.1  # Added mutation rate\n\n    def oppositional_learning(self, positions):\n        opposite_positions = self.pos_bounds[0] + self.pos_bounds[1] - positions\n        return opposite_positions\n\n    def adaptive_topology(self, positions, scores):\n        neighborhood_size = max(1, int(self.population_size * 0.1))\n        indices = np.argsort(scores)\n        return positions[indices[:neighborhood_size]], scores[indices[:neighborhood_size]]\n\n    def mutate_positions(self, positions):\n        # New function for mutation\n        mutation_vector = np.random.uniform(-0.1, 0.1, positions.shape)\n        mutations = np.random.rand(self.population_size, self.dim) < self.mutation_rate\n        positions += mutation_vector * mutations\n        return np.clip(positions, self.pos_bounds[0], self.pos_bounds[1])\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.pos_bounds[0], self.pos_bounds[1], (self.population_size, self.dim))\n        velocities = np.random.uniform(self.vel_bounds[0], self.vel_bounds[1], (self.population_size, self.dim))\n        \n        opposite_positions = self.oppositional_learning(positions)\n        oppositional_scores = np.array([func(pos) for pos in opposite_positions])\n        scores = np.array([func(pos) for pos in positions])\n        \n        better_initial = oppositional_scores < scores\n        positions[better_initial] = opposite_positions[better_initial]\n        scores[better_initial] = oppositional_scores[better_initial]\n\n        pbest_positions = positions.copy()\n        pbest_scores = scores.copy()\n        gbest_position = pbest_positions[np.argmin(pbest_scores)]\n        gbest_score = np.min(pbest_scores)\n\n        for i in range(self.iterations):\n            self.memory_rate = 0.1 + 0.9 * (i / self.iterations)\n            inertia_weight = self.inertia * (1 - (i / self.iterations)**2)\n\n            self.cognitive_coef = 1.5 + 0.5 * (i / self.iterations)\n\n            local_positions, local_scores = self.adaptive_topology(positions, scores)\n            local_best_position = local_positions[np.argmin(local_scores)]\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_coef * r1 * (pbest_positions - positions) +\n                          self.social_coef * r2 * (local_best_position - positions))\n            velocities = np.clip(velocities, self.vel_bounds[0], self.vel_bounds[1])\n\n            positions += velocities\n            positions = self.mutate_positions(positions)  # Apply mutation\n            scores = np.array([func(pos) for pos in positions])\n\n            better_indices = scores < pbest_scores\n            pbest_positions[better_indices] = positions[better_indices]\n            pbest_scores[better_indices] = scores[better_indices]\n\n            if np.min(pbest_scores) < gbest_score:\n                gbest_score = np.min(pbest_scores)\n                gbest_position = pbest_positions[np.argmin(pbest_scores)]\n\n        return gbest_position", "name": "EnhancedAMPSO", "description": "Enhanced convergence in EnhancedAMPSO by incorporating a diversity mechanism through a mutation operator.", "configspace": "", "generation": 99, "fitness": 0.2751313562886101, "feedback": "The algorithm EnhancedAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "a39e803d-6128-4c69-8a0b-8fbdd652d38a", "metadata": {"aucs": [0.6158723837227353, 0.5939431981029328, 0.5934370619236929, 0.5802067514052054, 0.6154138305953013, 0.5914655229223814, 0.6061493705545302, 0.5954251426606979, 0.5893132784986201, 0.2459897981357274, 0.198694031278435, 0.17738853369645258, 0.22766444135071373, 0.20912016287554624, 0.18795710987603587, 0.22092328025314245, 0.21817316600690384, 0.20617973722558824, 0.14849735571576583, 0.13894096518713195, 0.20262583388430322, 0.14887354587878254, 0.2771187593375132, 0.11344063276061367, 0.11805126142998235, 0.15906137923378028, 0.15189514446840002, 0.1085883739619028, 0.04793122064296074, 0.08837144733674684, 0.10676699985439042, 0.0609504305433578, 0.09393853369213734, 0.13199118699769607, 0.08664116470018102, 0.06319487173541294, 0.9048836218067615, 0.9120010361512101, 0.8930273940009467, 0.9158501586254126, 0.9060003761086896, 0.8584186219700858, 0.8935682716559656, 0.889693757544489, 0.8802687188819898, 0.4023952323142901, 0.39117928964956616, 0.4046817782605119, 0.40437695044790567, 0.39498745501514987, 0.41111490151385544, 0.36884070689953974, 0.390510635631134, 0.3830121474122353, 0.7837889138923638, 0.8402546498541489, 0.22573629097885128, 0.21341870847408695, 0.19276654062719434, 0.8842055359085446, 0.7244332348802857, 0.231562739371464, 0.7320441537557332, 0.22013542545295606, 0.2163201828057194, 0.19688643248643745, 0.18623331660697262, 0.20675003052187935, 0.1952338736226502, 0.1893480736442258, 0.18256349387711834, 0.13240967955137972, 0.2157702406766746, 0.19673744410651195, 0.19945888940138023, 0.1742670664780469, 0.18037126124791103, 0.19925530607159525, 0.15726888646406822, 0.22416504000046078, 0.21054238556828864, 0.009333026771779829, 9.999999999998899e-05, 0.04982047927373001, 0.03428124378980979, 0.050259253095072065, 0.026928147833754856, 0.04340638282992426, 9.999999999998899e-05, 9.999999999998899e-05, 0.16407865010845557, 0.12252712792343423, 0.06938298144149924, 0.05448499297976872, 0.053710886305396, 0.055553750731539786, 0.11096108524258774, 0.10796676749678968, 0.07491154632302166, 0.059489461264124466, 0.03312418799634198, 0.07002621644998874, 0.058669497349375876, 0.04243484396180497, 0.041564140580935605, 0.05161448778863997, 0.056071306116241115, 0.07038985135567277, 0.1496278143353078, 0.13098286362934108, 0.17684968405846213, 0.13688497802906263, 0.11954151660145595, 0.09566556332816856, 0.09787503545207488, 0.1126698700026243, 0.081274891342626, 0.48495234999094816, 0.48281333801201687, 0.4784785250826289, 0.46597805528267433, 0.4707913424918454, 0.4764634337216517, 0.46866501028294116, 0.48590827658551494, 0.4813022963921091, 0.11836585595505389, 0.0775113923078341, 0.08986082700293441, 0.09177297200540757, 0.09731438794494496, 0.15571513722064922, 0.11181197103610963, 0.14168819390414322, 0.1427252804691398, 0.3537017345187895, 0.3002658874978159, 0.3410326371034367, 0.24801126128670603, 0.32687778553435365, 0.32359151394256747, 0.3496893807143079, 0.3586902311662713, 0.3465338400777941, 0.3596471522348038, 0.35484774457128276, 0.3630924428904727, 0.36803916965834715, 0.35892234453624217, 0.3508370732182424, 0.35040542701804656, 0.3585805183180101, 0.2667440790519303, 0.21346968397312083, 0.2606063505036983, 0.23035814421932732, 0.22536038885063858, 0.21738915858534535, 0.2480591885534119, 0.2397328554746614, 0.2303248205952133, 0.23975718507836663, 0.20807949834676476, 0.20355376441861794, 0.20161962585977178, 0.21111338999684914, 0.21675336347333674, 0.21932527318917605, 0.21431821919857497, 0.25280772446994326, 0.2271836288967517, 0.19442466616361953, 0.18221068884301217, 0.1891656599315341, 0.19860005402008707, 0.20570691815643838, 0.18301573666607207, 0.19027977540953644, 0.20558614965261934, 0.20749141514848557, 0.12251880043749575, 0.18594386418611952, 0.17416928617801308, 0.8547206451671041, 0.8410712880086912, 0.8844213829120064, 0.8204987128284476, 0.16674948737616946, 0.16673429901506553, 0.7928799416684004, 0.16803268109880132, 0.7531466364625292, 0.21118029593214938, 0.508588654316612, 0.15339637677583173, 0.11082486709272821, 0.6484687835398548, 0.09240966794555439, 0.18114193999057038, 0.19714439281424134, 0.18068987178522478, 0.1913194602639252, 0.19474684825086697, 0.17119974712120056, 0.18195899812513627, 0.17898452920883023, 0.1846251949922566, 0.10356286649661584, 0.08907482143883794, 0.09146759193749454, 0.09561615511770083, 0.09849564695532387, 0.10102703642137967, 0.08471470445714402, 0.08952357715962622, 0.08980441770768943]}, "mutation_prompt": null}
