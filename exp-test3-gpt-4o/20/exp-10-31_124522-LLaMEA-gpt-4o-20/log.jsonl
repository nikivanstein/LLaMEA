{"id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 0, "fitness": 0.18459765394958774, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "53b24cb7-0933-493e-8028-9f314bbb7ee2", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.9  # Adaptive inertia weight for PSO\n        self.c1 = 2.0 # Adaptive cognitive component for PSO\n        self.c2 = 1.5 # Adaptive social component for PSO\n        self.F = 0.5  # Adaptive differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                # Adaptive inertia weight and cognitive components\n                self.w = 0.9 - (0.5 * evaluations / self.budget)\n                self.c1 = 2.0 - (0.5 * evaluations / self.budget)\n\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "An enhanced DEPSO algorithm incorporating adaptive parameters for improved dynamic balance between exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.18143406320832642, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.3587458460154178, 0.3587458460154178, 0.3587458460154178, 0.3976590609072346, 0.3976590609072346, 0.3976590609072346, 0.3905173495241161, 0.3905173495241161, 0.3905173495241161, 0.043288916840445224, 0.043288916840445224, 0.043288916840445224, 0.06031006934383154, 0.06031006934383154, 0.06031006934383154, 0.10392195285932482, 0.10392195285932482, 0.10392195285932482, 0.07617473102628158, 0.07617473102628158, 0.07617473102628158, 0.07589052824242659, 0.07589052824242659, 0.07589052824242659, 0.09627620726239328, 0.09627620726239328, 0.09627620726239328, 0.055047416840597, 0.055047416840597, 0.055047416840597, 0.08018748362216299, 0.08018748362216299, 0.08018748362216299, 0.06300801727691474, 0.06300801727691474, 0.06300801727691474, 0.969734847310604, 0.969734847310604, 0.969734847310604, 0.9741879647598469, 0.9741879647598469, 0.9741879647598469, 0.9711337460701284, 0.9711337460701284, 0.9711337460701284, 0.20618502063420474, 0.20618502063420474, 0.20618502063420474, 0.1391877783684642, 0.1391877783684642, 0.1391877783684642, 0.2167248526265766, 0.2167248526265766, 0.2167248526265766, 0.24030311373360214, 0.24030311373360214, 0.24030311373360214, 0.19915414590859437, 0.19915414590859437, 0.19915414590859437, 0.26640317558955473, 0.26640317558955473, 0.26640317558955473, 0.10335146969181364, 0.10335146969181364, 0.10335146969181364, 0.11701212845796838, 0.11701212845796838, 0.11701212845796838, 0.08335374732491707, 0.08335374732491707, 0.08335374732491707, 0.07854626397590092, 0.07854626397590092, 0.07854626397590092, 0.08741201108467123, 0.08741201108467123, 0.08741201108467123, 0.11929383665613424, 0.11929383665613424, 0.11929383665613424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036871118176564632, 0.0036871118176564632, 0.0036871118176564632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04516521276006247, 0.04516521276006247, 0.04516521276006247, 0.010053386390176056, 0.010053386390176056, 0.010053386390176056, 0.023335235349648098, 0.023335235349648098, 0.023335235349648098, 0.014338274116484917, 0.014338274116484917, 0.014338274116484917, 0.011607924486238153, 0.011607924486238153, 0.011607924486238153, 0.01668185347410034, 0.01668185347410034, 0.01668185347410034, 0.03973647449211981, 0.03973647449211981, 0.03973647449211981, 0.08473202033501348, 0.08473202033501348, 0.08473202033501348, 0.04197087947127098, 0.04197087947127098, 0.04197087947127098, 0.31025160239629324, 0.31025160239629324, 0.31025160239629324, 0.3516461667322004, 0.3516461667322004, 0.3516461667322004, 0.3362162773906525, 0.3362162773906525, 0.3362162773906525, 0.08647782386685698, 0.08647782386685698, 0.08647782386685698, 0.07233592869936534, 0.07233592869936534, 0.07233592869936534, 0.07698201906203317, 0.07698201906203317, 0.07698201906203317, 0.1342426911910234, 0.1342426911910234, 0.1342426911910234, 0.16628217297109749, 0.16628217297109749, 0.16628217297109749, 0.19535556698979106, 0.19535556698979106, 0.19535556698979106, 0.24023863594266903, 0.24023863594266903, 0.24023863594266903, 0.21328955446215836, 0.21328955446215836, 0.21328955446215836, 0.24359032232598377, 0.24359032232598377, 0.24359032232598377, 0.1693591174578125, 0.1693591174578125, 0.1693591174578125, 0.1460180762345662, 0.1460180762345662, 0.1460180762345662, 0.17904811362681916, 0.17904811362681916, 0.17904811362681916, 0.17905594702895777, 0.17905594702895777, 0.17905594702895777, 0.18291595329401455, 0.18291595329401455, 0.18291595329401455, 0.1680955489073369, 0.1680955489073369, 0.1680955489073369, 0.18554038143512186, 0.18554038143512186, 0.18554038143512186, 0.16833653073425192, 0.16833653073425192, 0.16833653073425192, 0.17868336018472986, 0.17868336018472986, 0.17868336018472986, 0.4868326966386174, 0.4868326966386174, 0.4868326966386174, 0.18764433787086843, 0.18764433787086843, 0.18764433787086843, 0.15176830896702176, 0.15176830896702176, 0.15176830896702176, 0.27316782208368084, 0.27316782208368084, 0.27316782208368084, 0.1868701654151067, 0.1868701654151067, 0.1868701654151067, 0.1456153410110621, 0.1456153410110621, 0.1456153410110621, 0.20457407507325165, 0.20457407507325165, 0.20457407507325165, 0.18496411538643143, 0.18496411538643143, 0.18496411538643143, 0.1799880618202978, 0.1799880618202978, 0.1799880618202978, 0.07413304423207678, 0.07413304423207678, 0.07413304423207678, 0.07441764979323884, 0.07441764979323884, 0.07441764979323884, 0.06479508712721505, 0.06479508712721505, 0.06479508712721505]}, "mutation_prompt": null}
{"id": "d4c7b05f-c5f0-4011-af0e-dd74357bcb72", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.9  # Adapt inertia weight\n        self.c1 = 2.0 # Enhanced cognitive component for PSO\n        self.c2 = 2.0 # Enhanced social component for PSO\n        self.F = 0.5  # Adjusted differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            adapt_factor = 1 - evaluations / self.budget  # Adaptive factor\n            self.w = 0.4 + 0.5 * adapt_factor  # Adaptive inertia\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "An improved DEPSO algorithm incorporating adaptive parameters for dynamic balance between exploration and exploitation. ", "configspace": "", "generation": 2, "fitness": 0.14828826088956337, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.258982135217402, 0.258982135217402, 0.258982135217402, 0.2586649649968985, 0.2586649649968985, 0.2586649649968985, 0.27075647592040175, 0.27075647592040175, 0.27075647592040175, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013944653702943066, 0.013944653702943066, 0.013944653702943066, 0.008062126281248694, 0.008062126281248694, 0.008062126281248694, 0.06646211817484182, 0.06646211817484182, 0.06646211817484182, 0.06835441382887597, 0.06835441382887597, 0.06835441382887597, 0.07027606849678503, 0.07027606849678503, 0.07027606849678503, 0.03739169540532772, 0.03739169540532772, 0.03739169540532772, 0.051301874738842734, 0.051301874738842734, 0.051301874738842734, 0.04548631693241001, 0.04548631693241001, 0.04548631693241001, 0.9814020352063546, 0.9814020352063546, 0.9814020352063546, 0.9824954126206293, 0.9824954126206293, 0.9824954126206293, 0.982355371248656, 0.982355371248656, 0.982355371248656, 0.13822245475100758, 0.13822245475100758, 0.13822245475100758, 0.12482135665048355, 0.12482135665048355, 0.12482135665048355, 0.14820532779606743, 0.14820532779606743, 0.14820532779606743, 0.17192901531043514, 0.17192901531043514, 0.17192901531043514, 0.15105876316651046, 0.15105876316651046, 0.15105876316651046, 0.1404685874806917, 0.1404685874806917, 0.1404685874806917, 0.02825417118972784, 0.02825417118972784, 0.02825417118972784, 0.03338212937501284, 0.03338212937501284, 0.03338212937501284, 0.05454329919185297, 0.05454329919185297, 0.05454329919185297, 0.030151705024816122, 0.030151705024816122, 0.030151705024816122, 0.020121788009789587, 0.020121788009789587, 0.020121788009789587, 0.08563313438146847, 0.08563313438146847, 0.08563313438146847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06767150561658741, 0.06767150561658741, 0.06767150561658741, 0.01767040158562705, 0.01767040158562705, 0.01767040158562705, 0.0059016364326062165, 0.0059016364326062165, 0.0059016364326062165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02556825019557929, 0.02556825019557929, 0.02556825019557929, 0.025602252809247883, 0.025602252809247883, 0.025602252809247883, 0.031252822282755055, 0.031252822282755055, 0.031252822282755055, 0.2758770005096046, 0.2758770005096046, 0.2758770005096046, 0.2618396850667565, 0.2618396850667565, 0.2618396850667565, 0.24016570755860522, 0.24016570755860522, 0.24016570755860522, 0.09781548662534478, 0.09781548662534478, 0.09781548662534478, 0.05798436342539404, 0.05798436342539404, 0.05798436342539404, 0.0568916969843869, 0.0568916969843869, 0.0568916969843869, 0.1495365742936896, 0.1495365742936896, 0.1495365742936896, 0.16523680433868881, 0.16523680433868881, 0.16523680433868881, 0.14853213364744244, 0.14853213364744244, 0.14853213364744244, 0.19757776492365442, 0.19757776492365442, 0.19757776492365442, 0.17544401770533513, 0.17544401770533513, 0.17544401770533513, 0.20168160797899592, 0.20168160797899592, 0.20168160797899592, 0.12075200021020482, 0.12075200021020482, 0.12075200021020482, 0.11447914714784069, 0.11447914714784069, 0.11447914714784069, 0.13050955922880347, 0.13050955922880347, 0.13050955922880347, 0.19759372953669763, 0.19759372953669763, 0.19759372953669763, 0.1680451563322164, 0.1680451563322164, 0.1680451563322164, 0.175190710439302, 0.175190710439302, 0.175190710439302, 0.17166288070592894, 0.17166288070592894, 0.17166288070592894, 0.16218692972871773, 0.16218692972871773, 0.16218692972871773, 0.15729040541728612, 0.15729040541728612, 0.15729040541728612, 0.3305306024033282, 0.3305306024033282, 0.3305306024033282, 0.17463253500750253, 0.17463253500750253, 0.17463253500750253, 0.13699017151891169, 0.13699017151891169, 0.13699017151891169, 0.1670562212478851, 0.1670562212478851, 0.1670562212478851, 0.1708639896012164, 0.1708639896012164, 0.1708639896012164, 0.12828749465414402, 0.12828749465414402, 0.12828749465414402, 0.18105091415312935, 0.18105091415312935, 0.18105091415312935, 0.1999722465365149, 0.1999722465365149, 0.1999722465365149, 0.1764656079097049, 0.1764656079097049, 0.1764656079097049, 0.06128029792377543, 0.06128029792377543, 0.06128029792377543, 0.054327026656957655, 0.054327026656957655, 0.054327026656957655, 0.0719100506087127, 0.0719100506087127, 0.0719100506087127]}, "mutation_prompt": null}
{"id": "0b7d3d19-2c51-4fc8-8d04-98b76b1bccd3", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "6f581670-5ac4-48d2-b07e-44b003470efc", "solution": "import numpy as np\n\nclass EnhancedDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.initial_w = 0.9  # Initial inertia weight for PSO\n        self.final_w = 0.4    # Final inertia weight for PSO\n        self.c1 = 1.7         # Cognitive component for PSO\n        self.c2 = 1.7         # Social component for PSO\n        self.F = 0.6          # Differential weight for DE\n        self.CR = 0.9         # Crossover probability for DE\n        self.restart_threshold = budget // 5\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        restarts = 0\n        \n        while evaluations < self.budget:\n            if evaluations - restarts * self.restart_threshold >= self.restart_threshold:\n                restarts += 1\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.apply_along_axis(func, 1, pop)\n                personal_best_positions = np.copy(pop)\n                personal_best_fitness = np.copy(fitness)\n                global_best_position = pop[np.argmin(fitness)]\n                evaluations += self.population_size\n\n            w = self.initial_w - (self.initial_w - self.final_w) * (evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                velocities[i] = (w * velocities[i]\n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "EnhancedDEPSO", "description": "Enhanced DEPSO with adaptive parameters and random restarts to improve exploration and convergence.", "configspace": "", "generation": 4, "fitness": 0.1547681670255575, "feedback": "The algorithm EnhancedDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.25862694905160855, 0.25862694905160855, 0.25862694905160855, 0.3013047856206216, 0.3013047856206216, 0.3013047856206216, 0.2979597914410165, 0.2979597914410165, 0.2979597914410165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002018747899083073, 0.002018747899083073, 0.002018747899083073, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07678104614698389, 0.07678104614698389, 0.07678104614698389, 0.08664664181321224, 0.08664664181321224, 0.08664664181321224, 0.0734765581637492, 0.0734765581637492, 0.0734765581637492, 0.04697940548739776, 0.04697940548739776, 0.04697940548739776, 0.05983184510957329, 0.05983184510957329, 0.05983184510957329, 0.056458673661847536, 0.056458673661847536, 0.056458673661847536, 0.9703932745937587, 0.9703932745937587, 0.9703932745937587, 0.9781254164266053, 0.9781254164266053, 0.9781254164266053, 0.9709989535084084, 0.9709989535084084, 0.9709989535084084, 0.12391857657301641, 0.12391857657301641, 0.12391857657301641, 0.13758024250361234, 0.13758024250361234, 0.13758024250361234, 0.14786638584920697, 0.14786638584920697, 0.14786638584920697, 0.1605572356392324, 0.1605572356392324, 0.1605572356392324, 0.16474998316826217, 0.16474998316826217, 0.16474998316826217, 0.19311806895110462, 0.19311806895110462, 0.19311806895110462, 0.06982220980337495, 0.06982220980337495, 0.06982220980337495, 0.09244490345020073, 0.09244490345020073, 0.09244490345020073, 0.06718683349651855, 0.06718683349651855, 0.06718683349651855, 0.059433184040038056, 0.059433184040038056, 0.059433184040038056, 0.0474745892365771, 0.0474745892365771, 0.0474745892365771, 0.05372917108128916, 0.05372917108128916, 0.05372917108128916, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012927369243952436, 0.012927369243952436, 0.012927369243952436, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04747667558581525, 0.04747667558581525, 0.04747667558581525, 0.022948352264290373, 0.022948352264290373, 0.022948352264290373, 0.028409967693561744, 0.028409967693561744, 0.028409967693561744, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03337613250412341, 0.03337613250412341, 0.03337613250412341, 0.032202156850262176, 0.032202156850262176, 0.032202156850262176, 0.03717201332223263, 0.03717201332223263, 0.03717201332223263, 0.28071583640036146, 0.28071583640036146, 0.28071583640036146, 0.2932899401135364, 0.2932899401135364, 0.2932899401135364, 0.2838313175556618, 0.2838313175556618, 0.2838313175556618, 0.09115505609378327, 0.09115505609378327, 0.09115505609378327, 0.05834029658327322, 0.05834029658327322, 0.05834029658327322, 0.06690119393204619, 0.06690119393204619, 0.06690119393204619, 0.1419508793583567, 0.1419508793583567, 0.1419508793583567, 0.13314941950121206, 0.13314941950121206, 0.13314941950121206, 0.13953623176587082, 0.13953623176587082, 0.13953623176587082, 0.19514199462816828, 0.19514199462816828, 0.19514199462816828, 0.18605850115459532, 0.18605850115459532, 0.18605850115459532, 0.1972166891782111, 0.1972166891782111, 0.1972166891782111, 0.15635943794223117, 0.15635943794223117, 0.15635943794223117, 0.14331144555459685, 0.14331144555459685, 0.14331144555459685, 0.14009152160485105, 0.14009152160485105, 0.14009152160485105, 0.17005171318040613, 0.17005171318040613, 0.17005171318040613, 0.16336414504317254, 0.16336414504317254, 0.16336414504317254, 0.17518364559237454, 0.17518364559237454, 0.17518364559237454, 0.16970920813838308, 0.16970920813838308, 0.16970920813838308, 0.1595887449602693, 0.1595887449602693, 0.1595887449602693, 0.15871315491912774, 0.15871315491912774, 0.15871315491912774, 0.21854179784261207, 0.21854179784261207, 0.21854179784261207, 0.23399745718708187, 0.23399745718708187, 0.23399745718708187, 0.19670070471184764, 0.19670070471184764, 0.19670070471184764, 0.16447545166475808, 0.16447545166475808, 0.16447545166475808, 0.16624896268216016, 0.16624896268216016, 0.16624896268216016, 0.1810118904755409, 0.1810118904755409, 0.1810118904755409, 0.1925505155331272, 0.1925505155331272, 0.1925505155331272, 0.18527144563029174, 0.18527144563029174, 0.18527144563029174, 0.1878129314922865, 0.1878129314922865, 0.1878129314922865, 0.06855616778822948, 0.06855616778822948, 0.06855616778822948, 0.0668468691005033, 0.0668468691005033, 0.0668468691005033, 0.06493731835067451, 0.06493731835067451, 0.06493731835067451]}, "mutation_prompt": null}
{"id": "ba9ad80c-1e3b-430d-8436-be3bac3ac10a", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step - with adaptive F\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Particle Swarm Optimization step - with adaptive inertia\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive parameter update\n            self.w *= 0.99  # Decaying inertia weight\n            self.F = np.random.uniform(0.5, 1.0)  # Randomized differential weight\n\n            # Tournament selection\n            if evaluations + self.population_size <= self.budget:\n                new_pop = []\n                for _ in range(self.population_size):\n                    candidates = np.random.choice(self.population_size, 2, replace=False)\n                    winner = candidates[0] if fitness[candidates[0]] < fitness[candidates[1]] else candidates[1]\n                    new_pop.append(pop[winner])\n                pop = np.array(new_pop)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Incorporate adaptive parameters and introduce tournament selection to enhance convergence speed and solution quality.", "configspace": "", "generation": 5, "fitness": 0.13755397806988778, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.22528558228896978, 0.22528558228896978, 0.22528558228896978, 0.2560707953098501, 0.2560707953098501, 0.2560707953098501, 0.2434753369579543, 0.2434753369579543, 0.2434753369579543, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06504504356883967, 0.06504504356883967, 0.06504504356883967, 0.050509311168494775, 0.050509311168494775, 0.050509311168494775, 0.06531840143505196, 0.06531840143505196, 0.06531840143505196, 0.03361009814244065, 0.03361009814244065, 0.03361009814244065, 0.04272899666481422, 0.04272899666481422, 0.04272899666481422, 0.04065617442106506, 0.04065617442106506, 0.04065617442106506, 0.9663086653664034, 0.9663086653664034, 0.9663086653664034, 0.9668517868460219, 0.9668517868460219, 0.9668517868460219, 0.9712468200244204, 0.9712468200244204, 0.9712468200244204, 0.10370049562822747, 0.10370049562822747, 0.10370049562822747, 0.10624161531325538, 0.10624161531325538, 0.10624161531325538, 0.13791683281593758, 0.13791683281593758, 0.13791683281593758, 0.12419263379916079, 0.12419263379916079, 0.12419263379916079, 0.13234303562493532, 0.13234303562493532, 0.13234303562493532, 0.1372046771599187, 0.1372046771599187, 0.1372046771599187, 0.04625337667542495, 0.04625337667542495, 0.04625337667542495, 0.07934744910821678, 0.07934744910821678, 0.07934744910821678, 0.02567294295358058, 0.02567294295358058, 0.02567294295358058, 0.0359410127880716, 0.0359410127880716, 0.0359410127880716, 0.02324772611305126, 0.02324772611305126, 0.02324772611305126, 0.00011266458420466918, 0.00011266458420466918, 0.00011266458420466918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07544460047231971, 0.07544460047231971, 0.07544460047231971, 0.023045557110685677, 0.023045557110685677, 0.023045557110685677, 0.021458231307105557, 0.021458231307105557, 0.021458231307105557, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006738063096760949, 0.006738063096760949, 0.006738063096760949, 0.013198442378734021, 0.013198442378734021, 0.013198442378734021, 0.013324450792975395, 0.013324450792975395, 0.013324450792975395, 0.2348684688962791, 0.2348684688962791, 0.2348684688962791, 0.26107422870136265, 0.26107422870136265, 0.26107422870136265, 0.23964962727073869, 0.23964962727073869, 0.23964962727073869, 0.07830091490772961, 0.07830091490772961, 0.07830091490772961, 0.05306460992177342, 0.05306460992177342, 0.05306460992177342, 0.059287612374137266, 0.059287612374137266, 0.059287612374137266, 0.13833114920118683, 0.13833114920118683, 0.13833114920118683, 0.12196538597954532, 0.12196538597954532, 0.12196538597954532, 0.12744289102475592, 0.12744289102475592, 0.12744289102475592, 0.16772814693256966, 0.16772814693256966, 0.16772814693256966, 0.16468976748619824, 0.16468976748619824, 0.16468976748619824, 0.1802638517062216, 0.1802638517062216, 0.1802638517062216, 0.11142279611868522, 0.11142279611868522, 0.11142279611868522, 0.11900203666170606, 0.11900203666170606, 0.11900203666170606, 0.1250573647883706, 0.1250573647883706, 0.1250573647883706, 0.15135242194157295, 0.15135242194157295, 0.15135242194157295, 0.15706302068207734, 0.15706302068207734, 0.15706302068207734, 0.16787509558847125, 0.16787509558847125, 0.16787509558847125, 0.14988904496292765, 0.14988904496292765, 0.14988904496292765, 0.15788964451258858, 0.15788964451258858, 0.15788964451258858, 0.15826318235396775, 0.15826318235396775, 0.15826318235396775, 0.21734239036485692, 0.21734239036485692, 0.21734239036485692, 0.1507815409451294, 0.1507815409451294, 0.1507815409451294, 0.18643951447584572, 0.18643951447584572, 0.18643951447584572, 0.15253442716020926, 0.15253442716020926, 0.15253442716020926, 0.12753478276103414, 0.12753478276103414, 0.12753478276103414, 0.17469088525472287, 0.17469088525472287, 0.17469088525472287, 0.20932630804507313, 0.20932630804507313, 0.20932630804507313, 0.19095273214234376, 0.19095273214234376, 0.19095273214234376, 0.18437225763934373, 0.18437225763934373, 0.18437225763934373, 0.049653172762705644, 0.049653172762705644, 0.049653172762705644, 0.053548762438862973, 0.053548762438862973, 0.053548762438862973, 0.04883756511203463, 0.04883756511203463, 0.04883756511203463]}, "mutation_prompt": null}
{"id": "06bab042-b9bb-434e-a27d-e6d3d885750d", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "086ed405-b08e-4dfe-a25a-6965150625e4", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "2add9cef-2197-4990-a704-9d7d9eb97940", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "1abc2ff2-790b-4ebd-b687-7463f994d523", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "a57ecef9-5006-451d-b3ca-e2de901def22", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "7ae38c21-5fc8-4088-99c8-37d86be0d5af", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "2865e7d9-bf0d-4eaf-ae5a-c6c4877ade79", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "37ef2edf-8a50-497e-951a-5db2271b5e05", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "bf0b464a-d498-4d99-abf1-da0e5e6d7abb", "solution": "import numpy as np\n\nclass ADEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.9  # Increased inertia weight for better global search\n        self.c1 = 2.0 # Enhanced cognitive component for faster personal convergence\n        self.c2 = 1.5 # Unchanged social component\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.F = 0.5 + np.random.rand() * 0.5  # Adaptive differential weight\n            self.c1 = 1.5 + np.random.rand()  # Adaptive cognitive component\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "ADEPSO", "description": "An enhanced DEPSO variant incorporating adaptive parameters to dynamically adjust exploration and exploitation phases, aiming to improve convergence.", "configspace": "", "generation": 14, "fitness": 0.1422155813289612, "feedback": "The algorithm ADEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.19300089479554483, 0.19300089479554483, 0.19300089479554483, 0.2280504488857077, 0.2280504488857077, 0.2280504488857077, 0.24124307452496774, 0.24124307452496774, 0.24124307452496774, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0776948160343951, 0.0776948160343951, 0.0776948160343951, 0.058644280716242836, 0.058644280716242836, 0.058644280716242836, 0.062405338378298425, 0.062405338378298425, 0.062405338378298425, 0.046280934390119155, 0.046280934390119155, 0.046280934390119155, 0.04517124433231057, 0.04517124433231057, 0.04517124433231057, 0.03916982226504839, 0.03916982226504839, 0.03916982226504839, 0.9696534672716628, 0.9696534672716628, 0.9696534672716628, 0.9823772497121629, 0.9823772497121629, 0.9823772497121629, 0.9692100874609245, 0.9692100874609245, 0.9692100874609245, 0.09222332505717279, 0.09222332505717279, 0.09222332505717279, 0.11136850065348958, 0.11136850065348958, 0.11136850065348958, 0.12937941229589067, 0.12937941229589067, 0.12937941229589067, 0.14290204618505886, 0.14290204618505886, 0.14290204618505886, 0.17022578002073785, 0.17022578002073785, 0.17022578002073785, 0.1486006866857389, 0.1486006866857389, 0.1486006866857389, 0.04929801372844156, 0.04929801372844156, 0.04929801372844156, 0.07503652431429342, 0.07503652431429342, 0.07503652431429342, 0.010161904426163382, 0.010161904426163382, 0.010161904426163382, 0.039091806083591085, 0.039091806083591085, 0.039091806083591085, 0.0030159630086403766, 0.0030159630086403766, 0.0030159630086403766, 0.039532838747362464, 0.039532838747362464, 0.039532838747362464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11261136212374945, 0.11261136212374945, 0.11261136212374945, 0.009240892528824762, 0.009240892528824762, 0.009240892528824762, 0.03163340134970971, 0.03163340134970971, 0.03163340134970971, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03168855762042855, 0.03168855762042855, 0.03168855762042855, 0.010174283046990085, 0.010174283046990085, 0.010174283046990085, 0.026772772674123035, 0.026772772674123035, 0.026772772674123035, 0.23324557198247897, 0.23324557198247897, 0.23324557198247897, 0.2248831272180294, 0.2248831272180294, 0.2248831272180294, 0.23502171542127903, 0.23502171542127903, 0.23502171542127903, 0.06110558662973564, 0.06110558662973564, 0.06110558662973564, 0.0693730187261068, 0.0693730187261068, 0.0693730187261068, 0.06040062515496447, 0.06040062515496447, 0.06040062515496447, 0.14443073202994505, 0.14443073202994505, 0.14443073202994505, 0.16137404916417286, 0.16137404916417286, 0.16137404916417286, 0.13915774906692024, 0.13915774906692024, 0.13915774906692024, 0.1776702705037918, 0.1776702705037918, 0.1776702705037918, 0.18923656528096233, 0.18923656528096233, 0.18923656528096233, 0.195454695222962, 0.195454695222962, 0.195454695222962, 0.1244561021042766, 0.1244561021042766, 0.1244561021042766, 0.13120523361067593, 0.13120523361067593, 0.13120523361067593, 0.12681698946256015, 0.12681698946256015, 0.12681698946256015, 0.14922143246835318, 0.14922143246835318, 0.14922143246835318, 0.14508903281813978, 0.14508903281813978, 0.14508903281813978, 0.16117157713502817, 0.16117157713502817, 0.16117157713502817, 0.15511540722977912, 0.15511540722977912, 0.15511540722977912, 0.1651417763363554, 0.1651417763363554, 0.1651417763363554, 0.17817428282850156, 0.17817428282850156, 0.17817428282850156, 0.28072715353321565, 0.28072715353321565, 0.28072715353321565, 0.1655386945643802, 0.1655386945643802, 0.1655386945643802, 0.1631175367318507, 0.1631175367318507, 0.1631175367318507, 0.1613959366285449, 0.1613959366285449, 0.1613959366285449, 0.1406961390165985, 0.1406961390165985, 0.1406961390165985, 0.21652535472818213, 0.21652535472818213, 0.21652535472818213, 0.17938906721072, 0.17938906721072, 0.17938906721072, 0.178518730763916, 0.178518730763916, 0.178518730763916, 0.17413074563525022, 0.17413074563525022, 0.17413074563525022, 0.07038493642728283, 0.07038493642728283, 0.07038493642728283, 0.06203887211990966, 0.06203887211990966, 0.06203887211990966, 0.0725534186125466, 0.0725534186125466, 0.0725534186125466]}, "mutation_prompt": null}
{"id": "e80fbb8e-91f8-4469-b9a3-dfc3c2f8c38b", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.9  # Adaptive initial inertia weight for PSO\n        self.w_min = 0.4  # Minimum inertia weight\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Adaptive initial crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO parameters\n            self.w = self.w_min + (0.9 - self.w_min) * ((self.budget - evaluations) / self.budget)\n            self.CR = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhancing DEPSO by incorporating adaptive inertia and crossover rates to dynamically balance exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.17774707323246466, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.37335265341741264, 0.37335265341741264, 0.37335265341741264, 0.39453414079537297, 0.39453414079537297, 0.39453414079537297, 0.42185384556703953, 0.42185384556703953, 0.42185384556703953, 0.1116615277670453, 0.1116615277670453, 0.1116615277670453, 0.09848582852209964, 0.09848582852209964, 0.09848582852209964, 0.10560967712358793, 0.10560967712358793, 0.10560967712358793, 0.08422573205329409, 0.08422573205329409, 0.08422573205329409, 0.0691963065786878, 0.0691963065786878, 0.0691963065786878, 0.07505438449330981, 0.07505438449330981, 0.07505438449330981, 0.0700335037091725, 0.0700335037091725, 0.0700335037091725, 0.05659095156889815, 0.05659095156889815, 0.05659095156889815, 0.06475569628739575, 0.06475569628739575, 0.06475569628739575, 0.9689497358341032, 0.9689497358341032, 0.9689497358341032, 0.9731103566129556, 0.9731103566129556, 0.9731103566129556, 0.9733277541306751, 0.9733277541306751, 0.9733277541306751, 0.1769011392339347, 0.1769011392339347, 0.1769011392339347, 0.15978449359231384, 0.15978449359231384, 0.15978449359231384, 0.19509903167436193, 0.19509903167436193, 0.19509903167436193, 0.2300428995910263, 0.2300428995910263, 0.2300428995910263, 0.19484193344279, 0.19484193344279, 0.19484193344279, 0.20522458507803198, 0.20522458507803198, 0.20522458507803198, 0.08354500981602564, 0.08354500981602564, 0.08354500981602564, 0.09740705855733689, 0.09740705855733689, 0.09740705855733689, 0.09823477103525924, 0.09823477103525924, 0.09823477103525924, 0.09569800807407625, 0.09569800807407625, 0.09569800807407625, 0.1072430627191785, 0.1072430627191785, 0.1072430627191785, 0.06963813144355535, 0.06963813144355535, 0.06963813144355535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07353852687370033, 0.07353852687370033, 0.07353852687370033, 0.007846704822284667, 0.007846704822284667, 0.007846704822284667, 0.01697863962170354, 0.01697863962170354, 0.01697863962170354, 0.01520899589642577, 0.01520899589642577, 0.01520899589642577, 0.014869014176012607, 0.014869014176012607, 0.014869014176012607, 0.0017717221757302948, 0.0017717221757302948, 0.0017717221757302948, 0.05735630634930766, 0.05735630634930766, 0.05735630634930766, 0.06235415021364077, 0.06235415021364077, 0.06235415021364077, 0.04494694987613057, 0.04494694987613057, 0.04494694987613057, 0.30805370306174096, 0.30805370306174096, 0.30805370306174096, 0.35234211806584137, 0.35234211806584137, 0.35234211806584137, 0.3233245900394679, 0.3233245900394679, 0.3233245900394679, 0.07687889996225128, 0.07687889996225128, 0.07687889996225128, 0.07461139048680687, 0.07461139048680687, 0.07461139048680687, 0.07611566562190453, 0.07611566562190453, 0.07611566562190453, 0.12816909297999501, 0.12816909297999501, 0.12816909297999501, 0.143846647073679, 0.143846647073679, 0.143846647073679, 0.14705644500777215, 0.14705644500777215, 0.14705644500777215, 0.22736884386107548, 0.22736884386107548, 0.22736884386107548, 0.24167829695474352, 0.24167829695474352, 0.24167829695474352, 0.2596423647811368, 0.2596423647811368, 0.2596423647811368, 0.1564190512269863, 0.1564190512269863, 0.1564190512269863, 0.15455703723347147, 0.15455703723347147, 0.15455703723347147, 0.13921714655874806, 0.13921714655874806, 0.13921714655874806, 0.16211823863348473, 0.16211823863348473, 0.16211823863348473, 0.19387536157702157, 0.19387536157702157, 0.19387536157702157, 0.20352790188453052, 0.20352790188453052, 0.20352790188453052, 0.1670196481354569, 0.1670196481354569, 0.1670196481354569, 0.16851998868244578, 0.16851998868244578, 0.16851998868244578, 0.16773451496377823, 0.16773451496377823, 0.16773451496377823, 0.3879555408534682, 0.3879555408534682, 0.3879555408534682, 0.17762387756398001, 0.17762387756398001, 0.17762387756398001, 0.21408518615256944, 0.21408518615256944, 0.21408518615256944, 0.18030702096365037, 0.18030702096365037, 0.18030702096365037, 0.18359132734980632, 0.18359132734980632, 0.18359132734980632, 0.14551841442734037, 0.14551841442734037, 0.14551841442734037, 0.18421522030334003, 0.18421522030334003, 0.18421522030334003, 0.18233359320198983, 0.18233359320198983, 0.18233359320198983, 0.21040645153281978, 0.21040645153281978, 0.21040645153281978, 0.07519686623035282, 0.07519686623035282, 0.07519686623035282, 0.07200483237461208, 0.07200483237461208, 0.07200483237461208, 0.06290076626731245, 0.06290076626731245, 0.06290076626731245]}, "mutation_prompt": null}
{"id": "2251c452-06c2-44a8-8743-bad329f09859", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.9  # Increased inertia weight for PSO\n        self.c1 = 2.0 # Increased cognitive component for PSO\n        self.c2 = 2.0 # Increased social component for PSO\n        self.F = 0.5  # Adaptive differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                F_i = self.F + np.random.rand() * 0.2  # Add randomness to F\n                mutant = np.clip(a + F_i * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "An enhanced DEPSO algorithm with adaptive parameters for better balance between exploration and exploitation.", "configspace": "", "generation": 16, "fitness": 0.13627879973983886, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.22815473533915287, 0.22815473533915287, 0.22815473533915287, 0.2809428040086057, 0.2809428040086057, 0.2809428040086057, 0.29994941625401805, 0.29994941625401805, 0.29994941625401805, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058796993120641905, 0.058796993120641905, 0.058796993120641905, 0.053816682852076525, 0.053816682852076525, 0.053816682852076525, 0.04867906358409346, 0.04867906358409346, 0.04867906358409346, 0.036756856525391735, 0.036756856525391735, 0.036756856525391735, 0.04785517157026009, 0.04785517157026009, 0.04785517157026009, 0.049175254598907814, 0.049175254598907814, 0.049175254598907814, 0.9728467861341128, 0.9728467861341128, 0.9728467861341128, 0.9740204717722714, 0.9740204717722714, 0.9740204717722714, 0.9721461325198616, 0.9721461325198616, 0.9721461325198616, 0.10308841863080231, 0.10308841863080231, 0.10308841863080231, 0.10515463641792744, 0.10515463641792744, 0.10515463641792744, 0.12762473688225706, 0.12762473688225706, 0.12762473688225706, 0.11734800319094907, 0.11734800319094907, 0.11734800319094907, 0.12584010477869068, 0.12584010477869068, 0.12584010477869068, 0.1390256232704925, 0.1390256232704925, 0.1390256232704925, 0.017807535088837034, 0.017807535088837034, 0.017807535088837034, 0.03538301440578229, 0.03538301440578229, 0.03538301440578229, 0.0049962396226126415, 0.0049962396226126415, 0.0049962396226126415, 0.028667316080166483, 0.028667316080166483, 0.028667316080166483, 0.01502254153331306, 0.01502254153331306, 0.01502254153331306, 0.00020730039738814376, 0.00020730039738814376, 0.00020730039738814376, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033911274978874695, 0.033911274978874695, 0.033911274978874695, 0.06928374292434492, 0.06928374292434492, 0.06928374292434492, 0.011846717822010078, 0.011846717822010078, 0.011846717822010078, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02083206582033892, 0.02083206582033892, 0.02083206582033892, 0.0005007092853804851, 0.0005007092853804851, 0.0005007092853804851, 0.0015099763429108348, 0.0015099763429108348, 0.0015099763429108348, 0.24339232393913457, 0.24339232393913457, 0.24339232393913457, 0.21880451814378443, 0.21880451814378443, 0.21880451814378443, 0.20436893880747997, 0.20436893880747997, 0.20436893880747997, 0.06450799998838719, 0.06450799998838719, 0.06450799998838719, 0.05342913017847073, 0.05342913017847073, 0.05342913017847073, 0.06027612371952751, 0.06027612371952751, 0.06027612371952751, 0.13039877144381995, 0.13039877144381995, 0.13039877144381995, 0.14500597611485533, 0.14500597611485533, 0.14500597611485533, 0.15397442948533024, 0.15397442948533024, 0.15397442948533024, 0.1605339675047187, 0.1605339675047187, 0.1605339675047187, 0.18849815816778293, 0.18849815816778293, 0.18849815816778293, 0.1789187619279985, 0.1789187619279985, 0.1789187619279985, 0.14174652278569666, 0.14174652278569666, 0.14174652278569666, 0.14550624927948697, 0.14550624927948697, 0.14550624927948697, 0.12801222234629372, 0.12801222234629372, 0.12801222234629372, 0.1495087879609195, 0.1495087879609195, 0.1495087879609195, 0.1564476583974007, 0.1564476583974007, 0.1564476583974007, 0.1686048087500781, 0.1686048087500781, 0.1686048087500781, 0.15370971252989507, 0.15370971252989507, 0.15370971252989507, 0.1461978779120312, 0.1461978779120312, 0.1461978779120312, 0.14060473665243445, 0.14060473665243445, 0.14060473665243445, 0.24249453729261694, 0.24249453729261694, 0.24249453729261694, 0.19465971896829848, 0.19465971896829848, 0.19465971896829848, 0.15982728192962858, 0.15982728192962858, 0.15982728192962858, 0.11574959070492385, 0.11574959070492385, 0.11574959070492385, 0.1122502134934199, 0.1122502134934199, 0.1122502134934199, 0.13560518155050705, 0.13560518155050705, 0.13560518155050705, 0.2051877253103782, 0.2051877253103782, 0.2051877253103782, 0.1713198615904179, 0.1713198615904179, 0.1713198615904179, 0.19362107541825557, 0.19362107541825557, 0.19362107541825557, 0.055109657369299736, 0.055109657369299736, 0.055109657369299736, 0.054767156264658334, 0.054767156264658334, 0.054767156264658334, 0.05694357958799523, 0.05694357958799523, 0.05694357958799523]}, "mutation_prompt": null}
{"id": "fa493dc7-dbac-4a34-a4f8-d6267fa0f257", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "3425db14-a7d7-4e9e-83e6-128245f9a2a6", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "813c5295-7d5f-4539-a6b9-a89d7192689c", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "712f8dc8-65b4-4623-a83d-65b33271e8f9", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "4652f8c2-896c-48b7-b937-a50787321347", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "e8b8ffb4-767d-46d3-bb4b-8641993bcfb1", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                self.w = 0.9 - ((0.9 - 0.4) * evaluations / self.budget)  # Dynamic inertia weight\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A refined hybrid DEPSO algorithm that dynamically adjusts exploration and exploitation phases to enhance performance across diverse optimization landscapes.", "configspace": "", "generation": 22, "fitness": 0.18088561291122318, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.3609961046964125, 0.3609961046964125, 0.3609961046964125, 0.39552234136328523, 0.39552234136328523, 0.39552234136328523, 0.3847830529583467, 0.3847830529583467, 0.3847830529583467, 0.0995741260195544, 0.0995741260195544, 0.0995741260195544, 0.1094586786517735, 0.1094586786517735, 0.1094586786517735, 0.10961354009548818, 0.10961354009548818, 0.10961354009548818, 0.08015688682752808, 0.08015688682752808, 0.08015688682752808, 0.07506863514713913, 0.07506863514713913, 0.07506863514713913, 0.08442547100566677, 0.08442547100566677, 0.08442547100566677, 0.06207144846587731, 0.06207144846587731, 0.06207144846587731, 0.08160707204142958, 0.08160707204142958, 0.08160707204142958, 0.06775676834840993, 0.06775676834840993, 0.06775676834840993, 0.9690350960221719, 0.9690350960221719, 0.9690350960221719, 0.9731095023592828, 0.9731095023592828, 0.9731095023592828, 0.9733274805938857, 0.9733274805938857, 0.9733274805938857, 0.16494614562483745, 0.16494614562483745, 0.16494614562483745, 0.15718173937915492, 0.15718173937915492, 0.15718173937915492, 0.16990550146196004, 0.16990550146196004, 0.16990550146196004, 0.23225592779075588, 0.23225592779075588, 0.23225592779075588, 0.22116519451003336, 0.22116519451003336, 0.22116519451003336, 0.18871862467375888, 0.18871862467375888, 0.18871862467375888, 0.0757166372272633, 0.0757166372272633, 0.0757166372272633, 0.12363274009271386, 0.12363274009271386, 0.12363274009271386, 0.10288799355117861, 0.10288799355117861, 0.10288799355117861, 0.09924564179546613, 0.09924564179546613, 0.09924564179546613, 0.09226640724464874, 0.09226640724464874, 0.09226640724464874, 0.09833068888872654, 0.09833068888872654, 0.09833068888872654, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07235368553113186, 0.07235368553113186, 0.07235368553113186, 0.015935013267031728, 0.015935013267031728, 0.015935013267031728, 0.03988501701629377, 0.03988501701629377, 0.03988501701629377, 0.014757264469495879, 0.014757264469495879, 0.014757264469495879, 0.012177040638087444, 0.012177040638087444, 0.012177040638087444, 0.03296789933571509, 0.03296789933571509, 0.03296789933571509, 0.04816754042615834, 0.04816754042615834, 0.04816754042615834, 0.05087814990167916, 0.05087814990167916, 0.05087814990167916, 0.05324179780411287, 0.05324179780411287, 0.05324179780411287, 0.30765679667408574, 0.30765679667408574, 0.30765679667408574, 0.3096957811631903, 0.3096957811631903, 0.3096957811631903, 0.3552752524882038, 0.3552752524882038, 0.3552752524882038, 0.08690929651617829, 0.08690929651617829, 0.08690929651617829, 0.0846330831385993, 0.0846330831385993, 0.0846330831385993, 0.07360477463655501, 0.07360477463655501, 0.07360477463655501, 0.12449834272396854, 0.12449834272396854, 0.12449834272396854, 0.15548763525965803, 0.15548763525965803, 0.15548763525965803, 0.17239460436887089, 0.17239460436887089, 0.17239460436887089, 0.2427890530267236, 0.2427890530267236, 0.2427890530267236, 0.20952585653418299, 0.20952585653418299, 0.20952585653418299, 0.22719101786595397, 0.22719101786595397, 0.22719101786595397, 0.178546938535459, 0.178546938535459, 0.178546938535459, 0.14325464124749798, 0.14325464124749798, 0.14325464124749798, 0.15659920059955035, 0.15659920059955035, 0.15659920059955035, 0.19398338081789723, 0.19398338081789723, 0.19398338081789723, 0.17095818765017534, 0.17095818765017534, 0.17095818765017534, 0.18404844768330408, 0.18404844768330408, 0.18404844768330408, 0.18070426942613105, 0.18070426942613105, 0.18070426942613105, 0.1801217556214071, 0.1801217556214071, 0.1801217556214071, 0.1748494162152574, 0.1748494162152574, 0.1748494162152574, 0.515780484072949, 0.515780484072949, 0.515780484072949, 0.30252651586432244, 0.30252651586432244, 0.30252651586432244, 0.1689739616507956, 0.1689739616507956, 0.1689739616507956, 0.1460467794489989, 0.1460467794489989, 0.1460467794489989, 0.18467455336989813, 0.18467455336989813, 0.18467455336989813, 0.1499881497251878, 0.1499881497251878, 0.1499881497251878, 0.1767569123950472, 0.1767569123950472, 0.1767569123950472, 0.1887191830521936, 0.1887191830521936, 0.1887191830521936, 0.1959390582206042, 0.1959390582206042, 0.1959390582206042, 0.06622396235913552, 0.06622396235913552, 0.06622396235913552, 0.06389232912988241, 0.06389232912988241, 0.06389232912988241, 0.05809165289974805, 0.05809165289974805, 0.05809165289974805]}, "mutation_prompt": null}
{"id": "37b9717e-de34-4abe-b9a9-dfcacd4e39dd", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.9  # Increased initial inertia weight for PSO\n        self.c1 = 2.0 # Increased cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.7  # Adjusted differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm enhanced with adaptive parameters for improved exploration-exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.16762781504657337, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.3702711536730847, 0.3702711536730847, 0.3702711536730847, 0.3313372599083325, 0.3313372599083325, 0.3313372599083325, 0.29244374119576666, 0.29244374119576666, 0.29244374119576666, 0.054553444262311124, 0.054553444262311124, 0.054553444262311124, 0.06873257013419065, 0.06873257013419065, 0.06873257013419065, 0.05093589835223611, 0.05093589835223611, 0.05093589835223611, 0.08154751189236287, 0.08154751189236287, 0.08154751189236287, 0.06837038252992911, 0.06837038252992911, 0.06837038252992911, 0.07232536036525927, 0.07232536036525927, 0.07232536036525927, 0.0573871356028447, 0.0573871356028447, 0.0573871356028447, 0.06689923569844536, 0.06689923569844536, 0.06689923569844536, 0.051418983544814, 0.051418983544814, 0.051418983544814, 0.9694734806573131, 0.9694734806573131, 0.9694734806573131, 0.9721073120489703, 0.9721073120489703, 0.9721073120489703, 0.9709651781834645, 0.9709651781834645, 0.9709651781834645, 0.1666974402393584, 0.1666974402393584, 0.1666974402393584, 0.15905366375606222, 0.15905366375606222, 0.15905366375606222, 0.1775897618196456, 0.1775897618196456, 0.1775897618196456, 0.1825399436462497, 0.1825399436462497, 0.1825399436462497, 0.19041348451636386, 0.19041348451636386, 0.19041348451636386, 0.18322531738650205, 0.18322531738650205, 0.18322531738650205, 0.08653004412992027, 0.08653004412992027, 0.08653004412992027, 0.10566472876626143, 0.10566472876626143, 0.10566472876626143, 0.09684497437998996, 0.09684497437998996, 0.09684497437998996, 0.037777405503501504, 0.037777405503501504, 0.037777405503501504, 0.05788960645851804, 0.05788960645851804, 0.05788960645851804, 0.04913764031826473, 0.04913764031826473, 0.04913764031826473, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07802635239449085, 0.07802635239449085, 0.07802635239449085, 0.023177002245910128, 0.023177002245910128, 0.023177002245910128, 0.053067496136392056, 0.053067496136392056, 0.053067496136392056, 0.004157136346795376, 0.004157136346795376, 0.004157136346795376, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012696030947335069, 0.012696030947335069, 0.012696030947335069, 0.03338140405776335, 0.03338140405776335, 0.03338140405776335, 0.04993245600464691, 0.04993245600464691, 0.04993245600464691, 0.04234409117295723, 0.04234409117295723, 0.04234409117295723, 0.2890018914132676, 0.2890018914132676, 0.2890018914132676, 0.3098282666719211, 0.3098282666719211, 0.3098282666719211, 0.2932763019458232, 0.2932763019458232, 0.2932763019458232, 0.08509159696531188, 0.08509159696531188, 0.08509159696531188, 0.0812936406913124, 0.0812936406913124, 0.0812936406913124, 0.06846199499933969, 0.06846199499933969, 0.06846199499933969, 0.13857594041061672, 0.13857594041061672, 0.13857594041061672, 0.1379340465625466, 0.1379340465625466, 0.1379340465625466, 0.13840266388354672, 0.13840266388354672, 0.13840266388354672, 0.2026539908693059, 0.2026539908693059, 0.2026539908693059, 0.22223599837866914, 0.22223599837866914, 0.22223599837866914, 0.2187508419384102, 0.2187508419384102, 0.2187508419384102, 0.15116002420909813, 0.15116002420909813, 0.15116002420909813, 0.15743655439750148, 0.15743655439750148, 0.15743655439750148, 0.1335769339123437, 0.1335769339123437, 0.1335769339123437, 0.165111726407005, 0.165111726407005, 0.165111726407005, 0.2167611804994184, 0.2167611804994184, 0.2167611804994184, 0.1695859667253038, 0.1695859667253038, 0.1695859667253038, 0.1609355975964719, 0.1609355975964719, 0.1609355975964719, 0.16312405468985125, 0.16312405468985125, 0.16312405468985125, 0.1745909080401703, 0.1745909080401703, 0.1745909080401703, 0.46659984743041316, 0.46659984743041316, 0.46659984743041316, 0.1667879085868006, 0.1667879085868006, 0.1667879085868006, 0.16570204317825032, 0.16570204317825032, 0.16570204317825032, 0.24135806838925022, 0.24135806838925022, 0.24135806838925022, 0.18362419547075703, 0.18362419547075703, 0.18362419547075703, 0.14934166022408701, 0.14934166022408701, 0.14934166022408701, 0.19482371165578227, 0.19482371165578227, 0.19482371165578227, 0.18567058701020822, 0.18567058701020822, 0.18567058701020822, 0.1764274537926951, 0.1764274537926951, 0.1764274537926951, 0.06579159565665937, 0.06579159565665937, 0.06579159565665937, 0.06667396885268351, 0.06667396885268351, 0.06667396885268351, 0.059296893622205804, 0.059296893622205804, 0.059296893622205804]}, "mutation_prompt": null}
{"id": "73804bc0-5db7-4145-b876-93bd2a8407a3", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm that balances exploration and exploitation for efficient search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.45814213462186604, 0.45814213462186604, 0.45814213462186604, 0.18829373914063052, 0.18829373914063052, 0.18829373914063052, 0.41415310960846696, 0.41415310960846696, 0.41415310960846696, 0.11142028019866268, 0.11142028019866268, 0.11142028019866268, 0.04654640311963576, 0.04654640311963576, 0.04654640311963576, 0.11326924195311405, 0.11326924195311405, 0.11326924195311405, 0.086363887498759, 0.086363887498759, 0.086363887498759, 0.08561068049885967, 0.08561068049885967, 0.08561068049885967, 0.0923248956053887, 0.0923248956053887, 0.0923248956053887, 0.07738565749348014, 0.07738565749348014, 0.07738565749348014, 0.07295765602417992, 0.07295765602417992, 0.07295765602417992, 0.06797982600147856, 0.06797982600147856, 0.06797982600147856, 0.967212623902598, 0.967212623902598, 0.967212623902598, 0.968385173063988, 0.968385173063988, 0.968385173063988, 0.9718627020350978, 0.9718627020350978, 0.9718627020350978, 0.18888334096698856, 0.18888334096698856, 0.18888334096698856, 0.2050867737371267, 0.2050867737371267, 0.2050867737371267, 0.21711299687717822, 0.21711299687717822, 0.21711299687717822, 0.2160827718961411, 0.2160827718961411, 0.2160827718961411, 0.19421984669677006, 0.19421984669677006, 0.19421984669677006, 0.2083046653136118, 0.2083046653136118, 0.2083046653136118, 0.13167344061684338, 0.13167344061684338, 0.13167344061684338, 0.14819505091134522, 0.14819505091134522, 0.14819505091134522, 0.11371308299090033, 0.11371308299090033, 0.11371308299090033, 0.1331852127654818, 0.1331852127654818, 0.1331852127654818, 0.10515907854772233, 0.10515907854772233, 0.10515907854772233, 0.12207815976087533, 0.12207815976087533, 0.12207815976087533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11346582055587973, 0.11346582055587973, 0.11346582055587973, 0.05798730420705489, 0.05798730420705489, 0.05798730420705489, 0.03922904579002029, 0.03922904579002029, 0.03922904579002029, 0.01276324666893236, 0.01276324666893236, 0.01276324666893236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043848948167385826, 0.043848948167385826, 0.043848948167385826, 0.0740341872007293, 0.0740341872007293, 0.0740341872007293, 0.04337141191762384, 0.04337141191762384, 0.04337141191762384, 0.34787227316417757, 0.34787227316417757, 0.34787227316417757, 0.3590241388046739, 0.3590241388046739, 0.3590241388046739, 0.37338553033168176, 0.37338553033168176, 0.37338553033168176, 0.08952346160790525, 0.08952346160790525, 0.08952346160790525, 0.08363596649063676, 0.08363596649063676, 0.08363596649063676, 0.10643159101958266, 0.10643159101958266, 0.10643159101958266, 0.13419498004879082, 0.13419498004879082, 0.13419498004879082, 0.16028286805789616, 0.16028286805789616, 0.16028286805789616, 0.15858548878670808, 0.15858548878670808, 0.15858548878670808, 0.26649543520445496, 0.26649543520445496, 0.26649543520445496, 0.1904136066223463, 0.1904136066223463, 0.1904136066223463, 0.24014391296293003, 0.24014391296293003, 0.24014391296293003, 0.1418181740528116, 0.1418181740528116, 0.1418181740528116, 0.15278601981544415, 0.15278601981544415, 0.15278601981544415, 0.14120561861053682, 0.14120561861053682, 0.14120561861053682, 0.20229647698598474, 0.20229647698598474, 0.20229647698598474, 0.1780531000604202, 0.1780531000604202, 0.1780531000604202, 0.17672386173922494, 0.17672386173922494, 0.17672386173922494, 0.17334306772693509, 0.17334306772693509, 0.17334306772693509, 0.1741470486464013, 0.1741470486464013, 0.1741470486464013, 0.1770538520835866, 0.1770538520835866, 0.1770538520835866, 0.5107328011876815, 0.5107328011876815, 0.5107328011876815, 0.19964117557805694, 0.19964117557805694, 0.19964117557805694, 0.16997204860281545, 0.16997204860281545, 0.16997204860281545, 0.15228985810854012, 0.15228985810854012, 0.15228985810854012, 0.20080496920877877, 0.20080496920877877, 0.20080496920877877, 0.15110845699803999, 0.15110845699803999, 0.15110845699803999, 0.18456743071652326, 0.18456743071652326, 0.18456743071652326, 0.186383207215431, 0.186383207215431, 0.186383207215431, 0.1910065686729564, 0.1910065686729564, 0.1910065686729564, 0.06671796314405853, 0.06671796314405853, 0.06671796314405853, 0.0756733454793026, 0.0756733454793026, 0.0756733454793026, 0.08391439028018643, 0.08391439028018643, 0.08391439028018643]}, "mutation_prompt": null}
{"id": "4992af43-4904-4fc7-8fad-ce41310347c0", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.2 * np.random.rand()\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid DE and PSO algorithm with adaptive parameters for improved balance between exploration and exploitation.", "configspace": "", "generation": 25, "fitness": 0.18504725970127223, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "4a67af58-419b-4a22-9eab-638ebb44e44c", "metadata": {"aucs": [0.48391819398292735, 0.48391819398292735, 0.48391819398292735, 0.43331191207310116, 0.43331191207310116, 0.43331191207310116, 0.4592145343407853, 0.4592145343407853, 0.4592145343407853, 0.07544561722340737, 0.07544561722340737, 0.07544561722340737, 0.02968487063818681, 0.02968487063818681, 0.02968487063818681, 0.09881885640746457, 0.09881885640746457, 0.09881885640746457, 0.0841650694368078, 0.0841650694368078, 0.0841650694368078, 0.06898579564732332, 0.06898579564732332, 0.06898579564732332, 0.08199901673650623, 0.08199901673650623, 0.08199901673650623, 0.06660926852826454, 0.06660926852826454, 0.06660926852826454, 0.06727332284439802, 0.06727332284439802, 0.06727332284439802, 0.06978902646344232, 0.06978902646344232, 0.06978902646344232, 0.9698037415299489, 0.9698037415299489, 0.9698037415299489, 0.9720620378815623, 0.9720620378815623, 0.9720620378815623, 0.9692062106635001, 0.9692062106635001, 0.9692062106635001, 0.2227104880045625, 0.2227104880045625, 0.2227104880045625, 0.21399884030176897, 0.21399884030176897, 0.21399884030176897, 0.22032554859463394, 0.22032554859463394, 0.22032554859463394, 0.21346443937217996, 0.21346443937217996, 0.21346443937217996, 0.15678335377847963, 0.15678335377847963, 0.15678335377847963, 0.2603322863765074, 0.2603322863765074, 0.2603322863765074, 0.09672065453272205, 0.09672065453272205, 0.09672065453272205, 0.1313935828448306, 0.1313935828448306, 0.1313935828448306, 0.11430551265594802, 0.11430551265594802, 0.11430551265594802, 0.03886899532859933, 0.03886899532859933, 0.03886899532859933, 0.07693561215010669, 0.07693561215010669, 0.07693561215010669, 0.07903305784864711, 0.07903305784864711, 0.07903305784864711, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019191521580902426, 0.0019191521580902426, 0.0019191521580902426, 0.0006027117687638084, 0.0006027117687638084, 0.0006027117687638084, 0.047420014786898945, 0.047420014786898945, 0.047420014786898945, 0.08513925213301465, 0.08513925213301465, 0.08513925213301465, 0.00909791057132936, 0.00909791057132936, 0.00909791057132936, 0.016604306422148274, 0.016604306422148274, 0.016604306422148274, 0.0028463455883509514, 0.0028463455883509514, 0.0028463455883509514, 0.015148642716878546, 0.015148642716878546, 0.015148642716878546, 0.09915951021449398, 0.09915951021449398, 0.09915951021449398, 0.07079278488283891, 0.07079278488283891, 0.07079278488283891, 0.04476712849518083, 0.04476712849518083, 0.04476712849518083, 0.33193690702880796, 0.33193690702880796, 0.33193690702880796, 0.33569519597461905, 0.33569519597461905, 0.33569519597461905, 0.31235634786038713, 0.31235634786038713, 0.31235634786038713, 0.08279756741566124, 0.08279756741566124, 0.08279756741566124, 0.08057918487905824, 0.08057918487905824, 0.08057918487905824, 0.08221506600821937, 0.08221506600821937, 0.08221506600821937, 0.1450352698587043, 0.1450352698587043, 0.1450352698587043, 0.1689446540466113, 0.1689446540466113, 0.1689446540466113, 0.15947234902541496, 0.15947234902541496, 0.15947234902541496, 0.2539196040400733, 0.2539196040400733, 0.2539196040400733, 0.20901812728052627, 0.20901812728052627, 0.20901812728052627, 0.26426244698461365, 0.26426244698461365, 0.26426244698461365, 0.13292927082742678, 0.13292927082742678, 0.13292927082742678, 0.15647840653196765, 0.15647840653196765, 0.15647840653196765, 0.16803114102790673, 0.16803114102790673, 0.16803114102790673, 0.17233153363652887, 0.17233153363652887, 0.17233153363652887, 0.18521604205038134, 0.18521604205038134, 0.18521604205038134, 0.17166118823559318, 0.17166118823559318, 0.17166118823559318, 0.17985303413447895, 0.17985303413447895, 0.17985303413447895, 0.16951836397677256, 0.16951836397677256, 0.16951836397677256, 0.18582429966761294, 0.18582429966761294, 0.18582429966761294, 0.5046925082603553, 0.5046925082603553, 0.5046925082603553, 0.18434471159812482, 0.18434471159812482, 0.18434471159812482, 0.19269327730107055, 0.19269327730107055, 0.19269327730107055, 0.22579606513876205, 0.22579606513876205, 0.22579606513876205, 0.19139774061013914, 0.19139774061013914, 0.19139774061013914, 0.14965577833258825, 0.14965577833258825, 0.14965577833258825, 0.19293158471280647, 0.19293158471280647, 0.19293158471280647, 0.19272156196959755, 0.19272156196959755, 0.19272156196959755, 0.17312915733513234, 0.17312915733513234, 0.17312915733513234, 0.07596877798211377, 0.07596877798211377, 0.07596877798211377, 0.07363915404611177, 0.07363915404611177, 0.07363915404611177, 0.06959877478882959, 0.06959877478882959, 0.06959877478882959]}, "mutation_prompt": null}
{"id": "fa494170-3ed4-49e8-882f-cc81aad262df", "solution": "import numpy as np\n\nclass DEPSOPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.3 * np.random.rand()  # Increased variability in F\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] += (self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                  + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                if np.random.rand() < 0.5:  # Selective local best update\n                    velocities[i] *= self.w\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSOPlus", "description": "DEPSO+ with adaptive mutation and selective local best updates for enhanced exploration and convergence.", "configspace": "", "generation": 26, "fitness": 0.15856061379700379, "feedback": "The algorithm DEPSOPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "4992af43-4904-4fc7-8fad-ce41310347c0", "metadata": {"aucs": [0.27421500544164124, 0.27421500544164124, 0.27421500544164124, 0.3152464467564994, 0.3152464467564994, 0.3152464467564994, 0.277146881055261, 0.277146881055261, 0.277146881055261, 0.025017317314978915, 0.025017317314978915, 0.025017317314978915, 0.011952760307349819, 0.011952760307349819, 0.011952760307349819, 0.005776417589806848, 0.005776417589806848, 0.005776417589806848, 0.07575047705190519, 0.07575047705190519, 0.07575047705190519, 0.056008013753650276, 0.056008013753650276, 0.056008013753650276, 0.07911687766180442, 0.07911687766180442, 0.07911687766180442, 0.05485763248547815, 0.05485763248547815, 0.05485763248547815, 0.05457067296730633, 0.05457067296730633, 0.05457067296730633, 0.06011021779550629, 0.06011021779550629, 0.06011021779550629, 0.9698525082660168, 0.9698525082660168, 0.9698525082660168, 0.972744043450413, 0.972744043450413, 0.972744043450413, 0.9763018099533805, 0.9763018099533805, 0.9763018099533805, 0.1764952480745584, 0.1764952480745584, 0.1764952480745584, 0.1453630924229441, 0.1453630924229441, 0.1453630924229441, 0.1608607897853941, 0.1608607897853941, 0.1608607897853941, 0.16958835883718093, 0.16958835883718093, 0.16958835883718093, 0.18452764472650585, 0.18452764472650585, 0.18452764472650585, 0.1563343646433497, 0.1563343646433497, 0.1563343646433497, 0.068764065172353, 0.068764065172353, 0.068764065172353, 0.07739425052770621, 0.07739425052770621, 0.07739425052770621, 0.07980928480316474, 0.07980928480316474, 0.07980928480316474, 0.04994717002061155, 0.04994717002061155, 0.04994717002061155, 0.06169010975607525, 0.06169010975607525, 0.06169010975607525, 0.024773160723140064, 0.024773160723140064, 0.024773160723140064, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06836530206551228, 0.06836530206551228, 0.06836530206551228, 0.00248604973849309, 0.00248604973849309, 0.00248604973849309, 0.02667196116303816, 0.02667196116303816, 0.02667196116303816, 0.00022498025381789688, 0.00022498025381789688, 0.00022498025381789688, 0.00026416400091233694, 0.00026416400091233694, 0.00026416400091233694, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024072951463357972, 0.024072951463357972, 0.024072951463357972, 0.0349436300228928, 0.0349436300228928, 0.0349436300228928, 0.05583583777093171, 0.05583583777093171, 0.05583583777093171, 0.2870178063033081, 0.2870178063033081, 0.2870178063033081, 0.26656950801560064, 0.26656950801560064, 0.26656950801560064, 0.26967116275255976, 0.26967116275255976, 0.26967116275255976, 0.0917265289655741, 0.0917265289655741, 0.0917265289655741, 0.08420002584322661, 0.08420002584322661, 0.08420002584322661, 0.062107594046956205, 0.062107594046956205, 0.062107594046956205, 0.15781524001638902, 0.15781524001638902, 0.15781524001638902, 0.15807092167651748, 0.15807092167651748, 0.15807092167651748, 0.17837623093914212, 0.17837623093914212, 0.17837623093914212, 0.20320910179597207, 0.20320910179597207, 0.20320910179597207, 0.20591917163925044, 0.20591917163925044, 0.20591917163925044, 0.23751197461464313, 0.23751197461464313, 0.23751197461464313, 0.15078830950020294, 0.15078830950020294, 0.15078830950020294, 0.14352413718637058, 0.14352413718637058, 0.14352413718637058, 0.11425985726386156, 0.11425985726386156, 0.11425985726386156, 0.16619241136257334, 0.16619241136257334, 0.16619241136257334, 0.17211711341964897, 0.17211711341964897, 0.17211711341964897, 0.18062319819535455, 0.18062319819535455, 0.18062319819535455, 0.162187824970647, 0.162187824970647, 0.162187824970647, 0.17044674423316464, 0.17044674423316464, 0.17044674423316464, 0.1618970119783315, 0.1618970119783315, 0.1618970119783315, 0.3575211198977557, 0.3575211198977557, 0.3575211198977557, 0.16516242712546303, 0.16516242712546303, 0.16516242712546303, 0.1815229099660528, 0.1815229099660528, 0.1815229099660528, 0.17099592759250082, 0.17099592759250082, 0.17099592759250082, 0.23478633310161412, 0.23478633310161412, 0.23478633310161412, 0.14277569998218065, 0.14277569998218065, 0.14277569998218065, 0.1741289255398617, 0.1741289255398617, 0.1741289255398617, 0.1980596250414315, 0.1980596250414315, 0.1980596250414315, 0.18291751537430323, 0.18291751537430323, 0.18291751537430323, 0.06952567370650198, 0.06952567370650198, 0.06952567370650198, 0.06721538647462288, 0.06721538647462288, 0.06721538647462288, 0.07004127703975116, 0.07004127703975116, 0.07004127703975116]}, "mutation_prompt": null}
{"id": "95702885-6b38-4e50-92be-b51a4b7cfae4", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.2 * np.random.rand()\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid DE and PSO algorithm with adaptive parameters for improved balance between exploration and exploitation.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4992af43-4904-4fc7-8fad-ce41310347c0", "metadata": {"aucs": [0.48391819398292735, 0.48391819398292735, 0.48391819398292735, 0.43331191207310116, 0.43331191207310116, 0.43331191207310116, 0.4592145343407853, 0.4592145343407853, 0.4592145343407853, 0.07544561722340737, 0.07544561722340737, 0.07544561722340737, 0.02968487063818681, 0.02968487063818681, 0.02968487063818681, 0.09881885640746457, 0.09881885640746457, 0.09881885640746457, 0.0841650694368078, 0.0841650694368078, 0.0841650694368078, 0.06898579564732332, 0.06898579564732332, 0.06898579564732332, 0.08199901673650623, 0.08199901673650623, 0.08199901673650623, 0.06660926852826454, 0.06660926852826454, 0.06660926852826454, 0.06727332284439802, 0.06727332284439802, 0.06727332284439802, 0.06978902646344232, 0.06978902646344232, 0.06978902646344232, 0.9698037415299489, 0.9698037415299489, 0.9698037415299489, 0.9720620378815623, 0.9720620378815623, 0.9720620378815623, 0.9692062106635001, 0.9692062106635001, 0.9692062106635001, 0.2227104880045625, 0.2227104880045625, 0.2227104880045625, 0.21399884030176897, 0.21399884030176897, 0.21399884030176897, 0.22032554859463394, 0.22032554859463394, 0.22032554859463394, 0.21346443937217996, 0.21346443937217996, 0.21346443937217996, 0.15678335377847963, 0.15678335377847963, 0.15678335377847963, 0.2603322863765074, 0.2603322863765074, 0.2603322863765074, 0.09672065453272205, 0.09672065453272205, 0.09672065453272205, 0.1313935828448306, 0.1313935828448306, 0.1313935828448306, 0.11430551265594802, 0.11430551265594802, 0.11430551265594802, 0.03886899532859933, 0.03886899532859933, 0.03886899532859933, 0.07693561215010669, 0.07693561215010669, 0.07693561215010669, 0.07903305784864711, 0.07903305784864711, 0.07903305784864711, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019191521580902426, 0.0019191521580902426, 0.0019191521580902426, 0.0006027117687638084, 0.0006027117687638084, 0.0006027117687638084, 0.047420014786898945, 0.047420014786898945, 0.047420014786898945, 0.08513925213301465, 0.08513925213301465, 0.08513925213301465, 0.00909791057132936, 0.00909791057132936, 0.00909791057132936, 0.016604306422148274, 0.016604306422148274, 0.016604306422148274, 0.0028463455883509514, 0.0028463455883509514, 0.0028463455883509514, 0.015148642716878546, 0.015148642716878546, 0.015148642716878546, 0.09915951021449398, 0.09915951021449398, 0.09915951021449398, 0.07079278488283891, 0.07079278488283891, 0.07079278488283891, 0.04476712849518083, 0.04476712849518083, 0.04476712849518083, 0.33193690702880796, 0.33193690702880796, 0.33193690702880796, 0.33569519597461905, 0.33569519597461905, 0.33569519597461905, 0.31235634786038713, 0.31235634786038713, 0.31235634786038713, 0.08279756741566124, 0.08279756741566124, 0.08279756741566124, 0.08057918487905824, 0.08057918487905824, 0.08057918487905824, 0.08221506600821937, 0.08221506600821937, 0.08221506600821937, 0.1450352698587043, 0.1450352698587043, 0.1450352698587043, 0.1689446540466113, 0.1689446540466113, 0.1689446540466113, 0.15947234902541496, 0.15947234902541496, 0.15947234902541496, 0.2539196040400733, 0.2539196040400733, 0.2539196040400733, 0.20901812728052627, 0.20901812728052627, 0.20901812728052627, 0.26426244698461365, 0.26426244698461365, 0.26426244698461365, 0.13292927082742678, 0.13292927082742678, 0.13292927082742678, 0.15647840653196765, 0.15647840653196765, 0.15647840653196765, 0.16803114102790673, 0.16803114102790673, 0.16803114102790673, 0.17233153363652887, 0.17233153363652887, 0.17233153363652887, 0.18521604205038134, 0.18521604205038134, 0.18521604205038134, 0.17166118823559318, 0.17166118823559318, 0.17166118823559318, 0.17985303413447895, 0.17985303413447895, 0.17985303413447895, 0.16951836397677256, 0.16951836397677256, 0.16951836397677256, 0.18582429966761294, 0.18582429966761294, 0.18582429966761294, 0.5046925082603553, 0.5046925082603553, 0.5046925082603553, 0.18434471159812482, 0.18434471159812482, 0.18434471159812482, 0.19269327730107055, 0.19269327730107055, 0.19269327730107055, 0.22579606513876205, 0.22579606513876205, 0.22579606513876205, 0.19139774061013914, 0.19139774061013914, 0.19139774061013914, 0.14965577833258825, 0.14965577833258825, 0.14965577833258825, 0.19293158471280647, 0.19293158471280647, 0.19293158471280647, 0.19272156196959755, 0.19272156196959755, 0.19272156196959755, 0.17312915733513234, 0.17312915733513234, 0.17312915733513234, 0.07596877798211377, 0.07596877798211377, 0.07596877798211377, 0.07363915404611177, 0.07363915404611177, 0.07363915404611177, 0.06959877478882959, 0.06959877478882959, 0.06959877478882959]}, "mutation_prompt": null}
{"id": "d3ad05b5-44ce-466e-9645-2a060fe0b7d0", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.2 * np.random.rand()\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "A hybrid DE and PSO algorithm with adaptive parameters for improved balance between exploration and exploitation.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4992af43-4904-4fc7-8fad-ce41310347c0", "metadata": {"aucs": [0.48391819398292735, 0.48391819398292735, 0.48391819398292735, 0.43331191207310116, 0.43331191207310116, 0.43331191207310116, 0.4592145343407853, 0.4592145343407853, 0.4592145343407853, 0.07544561722340737, 0.07544561722340737, 0.07544561722340737, 0.02968487063818681, 0.02968487063818681, 0.02968487063818681, 0.09881885640746457, 0.09881885640746457, 0.09881885640746457, 0.0841650694368078, 0.0841650694368078, 0.0841650694368078, 0.06898579564732332, 0.06898579564732332, 0.06898579564732332, 0.08199901673650623, 0.08199901673650623, 0.08199901673650623, 0.06660926852826454, 0.06660926852826454, 0.06660926852826454, 0.06727332284439802, 0.06727332284439802, 0.06727332284439802, 0.06978902646344232, 0.06978902646344232, 0.06978902646344232, 0.9698037415299489, 0.9698037415299489, 0.9698037415299489, 0.9720620378815623, 0.9720620378815623, 0.9720620378815623, 0.9692062106635001, 0.9692062106635001, 0.9692062106635001, 0.2227104880045625, 0.2227104880045625, 0.2227104880045625, 0.21399884030176897, 0.21399884030176897, 0.21399884030176897, 0.22032554859463394, 0.22032554859463394, 0.22032554859463394, 0.21346443937217996, 0.21346443937217996, 0.21346443937217996, 0.15678335377847963, 0.15678335377847963, 0.15678335377847963, 0.2603322863765074, 0.2603322863765074, 0.2603322863765074, 0.09672065453272205, 0.09672065453272205, 0.09672065453272205, 0.1313935828448306, 0.1313935828448306, 0.1313935828448306, 0.11430551265594802, 0.11430551265594802, 0.11430551265594802, 0.03886899532859933, 0.03886899532859933, 0.03886899532859933, 0.07693561215010669, 0.07693561215010669, 0.07693561215010669, 0.07903305784864711, 0.07903305784864711, 0.07903305784864711, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019191521580902426, 0.0019191521580902426, 0.0019191521580902426, 0.0006027117687638084, 0.0006027117687638084, 0.0006027117687638084, 0.047420014786898945, 0.047420014786898945, 0.047420014786898945, 0.08513925213301465, 0.08513925213301465, 0.08513925213301465, 0.00909791057132936, 0.00909791057132936, 0.00909791057132936, 0.016604306422148274, 0.016604306422148274, 0.016604306422148274, 0.0028463455883509514, 0.0028463455883509514, 0.0028463455883509514, 0.015148642716878546, 0.015148642716878546, 0.015148642716878546, 0.09915951021449398, 0.09915951021449398, 0.09915951021449398, 0.07079278488283891, 0.07079278488283891, 0.07079278488283891, 0.04476712849518083, 0.04476712849518083, 0.04476712849518083, 0.33193690702880796, 0.33193690702880796, 0.33193690702880796, 0.33569519597461905, 0.33569519597461905, 0.33569519597461905, 0.31235634786038713, 0.31235634786038713, 0.31235634786038713, 0.08279756741566124, 0.08279756741566124, 0.08279756741566124, 0.08057918487905824, 0.08057918487905824, 0.08057918487905824, 0.08221506600821937, 0.08221506600821937, 0.08221506600821937, 0.1450352698587043, 0.1450352698587043, 0.1450352698587043, 0.1689446540466113, 0.1689446540466113, 0.1689446540466113, 0.15947234902541496, 0.15947234902541496, 0.15947234902541496, 0.2539196040400733, 0.2539196040400733, 0.2539196040400733, 0.20901812728052627, 0.20901812728052627, 0.20901812728052627, 0.26426244698461365, 0.26426244698461365, 0.26426244698461365, 0.13292927082742678, 0.13292927082742678, 0.13292927082742678, 0.15647840653196765, 0.15647840653196765, 0.15647840653196765, 0.16803114102790673, 0.16803114102790673, 0.16803114102790673, 0.17233153363652887, 0.17233153363652887, 0.17233153363652887, 0.18521604205038134, 0.18521604205038134, 0.18521604205038134, 0.17166118823559318, 0.17166118823559318, 0.17166118823559318, 0.17985303413447895, 0.17985303413447895, 0.17985303413447895, 0.16951836397677256, 0.16951836397677256, 0.16951836397677256, 0.18582429966761294, 0.18582429966761294, 0.18582429966761294, 0.5046925082603553, 0.5046925082603553, 0.5046925082603553, 0.18434471159812482, 0.18434471159812482, 0.18434471159812482, 0.19269327730107055, 0.19269327730107055, 0.19269327730107055, 0.22579606513876205, 0.22579606513876205, 0.22579606513876205, 0.19139774061013914, 0.19139774061013914, 0.19139774061013914, 0.14965577833258825, 0.14965577833258825, 0.14965577833258825, 0.19293158471280647, 0.19293158471280647, 0.19293158471280647, 0.19272156196959755, 0.19272156196959755, 0.19272156196959755, 0.17312915733513234, 0.17312915733513234, 0.17312915733513234, 0.07596877798211377, 0.07596877798211377, 0.07596877798211377, 0.07363915404611177, 0.07363915404611177, 0.07363915404611177, 0.06959877478882959, 0.06959877478882959, 0.06959877478882959]}, "mutation_prompt": null}
{"id": "0c7ab9fe-a571-43ae-868d-9573aa2d9e4e", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhanced hybrid DE and PSO with self-adaptive mutation and crossover rates for improved convergence.", "configspace": "", "generation": 29, "fitness": 0.18707864748226044, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "4992af43-4904-4fc7-8fad-ce41310347c0", "metadata": {"aucs": [0.4103249722892779, 0.4103249722892779, 0.4103249722892779, 0.43008311468859495, 0.43008311468859495, 0.43008311468859495, 0.41078016656011607, 0.41078016656011607, 0.41078016656011607, 0.10644500169628957, 0.10644500169628957, 0.10644500169628957, 0.09648428150598465, 0.09648428150598465, 0.09648428150598465, 0.05927592318694297, 0.05927592318694297, 0.05927592318694297, 0.0961114659578014, 0.0961114659578014, 0.0961114659578014, 0.07458231651103286, 0.07458231651103286, 0.07458231651103286, 0.083573023507025, 0.083573023507025, 0.083573023507025, 0.06459294808902682, 0.06459294808902682, 0.06459294808902682, 0.05598867642649186, 0.05598867642649186, 0.05598867642649186, 0.06621856478205268, 0.06621856478205268, 0.06621856478205268, 0.9712922589631109, 0.9712922589631109, 0.9712922589631109, 0.9717322919352486, 0.9717322919352486, 0.9717322919352486, 0.9712462984596584, 0.9712462984596584, 0.9712462984596584, 0.22154228742352833, 0.22154228742352833, 0.22154228742352833, 0.20579218555536205, 0.20579218555536205, 0.20579218555536205, 0.2184007983455224, 0.2184007983455224, 0.2184007983455224, 0.22515470239715374, 0.22515470239715374, 0.22515470239715374, 0.34796555715564625, 0.34796555715564625, 0.34796555715564625, 0.2115433787026919, 0.2115433787026919, 0.2115433787026919, 0.10310102389277476, 0.10310102389277476, 0.10310102389277476, 0.12374435351510837, 0.12374435351510837, 0.12374435351510837, 0.10002119055250935, 0.10002119055250935, 0.10002119055250935, 0.015292634093887703, 0.015292634093887703, 0.015292634093887703, 0.11814858744412982, 0.11814858744412982, 0.11814858744412982, 0.09380813409105482, 0.09380813409105482, 0.09380813409105482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010424490657168217, 0.00010424490657168217, 0.00010424490657168217, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07591312130630212, 0.07591312130630212, 0.07591312130630212, 0.014877179190464607, 0.014877179190464607, 0.014877179190464607, 0.03380187917893074, 0.03380187917893074, 0.03380187917893074, 0.010741686514048499, 0.010741686514048499, 0.010741686514048499, 0.034591612529009996, 0.034591612529009996, 0.034591612529009996, 0.010183025216879638, 0.010183025216879638, 0.010183025216879638, 0.04408643464398154, 0.04408643464398154, 0.04408643464398154, 0.06379632356360598, 0.06379632356360598, 0.06379632356360598, 0.04201932918388285, 0.04201932918388285, 0.04201932918388285, 0.38686327148567257, 0.38686327148567257, 0.38686327148567257, 0.3334052825629633, 0.3334052825629633, 0.3334052825629633, 0.3076104901557082, 0.3076104901557082, 0.3076104901557082, 0.08101427932536875, 0.08101427932536875, 0.08101427932536875, 0.07870027202177776, 0.07870027202177776, 0.07870027202177776, 0.0757327583928924, 0.0757327583928924, 0.0757327583928924, 0.14793740681558087, 0.14793740681558087, 0.14793740681558087, 0.13072071854169098, 0.13072071854169098, 0.13072071854169098, 0.13775308981522516, 0.13775308981522516, 0.13775308981522516, 0.20729576968421348, 0.20729576968421348, 0.20729576968421348, 0.23454677624616316, 0.23454677624616316, 0.23454677624616316, 0.2520860713662717, 0.2520860713662717, 0.2520860713662717, 0.15594760699597832, 0.15594760699597832, 0.15594760699597832, 0.13817811249145984, 0.13817811249145984, 0.13817811249145984, 0.1202918601689904, 0.1202918601689904, 0.1202918601689904, 0.17368236324339303, 0.17368236324339303, 0.17368236324339303, 0.18427802022530093, 0.18427802022530093, 0.18427802022530093, 0.1826349633091111, 0.1826349633091111, 0.1826349633091111, 0.16326796703532598, 0.16326796703532598, 0.16326796703532598, 0.17069765809358417, 0.17069765809358417, 0.17069765809358417, 0.17605900542587083, 0.17605900542587083, 0.17605900542587083, 0.4722613141970289, 0.4722613141970289, 0.4722613141970289, 0.17526326041570806, 0.17526326041570806, 0.17526326041570806, 0.3838539683166823, 0.3838539683166823, 0.3838539683166823, 0.2262023516691979, 0.2262023516691979, 0.2262023516691979, 0.1918441405639304, 0.1918441405639304, 0.1918441405639304, 0.19548802682760535, 0.19548802682760535, 0.19548802682760535, 0.1867366107277405, 0.1867366107277405, 0.1867366107277405, 0.1960677289099776, 0.1960677289099776, 0.1960677289099776, 0.19872823355961822, 0.19872823355961822, 0.19872823355961822, 0.07704981236944097, 0.07704981236944097, 0.07704981236944097, 0.07515003839493206, 0.07515003839493206, 0.07515003839493206, 0.06875241540664379, 0.06875241540664379, 0.06875241540664379]}, "mutation_prompt": null}
{"id": "fa9028fa-becd-4b35-a6f4-4f25bbcad554", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhanced hybrid DE and PSO with self-adaptive mutation and crossover rates for improved convergence.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0c7ab9fe-a571-43ae-868d-9573aa2d9e4e", "metadata": {"aucs": [0.4103249722892779, 0.4103249722892779, 0.4103249722892779, 0.43008311468859495, 0.43008311468859495, 0.43008311468859495, 0.41078016656011607, 0.41078016656011607, 0.41078016656011607, 0.10644500169628957, 0.10644500169628957, 0.10644500169628957, 0.09648428150598465, 0.09648428150598465, 0.09648428150598465, 0.05927592318694297, 0.05927592318694297, 0.05927592318694297, 0.0961114659578014, 0.0961114659578014, 0.0961114659578014, 0.07458231651103286, 0.07458231651103286, 0.07458231651103286, 0.083573023507025, 0.083573023507025, 0.083573023507025, 0.06459294808902682, 0.06459294808902682, 0.06459294808902682, 0.05598867642649186, 0.05598867642649186, 0.05598867642649186, 0.06621856478205268, 0.06621856478205268, 0.06621856478205268, 0.9712922589631109, 0.9712922589631109, 0.9712922589631109, 0.9717322919352486, 0.9717322919352486, 0.9717322919352486, 0.9712462984596584, 0.9712462984596584, 0.9712462984596584, 0.22154228742352833, 0.22154228742352833, 0.22154228742352833, 0.20579218555536205, 0.20579218555536205, 0.20579218555536205, 0.2184007983455224, 0.2184007983455224, 0.2184007983455224, 0.22515470239715374, 0.22515470239715374, 0.22515470239715374, 0.34796555715564625, 0.34796555715564625, 0.34796555715564625, 0.2115433787026919, 0.2115433787026919, 0.2115433787026919, 0.10310102389277476, 0.10310102389277476, 0.10310102389277476, 0.12374435351510837, 0.12374435351510837, 0.12374435351510837, 0.10002119055250935, 0.10002119055250935, 0.10002119055250935, 0.015292634093887703, 0.015292634093887703, 0.015292634093887703, 0.11814858744412982, 0.11814858744412982, 0.11814858744412982, 0.09380813409105482, 0.09380813409105482, 0.09380813409105482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010424490657168217, 0.00010424490657168217, 0.00010424490657168217, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07591312130630212, 0.07591312130630212, 0.07591312130630212, 0.014877179190464607, 0.014877179190464607, 0.014877179190464607, 0.03380187917893074, 0.03380187917893074, 0.03380187917893074, 0.010741686514048499, 0.010741686514048499, 0.010741686514048499, 0.034591612529009996, 0.034591612529009996, 0.034591612529009996, 0.010183025216879638, 0.010183025216879638, 0.010183025216879638, 0.04408643464398154, 0.04408643464398154, 0.04408643464398154, 0.06379632356360598, 0.06379632356360598, 0.06379632356360598, 0.04201932918388285, 0.04201932918388285, 0.04201932918388285, 0.38686327148567257, 0.38686327148567257, 0.38686327148567257, 0.3334052825629633, 0.3334052825629633, 0.3334052825629633, 0.3076104901557082, 0.3076104901557082, 0.3076104901557082, 0.08101427932536875, 0.08101427932536875, 0.08101427932536875, 0.07870027202177776, 0.07870027202177776, 0.07870027202177776, 0.0757327583928924, 0.0757327583928924, 0.0757327583928924, 0.14793740681558087, 0.14793740681558087, 0.14793740681558087, 0.13072071854169098, 0.13072071854169098, 0.13072071854169098, 0.13775308981522516, 0.13775308981522516, 0.13775308981522516, 0.20729576968421348, 0.20729576968421348, 0.20729576968421348, 0.23454677624616316, 0.23454677624616316, 0.23454677624616316, 0.2520860713662717, 0.2520860713662717, 0.2520860713662717, 0.15594760699597832, 0.15594760699597832, 0.15594760699597832, 0.13817811249145984, 0.13817811249145984, 0.13817811249145984, 0.1202918601689904, 0.1202918601689904, 0.1202918601689904, 0.17368236324339303, 0.17368236324339303, 0.17368236324339303, 0.18427802022530093, 0.18427802022530093, 0.18427802022530093, 0.1826349633091111, 0.1826349633091111, 0.1826349633091111, 0.16326796703532598, 0.16326796703532598, 0.16326796703532598, 0.17069765809358417, 0.17069765809358417, 0.17069765809358417, 0.17605900542587083, 0.17605900542587083, 0.17605900542587083, 0.4722613141970289, 0.4722613141970289, 0.4722613141970289, 0.17526326041570806, 0.17526326041570806, 0.17526326041570806, 0.3838539683166823, 0.3838539683166823, 0.3838539683166823, 0.2262023516691979, 0.2262023516691979, 0.2262023516691979, 0.1918441405639304, 0.1918441405639304, 0.1918441405639304, 0.19548802682760535, 0.19548802682760535, 0.19548802682760535, 0.1867366107277405, 0.1867366107277405, 0.1867366107277405, 0.1960677289099776, 0.1960677289099776, 0.1960677289099776, 0.19872823355961822, 0.19872823355961822, 0.19872823355961822, 0.07704981236944097, 0.07704981236944097, 0.07704981236944097, 0.07515003839493206, 0.07515003839493206, 0.07515003839493206, 0.06875241540664379, 0.06875241540664379, 0.06875241540664379]}, "mutation_prompt": null}
{"id": "997cce88-0840-4c37-92ff-c2767fc563c4", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhanced hybrid DE and PSO with self-adaptive mutation and crossover rates for improved convergence.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0c7ab9fe-a571-43ae-868d-9573aa2d9e4e", "metadata": {"aucs": [0.4103249722892779, 0.4103249722892779, 0.4103249722892779, 0.43008311468859495, 0.43008311468859495, 0.43008311468859495, 0.41078016656011607, 0.41078016656011607, 0.41078016656011607, 0.10644500169628957, 0.10644500169628957, 0.10644500169628957, 0.09648428150598465, 0.09648428150598465, 0.09648428150598465, 0.05927592318694297, 0.05927592318694297, 0.05927592318694297, 0.0961114659578014, 0.0961114659578014, 0.0961114659578014, 0.07458231651103286, 0.07458231651103286, 0.07458231651103286, 0.083573023507025, 0.083573023507025, 0.083573023507025, 0.06459294808902682, 0.06459294808902682, 0.06459294808902682, 0.05598867642649186, 0.05598867642649186, 0.05598867642649186, 0.06621856478205268, 0.06621856478205268, 0.06621856478205268, 0.9712922589631109, 0.9712922589631109, 0.9712922589631109, 0.9717322919352486, 0.9717322919352486, 0.9717322919352486, 0.9712462984596584, 0.9712462984596584, 0.9712462984596584, 0.22154228742352833, 0.22154228742352833, 0.22154228742352833, 0.20579218555536205, 0.20579218555536205, 0.20579218555536205, 0.2184007983455224, 0.2184007983455224, 0.2184007983455224, 0.22515470239715374, 0.22515470239715374, 0.22515470239715374, 0.34796555715564625, 0.34796555715564625, 0.34796555715564625, 0.2115433787026919, 0.2115433787026919, 0.2115433787026919, 0.10310102389277476, 0.10310102389277476, 0.10310102389277476, 0.12374435351510837, 0.12374435351510837, 0.12374435351510837, 0.10002119055250935, 0.10002119055250935, 0.10002119055250935, 0.015292634093887703, 0.015292634093887703, 0.015292634093887703, 0.11814858744412982, 0.11814858744412982, 0.11814858744412982, 0.09380813409105482, 0.09380813409105482, 0.09380813409105482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010424490657168217, 0.00010424490657168217, 0.00010424490657168217, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07591312130630212, 0.07591312130630212, 0.07591312130630212, 0.014877179190464607, 0.014877179190464607, 0.014877179190464607, 0.03380187917893074, 0.03380187917893074, 0.03380187917893074, 0.010741686514048499, 0.010741686514048499, 0.010741686514048499, 0.034591612529009996, 0.034591612529009996, 0.034591612529009996, 0.010183025216879638, 0.010183025216879638, 0.010183025216879638, 0.04408643464398154, 0.04408643464398154, 0.04408643464398154, 0.06379632356360598, 0.06379632356360598, 0.06379632356360598, 0.04201932918388285, 0.04201932918388285, 0.04201932918388285, 0.38686327148567257, 0.38686327148567257, 0.38686327148567257, 0.3334052825629633, 0.3334052825629633, 0.3334052825629633, 0.3076104901557082, 0.3076104901557082, 0.3076104901557082, 0.08101427932536875, 0.08101427932536875, 0.08101427932536875, 0.07870027202177776, 0.07870027202177776, 0.07870027202177776, 0.0757327583928924, 0.0757327583928924, 0.0757327583928924, 0.14793740681558087, 0.14793740681558087, 0.14793740681558087, 0.13072071854169098, 0.13072071854169098, 0.13072071854169098, 0.13775308981522516, 0.13775308981522516, 0.13775308981522516, 0.20729576968421348, 0.20729576968421348, 0.20729576968421348, 0.23454677624616316, 0.23454677624616316, 0.23454677624616316, 0.2520860713662717, 0.2520860713662717, 0.2520860713662717, 0.15594760699597832, 0.15594760699597832, 0.15594760699597832, 0.13817811249145984, 0.13817811249145984, 0.13817811249145984, 0.1202918601689904, 0.1202918601689904, 0.1202918601689904, 0.17368236324339303, 0.17368236324339303, 0.17368236324339303, 0.18427802022530093, 0.18427802022530093, 0.18427802022530093, 0.1826349633091111, 0.1826349633091111, 0.1826349633091111, 0.16326796703532598, 0.16326796703532598, 0.16326796703532598, 0.17069765809358417, 0.17069765809358417, 0.17069765809358417, 0.17605900542587083, 0.17605900542587083, 0.17605900542587083, 0.4722613141970289, 0.4722613141970289, 0.4722613141970289, 0.17526326041570806, 0.17526326041570806, 0.17526326041570806, 0.3838539683166823, 0.3838539683166823, 0.3838539683166823, 0.2262023516691979, 0.2262023516691979, 0.2262023516691979, 0.1918441405639304, 0.1918441405639304, 0.1918441405639304, 0.19548802682760535, 0.19548802682760535, 0.19548802682760535, 0.1867366107277405, 0.1867366107277405, 0.1867366107277405, 0.1960677289099776, 0.1960677289099776, 0.1960677289099776, 0.19872823355961822, 0.19872823355961822, 0.19872823355961822, 0.07704981236944097, 0.07704981236944097, 0.07704981236944097, 0.07515003839493206, 0.07515003839493206, 0.07515003839493206, 0.06875241540664379, 0.06875241540664379, 0.06875241540664379]}, "mutation_prompt": null}
{"id": "b28bf0c7-89f9-4cbe-84ca-7ad2fbb3b4ff", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhanced hybrid DE and PSO with self-adaptive mutation and crossover rates for improved convergence.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0c7ab9fe-a571-43ae-868d-9573aa2d9e4e", "metadata": {"aucs": [0.4103249722892779, 0.4103249722892779, 0.4103249722892779, 0.43008311468859495, 0.43008311468859495, 0.43008311468859495, 0.41078016656011607, 0.41078016656011607, 0.41078016656011607, 0.10644500169628957, 0.10644500169628957, 0.10644500169628957, 0.09648428150598465, 0.09648428150598465, 0.09648428150598465, 0.05927592318694297, 0.05927592318694297, 0.05927592318694297, 0.0961114659578014, 0.0961114659578014, 0.0961114659578014, 0.07458231651103286, 0.07458231651103286, 0.07458231651103286, 0.083573023507025, 0.083573023507025, 0.083573023507025, 0.06459294808902682, 0.06459294808902682, 0.06459294808902682, 0.05598867642649186, 0.05598867642649186, 0.05598867642649186, 0.06621856478205268, 0.06621856478205268, 0.06621856478205268, 0.9712922589631109, 0.9712922589631109, 0.9712922589631109, 0.9717322919352486, 0.9717322919352486, 0.9717322919352486, 0.9712462984596584, 0.9712462984596584, 0.9712462984596584, 0.22154228742352833, 0.22154228742352833, 0.22154228742352833, 0.20579218555536205, 0.20579218555536205, 0.20579218555536205, 0.2184007983455224, 0.2184007983455224, 0.2184007983455224, 0.22515470239715374, 0.22515470239715374, 0.22515470239715374, 0.34796555715564625, 0.34796555715564625, 0.34796555715564625, 0.2115433787026919, 0.2115433787026919, 0.2115433787026919, 0.10310102389277476, 0.10310102389277476, 0.10310102389277476, 0.12374435351510837, 0.12374435351510837, 0.12374435351510837, 0.10002119055250935, 0.10002119055250935, 0.10002119055250935, 0.015292634093887703, 0.015292634093887703, 0.015292634093887703, 0.11814858744412982, 0.11814858744412982, 0.11814858744412982, 0.09380813409105482, 0.09380813409105482, 0.09380813409105482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010424490657168217, 0.00010424490657168217, 0.00010424490657168217, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07591312130630212, 0.07591312130630212, 0.07591312130630212, 0.014877179190464607, 0.014877179190464607, 0.014877179190464607, 0.03380187917893074, 0.03380187917893074, 0.03380187917893074, 0.010741686514048499, 0.010741686514048499, 0.010741686514048499, 0.034591612529009996, 0.034591612529009996, 0.034591612529009996, 0.010183025216879638, 0.010183025216879638, 0.010183025216879638, 0.04408643464398154, 0.04408643464398154, 0.04408643464398154, 0.06379632356360598, 0.06379632356360598, 0.06379632356360598, 0.04201932918388285, 0.04201932918388285, 0.04201932918388285, 0.38686327148567257, 0.38686327148567257, 0.38686327148567257, 0.3334052825629633, 0.3334052825629633, 0.3334052825629633, 0.3076104901557082, 0.3076104901557082, 0.3076104901557082, 0.08101427932536875, 0.08101427932536875, 0.08101427932536875, 0.07870027202177776, 0.07870027202177776, 0.07870027202177776, 0.0757327583928924, 0.0757327583928924, 0.0757327583928924, 0.14793740681558087, 0.14793740681558087, 0.14793740681558087, 0.13072071854169098, 0.13072071854169098, 0.13072071854169098, 0.13775308981522516, 0.13775308981522516, 0.13775308981522516, 0.20729576968421348, 0.20729576968421348, 0.20729576968421348, 0.23454677624616316, 0.23454677624616316, 0.23454677624616316, 0.2520860713662717, 0.2520860713662717, 0.2520860713662717, 0.15594760699597832, 0.15594760699597832, 0.15594760699597832, 0.13817811249145984, 0.13817811249145984, 0.13817811249145984, 0.1202918601689904, 0.1202918601689904, 0.1202918601689904, 0.17368236324339303, 0.17368236324339303, 0.17368236324339303, 0.18427802022530093, 0.18427802022530093, 0.18427802022530093, 0.1826349633091111, 0.1826349633091111, 0.1826349633091111, 0.16326796703532598, 0.16326796703532598, 0.16326796703532598, 0.17069765809358417, 0.17069765809358417, 0.17069765809358417, 0.17605900542587083, 0.17605900542587083, 0.17605900542587083, 0.4722613141970289, 0.4722613141970289, 0.4722613141970289, 0.17526326041570806, 0.17526326041570806, 0.17526326041570806, 0.3838539683166823, 0.3838539683166823, 0.3838539683166823, 0.2262023516691979, 0.2262023516691979, 0.2262023516691979, 0.1918441405639304, 0.1918441405639304, 0.1918441405639304, 0.19548802682760535, 0.19548802682760535, 0.19548802682760535, 0.1867366107277405, 0.1867366107277405, 0.1867366107277405, 0.1960677289099776, 0.1960677289099776, 0.1960677289099776, 0.19872823355961822, 0.19872823355961822, 0.19872823355961822, 0.07704981236944097, 0.07704981236944097, 0.07704981236944097, 0.07515003839493206, 0.07515003839493206, 0.07515003839493206, 0.06875241540664379, 0.06875241540664379, 0.06875241540664379]}, "mutation_prompt": null}
{"id": "ccade65c-1d97-46bf-9a69-dbac7dd220a8", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n            \n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(self.population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhanced hybrid DE and PSO with self-adaptive mutation and crossover rates for improved convergence.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0c7ab9fe-a571-43ae-868d-9573aa2d9e4e", "metadata": {"aucs": [0.4103249722892779, 0.4103249722892779, 0.4103249722892779, 0.43008311468859495, 0.43008311468859495, 0.43008311468859495, 0.41078016656011607, 0.41078016656011607, 0.41078016656011607, 0.10644500169628957, 0.10644500169628957, 0.10644500169628957, 0.09648428150598465, 0.09648428150598465, 0.09648428150598465, 0.05927592318694297, 0.05927592318694297, 0.05927592318694297, 0.0961114659578014, 0.0961114659578014, 0.0961114659578014, 0.07458231651103286, 0.07458231651103286, 0.07458231651103286, 0.083573023507025, 0.083573023507025, 0.083573023507025, 0.06459294808902682, 0.06459294808902682, 0.06459294808902682, 0.05598867642649186, 0.05598867642649186, 0.05598867642649186, 0.06621856478205268, 0.06621856478205268, 0.06621856478205268, 0.9712922589631109, 0.9712922589631109, 0.9712922589631109, 0.9717322919352486, 0.9717322919352486, 0.9717322919352486, 0.9712462984596584, 0.9712462984596584, 0.9712462984596584, 0.22154228742352833, 0.22154228742352833, 0.22154228742352833, 0.20579218555536205, 0.20579218555536205, 0.20579218555536205, 0.2184007983455224, 0.2184007983455224, 0.2184007983455224, 0.22515470239715374, 0.22515470239715374, 0.22515470239715374, 0.34796555715564625, 0.34796555715564625, 0.34796555715564625, 0.2115433787026919, 0.2115433787026919, 0.2115433787026919, 0.10310102389277476, 0.10310102389277476, 0.10310102389277476, 0.12374435351510837, 0.12374435351510837, 0.12374435351510837, 0.10002119055250935, 0.10002119055250935, 0.10002119055250935, 0.015292634093887703, 0.015292634093887703, 0.015292634093887703, 0.11814858744412982, 0.11814858744412982, 0.11814858744412982, 0.09380813409105482, 0.09380813409105482, 0.09380813409105482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010424490657168217, 0.00010424490657168217, 0.00010424490657168217, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07591312130630212, 0.07591312130630212, 0.07591312130630212, 0.014877179190464607, 0.014877179190464607, 0.014877179190464607, 0.03380187917893074, 0.03380187917893074, 0.03380187917893074, 0.010741686514048499, 0.010741686514048499, 0.010741686514048499, 0.034591612529009996, 0.034591612529009996, 0.034591612529009996, 0.010183025216879638, 0.010183025216879638, 0.010183025216879638, 0.04408643464398154, 0.04408643464398154, 0.04408643464398154, 0.06379632356360598, 0.06379632356360598, 0.06379632356360598, 0.04201932918388285, 0.04201932918388285, 0.04201932918388285, 0.38686327148567257, 0.38686327148567257, 0.38686327148567257, 0.3334052825629633, 0.3334052825629633, 0.3334052825629633, 0.3076104901557082, 0.3076104901557082, 0.3076104901557082, 0.08101427932536875, 0.08101427932536875, 0.08101427932536875, 0.07870027202177776, 0.07870027202177776, 0.07870027202177776, 0.0757327583928924, 0.0757327583928924, 0.0757327583928924, 0.14793740681558087, 0.14793740681558087, 0.14793740681558087, 0.13072071854169098, 0.13072071854169098, 0.13072071854169098, 0.13775308981522516, 0.13775308981522516, 0.13775308981522516, 0.20729576968421348, 0.20729576968421348, 0.20729576968421348, 0.23454677624616316, 0.23454677624616316, 0.23454677624616316, 0.2520860713662717, 0.2520860713662717, 0.2520860713662717, 0.15594760699597832, 0.15594760699597832, 0.15594760699597832, 0.13817811249145984, 0.13817811249145984, 0.13817811249145984, 0.1202918601689904, 0.1202918601689904, 0.1202918601689904, 0.17368236324339303, 0.17368236324339303, 0.17368236324339303, 0.18427802022530093, 0.18427802022530093, 0.18427802022530093, 0.1826349633091111, 0.1826349633091111, 0.1826349633091111, 0.16326796703532598, 0.16326796703532598, 0.16326796703532598, 0.17069765809358417, 0.17069765809358417, 0.17069765809358417, 0.17605900542587083, 0.17605900542587083, 0.17605900542587083, 0.4722613141970289, 0.4722613141970289, 0.4722613141970289, 0.17526326041570806, 0.17526326041570806, 0.17526326041570806, 0.3838539683166823, 0.3838539683166823, 0.3838539683166823, 0.2262023516691979, 0.2262023516691979, 0.2262023516691979, 0.1918441405639304, 0.1918441405639304, 0.1918441405639304, 0.19548802682760535, 0.19548802682760535, 0.19548802682760535, 0.1867366107277405, 0.1867366107277405, 0.1867366107277405, 0.1960677289099776, 0.1960677289099776, 0.1960677289099776, 0.19872823355961822, 0.19872823355961822, 0.19872823355961822, 0.07704981236944097, 0.07704981236944097, 0.07704981236944097, 0.07515003839493206, 0.07515003839493206, 0.07515003839493206, 0.06875241540664379, 0.06875241540664379, 0.06875241540664379]}, "mutation_prompt": null}
{"id": "7dee13b7-725a-4563-9760-0962f71247b7", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n\n            # Swarm resizing\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            # Differential Evolution step\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Introduce adaptive swarm resizing and neighborhood-based mutation to enhance exploration and convergence.", "configspace": "", "generation": 34, "fitness": 0.2153001008484132, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "0c7ab9fe-a571-43ae-868d-9573aa2d9e4e", "metadata": {"aucs": [0.4676987474089426, 0.4676987474089426, 0.4676987474089426, 0.532184532210318, 0.532184532210318, 0.532184532210318, 0.4756874760276072, 0.4756874760276072, 0.4756874760276072, 0.22779316541956418, 0.22779316541956418, 0.22779316541956418, 0.2620414640218659, 0.2620414640218659, 0.2620414640218659, 0.25187672707525266, 0.25187672707525266, 0.25187672707525266, 0.10393818371219443, 0.10393818371219443, 0.10393818371219443, 0.10473926115786947, 0.10473926115786947, 0.10473926115786947, 0.087814237213657, 0.087814237213657, 0.087814237213657, 0.076738595694126, 0.076738595694126, 0.076738595694126, 0.07176337806163025, 0.07176337806163025, 0.07176337806163025, 0.08959514195869256, 0.08959514195869256, 0.08959514195869256, 0.9730404436937634, 0.9730404436937634, 0.9730404436937634, 0.9681928974157534, 0.9681928974157534, 0.9681928974157534, 0.9627705388841867, 0.9627705388841867, 0.9627705388841867, 0.2770721999367818, 0.2770721999367818, 0.2770721999367818, 0.2919311846966227, 0.2919311846966227, 0.2919311846966227, 0.3078337413489085, 0.3078337413489085, 0.3078337413489085, 0.4226824242614554, 0.4226824242614554, 0.4226824242614554, 0.25243370008298416, 0.25243370008298416, 0.25243370008298416, 0.38714733297162174, 0.38714733297162174, 0.38714733297162174, 0.10378120648704825, 0.10378120648704825, 0.10378120648704825, 0.1219338912236061, 0.1219338912236061, 0.1219338912236061, 0.10528370514385532, 0.10528370514385532, 0.10528370514385532, 0.12200978123200201, 0.12200978123200201, 0.12200978123200201, 0.11627568307627789, 0.11627568307627789, 0.11627568307627789, 0.1208110122323196, 0.1208110122323196, 0.1208110122323196, 0.001745064177821054, 0.001745064177821054, 0.001745064177821054, 0.017235787873674413, 0.017235787873674413, 0.017235787873674413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028208041073622736, 0.028208041073622736, 0.028208041073622736, 0.00792792162787248, 0.00792792162787248, 0.00792792162787248, 0.05232644759468208, 0.05232644759468208, 0.05232644759468208, 0.04163908052890075, 0.04163908052890075, 0.04163908052890075, 0.03820946738032471, 0.03820946738032471, 0.03820946738032471, 0.03382944344309746, 0.03382944344309746, 0.03382944344309746, 0.11828954986765183, 0.11828954986765183, 0.11828954986765183, 0.07237353433983407, 0.07237353433983407, 0.07237353433983407, 0.0431273863021977, 0.0431273863021977, 0.0431273863021977, 0.3905852773063182, 0.3905852773063182, 0.3905852773063182, 0.3703749343261392, 0.3703749343261392, 0.3703749343261392, 0.3546918385344314, 0.3546918385344314, 0.3546918385344314, 0.09987525270734954, 0.09987525270734954, 0.09987525270734954, 0.08157197404752714, 0.08157197404752714, 0.08157197404752714, 0.10364104978287214, 0.10364104978287214, 0.10364104978287214, 0.1326985224220727, 0.1326985224220727, 0.1326985224220727, 0.19641194625421177, 0.19641194625421177, 0.19641194625421177, 0.16082275448926175, 0.16082275448926175, 0.16082275448926175, 0.27729342353657727, 0.27729342353657727, 0.27729342353657727, 0.2504953935295322, 0.2504953935295322, 0.2504953935295322, 0.3030806809650338, 0.3030806809650338, 0.3030806809650338, 0.1936192007174652, 0.1936192007174652, 0.1936192007174652, 0.16009922193895132, 0.16009922193895132, 0.16009922193895132, 0.2074367193501926, 0.2074367193501926, 0.2074367193501926, 0.16938140703365567, 0.16938140703365567, 0.16938140703365567, 0.17614556640281587, 0.17614556640281587, 0.17614556640281587, 0.17314718593725797, 0.17314718593725797, 0.17314718593725797, 0.17899884668633514, 0.17899884668633514, 0.17899884668633514, 0.25784375337724286, 0.25784375337724286, 0.25784375337724286, 0.23736380786791555, 0.23736380786791555, 0.23736380786791555, 0.59573598440962, 0.59573598440962, 0.59573598440962, 0.19032750656956576, 0.19032750656956576, 0.19032750656956576, 0.16259406002140864, 0.16259406002140864, 0.16259406002140864, 0.16083677137745722, 0.16083677137745722, 0.16083677137745722, 0.18996156705250333, 0.18996156705250333, 0.18996156705250333, 0.19589883933110286, 0.19589883933110286, 0.19589883933110286, 0.1906449504151051, 0.1906449504151051, 0.1906449504151051, 0.18167761255818382, 0.18167761255818382, 0.18167761255818382, 0.18858276872133928, 0.18858276872133928, 0.18858276872133928, 0.07789425845422515, 0.07789425845422515, 0.07789425845422515, 0.07726886419607448, 0.07726886419607448, 0.07726886419607448, 0.07452294390741787, 0.07452294390741787, 0.07452294390741787]}, "mutation_prompt": null}
{"id": "25b83e14-87ca-455b-81db-4ef6d47752cf", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n\n            # Swarm resizing\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            # Differential Evolution step\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Introduce adaptive swarm resizing and neighborhood-based mutation to enhance exploration and convergence.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7dee13b7-725a-4563-9760-0962f71247b7", "metadata": {"aucs": [0.4676987474089426, 0.4676987474089426, 0.4676987474089426, 0.532184532210318, 0.532184532210318, 0.532184532210318, 0.4756874760276072, 0.4756874760276072, 0.4756874760276072, 0.22779316541956418, 0.22779316541956418, 0.22779316541956418, 0.2620414640218659, 0.2620414640218659, 0.2620414640218659, 0.25187672707525266, 0.25187672707525266, 0.25187672707525266, 0.10393818371219443, 0.10393818371219443, 0.10393818371219443, 0.10473926115786947, 0.10473926115786947, 0.10473926115786947, 0.087814237213657, 0.087814237213657, 0.087814237213657, 0.076738595694126, 0.076738595694126, 0.076738595694126, 0.07176337806163025, 0.07176337806163025, 0.07176337806163025, 0.08959514195869256, 0.08959514195869256, 0.08959514195869256, 0.9730404436937634, 0.9730404436937634, 0.9730404436937634, 0.9681928974157534, 0.9681928974157534, 0.9681928974157534, 0.9627705388841867, 0.9627705388841867, 0.9627705388841867, 0.2770721999367818, 0.2770721999367818, 0.2770721999367818, 0.2919311846966227, 0.2919311846966227, 0.2919311846966227, 0.3078337413489085, 0.3078337413489085, 0.3078337413489085, 0.4226824242614554, 0.4226824242614554, 0.4226824242614554, 0.25243370008298416, 0.25243370008298416, 0.25243370008298416, 0.38714733297162174, 0.38714733297162174, 0.38714733297162174, 0.10378120648704825, 0.10378120648704825, 0.10378120648704825, 0.1219338912236061, 0.1219338912236061, 0.1219338912236061, 0.10528370514385532, 0.10528370514385532, 0.10528370514385532, 0.12200978123200201, 0.12200978123200201, 0.12200978123200201, 0.11627568307627789, 0.11627568307627789, 0.11627568307627789, 0.1208110122323196, 0.1208110122323196, 0.1208110122323196, 0.001745064177821054, 0.001745064177821054, 0.001745064177821054, 0.017235787873674413, 0.017235787873674413, 0.017235787873674413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028208041073622736, 0.028208041073622736, 0.028208041073622736, 0.00792792162787248, 0.00792792162787248, 0.00792792162787248, 0.05232644759468208, 0.05232644759468208, 0.05232644759468208, 0.04163908052890075, 0.04163908052890075, 0.04163908052890075, 0.03820946738032471, 0.03820946738032471, 0.03820946738032471, 0.03382944344309746, 0.03382944344309746, 0.03382944344309746, 0.11828954986765183, 0.11828954986765183, 0.11828954986765183, 0.07237353433983407, 0.07237353433983407, 0.07237353433983407, 0.0431273863021977, 0.0431273863021977, 0.0431273863021977, 0.3905852773063182, 0.3905852773063182, 0.3905852773063182, 0.3703749343261392, 0.3703749343261392, 0.3703749343261392, 0.3546918385344314, 0.3546918385344314, 0.3546918385344314, 0.09987525270734954, 0.09987525270734954, 0.09987525270734954, 0.08157197404752714, 0.08157197404752714, 0.08157197404752714, 0.10364104978287214, 0.10364104978287214, 0.10364104978287214, 0.1326985224220727, 0.1326985224220727, 0.1326985224220727, 0.19641194625421177, 0.19641194625421177, 0.19641194625421177, 0.16082275448926175, 0.16082275448926175, 0.16082275448926175, 0.27729342353657727, 0.27729342353657727, 0.27729342353657727, 0.2504953935295322, 0.2504953935295322, 0.2504953935295322, 0.3030806809650338, 0.3030806809650338, 0.3030806809650338, 0.1936192007174652, 0.1936192007174652, 0.1936192007174652, 0.16009922193895132, 0.16009922193895132, 0.16009922193895132, 0.2074367193501926, 0.2074367193501926, 0.2074367193501926, 0.16938140703365567, 0.16938140703365567, 0.16938140703365567, 0.17614556640281587, 0.17614556640281587, 0.17614556640281587, 0.17314718593725797, 0.17314718593725797, 0.17314718593725797, 0.17899884668633514, 0.17899884668633514, 0.17899884668633514, 0.25784375337724286, 0.25784375337724286, 0.25784375337724286, 0.23736380786791555, 0.23736380786791555, 0.23736380786791555, 0.59573598440962, 0.59573598440962, 0.59573598440962, 0.19032750656956576, 0.19032750656956576, 0.19032750656956576, 0.16259406002140864, 0.16259406002140864, 0.16259406002140864, 0.16083677137745722, 0.16083677137745722, 0.16083677137745722, 0.18996156705250333, 0.18996156705250333, 0.18996156705250333, 0.19589883933110286, 0.19589883933110286, 0.19589883933110286, 0.1906449504151051, 0.1906449504151051, 0.1906449504151051, 0.18167761255818382, 0.18167761255818382, 0.18167761255818382, 0.18858276872133928, 0.18858276872133928, 0.18858276872133928, 0.07789425845422515, 0.07789425845422515, 0.07789425845422515, 0.07726886419607448, 0.07726886419607448, 0.07726886419607448, 0.07452294390741787, 0.07452294390741787, 0.07452294390741787]}, "mutation_prompt": null}
{"id": "fe561e9d-e7ba-4b8a-926b-b3b1d5aeac15", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n\n            # Swarm resizing\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            # Differential Evolution step\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Introduce adaptive swarm resizing and neighborhood-based mutation to enhance exploration and convergence.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7dee13b7-725a-4563-9760-0962f71247b7", "metadata": {"aucs": [0.4676987474089426, 0.4676987474089426, 0.4676987474089426, 0.532184532210318, 0.532184532210318, 0.532184532210318, 0.4756874760276072, 0.4756874760276072, 0.4756874760276072, 0.22779316541956418, 0.22779316541956418, 0.22779316541956418, 0.2620414640218659, 0.2620414640218659, 0.2620414640218659, 0.25187672707525266, 0.25187672707525266, 0.25187672707525266, 0.10393818371219443, 0.10393818371219443, 0.10393818371219443, 0.10473926115786947, 0.10473926115786947, 0.10473926115786947, 0.087814237213657, 0.087814237213657, 0.087814237213657, 0.076738595694126, 0.076738595694126, 0.076738595694126, 0.07176337806163025, 0.07176337806163025, 0.07176337806163025, 0.08959514195869256, 0.08959514195869256, 0.08959514195869256, 0.9730404436937634, 0.9730404436937634, 0.9730404436937634, 0.9681928974157534, 0.9681928974157534, 0.9681928974157534, 0.9627705388841867, 0.9627705388841867, 0.9627705388841867, 0.2770721999367818, 0.2770721999367818, 0.2770721999367818, 0.2919311846966227, 0.2919311846966227, 0.2919311846966227, 0.3078337413489085, 0.3078337413489085, 0.3078337413489085, 0.4226824242614554, 0.4226824242614554, 0.4226824242614554, 0.25243370008298416, 0.25243370008298416, 0.25243370008298416, 0.38714733297162174, 0.38714733297162174, 0.38714733297162174, 0.10378120648704825, 0.10378120648704825, 0.10378120648704825, 0.1219338912236061, 0.1219338912236061, 0.1219338912236061, 0.10528370514385532, 0.10528370514385532, 0.10528370514385532, 0.12200978123200201, 0.12200978123200201, 0.12200978123200201, 0.11627568307627789, 0.11627568307627789, 0.11627568307627789, 0.1208110122323196, 0.1208110122323196, 0.1208110122323196, 0.001745064177821054, 0.001745064177821054, 0.001745064177821054, 0.017235787873674413, 0.017235787873674413, 0.017235787873674413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028208041073622736, 0.028208041073622736, 0.028208041073622736, 0.00792792162787248, 0.00792792162787248, 0.00792792162787248, 0.05232644759468208, 0.05232644759468208, 0.05232644759468208, 0.04163908052890075, 0.04163908052890075, 0.04163908052890075, 0.03820946738032471, 0.03820946738032471, 0.03820946738032471, 0.03382944344309746, 0.03382944344309746, 0.03382944344309746, 0.11828954986765183, 0.11828954986765183, 0.11828954986765183, 0.07237353433983407, 0.07237353433983407, 0.07237353433983407, 0.0431273863021977, 0.0431273863021977, 0.0431273863021977, 0.3905852773063182, 0.3905852773063182, 0.3905852773063182, 0.3703749343261392, 0.3703749343261392, 0.3703749343261392, 0.3546918385344314, 0.3546918385344314, 0.3546918385344314, 0.09987525270734954, 0.09987525270734954, 0.09987525270734954, 0.08157197404752714, 0.08157197404752714, 0.08157197404752714, 0.10364104978287214, 0.10364104978287214, 0.10364104978287214, 0.1326985224220727, 0.1326985224220727, 0.1326985224220727, 0.19641194625421177, 0.19641194625421177, 0.19641194625421177, 0.16082275448926175, 0.16082275448926175, 0.16082275448926175, 0.27729342353657727, 0.27729342353657727, 0.27729342353657727, 0.2504953935295322, 0.2504953935295322, 0.2504953935295322, 0.3030806809650338, 0.3030806809650338, 0.3030806809650338, 0.1936192007174652, 0.1936192007174652, 0.1936192007174652, 0.16009922193895132, 0.16009922193895132, 0.16009922193895132, 0.2074367193501926, 0.2074367193501926, 0.2074367193501926, 0.16938140703365567, 0.16938140703365567, 0.16938140703365567, 0.17614556640281587, 0.17614556640281587, 0.17614556640281587, 0.17314718593725797, 0.17314718593725797, 0.17314718593725797, 0.17899884668633514, 0.17899884668633514, 0.17899884668633514, 0.25784375337724286, 0.25784375337724286, 0.25784375337724286, 0.23736380786791555, 0.23736380786791555, 0.23736380786791555, 0.59573598440962, 0.59573598440962, 0.59573598440962, 0.19032750656956576, 0.19032750656956576, 0.19032750656956576, 0.16259406002140864, 0.16259406002140864, 0.16259406002140864, 0.16083677137745722, 0.16083677137745722, 0.16083677137745722, 0.18996156705250333, 0.18996156705250333, 0.18996156705250333, 0.19589883933110286, 0.19589883933110286, 0.19589883933110286, 0.1906449504151051, 0.1906449504151051, 0.1906449504151051, 0.18167761255818382, 0.18167761255818382, 0.18167761255818382, 0.18858276872133928, 0.18858276872133928, 0.18858276872133928, 0.07789425845422515, 0.07789425845422515, 0.07789425845422515, 0.07726886419607448, 0.07726886419607448, 0.07726886419607448, 0.07452294390741787, 0.07452294390741787, 0.07452294390741787]}, "mutation_prompt": null}
{"id": "3589e21c-763d-40f0-be7e-5311c5532e55", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n\n            # Swarm resizing\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            # Differential Evolution step\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Introduce adaptive swarm resizing and neighborhood-based mutation to enhance exploration and convergence.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7dee13b7-725a-4563-9760-0962f71247b7", "metadata": {"aucs": [0.4676987474089426, 0.4676987474089426, 0.4676987474089426, 0.532184532210318, 0.532184532210318, 0.532184532210318, 0.4756874760276072, 0.4756874760276072, 0.4756874760276072, 0.22779316541956418, 0.22779316541956418, 0.22779316541956418, 0.2620414640218659, 0.2620414640218659, 0.2620414640218659, 0.25187672707525266, 0.25187672707525266, 0.25187672707525266, 0.10393818371219443, 0.10393818371219443, 0.10393818371219443, 0.10473926115786947, 0.10473926115786947, 0.10473926115786947, 0.087814237213657, 0.087814237213657, 0.087814237213657, 0.076738595694126, 0.076738595694126, 0.076738595694126, 0.07176337806163025, 0.07176337806163025, 0.07176337806163025, 0.08959514195869256, 0.08959514195869256, 0.08959514195869256, 0.9730404436937634, 0.9730404436937634, 0.9730404436937634, 0.9681928974157534, 0.9681928974157534, 0.9681928974157534, 0.9627705388841867, 0.9627705388841867, 0.9627705388841867, 0.2770721999367818, 0.2770721999367818, 0.2770721999367818, 0.2919311846966227, 0.2919311846966227, 0.2919311846966227, 0.3078337413489085, 0.3078337413489085, 0.3078337413489085, 0.4226824242614554, 0.4226824242614554, 0.4226824242614554, 0.25243370008298416, 0.25243370008298416, 0.25243370008298416, 0.38714733297162174, 0.38714733297162174, 0.38714733297162174, 0.10378120648704825, 0.10378120648704825, 0.10378120648704825, 0.1219338912236061, 0.1219338912236061, 0.1219338912236061, 0.10528370514385532, 0.10528370514385532, 0.10528370514385532, 0.12200978123200201, 0.12200978123200201, 0.12200978123200201, 0.11627568307627789, 0.11627568307627789, 0.11627568307627789, 0.1208110122323196, 0.1208110122323196, 0.1208110122323196, 0.001745064177821054, 0.001745064177821054, 0.001745064177821054, 0.017235787873674413, 0.017235787873674413, 0.017235787873674413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028208041073622736, 0.028208041073622736, 0.028208041073622736, 0.00792792162787248, 0.00792792162787248, 0.00792792162787248, 0.05232644759468208, 0.05232644759468208, 0.05232644759468208, 0.04163908052890075, 0.04163908052890075, 0.04163908052890075, 0.03820946738032471, 0.03820946738032471, 0.03820946738032471, 0.03382944344309746, 0.03382944344309746, 0.03382944344309746, 0.11828954986765183, 0.11828954986765183, 0.11828954986765183, 0.07237353433983407, 0.07237353433983407, 0.07237353433983407, 0.0431273863021977, 0.0431273863021977, 0.0431273863021977, 0.3905852773063182, 0.3905852773063182, 0.3905852773063182, 0.3703749343261392, 0.3703749343261392, 0.3703749343261392, 0.3546918385344314, 0.3546918385344314, 0.3546918385344314, 0.09987525270734954, 0.09987525270734954, 0.09987525270734954, 0.08157197404752714, 0.08157197404752714, 0.08157197404752714, 0.10364104978287214, 0.10364104978287214, 0.10364104978287214, 0.1326985224220727, 0.1326985224220727, 0.1326985224220727, 0.19641194625421177, 0.19641194625421177, 0.19641194625421177, 0.16082275448926175, 0.16082275448926175, 0.16082275448926175, 0.27729342353657727, 0.27729342353657727, 0.27729342353657727, 0.2504953935295322, 0.2504953935295322, 0.2504953935295322, 0.3030806809650338, 0.3030806809650338, 0.3030806809650338, 0.1936192007174652, 0.1936192007174652, 0.1936192007174652, 0.16009922193895132, 0.16009922193895132, 0.16009922193895132, 0.2074367193501926, 0.2074367193501926, 0.2074367193501926, 0.16938140703365567, 0.16938140703365567, 0.16938140703365567, 0.17614556640281587, 0.17614556640281587, 0.17614556640281587, 0.17314718593725797, 0.17314718593725797, 0.17314718593725797, 0.17899884668633514, 0.17899884668633514, 0.17899884668633514, 0.25784375337724286, 0.25784375337724286, 0.25784375337724286, 0.23736380786791555, 0.23736380786791555, 0.23736380786791555, 0.59573598440962, 0.59573598440962, 0.59573598440962, 0.19032750656956576, 0.19032750656956576, 0.19032750656956576, 0.16259406002140864, 0.16259406002140864, 0.16259406002140864, 0.16083677137745722, 0.16083677137745722, 0.16083677137745722, 0.18996156705250333, 0.18996156705250333, 0.18996156705250333, 0.19589883933110286, 0.19589883933110286, 0.19589883933110286, 0.1906449504151051, 0.1906449504151051, 0.1906449504151051, 0.18167761255818382, 0.18167761255818382, 0.18167761255818382, 0.18858276872133928, 0.18858276872133928, 0.18858276872133928, 0.07789425845422515, 0.07789425845422515, 0.07789425845422515, 0.07726886419607448, 0.07726886419607448, 0.07726886419607448, 0.07452294390741787, 0.07452294390741787, 0.07452294390741787]}, "mutation_prompt": null}
{"id": "4d47790e-b4be-49ff-ab48-76f4806ec5bf", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        # Initialize population\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        # Evaluate population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adjust parameters adaptively\n            self.w = max(0.4, 0.9 - 0.5 * evaluations / self.budget)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive mutation factor\n            self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover rate\n\n            # Swarm resizing\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            # Differential Evolution step\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Particle Swarm Optimization step\n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Introduce adaptive swarm resizing and neighborhood-based mutation to enhance exploration and convergence.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7dee13b7-725a-4563-9760-0962f71247b7", "metadata": {"aucs": [0.4676987474089426, 0.4676987474089426, 0.4676987474089426, 0.532184532210318, 0.532184532210318, 0.532184532210318, 0.4756874760276072, 0.4756874760276072, 0.4756874760276072, 0.22779316541956418, 0.22779316541956418, 0.22779316541956418, 0.2620414640218659, 0.2620414640218659, 0.2620414640218659, 0.25187672707525266, 0.25187672707525266, 0.25187672707525266, 0.10393818371219443, 0.10393818371219443, 0.10393818371219443, 0.10473926115786947, 0.10473926115786947, 0.10473926115786947, 0.087814237213657, 0.087814237213657, 0.087814237213657, 0.076738595694126, 0.076738595694126, 0.076738595694126, 0.07176337806163025, 0.07176337806163025, 0.07176337806163025, 0.08959514195869256, 0.08959514195869256, 0.08959514195869256, 0.9730404436937634, 0.9730404436937634, 0.9730404436937634, 0.9681928974157534, 0.9681928974157534, 0.9681928974157534, 0.9627705388841867, 0.9627705388841867, 0.9627705388841867, 0.2770721999367818, 0.2770721999367818, 0.2770721999367818, 0.2919311846966227, 0.2919311846966227, 0.2919311846966227, 0.3078337413489085, 0.3078337413489085, 0.3078337413489085, 0.4226824242614554, 0.4226824242614554, 0.4226824242614554, 0.25243370008298416, 0.25243370008298416, 0.25243370008298416, 0.38714733297162174, 0.38714733297162174, 0.38714733297162174, 0.10378120648704825, 0.10378120648704825, 0.10378120648704825, 0.1219338912236061, 0.1219338912236061, 0.1219338912236061, 0.10528370514385532, 0.10528370514385532, 0.10528370514385532, 0.12200978123200201, 0.12200978123200201, 0.12200978123200201, 0.11627568307627789, 0.11627568307627789, 0.11627568307627789, 0.1208110122323196, 0.1208110122323196, 0.1208110122323196, 0.001745064177821054, 0.001745064177821054, 0.001745064177821054, 0.017235787873674413, 0.017235787873674413, 0.017235787873674413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028208041073622736, 0.028208041073622736, 0.028208041073622736, 0.00792792162787248, 0.00792792162787248, 0.00792792162787248, 0.05232644759468208, 0.05232644759468208, 0.05232644759468208, 0.04163908052890075, 0.04163908052890075, 0.04163908052890075, 0.03820946738032471, 0.03820946738032471, 0.03820946738032471, 0.03382944344309746, 0.03382944344309746, 0.03382944344309746, 0.11828954986765183, 0.11828954986765183, 0.11828954986765183, 0.07237353433983407, 0.07237353433983407, 0.07237353433983407, 0.0431273863021977, 0.0431273863021977, 0.0431273863021977, 0.3905852773063182, 0.3905852773063182, 0.3905852773063182, 0.3703749343261392, 0.3703749343261392, 0.3703749343261392, 0.3546918385344314, 0.3546918385344314, 0.3546918385344314, 0.09987525270734954, 0.09987525270734954, 0.09987525270734954, 0.08157197404752714, 0.08157197404752714, 0.08157197404752714, 0.10364104978287214, 0.10364104978287214, 0.10364104978287214, 0.1326985224220727, 0.1326985224220727, 0.1326985224220727, 0.19641194625421177, 0.19641194625421177, 0.19641194625421177, 0.16082275448926175, 0.16082275448926175, 0.16082275448926175, 0.27729342353657727, 0.27729342353657727, 0.27729342353657727, 0.2504953935295322, 0.2504953935295322, 0.2504953935295322, 0.3030806809650338, 0.3030806809650338, 0.3030806809650338, 0.1936192007174652, 0.1936192007174652, 0.1936192007174652, 0.16009922193895132, 0.16009922193895132, 0.16009922193895132, 0.2074367193501926, 0.2074367193501926, 0.2074367193501926, 0.16938140703365567, 0.16938140703365567, 0.16938140703365567, 0.17614556640281587, 0.17614556640281587, 0.17614556640281587, 0.17314718593725797, 0.17314718593725797, 0.17314718593725797, 0.17899884668633514, 0.17899884668633514, 0.17899884668633514, 0.25784375337724286, 0.25784375337724286, 0.25784375337724286, 0.23736380786791555, 0.23736380786791555, 0.23736380786791555, 0.59573598440962, 0.59573598440962, 0.59573598440962, 0.19032750656956576, 0.19032750656956576, 0.19032750656956576, 0.16259406002140864, 0.16259406002140864, 0.16259406002140864, 0.16083677137745722, 0.16083677137745722, 0.16083677137745722, 0.18996156705250333, 0.18996156705250333, 0.18996156705250333, 0.19589883933110286, 0.19589883933110286, 0.19589883933110286, 0.1906449504151051, 0.1906449504151051, 0.1906449504151051, 0.18167761255818382, 0.18167761255818382, 0.18167761255818382, 0.18858276872133928, 0.18858276872133928, 0.18858276872133928, 0.07789425845422515, 0.07789425845422515, 0.07789425845422515, 0.07726886419607448, 0.07726886419607448, 0.07726886419607448, 0.07452294390741787, 0.07452294390741787, 0.07452294390741787]}, "mutation_prompt": null}
{"id": "924187c7-1e87-454c-9a40-9c2626ee64c8", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Integrate a rank-based selection mechanism and a dynamic inertia weight strategy to balance exploration and exploitation effectively.", "configspace": "", "generation": 39, "fitness": 0.3041447361864102, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "7dee13b7-725a-4563-9760-0962f71247b7", "metadata": {"aucs": [0.8247482025505138, 0.8247482025505138, 0.8247482025505138, 0.810732452173623, 0.810732452173623, 0.810732452173623, 0.8250285726922956, 0.8250285726922956, 0.8250285726922956, 0.686850907324624, 0.686850907324624, 0.686850907324624, 0.67961359234964, 0.67961359234964, 0.67961359234964, 0.6630945537708235, 0.6630945537708235, 0.6630945537708235, 0.14467421094424315, 0.14467421094424315, 0.14467421094424315, 0.1298196961785012, 0.1298196961785012, 0.1298196961785012, 0.14826501402995496, 0.14826501402995496, 0.14826501402995496, 0.13358667471076002, 0.13358667471076002, 0.13358667471076002, 0.13087855908017865, 0.13087855908017865, 0.13087855908017865, 0.1051213958082663, 0.1051213958082663, 0.1051213958082663, 0.9731936479621544, 0.9731936479621544, 0.9731936479621544, 0.9680751893627105, 0.9680751893627105, 0.9680751893627105, 0.9628028755471258, 0.9628028755471258, 0.9628028755471258, 0.7028208626550138, 0.7028208626550138, 0.7028208626550138, 0.5521337556937612, 0.5521337556937612, 0.5521337556937612, 0.6769206099040483, 0.6769206099040483, 0.6769206099040483, 0.35281506472306234, 0.35281506472306234, 0.35281506472306234, 0.19112068534072624, 0.19112068534072624, 0.19112068534072624, 0.37199574439493577, 0.37199574439493577, 0.37199574439493577, 0.1816271637575304, 0.1816271637575304, 0.1816271637575304, 0.19074631122900343, 0.19074631122900343, 0.19074631122900343, 0.18200798521656747, 0.18200798521656747, 0.18200798521656747, 0.18476237639369497, 0.18476237639369497, 0.18476237639369497, 0.19328538707416776, 0.19328538707416776, 0.19328538707416776, 0.2219700242959729, 0.2219700242959729, 0.2219700242959729, 0.005814262168618356, 0.005814262168618356, 0.005814262168618356, 0.03277518178177907, 0.03277518178177907, 0.03277518178177907, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058198000757016755, 0.058198000757016755, 0.058198000757016755, 0.013847441853988451, 0.013847441853988451, 0.013847441853988451, 0.06798698902963773, 0.06798698902963773, 0.06798698902963773, 0.21009881424977772, 0.21009881424977772, 0.21009881424977772, 0.13357960424154658, 0.13357960424154658, 0.13357960424154658, 0.08899955027399886, 0.08899955027399886, 0.08899955027399886, 0.1231986507625854, 0.1231986507625854, 0.1231986507625854, 0.08219755096914849, 0.08219755096914849, 0.08219755096914849, 0.0543648922326333, 0.0543648922326333, 0.0543648922326333, 0.5094190376079548, 0.5094190376079548, 0.5094190376079548, 0.5543915344238289, 0.5543915344238289, 0.5543915344238289, 0.5342580718115171, 0.5342580718115171, 0.5342580718115171, 0.08554817200535092, 0.08554817200535092, 0.08554817200535092, 0.10009318913580978, 0.10009318913580978, 0.10009318913580978, 0.08683199883060844, 0.08683199883060844, 0.08683199883060844, 0.15964385537981762, 0.15964385537981762, 0.15964385537981762, 0.14033570587822541, 0.14033570587822541, 0.14033570587822541, 0.15990732192740542, 0.15990732192740542, 0.15990732192740542, 0.32371428563193483, 0.32371428563193483, 0.32371428563193483, 0.24913059219901756, 0.24913059219901756, 0.24913059219901756, 0.4830628149821873, 0.4830628149821873, 0.4830628149821873, 0.38207292275914406, 0.38207292275914406, 0.38207292275914406, 0.22034581877675996, 0.22034581877675996, 0.22034581877675996, 0.39738877544178874, 0.39738877544178874, 0.39738877544178874, 0.19428909558698515, 0.19428909558698515, 0.19428909558698515, 0.2007354834089622, 0.2007354834089622, 0.2007354834089622, 0.2076550770487272, 0.2076550770487272, 0.2076550770487272, 0.2170779284495591, 0.2170779284495591, 0.2170779284495591, 0.23358204697031137, 0.23358204697031137, 0.23358204697031137, 0.19884855439083893, 0.19884855439083893, 0.19884855439083893, 0.869570985767217, 0.869570985767217, 0.869570985767217, 0.1531086718093485, 0.1531086718093485, 0.1531086718093485, 0.13517101562477074, 0.13517101562477074, 0.13517101562477074, 0.8266023453169962, 0.8266023453169962, 0.8266023453169962, 0.20866064013675234, 0.20866064013675234, 0.20866064013675234, 0.15166219133232572, 0.15166219133232572, 0.15166219133232572, 0.18779693815373877, 0.18779693815373877, 0.18779693815373877, 0.20947929404337806, 0.20947929404337806, 0.20947929404337806, 0.1839220131083984, 0.1839220131083984, 0.1839220131083984, 0.09199305181711004, 0.09199305181711004, 0.09199305181711004, 0.09427828084452994, 0.09427828084452994, 0.09427828084452994, 0.0879908413356032, 0.0879908413356032, 0.0879908413356032]}, "mutation_prompt": null}
{"id": "7ce81a0c-9a0d-489e-afac-8f8b315b7ac3", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Integrate a rank-based selection mechanism and a dynamic inertia weight strategy to balance exploration and exploitation effectively.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "924187c7-1e87-454c-9a40-9c2626ee64c8", "metadata": {"aucs": [0.8247482025505138, 0.8247482025505138, 0.8247482025505138, 0.810732452173623, 0.810732452173623, 0.810732452173623, 0.8250285726922956, 0.8250285726922956, 0.8250285726922956, 0.686850907324624, 0.686850907324624, 0.686850907324624, 0.67961359234964, 0.67961359234964, 0.67961359234964, 0.6630945537708235, 0.6630945537708235, 0.6630945537708235, 0.14467421094424315, 0.14467421094424315, 0.14467421094424315, 0.1298196961785012, 0.1298196961785012, 0.1298196961785012, 0.14826501402995496, 0.14826501402995496, 0.14826501402995496, 0.13358667471076002, 0.13358667471076002, 0.13358667471076002, 0.13087855908017865, 0.13087855908017865, 0.13087855908017865, 0.1051213958082663, 0.1051213958082663, 0.1051213958082663, 0.9731936479621544, 0.9731936479621544, 0.9731936479621544, 0.9680751893627105, 0.9680751893627105, 0.9680751893627105, 0.9628028755471258, 0.9628028755471258, 0.9628028755471258, 0.7028208626550138, 0.7028208626550138, 0.7028208626550138, 0.5521337556937612, 0.5521337556937612, 0.5521337556937612, 0.6769206099040483, 0.6769206099040483, 0.6769206099040483, 0.35281506472306234, 0.35281506472306234, 0.35281506472306234, 0.19112068534072624, 0.19112068534072624, 0.19112068534072624, 0.37199574439493577, 0.37199574439493577, 0.37199574439493577, 0.1816271637575304, 0.1816271637575304, 0.1816271637575304, 0.19074631122900343, 0.19074631122900343, 0.19074631122900343, 0.18200798521656747, 0.18200798521656747, 0.18200798521656747, 0.18476237639369497, 0.18476237639369497, 0.18476237639369497, 0.19328538707416776, 0.19328538707416776, 0.19328538707416776, 0.2219700242959729, 0.2219700242959729, 0.2219700242959729, 0.005814262168618356, 0.005814262168618356, 0.005814262168618356, 0.03277518178177907, 0.03277518178177907, 0.03277518178177907, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058198000757016755, 0.058198000757016755, 0.058198000757016755, 0.013847441853988451, 0.013847441853988451, 0.013847441853988451, 0.06798698902963773, 0.06798698902963773, 0.06798698902963773, 0.21009881424977772, 0.21009881424977772, 0.21009881424977772, 0.13357960424154658, 0.13357960424154658, 0.13357960424154658, 0.08899955027399886, 0.08899955027399886, 0.08899955027399886, 0.1231986507625854, 0.1231986507625854, 0.1231986507625854, 0.08219755096914849, 0.08219755096914849, 0.08219755096914849, 0.0543648922326333, 0.0543648922326333, 0.0543648922326333, 0.5094190376079548, 0.5094190376079548, 0.5094190376079548, 0.5543915344238289, 0.5543915344238289, 0.5543915344238289, 0.5342580718115171, 0.5342580718115171, 0.5342580718115171, 0.08554817200535092, 0.08554817200535092, 0.08554817200535092, 0.10009318913580978, 0.10009318913580978, 0.10009318913580978, 0.08683199883060844, 0.08683199883060844, 0.08683199883060844, 0.15964385537981762, 0.15964385537981762, 0.15964385537981762, 0.14033570587822541, 0.14033570587822541, 0.14033570587822541, 0.15990732192740542, 0.15990732192740542, 0.15990732192740542, 0.32371428563193483, 0.32371428563193483, 0.32371428563193483, 0.24913059219901756, 0.24913059219901756, 0.24913059219901756, 0.4830628149821873, 0.4830628149821873, 0.4830628149821873, 0.38207292275914406, 0.38207292275914406, 0.38207292275914406, 0.22034581877675996, 0.22034581877675996, 0.22034581877675996, 0.39738877544178874, 0.39738877544178874, 0.39738877544178874, 0.19428909558698515, 0.19428909558698515, 0.19428909558698515, 0.2007354834089622, 0.2007354834089622, 0.2007354834089622, 0.2076550770487272, 0.2076550770487272, 0.2076550770487272, 0.2170779284495591, 0.2170779284495591, 0.2170779284495591, 0.23358204697031137, 0.23358204697031137, 0.23358204697031137, 0.19884855439083893, 0.19884855439083893, 0.19884855439083893, 0.869570985767217, 0.869570985767217, 0.869570985767217, 0.1531086718093485, 0.1531086718093485, 0.1531086718093485, 0.13517101562477074, 0.13517101562477074, 0.13517101562477074, 0.8266023453169962, 0.8266023453169962, 0.8266023453169962, 0.20866064013675234, 0.20866064013675234, 0.20866064013675234, 0.15166219133232572, 0.15166219133232572, 0.15166219133232572, 0.18779693815373877, 0.18779693815373877, 0.18779693815373877, 0.20947929404337806, 0.20947929404337806, 0.20947929404337806, 0.1839220131083984, 0.1839220131083984, 0.1839220131083984, 0.09199305181711004, 0.09199305181711004, 0.09199305181711004, 0.09427828084452994, 0.09427828084452994, 0.09427828084452994, 0.0879908413356032, 0.0879908413356032, 0.0879908413356032]}, "mutation_prompt": null}
{"id": "9f1d2a9a-4c10-4cb0-8e01-b3cc96cfae24", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        self.velocity_limit = 0.2 * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-self.velocity_limit, self.velocity_limit, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                competitors = np.random.choice(current_population_size, 4, replace=False)\n                winner = competitors[np.argmin(fitness[competitors])]\n                a, b, c = pop[winner], pop[np.random.choice(idxs)], pop[np.random.choice(idxs)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = np.clip((self.w * velocities[i] \n                                         + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                         + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i])),\n                                        -self.velocity_limit, self.velocity_limit)\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by introducing adaptive velocity limits and a tournament selection strategy to improve convergence efficiency.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'idxs' is not defined\").", "error": "NameError(\"name 'idxs' is not defined\")", "parent_id": "924187c7-1e87-454c-9a40-9c2626ee64c8", "metadata": {}, "mutation_prompt": null}
{"id": "021f9b18-9624-4c04-95b4-69093ea8c89a", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.4, self.w * (1 - evaluations / self.budget))  # Adjusted dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover probability\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            prob_selection = np.exp(-ranks / (0.2 * current_population_size))  # Stochastic rank-based selection\n            prob_selection /= prob_selection.sum()\n            selected_indices = np.random.choice(current_population_size, current_population_size, p=prob_selection, replace=False)\n            for i in selected_indices:\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Hybrid DEPSO with adaptive learning rate and stochastic rank-based selection.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "924187c7-1e87-454c-9a40-9c2626ee64c8", "metadata": {}, "mutation_prompt": null}
{"id": "d8e4aaf3-768c-4972-ae37-7b225a3fc93c", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                # Apply Gaussian perturbation\n                if np.random.rand() < 0.1:  # 10% chance to perturb\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    pop[i] = np.clip(pop[i] + perturbation, self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Introduce a diversity-preserving mechanism via Gaussian perturbation to enhance exploration and avoid stagnation.", "configspace": "", "generation": 43, "fitness": 0.29337630041707147, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "924187c7-1e87-454c-9a40-9c2626ee64c8", "metadata": {"aucs": [0.7976943614877043, 0.7976943614877043, 0.7976943614877043, 0.8100374124564008, 0.8100374124564008, 0.8100374124564008, 0.8250308255792027, 0.8250308255792027, 0.8250308255792027, 0.5389931533270249, 0.5389931533270249, 0.5389931533270249, 0.4243478465746312, 0.4243478465746312, 0.4243478465746312, 0.5273248286000605, 0.5273248286000605, 0.5273248286000605, 0.15365283520804895, 0.15365283520804895, 0.15365283520804895, 0.40025255819294603, 0.40025255819294603, 0.40025255819294603, 0.11460062284615691, 0.11460062284615691, 0.11460062284615691, 0.10151424077706162, 0.10151424077706162, 0.10151424077706162, 0.15866062978709794, 0.15866062978709794, 0.15866062978709794, 0.1016952116902492, 0.1016952116902492, 0.1016952116902492, 0.9725120776325981, 0.9725120776325981, 0.9725120776325981, 0.9706676790740855, 0.9706676790740855, 0.9706676790740855, 0.9678740303565508, 0.9678740303565508, 0.9678740303565508, 0.5017905362050308, 0.5017905362050308, 0.5017905362050308, 0.4270100615937428, 0.4270100615937428, 0.4270100615937428, 0.45677715727111723, 0.45677715727111723, 0.45677715727111723, 0.21420524433098587, 0.21420524433098587, 0.21420524433098587, 0.18888569823754564, 0.18888569823754564, 0.18888569823754564, 0.22094585389792087, 0.22094585389792087, 0.22094585389792087, 0.1771164226365698, 0.1771164226365698, 0.1771164226365698, 0.1859377777832183, 0.1859377777832183, 0.1859377777832183, 0.18638344731587564, 0.18638344731587564, 0.18638344731587564, 0.21121741395225146, 0.21121741395225146, 0.21121741395225146, 0.18774225210222706, 0.18774225210222706, 0.18774225210222706, 0.211833103437978, 0.211833103437978, 0.211833103437978, 0.025215781392432857, 0.025215781392432857, 0.025215781392432857, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04078845771650452, 0.04078845771650452, 0.04078845771650452, 0.022102165850672817, 0.022102165850672817, 0.022102165850672817, 0.05122970471631649, 0.05122970471631649, 0.05122970471631649, 0.0461966847659131, 0.0461966847659131, 0.0461966847659131, 0.08249543320137509, 0.08249543320137509, 0.08249543320137509, 0.08988781204333574, 0.08988781204333574, 0.08988781204333574, 0.1782899563032957, 0.1782899563032957, 0.1782899563032957, 0.07677539929537469, 0.07677539929537469, 0.07677539929537469, 0.0530916456418028, 0.0530916456418028, 0.0530916456418028, 0.4721501292894278, 0.4721501292894278, 0.4721501292894278, 0.48331890207057093, 0.48331890207057093, 0.48331890207057093, 0.5148610140837497, 0.5148610140837497, 0.5148610140837497, 0.13725951285691773, 0.13725951285691773, 0.13725951285691773, 0.3524110643428934, 0.3524110643428934, 0.3524110643428934, 0.11026680877403428, 0.11026680877403428, 0.11026680877403428, 0.14897042561755225, 0.14897042561755225, 0.14897042561755225, 0.2444144091671353, 0.2444144091671353, 0.2444144091671353, 0.21872292391362624, 0.21872292391362624, 0.21872292391362624, 0.39178503359929917, 0.39178503359929917, 0.39178503359929917, 0.4118296174174164, 0.4118296174174164, 0.4118296174174164, 0.4192160019276029, 0.4192160019276029, 0.4192160019276029, 0.18532837577041172, 0.18532837577041172, 0.18532837577041172, 0.25315350712528983, 0.25315350712528983, 0.25315350712528983, 0.2572984445884685, 0.2572984445884685, 0.2572984445884685, 0.1932725790357256, 0.1932725790357256, 0.1932725790357256, 0.20899139655180732, 0.20899139655180732, 0.20899139655180732, 0.2365015740011731, 0.2365015740011731, 0.2365015740011731, 0.19018472879538517, 0.19018472879538517, 0.19018472879538517, 0.21314925560931097, 0.21314925560931097, 0.21314925560931097, 0.23933480128959728, 0.23933480128959728, 0.23933480128959728, 0.8469848069377461, 0.8469848069377461, 0.8469848069377461, 0.7312288811956723, 0.7312288811956723, 0.7312288811956723, 0.16615536689490729, 0.16615536689490729, 0.16615536689490729, 0.5972395232756079, 0.5972395232756079, 0.5972395232756079, 0.20762262162581935, 0.20762262162581935, 0.20762262162581935, 0.15533441329530928, 0.15533441329530928, 0.15533441329530928, 0.17810147934992526, 0.17810147934992526, 0.17810147934992526, 0.1953719950560444, 0.1953719950560444, 0.1953719950560444, 0.18318430696199806, 0.18318430696199806, 0.18318430696199806, 0.08832047849559599, 0.08832047849559599, 0.08832047849559599, 0.08576542412571764, 0.08576542412571764, 0.08576542412571764, 0.10438750370609962, 0.10438750370609962, 0.10438750370609962]}, "mutation_prompt": null}
{"id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 44, "fitness": 0.30522235174769885, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "924187c7-1e87-454c-9a40-9c2626ee64c8", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "67315098-bba8-4c68-ae81-ed514f32e50a", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "fcf7b536-df11-4521-92d4-1c77665ff8d3", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "4d12c1d0-d991-46f2-a5b1-e6250c1c97b3", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "381b62ca-4829-42ec-b403-104263d25e48", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.1, self.w * (1 - evaluations / self.budget))  # Adjusted dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive velocity scaling\n            velocity_scale = 0.5 + 0.5 * ((self.budget - evaluations) / self.budget)\n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                velocities[i] = velocities[i] * velocity_scale  # Scale the velocity based on budget\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by introducing dynamic population variance and adaptive velocity scaling based on convergence trends.", "configspace": "", "generation": 48, "fitness": 0.28897503850374684, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.8361075148355891, 0.8361075148355891, 0.8361075148355891, 0.8281047328977063, 0.8281047328977063, 0.8281047328977063, 0.8356718564891435, 0.8356718564891435, 0.8356718564891435, 0.7202154737487022, 0.7202154737487022, 0.7202154737487022, 0.6990815376739201, 0.6990815376739201, 0.6990815376739201, 0.7011028594334079, 0.7011028594334079, 0.7011028594334079, 0.13295768490166227, 0.13295768490166227, 0.13295768490166227, 0.1339185261376029, 0.1339185261376029, 0.1339185261376029, 0.10406890846107963, 0.10406890846107963, 0.10406890846107963, 0.12150452296921399, 0.12150452296921399, 0.12150452296921399, 0.11068848562901934, 0.11068848562901934, 0.11068848562901934, 0.1004713283979689, 0.1004713283979689, 0.1004713283979689, 0.9730987991346377, 0.9730987991346377, 0.9730987991346377, 0.9679661112355145, 0.9679661112355145, 0.9679661112355145, 0.9626207874012115, 0.9626207874012115, 0.9626207874012115, 0.3160879209094879, 0.3160879209094879, 0.3160879209094879, 0.3353616960951544, 0.3353616960951544, 0.3353616960951544, 0.5818785928809739, 0.5818785928809739, 0.5818785928809739, 0.3388108311168705, 0.3388108311168705, 0.3388108311168705, 0.2064890151179105, 0.2064890151179105, 0.2064890151179105, 0.17018434059533338, 0.17018434059533338, 0.17018434059533338, 0.15639604114254102, 0.15639604114254102, 0.15639604114254102, 0.14810078831464357, 0.14810078831464357, 0.14810078831464357, 0.14584754738827865, 0.14584754738827865, 0.14584754738827865, 0.17758111965525292, 0.17758111965525292, 0.17758111965525292, 0.16254862313166996, 0.16254862313166996, 0.16254862313166996, 0.13113004483152768, 0.13113004483152768, 0.13113004483152768, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051433787995059044, 0.051433787995059044, 0.051433787995059044, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05286658837423819, 0.05286658837423819, 0.05286658837423819, 0.01206708248226862, 0.01206708248226862, 0.01206708248226862, 0.1324276776639104, 0.1324276776639104, 0.1324276776639104, 0.04546511786851426, 0.04546511786851426, 0.04546511786851426, 0.07125631924957421, 0.07125631924957421, 0.07125631924957421, 0.0892265210895905, 0.0892265210895905, 0.0892265210895905, 0.2195627027479683, 0.2195627027479683, 0.2195627027479683, 0.08989535314144936, 0.08989535314144936, 0.08989535314144936, 0.08105911945239752, 0.08105911945239752, 0.08105911945239752, 0.5184418796733736, 0.5184418796733736, 0.5184418796733736, 0.5554341244882197, 0.5554341244882197, 0.5554341244882197, 0.5484240238078459, 0.5484240238078459, 0.5484240238078459, 0.12909916726438786, 0.12909916726438786, 0.12909916726438786, 0.10066113546028865, 0.10066113546028865, 0.10066113546028865, 0.12593088039428602, 0.12593088039428602, 0.12593088039428602, 0.17022968814942196, 0.17022968814942196, 0.17022968814942196, 0.22248061399037122, 0.22248061399037122, 0.22248061399037122, 0.1575233986809228, 0.1575233986809228, 0.1575233986809228, 0.4398762946840268, 0.4398762946840268, 0.4398762946840268, 0.23323937966026176, 0.23323937966026176, 0.23323937966026176, 0.4300680009544391, 0.4300680009544391, 0.4300680009544391, 0.2862045033246854, 0.2862045033246854, 0.2862045033246854, 0.2593202734441328, 0.2593202734441328, 0.2593202734441328, 0.19387172541388442, 0.19387172541388442, 0.19387172541388442, 0.22130646004497045, 0.22130646004497045, 0.22130646004497045, 0.21553315237147275, 0.21553315237147275, 0.21553315237147275, 0.20237550430218032, 0.20237550430218032, 0.20237550430218032, 0.21491423285593214, 0.21491423285593214, 0.21491423285593214, 0.740916311516751, 0.740916311516751, 0.740916311516751, 0.18457167681640607, 0.18457167681640607, 0.18457167681640607, 0.8786755471445937, 0.8786755471445937, 0.8786755471445937, 0.1705364215161781, 0.1705364215161781, 0.1705364215161781, 0.1355723100007652, 0.1355723100007652, 0.1355723100007652, 0.40175021408258316, 0.40175021408258316, 0.40175021408258316, 0.20901201935302105, 0.20901201935302105, 0.20901201935302105, 0.10433417965671599, 0.10433417965671599, 0.10433417965671599, 0.17694943790876327, 0.17694943790876327, 0.17694943790876327, 0.17649423285306798, 0.17649423285306798, 0.17649423285306798, 0.18332763155809695, 0.18332763155809695, 0.18332763155809695, 0.08980214073773041, 0.08980214073773041, 0.08980214073773041, 0.09746398856695837, 0.09746398856695837, 0.09746398856695837, 0.08840626100204318, 0.08840626100204318, 0.08840626100204318]}, "mutation_prompt": null}
{"id": "fd71abbd-5bf3-4371-88b5-a4818ba57471", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "246b0047-9236-4a4b-a93c-5ccc367a5e62", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "eaca6dac-44ea-444e-a0a7-412dd25f71e3", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "d37f72d7-a264-4601-84fb-5640fde52286", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "76bfdf5c-d345-404f-95ed-04d43fd39925", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "79433e03-e335-4a4a-8bf9-92b6ed45bfb5", "solution": "import numpy as np\n\nclass EnhancedDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                leader = pop[np.argmin(fitness)]\n                a, b = pop[np.random.choice(idxs, 2, replace=False)]\n                mutant = np.clip(leader + self.F * (a - b), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                # Adaptive local search\n                local_search = pop[i] + np.random.normal(0, 0.1, self.dim)\n                local_search = np.clip(local_search, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search)\n                \n                evaluations += 1\n                if local_fitness < fitness[i]:\n                    fitness[i] = local_fitness\n                    personal_best_positions[i] = local_search\n                    personal_best_fitness[i] = local_fitness\n                    if local_fitness < func(global_best_position):\n                        global_best_position = local_search\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "EnhancedDEPSO", "description": "Enhance DEPSO by introducing leader-based mutation and adaptive local search for improved exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.3023595734182501, "feedback": "The algorithm EnhancedDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.830806469730105, 0.830806469730105, 0.830806469730105, 0.8324242036001015, 0.8324242036001015, 0.8324242036001015, 0.8302636934061729, 0.8302636934061729, 0.8302636934061729, 0.6451199992088252, 0.6451199992088252, 0.6451199992088252, 0.6514747788704772, 0.6514747788704772, 0.6514747788704772, 0.4951263728807146, 0.4951263728807146, 0.4951263728807146, 0.1383528683078583, 0.1383528683078583, 0.1383528683078583, 0.1351080729412213, 0.1351080729412213, 0.1351080729412213, 0.14600621060462304, 0.14600621060462304, 0.14600621060462304, 0.09077505917274209, 0.09077505917274209, 0.09077505917274209, 0.08621988753044207, 0.08621988753044207, 0.08621988753044207, 0.1340549845161778, 0.1340549845161778, 0.1340549845161778, 0.9648179458152958, 0.9648179458152958, 0.9648179458152958, 0.9783814815176174, 0.9783814815176174, 0.9783814815176174, 0.9631948571288523, 0.9631948571288523, 0.9631948571288523, 0.6795968894819749, 0.6795968894819749, 0.6795968894819749, 0.6793187227802773, 0.6793187227802773, 0.6793187227802773, 0.6633470474223259, 0.6633470474223259, 0.6633470474223259, 0.21172080254427217, 0.21172080254427217, 0.21172080254427217, 0.15971198593985392, 0.15971198593985392, 0.15971198593985392, 0.8074043488613277, 0.8074043488613277, 0.8074043488613277, 0.20411746949631426, 0.20411746949631426, 0.20411746949631426, 0.20860886519970845, 0.20860886519970845, 0.20860886519970845, 0.22089755954202572, 0.22089755954202572, 0.22089755954202572, 0.1729022546524993, 0.1729022546524993, 0.1729022546524993, 0.28880942829744516, 0.28880942829744516, 0.28880942829744516, 0.22358537560359004, 0.22358537560359004, 0.22358537560359004, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15343563699994445, 0.15343563699994445, 0.15343563699994445, 0.040983277643030336, 0.040983277643030336, 0.040983277643030336, 0.06460628890638309, 0.06460628890638309, 0.06460628890638309, 0.05688396115479333, 0.05688396115479333, 0.05688396115479333, 0.071464151846381, 0.071464151846381, 0.071464151846381, 0.08823603897438625, 0.08823603897438625, 0.08823603897438625, 0.05037369843664963, 0.05037369843664963, 0.05037369843664963, 0.047368949245531256, 0.047368949245531256, 0.047368949245531256, 0.05592481951034001, 0.05592481951034001, 0.05592481951034001, 0.5830202679432647, 0.5830202679432647, 0.5830202679432647, 0.5450932597912344, 0.5450932597912344, 0.5450932597912344, 0.5284614208318599, 0.5284614208318599, 0.5284614208318599, 0.12129255394095273, 0.12129255394095273, 0.12129255394095273, 0.12676706619310985, 0.12676706619310985, 0.12676706619310985, 0.11027193829389748, 0.11027193829389748, 0.11027193829389748, 0.2552683948490412, 0.2552683948490412, 0.2552683948490412, 0.1882799001483667, 0.1882799001483667, 0.1882799001483667, 0.29554299809617135, 0.29554299809617135, 0.29554299809617135, 0.4000653799730972, 0.4000653799730972, 0.4000653799730972, 0.4419122041310585, 0.4419122041310585, 0.4419122041310585, 0.36738696906926294, 0.36738696906926294, 0.36738696906926294, 0.2161667841543603, 0.2161667841543603, 0.2161667841543603, 0.15553191047956794, 0.15553191047956794, 0.15553191047956794, 0.16084703873596895, 0.16084703873596895, 0.16084703873596895, 0.17899440312089387, 0.17899440312089387, 0.17899440312089387, 0.18474074905445037, 0.18474074905445037, 0.18474074905445037, 0.18881029683126604, 0.18881029683126604, 0.18881029683126604, 0.20056120959418244, 0.20056120959418244, 0.20056120959418244, 0.19564959311162555, 0.19564959311162555, 0.19564959311162555, 0.19602897545351639, 0.19602897545351639, 0.19602897545351639, 0.8789745543834152, 0.8789745543834152, 0.8789745543834152, 0.1642929586068511, 0.1642929586068511, 0.1642929586068511, 0.1349717201278059, 0.1349717201278059, 0.1349717201278059, 0.6587397927316274, 0.6587397927316274, 0.6587397927316274, 0.2078200101530835, 0.2078200101530835, 0.2078200101530835, 0.15451804370834343, 0.15451804370834343, 0.15451804370834343, 0.19157560819892427, 0.19157560819892427, 0.19157560819892427, 0.17284711929294694, 0.17284711929294694, 0.17284711929294694, 0.20027667392941084, 0.20027667392941084, 0.20027667392941084, 0.09463476517473923, 0.09463476517473923, 0.09463476517473923, 0.0879325383572106, 0.0879325383572106, 0.0879325383572106, 0.11088772988221973, 0.11088772988221973, 0.11088772988221973]}, "mutation_prompt": null}
{"id": "d884a246-4971-4ac0-a366-98d0173d9dfb", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            diversity = np.std(pop, axis=0)\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand() * (1 + np.mean(diversity))\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            temp_factor = 1 - evaluations / self.budget\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                perturb = np.random.normal(0, temp_factor, self.dim)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant + perturb, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Refine DEPSO by introducing a mutation strategy inspired by Simulated Annealing and adapting the DE mutation scheme based on population diversity.", "configspace": "", "generation": 55, "fitness": 0.28512465268544046, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.818702141070405, 0.818702141070405, 0.818702141070405, 0.8111945057669726, 0.8111945057669726, 0.8111945057669726, 0.8210116231378355, 0.8210116231378355, 0.8210116231378355, 0.6611323583342306, 0.6611323583342306, 0.6611323583342306, 0.6585461087373979, 0.6585461087373979, 0.6585461087373979, 0.6588262697937178, 0.6588262697937178, 0.6588262697937178, 0.15145218489350787, 0.15145218489350787, 0.15145218489350787, 0.1359174252684805, 0.1359174252684805, 0.1359174252684805, 0.12078838243067835, 0.12078838243067835, 0.12078838243067835, 0.13655059521539137, 0.13655059521539137, 0.13655059521539137, 0.13865876153786827, 0.13865876153786827, 0.13865876153786827, 0.13555398489367165, 0.13555398489367165, 0.13555398489367165, 0.9678989690120291, 0.9678989690120291, 0.9678989690120291, 0.9674717786982046, 0.9674717786982046, 0.9674717786982046, 0.9735990264141252, 0.9735990264141252, 0.9735990264141252, 0.5345233035580581, 0.5345233035580581, 0.5345233035580581, 0.5553516364797977, 0.5553516364797977, 0.5553516364797977, 0.546616792116081, 0.546616792116081, 0.546616792116081, 0.337447006283239, 0.337447006283239, 0.337447006283239, 0.2338494364993896, 0.2338494364993896, 0.2338494364993896, 0.2188914511131469, 0.2188914511131469, 0.2188914511131469, 0.2005227482688271, 0.2005227482688271, 0.2005227482688271, 0.1522000230576368, 0.1522000230576368, 0.1522000230576368, 0.17288920508134575, 0.17288920508134575, 0.17288920508134575, 0.18759593410533226, 0.18759593410533226, 0.18759593410533226, 0.16946288294469924, 0.16946288294469924, 0.16946288294469924, 0.20523217838427388, 0.20523217838427388, 0.20523217838427388, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004177156002497795, 0.004177156002497795, 0.004177156002497795, 0.05938889906449041, 0.05938889906449041, 0.05938889906449041, 0.0464035487799207, 0.0464035487799207, 0.0464035487799207, 0.04467276884558957, 0.04467276884558957, 0.04467276884558957, 0.02959134717419709, 0.02959134717419709, 0.02959134717419709, 0.06209599767298313, 0.06209599767298313, 0.06209599767298313, 0.0691203284750933, 0.0691203284750933, 0.0691203284750933, 0.06414118624868481, 0.06414118624868481, 0.06414118624868481, 0.11513399891887999, 0.11513399891887999, 0.11513399891887999, 0.22380034660560533, 0.22380034660560533, 0.22380034660560533, 0.04738241335932469, 0.04738241335932469, 0.04738241335932469, 0.495411476894582, 0.495411476894582, 0.495411476894582, 0.5372995944549275, 0.5372995944549275, 0.5372995944549275, 0.4961543157595859, 0.4961543157595859, 0.4961543157595859, 0.12466641786205224, 0.12466641786205224, 0.12466641786205224, 0.11415473089878869, 0.11415473089878869, 0.11415473089878869, 0.0923104877014681, 0.0923104877014681, 0.0923104877014681, 0.17339002303172313, 0.17339002303172313, 0.17339002303172313, 0.18152045511393222, 0.18152045511393222, 0.18152045511393222, 0.16073274719792696, 0.16073274719792696, 0.16073274719792696, 0.4159363364720542, 0.4159363364720542, 0.4159363364720542, 0.34556920995468776, 0.34556920995468776, 0.34556920995468776, 0.41594841236986557, 0.41594841236986557, 0.41594841236986557, 0.2466116004426665, 0.2466116004426665, 0.2466116004426665, 0.1830571152253988, 0.1830571152253988, 0.1830571152253988, 0.20774531825916875, 0.20774531825916875, 0.20774531825916875, 0.2300227433364822, 0.2300227433364822, 0.2300227433364822, 0.19229087718908344, 0.19229087718908344, 0.19229087718908344, 0.20228520984066678, 0.20228520984066678, 0.20228520984066678, 0.37466892042345334, 0.37466892042345334, 0.37466892042345334, 0.18932197564990416, 0.18932197564990416, 0.18932197564990416, 0.1982573478696662, 0.1982573478696662, 0.1982573478696662, 0.8672263224229617, 0.8672263224229617, 0.8672263224229617, 0.15657426590040613, 0.15657426590040613, 0.15657426590040613, 0.16703160124615302, 0.16703160124615302, 0.16703160124615302, 0.15226485400867185, 0.15226485400867185, 0.15226485400867185, 0.20647505179098724, 0.20647505179098724, 0.20647505179098724, 0.15431330710089475, 0.15431330710089475, 0.15431330710089475, 0.19473005571054536, 0.19473005571054536, 0.19473005571054536, 0.17845118224270795, 0.17845118224270795, 0.17845118224270795, 0.18097891176676595, 0.18097891176676595, 0.18097891176676595, 0.09661762099610349, 0.09661762099610349, 0.09661762099610349, 0.08046555539861389, 0.08046555539861389, 0.08046555539861389, 0.07859624457521042, 0.07859624457521042, 0.07859624457521042]}, "mutation_prompt": null}
{"id": "7a6c8b05-55ac-4639-9ac6-5f4dc591c4ba", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "c085a7ac-d88c-4060-8c53-df182c115365", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "d0972174-28fb-49fa-acff-7c42b3abd99c", "solution": "import numpy as np\n\nclass ImprovedDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            mutation_factor = self.F + 0.1 * np.sin(np.pi * evaluations / self.budget)\n\n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "ImprovedDEPSO", "description": "Improve DEPSO by introducing a dynamic population size and adaptive mutation strategies for enhanced exploration and exploitation balance.", "configspace": "", "generation": 58, "fitness": 0.29668288452931296, "feedback": "The algorithm ImprovedDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.825107035063928, 0.825107035063928, 0.825107035063928, 0.8153709854253495, 0.8153709854253495, 0.8153709854253495, 0.8206882397621877, 0.8206882397621877, 0.8206882397621877, 0.6284233558102625, 0.6284233558102625, 0.6284233558102625, 0.6825565322950597, 0.6825565322950597, 0.6825565322950597, 0.6195378427878651, 0.6195378427878651, 0.6195378427878651, 0.1214124759778229, 0.1214124759778229, 0.1214124759778229, 0.14419199041991448, 0.14419199041991448, 0.14419199041991448, 0.17531831123641095, 0.17531831123641095, 0.17531831123641095, 0.12688292180267802, 0.12688292180267802, 0.12688292180267802, 0.1283134798737654, 0.1283134798737654, 0.1283134798737654, 0.12320566113929943, 0.12320566113929943, 0.12320566113929943, 0.9731071187134492, 0.9731071187134492, 0.9731071187134492, 0.9679890736379951, 0.9679890736379951, 0.9679890736379951, 0.9626316746658578, 0.9626316746658578, 0.9626316746658578, 0.661147438878273, 0.661147438878273, 0.661147438878273, 0.6407376948331218, 0.6407376948331218, 0.6407376948331218, 0.6527360442356511, 0.6527360442356511, 0.6527360442356511, 0.30622359352866135, 0.30622359352866135, 0.30622359352866135, 0.2081146335419224, 0.2081146335419224, 0.2081146335419224, 0.22348861923719254, 0.22348861923719254, 0.22348861923719254, 0.11762958623229824, 0.11762958623229824, 0.11762958623229824, 0.12551081471080527, 0.12551081471080527, 0.12551081471080527, 0.19518437674033362, 0.19518437674033362, 0.19518437674033362, 0.22021576890894945, 0.22021576890894945, 0.22021576890894945, 0.20670425251972524, 0.20670425251972524, 0.20670425251972524, 0.2269348438934804, 0.2269348438934804, 0.2269348438934804, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023493744372410807, 0.023493744372410807, 0.023493744372410807, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04533281959406377, 0.04533281959406377, 0.04533281959406377, 0.029353984207372008, 0.029353984207372008, 0.029353984207372008, 0.09240796060367851, 0.09240796060367851, 0.09240796060367851, 0.04464537915864608, 0.04464537915864608, 0.04464537915864608, 0.07112818330219106, 0.07112818330219106, 0.07112818330219106, 0.11793711668540274, 0.11793711668540274, 0.11793711668540274, 0.0645720468252422, 0.0645720468252422, 0.0645720468252422, 0.2518662702825192, 0.2518662702825192, 0.2518662702825192, 0.13454202297376505, 0.13454202297376505, 0.13454202297376505, 0.5117835773550872, 0.5117835773550872, 0.5117835773550872, 0.5754435843713792, 0.5754435843713792, 0.5754435843713792, 0.5421226376540371, 0.5421226376540371, 0.5421226376540371, 0.1240107695038083, 0.1240107695038083, 0.1240107695038083, 0.15685754744774116, 0.15685754744774116, 0.15685754744774116, 0.1427016464945876, 0.1427016464945876, 0.1427016464945876, 0.2640363876500843, 0.2640363876500843, 0.2640363876500843, 0.25078901625104055, 0.25078901625104055, 0.25078901625104055, 0.16723669848345613, 0.16723669848345613, 0.16723669848345613, 0.3621160917385938, 0.3621160917385938, 0.3621160917385938, 0.22136875122766875, 0.22136875122766875, 0.22136875122766875, 0.280390145862093, 0.280390145862093, 0.280390145862093, 0.2774608980513973, 0.2774608980513973, 0.2774608980513973, 0.20280434892724075, 0.20280434892724075, 0.20280434892724075, 0.1351263791772238, 0.1351263791772238, 0.1351263791772238, 0.2013961832326644, 0.2013961832326644, 0.2013961832326644, 0.2010264803323507, 0.2010264803323507, 0.2010264803323507, 0.20486668203114233, 0.20486668203114233, 0.20486668203114233, 0.2025117305186398, 0.2025117305186398, 0.2025117305186398, 0.21074928439055984, 0.21074928439055984, 0.21074928439055984, 0.17627082035793484, 0.17627082035793484, 0.17627082035793484, 0.8689056489050587, 0.8689056489050587, 0.8689056489050587, 0.15587747146839137, 0.15587747146839137, 0.15587747146839137, 0.13535262020002392, 0.13535262020002392, 0.13535262020002392, 0.7945543231721379, 0.7945543231721379, 0.7945543231721379, 0.2081965299605404, 0.2081965299605404, 0.2081965299605404, 0.16468640029522907, 0.16468640029522907, 0.16468640029522907, 0.1805108011936667, 0.1805108011936667, 0.1805108011936667, 0.178559114515774, 0.178559114515774, 0.178559114515774, 0.17985836470075078, 0.17985836470075078, 0.17985836470075078, 0.09838770034361444, 0.09838770034361444, 0.09838770034361444, 0.09349684831836325, 0.09349684831836325, 0.09349684831836325, 0.11686830810070004, 0.11686830810070004, 0.11686830810070004]}, "mutation_prompt": null}
{"id": "a8ab6c54-d21a-4801-a70a-42711581d4a0", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "207c16b4-ff19-4d7d-a088-56401f07a1cb", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.1, self.w * (1 - evaluations / self.budget))  # Adjusted dynamic inertia weight\n            self.F = 0.6 + 0.4 * (1 - evaluations / self.budget) * np.random.rand()  # Adaptive F\n            self.CR = 0.7 + 0.3 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n            # Local Search Decay\n            for _ in range(2):  # Simple local search\n                local_test = global_best_position + np.random.randn(self.dim) * (0.05 * (self.upper_bound - self.lower_bound))\n                local_test = np.clip(local_test, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_test)\n                evaluations += 1\n                if local_fitness < func(global_best_position):\n                    global_best_position = local_test\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Introducing adaptive differential mutation and decay-based local search in DEPSO to enhance exploration and exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.29419811312757527, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.8280291957975014, 0.8280291957975014, 0.8280291957975014, 0.8230875324562693, 0.8230875324562693, 0.8230875324562693, 0.8150194860206846, 0.8150194860206846, 0.8150194860206846, 0.6816565604059122, 0.6816565604059122, 0.6816565604059122, 0.6952605672226528, 0.6952605672226528, 0.6952605672226528, 0.7093298211140939, 0.7093298211140939, 0.7093298211140939, 0.5984421329800962, 0.5984421329800962, 0.5984421329800962, 0.13561022030058534, 0.13561022030058534, 0.13561022030058534, 0.14666121313876523, 0.14666121313876523, 0.14666121313876523, 0.1697712086409372, 0.1697712086409372, 0.1697712086409372, 0.10713446181354414, 0.10713446181354414, 0.10713446181354414, 0.10497019845923405, 0.10497019845923405, 0.10497019845923405, 0.9730460829206236, 0.9730460829206236, 0.9730460829206236, 0.9688132950511035, 0.9688132950511035, 0.9688132950511035, 0.9697401322700628, 0.9697401322700628, 0.9697401322700628, 0.6462031424970766, 0.6462031424970766, 0.6462031424970766, 0.1972073022363281, 0.1972073022363281, 0.1972073022363281, 0.6672046112691867, 0.6672046112691867, 0.6672046112691867, 0.21754706781711552, 0.21754706781711552, 0.21754706781711552, 0.21235324646118137, 0.21235324646118137, 0.21235324646118137, 0.22676068570015628, 0.22676068570015628, 0.22676068570015628, 0.15290123509510245, 0.15290123509510245, 0.15290123509510245, 0.1688282964389518, 0.1688282964389518, 0.1688282964389518, 0.16397182237348462, 0.16397182237348462, 0.16397182237348462, 0.200321348451293, 0.200321348451293, 0.200321348451293, 0.1177586500331732, 0.1177586500331732, 0.1177586500331732, 0.11967927126568578, 0.11967927126568578, 0.11967927126568578, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0370396048194338, 0.0370396048194338, 0.0370396048194338, 0.060557867233532514, 0.060557867233532514, 0.060557867233532514, 0.04360320474650781, 0.04360320474650781, 0.04360320474650781, 0.032935777245981845, 0.032935777245981845, 0.032935777245981845, 0.07868997194802618, 0.07868997194802618, 0.07868997194802618, 0.09521431090238808, 0.09521431090238808, 0.09521431090238808, 0.10885734416117487, 0.10885734416117487, 0.10885734416117487, 0.14913065030456563, 0.14913065030456563, 0.14913065030456563, 0.05317830354411868, 0.05317830354411868, 0.05317830354411868, 0.4843262577077475, 0.4843262577077475, 0.4843262577077475, 0.4958381466556082, 0.4958381466556082, 0.4958381466556082, 0.5365602691662379, 0.5365602691662379, 0.5365602691662379, 0.10180100139651782, 0.10180100139651782, 0.10180100139651782, 0.11196611593061112, 0.11196611593061112, 0.11196611593061112, 0.13602360659747015, 0.13602360659747015, 0.13602360659747015, 0.2328223923828424, 0.2328223923828424, 0.2328223923828424, 0.22287391360685083, 0.22287391360685083, 0.22287391360685083, 0.21841378044431226, 0.21841378044431226, 0.21841378044431226, 0.35241738076508844, 0.35241738076508844, 0.35241738076508844, 0.3345000106224284, 0.3345000106224284, 0.3345000106224284, 0.5240417603620904, 0.5240417603620904, 0.5240417603620904, 0.21374449725498668, 0.21374449725498668, 0.21374449725498668, 0.21235188784192194, 0.21235188784192194, 0.21235188784192194, 0.26257517472103975, 0.26257517472103975, 0.26257517472103975, 0.19392875672397047, 0.19392875672397047, 0.19392875672397047, 0.22397323994729312, 0.22397323994729312, 0.22397323994729312, 0.2514869291716485, 0.2514869291716485, 0.2514869291716485, 0.19038568614939744, 0.19038568614939744, 0.19038568614939744, 0.20124464495021244, 0.20124464495021244, 0.20124464495021244, 0.1896540902322893, 0.1896540902322893, 0.1896540902322893, 0.8668945618234665, 0.8668945618234665, 0.8668945618234665, 0.1552286599854097, 0.1552286599854097, 0.1552286599854097, 0.16505058732209965, 0.16505058732209965, 0.16505058732209965, 0.659989056859014, 0.659989056859014, 0.659989056859014, 0.20659599740416879, 0.20659599740416879, 0.20659599740416879, 0.15355837581553444, 0.15355837581553444, 0.15355837581553444, 0.18207207394313452, 0.18207207394313452, 0.18207207394313452, 0.2002383388655291, 0.2002383388655291, 0.2002383388655291, 0.17013532783813023, 0.17013532783813023, 0.17013532783813023, 0.08583641322681046, 0.08583641322681046, 0.08583641322681046, 0.08023505213232474, 0.08023505213232474, 0.08023505213232474, 0.08868433420270028, 0.08868433420270028, 0.08868433420270028]}, "mutation_prompt": null}
{"id": "52e92cd8-96f2-4c52-91fe-ae272bc2e58e", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "5b3388c4-3ad9-4326-a1d1-a3b33aeed946", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "69b79117-e578-4db0-8b81-26d6efa0221c", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "86eb63eb-b15f-43fb-bc80-53067d825581", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "c1803d38-ac7d-4e38-9f9d-627265df82cd", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by incorporating adaptive learning rates and elitism to improve convergence and robustness.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.827278334715471, 0.827278334715471, 0.827278334715471, 0.8222719813411344, 0.8222719813411344, 0.8222719813411344, 0.8348793501177629, 0.8348793501177629, 0.8348793501177629, 0.6897946325242338, 0.6897946325242338, 0.6897946325242338, 0.6895243949110026, 0.6895243949110026, 0.6895243949110026, 0.5793285066318739, 0.5793285066318739, 0.5793285066318739, 0.16410270024523088, 0.16410270024523088, 0.16410270024523088, 0.14765432679426627, 0.14765432679426627, 0.14765432679426627, 0.16512358895718093, 0.16512358895718093, 0.16512358895718093, 0.14699899520720316, 0.14699899520720316, 0.14699899520720316, 0.1059784514903096, 0.1059784514903096, 0.1059784514903096, 0.1300435924365425, 0.1300435924365425, 0.1300435924365425, 0.9731062456189234, 0.9731062456189234, 0.9731062456189234, 0.967988233159199, 0.967988233159199, 0.967988233159199, 0.9626309062126166, 0.9626309062126166, 0.9626309062126166, 0.6376806152973393, 0.6376806152973393, 0.6376806152973393, 0.614065226491641, 0.614065226491641, 0.614065226491641, 0.6288975127839298, 0.6288975127839298, 0.6288975127839298, 0.7009284776587047, 0.7009284776587047, 0.7009284776587047, 0.16152685007756684, 0.16152685007756684, 0.16152685007756684, 0.3401519608892738, 0.3401519608892738, 0.3401519608892738, 0.19366823645362063, 0.19366823645362063, 0.19366823645362063, 0.12429211258580397, 0.12429211258580397, 0.12429211258580397, 0.17519814435049297, 0.17519814435049297, 0.17519814435049297, 0.20251690979943504, 0.20251690979943504, 0.20251690979943504, 0.18950567863906043, 0.18950567863906043, 0.18950567863906043, 0.24010809366114194, 0.24010809366114194, 0.24010809366114194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05919544281251454, 0.05919544281251454, 0.05919544281251454, 0.010461245913399253, 0.010461245913399253, 0.010461245913399253, 0.06532375779700739, 0.06532375779700739, 0.06532375779700739, 0.04434962405966947, 0.04434962405966947, 0.04434962405966947, 0.07021028460867729, 0.07021028460867729, 0.07021028460867729, 0.08890825578645367, 0.08890825578645367, 0.08890825578645367, 0.18467193139677407, 0.18467193139677407, 0.18467193139677407, 0.08991732768592098, 0.08991732768592098, 0.08991732768592098, 0.07916273835013565, 0.07916273835013565, 0.07916273835013565, 0.5226941962290244, 0.5226941962290244, 0.5226941962290244, 0.5547542387351195, 0.5547542387351195, 0.5547542387351195, 0.584807269098347, 0.584807269098347, 0.584807269098347, 0.09968354497170617, 0.09968354497170617, 0.09968354497170617, 0.13566218477125824, 0.13566218477125824, 0.13566218477125824, 0.12120272042942726, 0.12120272042942726, 0.12120272042942726, 0.18833404001048792, 0.18833404001048792, 0.18833404001048792, 0.14226100671656383, 0.14226100671656383, 0.14226100671656383, 0.29550064978237955, 0.29550064978237955, 0.29550064978237955, 0.372683467929265, 0.372683467929265, 0.372683467929265, 0.42415633346226145, 0.42415633346226145, 0.42415633346226145, 0.48642030209659537, 0.48642030209659537, 0.48642030209659537, 0.24216133734950807, 0.24216133734950807, 0.24216133734950807, 0.17850456013916172, 0.17850456013916172, 0.17850456013916172, 0.2172991234694719, 0.2172991234694719, 0.2172991234694719, 0.2171174114815071, 0.2171174114815071, 0.2171174114815071, 0.2404596023169746, 0.2404596023169746, 0.2404596023169746, 0.18259617419613583, 0.18259617419613583, 0.18259617419613583, 0.21419427084840648, 0.21419427084840648, 0.21419427084840648, 0.19983742279884253, 0.19983742279884253, 0.19983742279884253, 0.20488541251456638, 0.20488541251456638, 0.20488541251456638, 0.8590909484155203, 0.8590909484155203, 0.8590909484155203, 0.15300752245896387, 0.15300752245896387, 0.15300752245896387, 0.13517791758848086, 0.13517791758848086, 0.13517791758848086, 0.6543185975190766, 0.6543185975190766, 0.6543185975190766, 0.20835690266235773, 0.20835690266235773, 0.20835690266235773, 0.16469695019635577, 0.16469695019635577, 0.16469695019635577, 0.19946891536845301, 0.19946891536845301, 0.19946891536845301, 0.199888194311731, 0.199888194311731, 0.199888194311731, 0.18477659091455667, 0.18477659091455667, 0.18477659091455667, 0.09294244311541933, 0.09294244311541933, 0.09294244311541933, 0.08839977536850618, 0.08839977536850618, 0.08839977536850618, 0.10292463110636985, 0.10292463110636985, 0.10292463110636985]}, "mutation_prompt": null}
{"id": "69e61ec7-b064-40de-a8bc-81e154caa677", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 66, "fitness": 0.3103205928816674, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "70fe1a72-87d7-4d62-b167-13f052b6dc8a", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "b14bb6db-84f1-4ae0-9aab-b91c33f8dda7", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "29f40976-9f00-407e-953a-98833c66418f", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "5c505451-1e3b-4683-8f98-aa0e038bdd73", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "b7067b83-5f8f-4455-bbfe-65bf6a4dd130", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "a32408d8-7abe-4868-8508-036ed74832e1", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "a36b702c-f835-4ccb-915a-f43f2792092c", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c) * (1 + np.var(fitness))  # Adaptive mutation scaling\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                competitors = np.random.choice(current_population_size, 2, replace=False)\n                winner = competitors[np.argmin(fitness[competitors])]  # Tournament selection\n                velocities[i] = (self.w * velocities[i] \n                                + self.c1 * np.random.rand(self.dim) * (personal_best_positions[winner] - pop[i])\n                                + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by introducing tournament selection for better diversity and adaptive mutation scaling based on fitness variance to improve convergence.", "configspace": "", "generation": 72, "fitness": 0.21540438395859235, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.23.", "error": "", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.6846648339280821, 0.6846648339280821, 0.6846648339280821, 0.7222458100453717, 0.7222458100453717, 0.7222458100453717, 0.6941281176656573, 0.6941281176656573, 0.6941281176656573, 0.4981139261292903, 0.4981139261292903, 0.4981139261292903, 0.48446519157001033, 0.48446519157001033, 0.48446519157001033, 0.5075713875575106, 0.5075713875575106, 0.5075713875575106, 0.0901760460290505, 0.0901760460290505, 0.0901760460290505, 0.09095922169491477, 0.09095922169491477, 0.09095922169491477, 0.0865980049913675, 0.0865980049913675, 0.0865980049913675, 0.08001820980688135, 0.08001820980688135, 0.08001820980688135, 0.08440206152645935, 0.08440206152645935, 0.08440206152645935, 0.07814096842359486, 0.07814096842359486, 0.07814096842359486, 0.9847744559320517, 0.9847744559320517, 0.9847744559320517, 0.9789971051975108, 0.9789971051975108, 0.9789971051975108, 0.9711166035361619, 0.9711166035361619, 0.9711166035361619, 0.10359783898893327, 0.10359783898893327, 0.10359783898893327, 0.13751198187483793, 0.13751198187483793, 0.13751198187483793, 0.4370220777218542, 0.4370220777218542, 0.4370220777218542, 0.1555732163736253, 0.1555732163736253, 0.1555732163736253, 0.19609372374148215, 0.19609372374148215, 0.19609372374148215, 0.11595320524324526, 0.11595320524324526, 0.11595320524324526, 0.16349555669968463, 0.16349555669968463, 0.16349555669968463, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16685674783617765, 0.16685674783617765, 0.16685674783617765, 0.00986444208416104, 0.00986444208416104, 0.00986444208416104, 0.1849517622330058, 0.1849517622330058, 0.1849517622330058, 0.029277845858023843, 0.029277845858023843, 0.029277845858023843, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03869740210097461, 0.03869740210097461, 0.03869740210097461, 0.04151024454733365, 0.04151024454733365, 0.04151024454733365, 0.0075638946440081956, 0.0075638946440081956, 0.0075638946440081956, 0.038658235806247054, 0.038658235806247054, 0.038658235806247054, 0.055670863485437594, 0.055670863485437594, 0.055670863485437594, 0.07564693630647745, 0.07564693630647745, 0.07564693630647745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059607974668983155, 0.059607974668983155, 0.059607974668983155, 0.06845942570754504, 0.06845942570754504, 0.06845942570754504, 0.42295923582130335, 0.42295923582130335, 0.42295923582130335, 0.45230341388002904, 0.45230341388002904, 0.45230341388002904, 0.45071598675387736, 0.45071598675387736, 0.45071598675387736, 0.08422443482709319, 0.08422443482709319, 0.08422443482709319, 0.08878962371783072, 0.08878962371783072, 0.08878962371783072, 0.08801316634060075, 0.08801316634060075, 0.08801316634060075, 0.1382205027240705, 0.1382205027240705, 0.1382205027240705, 0.09903027992785063, 0.09903027992785063, 0.09903027992785063, 0.182270962488835, 0.182270962488835, 0.182270962488835, 0.3663099243653076, 0.3663099243653076, 0.3663099243653076, 0.20615513725589574, 0.20615513725589574, 0.20615513725589574, 0.3959853421524352, 0.3959853421524352, 0.3959853421524352, 0.2182388563430231, 0.2182388563430231, 0.2182388563430231, 0.18682302703440956, 0.18682302703440956, 0.18682302703440956, 0.1889165756149439, 0.1889165756149439, 0.1889165756149439, 0.16790630078903268, 0.16790630078903268, 0.16790630078903268, 0.180726033383227, 0.180726033383227, 0.180726033383227, 0.1858812404372473, 0.1858812404372473, 0.1858812404372473, 0.1837349422377197, 0.1837349422377197, 0.1837349422377197, 0.29806914861343303, 0.29806914861343303, 0.29806914861343303, 0.17054253810452225, 0.17054253810452225, 0.17054253810452225, 0.14530882433263936, 0.14530882433263936, 0.14530882433263936, 0.13803153546281355, 0.13803153546281355, 0.13803153546281355, 0.12371312146633295, 0.12371312146633295, 0.12371312146633295, 0.10784216424882853, 0.10784216424882853, 0.10784216424882853, 0.19878842267667673, 0.19878842267667673, 0.19878842267667673, 0.19126529716877017, 0.19126529716877017, 0.19126529716877017, 0.1853493879510294, 0.1853493879510294, 0.1853493879510294, 0.14959395448077617, 0.14959395448077617, 0.14959395448077617, 0.18652421872628888, 0.18652421872628888, 0.18652421872628888, 0.06697380721698987, 0.06697380721698987, 0.06697380721698987, 0.06934470560947614, 0.06934470560947614, 0.06934470560947614, 0.06767821290938758, 0.06767821290938758, 0.06767821290938758]}, "mutation_prompt": null}
{"id": "baf9dba9-eed5-498e-ab3a-8a5cf5a0abc6", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "ee1e5fdc-c0f8-4cc6-b29d-725f18463fcb", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "e7f4c617-d7d0-41c5-a4a2-47bff1d82ce4", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "f5160c0b-a83b-41ba-af60-f368da40c398", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "502051e6-9d32-4f13-8443-d584c4b53cf8", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "f166bac3-f98b-46e9-8f80-31bea7005dc7", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "db71d8c0-df42-4640-bb8c-1fb8b0045efd", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            diversity = np.std(pop, axis=0).mean()\n            self.F = 0.5 + 0.5 * diversity  # Dynamic differential weight based on diversity\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n            # Local search for intensification\n            if evaluations + self.dim <= self.budget:\n                local_search = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                local_fitness = func(local_search)\n                evaluations += self.dim\n                if local_fitness < func(global_best_position):\n                    global_best_position = local_search\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by introducing a dynamic differential weight based on population diversity and a local search phase for intensification.", "configspace": "", "generation": 79, "fitness": 0.28976555727561376, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8105784554544456, 0.8105784554544456, 0.8105784554544456, 0.8124832792677721, 0.8124832792677721, 0.8124832792677721, 0.8139920532958783, 0.8139920532958783, 0.8139920532958783, 0.6749217670930505, 0.6749217670930505, 0.6749217670930505, 0.6804935440451351, 0.6804935440451351, 0.6804935440451351, 0.6753749935318489, 0.6753749935318489, 0.6753749935318489, 0.14581047128141067, 0.14581047128141067, 0.14581047128141067, 0.1421095489253521, 0.1421095489253521, 0.1421095489253521, 0.16841474922710187, 0.16841474922710187, 0.16841474922710187, 0.11659795179587995, 0.11659795179587995, 0.11659795179587995, 0.12426622538682075, 0.12426622538682075, 0.12426622538682075, 0.10368490521407969, 0.10368490521407969, 0.10368490521407969, 0.9731873926182615, 0.9731873926182615, 0.9731873926182615, 0.970010132725316, 0.970010132725316, 0.970010132725316, 0.9651884013625106, 0.9651884013625106, 0.9651884013625106, 0.6238491350079636, 0.6238491350079636, 0.6238491350079636, 0.4470916478900796, 0.4470916478900796, 0.4470916478900796, 0.08923266785402051, 0.08923266785402051, 0.08923266785402051, 0.3601223279201097, 0.3601223279201097, 0.3601223279201097, 0.16012245296846617, 0.16012245296846617, 0.16012245296846617, 0.21291674523271154, 0.21291674523271154, 0.21291674523271154, 0.17538503318076726, 0.17538503318076726, 0.17538503318076726, 0.18324317483439034, 0.18324317483439034, 0.18324317483439034, 0.10777796657431826, 0.10777796657431826, 0.10777796657431826, 0.20114809778671716, 0.20114809778671716, 0.20114809778671716, 0.12237980148303773, 0.12237980148303773, 0.12237980148303773, 0.18890400030780852, 0.18890400030780852, 0.18890400030780852, 0.044045863554081244, 0.044045863554081244, 0.044045863554081244, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04080547654787092, 0.04080547654787092, 0.04080547654787092, 0.010156154408685558, 0.010156154408685558, 0.010156154408685558, 0.06438192203349447, 0.06438192203349447, 0.06438192203349447, 0.061748953862246214, 0.061748953862246214, 0.061748953862246214, 0.17158848693534456, 0.17158848693534456, 0.17158848693534456, 0.0912538574696824, 0.0912538574696824, 0.0912538574696824, 0.10802159998569982, 0.10802159998569982, 0.10802159998569982, 0.18373403053456916, 0.18373403053456916, 0.18373403053456916, 0.0765398674611184, 0.0765398674611184, 0.0765398674611184, 0.48741475963764125, 0.48741475963764125, 0.48741475963764125, 0.5152905482601948, 0.5152905482601948, 0.5152905482601948, 0.524405583865377, 0.524405583865377, 0.524405583865377, 0.1324619055502877, 0.1324619055502877, 0.1324619055502877, 0.10163482893902342, 0.10163482893902342, 0.10163482893902342, 0.09857058866422008, 0.09857058866422008, 0.09857058866422008, 0.2173976114270828, 0.2173976114270828, 0.2173976114270828, 0.1561889981815564, 0.1561889981815564, 0.1561889981815564, 0.23274004507127333, 0.23274004507127333, 0.23274004507127333, 0.28632477302821957, 0.28632477302821957, 0.28632477302821957, 0.5450242034942414, 0.5450242034942414, 0.5450242034942414, 0.4515322170711915, 0.4515322170711915, 0.4515322170711915, 0.18994055252270947, 0.18994055252270947, 0.18994055252270947, 0.18223850866675406, 0.18223850866675406, 0.18223850866675406, 0.11897237265026417, 0.11897237265026417, 0.11897237265026417, 0.20591444332978348, 0.20591444332978348, 0.20591444332978348, 0.20274584066909107, 0.20274584066909107, 0.20274584066909107, 0.2023754256125001, 0.2023754256125001, 0.2023754256125001, 0.20494471408574344, 0.20494471408574344, 0.20494471408574344, 0.23960187235955077, 0.23960187235955077, 0.23960187235955077, 0.1897441578406448, 0.1897441578406448, 0.1897441578406448, 0.8422591596744309, 0.8422591596744309, 0.8422591596744309, 0.8301000869680724, 0.8301000869680724, 0.8301000869680724, 0.16037575069886045, 0.16037575069886045, 0.16037575069886045, 0.47755594902619036, 0.47755594902619036, 0.47755594902619036, 0.20705413084194313, 0.20705413084194313, 0.20705413084194313, 0.1526124190792909, 0.1526124190792909, 0.1526124190792909, 0.17678731815625948, 0.17678731815625948, 0.17678731815625948, 0.1769941474630754, 0.1769941474630754, 0.1769941474630754, 0.1870084777046629, 0.1870084777046629, 0.1870084777046629, 0.09017235839097815, 0.09017235839097815, 0.09017235839097815, 0.08327864627705328, 0.08327864627705328, 0.08327864627705328, 0.09169459357798004, 0.09169459357798004, 0.09169459357798004]}, "mutation_prompt": null}
{"id": "83665a1f-67d5-4309-8c9b-a6a3e916acaf", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "ba25d621-6b12-4676-8696-6c5d7f87a9e4", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "93a10619-bdf8-4fe8-92f7-02f7c3955943", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                if i % 10 == 0:  # Adjust topology every 10 iterations\n                    velocities[i] = (self.w * velocities[i] \n                                     + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                     + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n            # Local search around the global best\n            if evaluations + 5 <= self.budget:\n                local_search = global_best_position + 0.1 * np.random.randn(self.dim)\n                local_search = np.clip(local_search, self.lower_bound, self.upper_bound)\n                local_search_fitness = func(local_search)\n                evaluations += 1\n                if local_search_fitness < func(global_best_position):\n                    global_best_position = local_search\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by integrating a dynamic swarm topology adjustment based on evaluations and introducing a local search around the global best to refine exploitation.", "configspace": "", "generation": 82, "fitness": 0.18143464067658177, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.3912273589916315, 0.3912273589916315, 0.3912273589916315, 0.39966727193838236, 0.39966727193838236, 0.39966727193838236, 0.45340027324633203, 0.45340027324633203, 0.45340027324633203, 0.0966979329182841, 0.0966979329182841, 0.0966979329182841, 0.0933966955569554, 0.0933966955569554, 0.0933966955569554, 0.08283048196462006, 0.08283048196462006, 0.08283048196462006, 0.10564217083379812, 0.10564217083379812, 0.10564217083379812, 0.09622938425689975, 0.09622938425689975, 0.09622938425689975, 0.0963661021603559, 0.0963661021603559, 0.0963661021603559, 0.09491655130089605, 0.09491655130089605, 0.09491655130089605, 0.05887379280473526, 0.05887379280473526, 0.05887379280473526, 0.07377124762982112, 0.07377124762982112, 0.07377124762982112, 0.9590375620220757, 0.9590375620220757, 0.9590375620220757, 0.9480521794479696, 0.9480521794479696, 0.9480521794479696, 0.9241209327200725, 0.9241209327200725, 0.9241209327200725, 0.14566678549523693, 0.14566678549523693, 0.14566678549523693, 0.2237519819684204, 0.2237519819684204, 0.2237519819684204, 0.22469752522958963, 0.22469752522958963, 0.22469752522958963, 0.15549880912160807, 0.15549880912160807, 0.15549880912160807, 0.14882162856695014, 0.14882162856695014, 0.14882162856695014, 0.1112842759877396, 0.1112842759877396, 0.1112842759877396, 0.15094322872482857, 0.15094322872482857, 0.15094322872482857, 0.11081374450857218, 0.11081374450857218, 0.11081374450857218, 0.1321304314484283, 0.1321304314484283, 0.1321304314484283, 0.05633330198726161, 0.05633330198726161, 0.05633330198726161, 0.15097019824615687, 0.15097019824615687, 0.15097019824615687, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026811448420217654, 0.026811448420217654, 0.026811448420217654, 0.008235375255047028, 0.008235375255047028, 0.008235375255047028, 0.05949179610605937, 0.05949179610605937, 0.05949179610605937, 0.0015904839675138227, 0.0015904839675138227, 0.0015904839675138227, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07521324035456034, 0.07521324035456034, 0.07521324035456034, 0.09331518013106066, 0.09331518013106066, 0.09331518013106066, 0.0936277024208122, 0.0936277024208122, 0.0936277024208122, 0.16863767875604385, 0.16863767875604385, 0.16863767875604385, 0.3980228191705504, 0.3980228191705504, 0.3980228191705504, 0.3550447167936074, 0.3550447167936074, 0.3550447167936074, 0.3351608638335305, 0.3351608638335305, 0.3351608638335305, 0.07553374105769539, 0.07553374105769539, 0.07553374105769539, 0.07585960462652763, 0.07585960462652763, 0.07585960462652763, 0.054427582664390295, 0.054427582664390295, 0.054427582664390295, 0.1478416272408254, 0.1478416272408254, 0.1478416272408254, 0.17089806730702273, 0.17089806730702273, 0.17089806730702273, 0.1411452252115336, 0.1411452252115336, 0.1411452252115336, 0.23863243205564955, 0.23863243205564955, 0.23863243205564955, 0.24183755794226258, 0.24183755794226258, 0.24183755794226258, 0.19830949812141552, 0.19830949812141552, 0.19830949812141552, 0.14778407062033017, 0.14778407062033017, 0.14778407062033017, 0.15512592031567352, 0.15512592031567352, 0.15512592031567352, 0.1914324460170156, 0.1914324460170156, 0.1914324460170156, 0.17730423511115478, 0.17730423511115478, 0.17730423511115478, 0.19798965272974667, 0.19798965272974667, 0.19798965272974667, 0.1725224030958249, 0.1725224030958249, 0.1725224030958249, 0.16337834028618436, 0.16337834028618436, 0.16337834028618436, 0.16636300343453037, 0.16636300343453037, 0.16636300343453037, 0.1761614005619282, 0.1761614005619282, 0.1761614005619282, 0.1853502919188953, 0.1853502919188953, 0.1853502919188953, 0.38625356877280326, 0.38625356877280326, 0.38625356877280326, 0.17024126262581718, 0.17024126262581718, 0.17024126262581718, 0.1645315437561381, 0.1645315437561381, 0.1645315437561381, 0.18097669133328198, 0.18097669133328198, 0.18097669133328198, 0.1963980325090522, 0.1963980325090522, 0.1963980325090522, 0.17551728647127784, 0.17551728647127784, 0.17551728647127784, 0.1754936379355817, 0.1754936379355817, 0.1754936379355817, 0.2552027356966263, 0.2552027356966263, 0.2552027356966263, 0.060429278011963294, 0.060429278011963294, 0.060429278011963294, 0.06400000795510385, 0.06400000795510385, 0.06400000795510385, 0.05555982904101109, 0.05555982904101109, 0.05555982904101109]}, "mutation_prompt": null}
{"id": "290d9518-ee6b-4fa7-bd91-270c4e6e4faa", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n            mutation_rate = np.linalg.norm(global_best_position - pop, axis=1) / self.dim\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = np.random.choice(current_population_size, 3, replace=False)\n                a, b, c = pop[idxs]\n                step = self.F * (b - c)\n                if np.random.rand() < mutation_rate[i]:  # Dynamic mutation rate\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by adding a stochastic tournament selection mechanism for maintaining diversity and introduce a dynamic mutation rate based on distance to the global best position.", "configspace": "", "generation": 83, "fitness": 0.2886398470204049, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8209026372547119, 0.8209026372547119, 0.8209026372547119, 0.8191369235459958, 0.8191369235459958, 0.8191369235459958, 0.8261352866084901, 0.8261352866084901, 0.8261352866084901, 0.6110709673021898, 0.6110709673021898, 0.6110709673021898, 0.6279311949896696, 0.6279311949896696, 0.6279311949896696, 0.677806810101038, 0.677806810101038, 0.677806810101038, 0.13622003583237452, 0.13622003583237452, 0.13622003583237452, 0.11203180026617099, 0.11203180026617099, 0.11203180026617099, 0.4755364709301403, 0.4755364709301403, 0.4755364709301403, 0.126623879285377, 0.126623879285377, 0.126623879285377, 0.10051804469359527, 0.10051804469359527, 0.10051804469359527, 0.09826419417189114, 0.09826419417189114, 0.09826419417189114, 0.967772790946154, 0.967772790946154, 0.967772790946154, 0.969341762348169, 0.969341762348169, 0.969341762348169, 0.969149725404866, 0.969149725404866, 0.969149725404866, 0.6640505042669435, 0.6640505042669435, 0.6640505042669435, 0.5919033010159356, 0.5919033010159356, 0.5919033010159356, 0.6620439786971843, 0.6620439786971843, 0.6620439786971843, 0.13765200812419498, 0.13765200812419498, 0.13765200812419498, 0.19041594672585482, 0.19041594672585482, 0.19041594672585482, 0.3358344779216801, 0.3358344779216801, 0.3358344779216801, 0.17898891134003114, 0.17898891134003114, 0.17898891134003114, 0.12192823821268906, 0.12192823821268906, 0.12192823821268906, 0.1932108988633484, 0.1932108988633484, 0.1932108988633484, 0.19221168800691035, 0.19221168800691035, 0.19221168800691035, 0.11863962441369735, 0.11863962441369735, 0.11863962441369735, 0.17679856390084403, 0.17679856390084403, 0.17679856390084403, 0.00047991697610483275, 0.00047991697610483275, 0.00047991697610483275, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020986182268803555, 0.020986182268803555, 0.020986182268803555, 0.030320399303932932, 0.030320399303932932, 0.030320399303932932, 0.027284212405303654, 0.027284212405303654, 0.027284212405303654, 0.06610344131389811, 0.06610344131389811, 0.06610344131389811, 0.09865104849330453, 0.09865104849330453, 0.09865104849330453, 0.08703604710475343, 0.08703604710475343, 0.08703604710475343, 0.14092401558695944, 0.14092401558695944, 0.14092401558695944, 0.036074497257615246, 0.036074497257615246, 0.036074497257615246, 0.052589654858999024, 0.052589654858999024, 0.052589654858999024, 0.4917618361096874, 0.4917618361096874, 0.4917618361096874, 0.5208984200686098, 0.5208984200686098, 0.5208984200686098, 0.5143842378302976, 0.5143842378302976, 0.5143842378302976, 0.10970268306500897, 0.10970268306500897, 0.10970268306500897, 0.10391009732175949, 0.10391009732175949, 0.10391009732175949, 0.0795522505458548, 0.0795522505458548, 0.0795522505458548, 0.37903257316974526, 0.37903257316974526, 0.37903257316974526, 0.2805849234626997, 0.2805849234626997, 0.2805849234626997, 0.2331469762056385, 0.2331469762056385, 0.2331469762056385, 0.2636495875141347, 0.2636495875141347, 0.2636495875141347, 0.3214727591801543, 0.3214727591801543, 0.3214727591801543, 0.5839222651857607, 0.5839222651857607, 0.5839222651857607, 0.17465175587162773, 0.17465175587162773, 0.17465175587162773, 0.2945821961758426, 0.2945821961758426, 0.2945821961758426, 0.1592590398294489, 0.1592590398294489, 0.1592590398294489, 0.24201536901568765, 0.24201536901568765, 0.24201536901568765, 0.20123049386962266, 0.20123049386962266, 0.20123049386962266, 0.23285484617939833, 0.23285484617939833, 0.23285484617939833, 0.1980897943983445, 0.1980897943983445, 0.1980897943983445, 0.20274241058261278, 0.20274241058261278, 0.20274241058261278, 0.20199661748834719, 0.20199661748834719, 0.20199661748834719, 0.8622100053701103, 0.8622100053701103, 0.8622100053701103, 0.12228853322541722, 0.12228853322541722, 0.12228853322541722, 0.1688531219638285, 0.1688531219638285, 0.1688531219638285, 0.20706046986448778, 0.20706046986448778, 0.20706046986448778, 0.20525938789819453, 0.20525938789819453, 0.20525938789819453, 0.15294142723199255, 0.15294142723199255, 0.15294142723199255, 0.18173160971597146, 0.18173160971597146, 0.18173160971597146, 0.18234493050140788, 0.18234493050140788, 0.18234493050140788, 0.18464534300810465, 0.18464534300810465, 0.18464534300810465, 0.07564013712441342, 0.07564013712441342, 0.07564013712441342, 0.07836598611694878, 0.07836598611694878, 0.07836598611694878, 0.10851681963817061, 0.10851681963817061, 0.10851681963817061]}, "mutation_prompt": null}
{"id": "f0212d36-32ea-435d-9a2a-a514566f00d8", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "5bcd0687-6afd-469c-b29b-f183afb28fef", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "ec887dff-f7ba-407b-990c-b1d152e352ed", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "1f5310b6-dfb5-43e0-8beb-41c321c40a78", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "633fb98a-e367-4669-8918-8881d30c73de", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "d20f46c7-e1f8-438c-b0e5-b8ba483da373", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "ef2f080c-2cac-4d86-af3f-703161127ab3", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "08f5c276-fc7d-4cb7-9d80-bb07831182c0", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Adjusted initial velocity range\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            # Stochastic tournament selection\n            selected = np.random.choice(np.arange(current_population_size), current_population_size, replace=True, p=np.exp(-fitness / np.sum(fitness)))\n            for i in selected:\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)  # Adaptive velocity clamping\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by incorporating a stochastic tournament selection mechanism and adaptive velocity clamping to enhance convergence stability and diversity.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {}, "mutation_prompt": null}
{"id": "425685a5-8dc0-4263-8b0a-a2ba6235f7bd", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "88333fef-6777-47a8-bda8-aae9c276b8fa", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "0412b3b5-e289-4731-8a61-f76f6d0a7fba", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "0f27f08b-9988-4adb-a49c-e85a1f052563", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "40812755-e733-43a8-b644-66131a09d2cd", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "56b41b09-7f00-482e-b125-f1806797f91a", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
{"id": "add052dc-f6c7-4470-875a-29cdc793822e", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        previous_global_best_fitness = func(global_best_position)\n        \n        while evaluations < self.budget:\n            improvement_rate = (previous_global_best_fitness - func(global_best_position)) / abs(previous_global_best_fitness)\n            self.w = max(0.2, self.w - 0.1 * improvement_rate)  # Intelligent inertia weight update\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget * 0.5)))  # Adaptive size\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n            previous_global_best_fitness = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Enhance DEPSO by integrating an adaptive population size reduction and intelligent inertia weight update based on fitness improvement rate.", "configspace": "", "generation": 98, "fitness": 0.21243061552815587, "feedback": "The algorithm DEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.5239065964538487, 0.5239065964538487, 0.5239065964538487, 0.5287333689228142, 0.5287333689228142, 0.5287333689228142, 0.5187929787766, 0.5187929787766, 0.5187929787766, 0.12157757710682104, 0.12157757710682104, 0.12157757710682104, 0.178652979470162, 0.178652979470162, 0.178652979470162, 0.13656787785690194, 0.13656787785690194, 0.13656787785690194, 0.09205537016376819, 0.09205537016376819, 0.09205537016376819, 0.09941597990256201, 0.09941597990256201, 0.09941597990256201, 0.08851963639265692, 0.08851963639265692, 0.08851963639265692, 0.08816920159891795, 0.08816920159891795, 0.08816920159891795, 0.08380025341711539, 0.08380025341711539, 0.08380025341711539, 0.09175341469819265, 0.09175341469819265, 0.09175341469819265, 0.9698700990848239, 0.9698700990848239, 0.9698700990848239, 0.9740464226252648, 0.9740464226252648, 0.9740464226252648, 0.9591300657757238, 0.9591300657757238, 0.9591300657757238, 0.213100146041317, 0.213100146041317, 0.213100146041317, 0.27143230534143614, 0.27143230534143614, 0.27143230534143614, 0.24347419019641314, 0.24347419019641314, 0.24347419019641314, 0.23656551451962782, 0.23656551451962782, 0.23656551451962782, 0.1988743861039335, 0.1988743861039335, 0.1988743861039335, 0.39905321509699576, 0.39905321509699576, 0.39905321509699576, 0.14753876266433563, 0.14753876266433563, 0.14753876266433563, 0.1436451186369062, 0.1436451186369062, 0.1436451186369062, 0.08881730159952517, 0.08881730159952517, 0.08881730159952517, 0.08230226019300424, 0.08230226019300424, 0.08230226019300424, 0.13650777903695, 0.13650777903695, 0.13650777903695, 0.1376381276154971, 0.1376381276154971, 0.1376381276154971, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04567028916258675, 0.04567028916258675, 0.04567028916258675, 0.009541210589169125, 0.009541210589169125, 0.009541210589169125, 0.04463644056780358, 0.04463644056780358, 0.04463644056780358, 0.020833616921995812, 0.020833616921995812, 0.020833616921995812, 0.03706141678103525, 0.03706141678103525, 0.03706141678103525, 0.05622234556566852, 0.05622234556566852, 0.05622234556566852, 0.074463880186457, 0.074463880186457, 0.074463880186457, 0.08469878857625168, 0.08469878857625168, 0.08469878857625168, 0.0684777171787595, 0.0684777171787595, 0.0684777171787595, 0.4039701084995112, 0.4039701084995112, 0.4039701084995112, 0.4340548253695212, 0.4340548253695212, 0.4340548253695212, 0.40367542269468815, 0.40367542269468815, 0.40367542269468815, 0.08991095175117403, 0.08991095175117403, 0.08991095175117403, 0.07883172994278631, 0.07883172994278631, 0.07883172994278631, 0.0885224144534208, 0.0885224144534208, 0.0885224144534208, 0.15143461890434518, 0.15143461890434518, 0.15143461890434518, 0.163091648409606, 0.163091648409606, 0.163091648409606, 0.17262666769351143, 0.17262666769351143, 0.17262666769351143, 0.2659910587886226, 0.2659910587886226, 0.2659910587886226, 0.22691954333888376, 0.22691954333888376, 0.22691954333888376, 0.26818836605619445, 0.26818836605619445, 0.26818836605619445, 0.15119843977235847, 0.15119843977235847, 0.15119843977235847, 0.1712047509170932, 0.1712047509170932, 0.1712047509170932, 0.21195626895045483, 0.21195626895045483, 0.21195626895045483, 0.18457608441043216, 0.18457608441043216, 0.18457608441043216, 0.1906811689429987, 0.1906811689429987, 0.1906811689429987, 0.175901607802318, 0.175901607802318, 0.175901607802318, 0.16334052791797926, 0.16334052791797926, 0.16334052791797926, 0.18586641854361452, 0.18586641854361452, 0.18586641854361452, 0.17925882823951345, 0.17925882823951345, 0.17925882823951345, 0.6452187376677403, 0.6452187376677403, 0.6452187376677403, 0.15781930332444294, 0.15781930332444294, 0.15781930332444294, 0.6077131855054614, 0.6077131855054614, 0.6077131855054614, 0.11098046422014507, 0.11098046422014507, 0.11098046422014507, 0.20740567370064777, 0.20740567370064777, 0.20740567370064777, 0.20238064771262532, 0.20238064771262532, 0.20238064771262532, 0.18142248910629077, 0.18142248910629077, 0.18142248910629077, 0.19234091347481563, 0.19234091347481563, 0.19234091347481563, 0.19247866854546902, 0.19247866854546902, 0.19247866854546902, 0.07637961185555764, 0.07637961185555764, 0.07637961185555764, 0.06986978403880328, 0.06986978403880328, 0.06986978403880328, 0.09394675265435348, 0.09394675265435348, 0.09394675265435348]}, "mutation_prompt": null}
{"id": "b0058e2b-13e8-4e0b-b98c-14c0d4f5e992", "solution": "import numpy as np\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5 # Cognitive component for PSO\n        self.c2 = 1.5 # Social component for PSO\n        self.F = 0.8  # Differential weight for DE\n        self.CR = 0.9 # Crossover probability for DE\n        \n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best_positions = np.copy(pop)\n        personal_best_fitness = np.copy(fitness)\n        global_best_position = pop[np.argmin(fitness)]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.w = max(0.2, self.w * (1 - evaluations / self.budget))  # Dynamic inertia weight\n            self.F = 0.5 + 0.5 * (1 - evaluations / self.budget) * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.exp(-np.var(fitness))  # Adaptive crossover rate\n\n            dynamic_size = max(10, int(self.population_size * (1 - evaluations / self.budget)))\n            current_population_size = min(self.population_size, dynamic_size)\n            \n            ranks = np.argsort(fitness)\n            for i in range(current_population_size):\n                idxs = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                step = self.F * (b - c)\n                if np.random.rand() < 0.3:  # Lvy flight mechanism\n                    step = step * np.random.standard_cauchy(self.dim)\n                mutant = np.clip(a + step, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best_position):\n                            global_best_position = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(current_population_size):\n                velocities[i] = (self.w * velocities[i] \n                                 + self.c1 * np.random.rand(self.dim) * (personal_best_positions[i] - pop[i])\n                                 + self.c2 * np.random.rand(self.dim) * (global_best_position - pop[i]))\n                pop[i] = np.clip(pop[i] + velocities[i], self.lower_bound, self.upper_bound)\n                \n                current_fitness = func(pop[i])\n                evaluations += 1\n                if current_fitness < fitness[i]:\n                    fitness[i] = current_fitness\n                    personal_best_positions[i] = pop[i]\n                    personal_best_fitness[i] = current_fitness\n                    if current_fitness < func(global_best_position):\n                        global_best_position = pop[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n            elite_idx = np.argmin(fitness)  # Elitism: Retain the best solution\n            pop[elite_idx] = global_best_position\n            fitness[elite_idx] = func(global_best_position)\n\n        return global_best_position, func(global_best_position)", "name": "DEPSO", "description": "Improve DEPSO by introducing a Lvy flight mechanism for enhanced exploration, and adaptive crossover rate using fitness variance to balance exploration and exploitation dynamically.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69e61ec7-b064-40de-a8bc-81e154caa677", "metadata": {"aucs": [0.8176117745018472, 0.8176117745018472, 0.8176117745018472, 0.8126411006542948, 0.8126411006542948, 0.8126411006542948, 0.8198632978593574, 0.8198632978593574, 0.8198632978593574, 0.6582294390727436, 0.6582294390727436, 0.6582294390727436, 0.6727861229585181, 0.6727861229585181, 0.6727861229585181, 0.6916793354473378, 0.6916793354473378, 0.6916793354473378, 0.16044292712394104, 0.16044292712394104, 0.16044292712394104, 0.1462037470144263, 0.1462037470144263, 0.1462037470144263, 0.6118792601724051, 0.6118792601724051, 0.6118792601724051, 0.128332610268721, 0.128332610268721, 0.128332610268721, 0.09804655179614497, 0.09804655179614497, 0.09804655179614497, 0.12612527236562543, 0.12612527236562543, 0.12612527236562543, 0.9691660565441584, 0.9691660565441584, 0.9691660565441584, 0.9744102303283405, 0.9744102303283405, 0.9744102303283405, 0.9587067608790266, 0.9587067608790266, 0.9587067608790266, 0.6697452441026506, 0.6697452441026506, 0.6697452441026506, 0.4278886730693462, 0.4278886730693462, 0.4278886730693462, 0.6290274663342788, 0.6290274663342788, 0.6290274663342788, 0.8189528231244956, 0.8189528231244956, 0.8189528231244956, 0.15912280487609298, 0.15912280487609298, 0.15912280487609298, 0.16993467345419644, 0.16993467345419644, 0.16993467345419644, 0.17767747263886957, 0.17767747263886957, 0.17767747263886957, 0.18171011487770983, 0.18171011487770983, 0.18171011487770983, 0.11900325460138317, 0.11900325460138317, 0.11900325460138317, 0.15880555750412406, 0.15880555750412406, 0.15880555750412406, 0.20852014314909062, 0.20852014314909062, 0.20852014314909062, 0.23405852445810937, 0.23405852445810937, 0.23405852445810937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0797190737295197, 0.0797190737295197, 0.0797190737295197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0626959294519629, 0.0626959294519629, 0.0626959294519629, 0.03407743072815539, 0.03407743072815539, 0.03407743072815539, 0.05075743847334069, 0.05075743847334069, 0.05075743847334069, 0.05648107663050428, 0.05648107663050428, 0.05648107663050428, 0.08349970099650195, 0.08349970099650195, 0.08349970099650195, 0.08886392076976246, 0.08886392076976246, 0.08886392076976246, 0.199586319180855, 0.199586319180855, 0.199586319180855, 0.036143815017256054, 0.036143815017256054, 0.036143815017256054, 0.07741957841770963, 0.07741957841770963, 0.07741957841770963, 0.5146183254037906, 0.5146183254037906, 0.5146183254037906, 0.4997482003358582, 0.4997482003358582, 0.4997482003358582, 0.5392555448242404, 0.5392555448242404, 0.5392555448242404, 0.1093690964666133, 0.1093690964666133, 0.1093690964666133, 0.12108733940939143, 0.12108733940939143, 0.12108733940939143, 0.11906219411943109, 0.11906219411943109, 0.11906219411943109, 0.17198412252182116, 0.17198412252182116, 0.17198412252182116, 0.16473845450934876, 0.16473845450934876, 0.16473845450934876, 0.16962110730634317, 0.16962110730634317, 0.16962110730634317, 0.3900433315686439, 0.3900433315686439, 0.3900433315686439, 0.21207887098254663, 0.21207887098254663, 0.21207887098254663, 0.3088923306183571, 0.3088923306183571, 0.3088923306183571, 0.22161210191827985, 0.22161210191827985, 0.22161210191827985, 0.16644554403684053, 0.16644554403684053, 0.16644554403684053, 0.16897807172943868, 0.16897807172943868, 0.16897807172943868, 0.1965720678944175, 0.1965720678944175, 0.1965720678944175, 0.21437481894189936, 0.21437481894189936, 0.21437481894189936, 0.2021359873721632, 0.2021359873721632, 0.2021359873721632, 0.19615497589670639, 0.19615497589670639, 0.19615497589670639, 0.20084633139241692, 0.20084633139241692, 0.20084633139241692, 0.21388384174645925, 0.21388384174645925, 0.21388384174645925, 0.8731964904340688, 0.8731964904340688, 0.8731964904340688, 0.15829277572131228, 0.15829277572131228, 0.15829277572131228, 0.8479079792411334, 0.8479079792411334, 0.8479079792411334, 0.11185061318236278, 0.11185061318236278, 0.11185061318236278, 0.20936389430740943, 0.20936389430740943, 0.20936389430740943, 0.7959295977798159, 0.7959295977798159, 0.7959295977798159, 0.18160011169564394, 0.18160011169564394, 0.18160011169564394, 0.19198297749609816, 0.19198297749609816, 0.19198297749609816, 0.19759807818999586, 0.19759807818999586, 0.19759807818999586, 0.09382586641523516, 0.09382586641523516, 0.09382586641523516, 0.0876131875363475, 0.0876131875363475, 0.0876131875363475, 0.12240293391282153, 0.12240293391282153, 0.12240293391282153]}, "mutation_prompt": null}
