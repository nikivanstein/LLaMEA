{"id": "5a031689-7c06-47ab-9207-4c320654f4f4", "solution": "import numpy as np\n\nclass HDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Crossover\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "HDEL", "description": "A Hybrid Differential Evolution with Local Search (HDEL) that combines global exploration and local exploitation to efficiently optimize complex functions.", "configspace": "", "generation": 0, "fitness": 0.10966492635012644, "feedback": "The algorithm HDEL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.12.", "error": "", "parent_id": null, "metadata": {"aucs": [0.20985158542090065, 0.19178559523220307, 0.18513216378107833, 0.21833151575919774, 0.23872006237022725, 0.22284517343932742, 0.218885237883769, 0.1813230503679324, 0.22128950172895245, 0.013060366575151638, 0.006995395400471671, 0.015422259035718033, 0.015569006113692385, 0.018610496421605838, 0.019118367494732946, 0.006414113063779259, 0.004242668102327873, 0.009605542437099213, 0.04583857884447751, 0.05609546439458013, 0.05073500508110451, 0.06005079085000564, 0.05617184222971883, 0.06441334445838076, 0.05297350124136424, 0.050835414281117264, 0.05120027560925333, 0.04175316048758959, 0.03718035299146982, 0.030823876617971813, 0.045247274297568585, 0.0346399964048969, 0.0338476644041692, 0.03922744851476323, 0.028801479354810144, 0.03226486648339055, 0.5818274652666973, 0.5776551673698218, 0.5778980369331765, 0.6018180109668302, 0.3542381510294158, 0.36371793741734904, 0.48324663641966703, 0.6400392710862324, 0.75352433749228, 0.08087168049727878, 0.08474584601703605, 0.04878869207167846, 0.05682215611202246, 0.038706259439387214, 0.06920157268396254, 0.0953203695123741, 0.09500263548738364, 0.09801520434084832, 0.14337146542883206, 0.13976608780756705, 0.14802856892448413, 0.12841669311792647, 0.14093570585690907, 0.11844766669533824, 0.12511704626214182, 0.15047440166399573, 0.13273017553264577, 0.0039896957656681, 0.016161560514479922, 0.016671886133970304, 0.019332514216161334, 0.02046819295270219, 0.024483884578936577, 0.03410924256517445, 0.009220002902835756, 0.03744543614546547, 0.037044189842361464, 0.025506862470586755, 0.018897077960784547, 0.0006752767569933038, 0.00527789040728599, 0.008242976731673846, 0.03450432201121345, 0.03520696809708457, 0.0026499779471043095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0733804941116234, 0.0895233016461301, 0.04852691288999189, 0.04319112731039476, 0.06103638273871925, 0.04424844080719981, 0.06328435968252433, 0.06471732142412334, 0.07340423468134527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003006222599410302, 0.004438771468566527, 0.007305890863607556, 0.007971821624589204, 0.004973223745005639, 0.017969648086800905, 0.009540947730343752, 0.013138964193374125, 0.00837286774927648, 0.20691384702580518, 0.1999596574186061, 0.20484226754045032, 0.21016201504659715, 0.2036547400321831, 0.21810703949159604, 0.2126624545519087, 0.19084572498497132, 0.20222378467804314, 0.04887685032286804, 0.06383129868688298, 0.05930565345953309, 0.05247100560401252, 0.045660560601151534, 0.053269123738492685, 0.06414090271184503, 0.055902220368076794, 0.05500810926893751, 0.11490880960595129, 0.10617914400700423, 0.1328706417026082, 0.11947346219568133, 0.11180431371501853, 0.12728134345428932, 0.12657479766381297, 0.12203381165538818, 0.1128449190760441, 0.1614673323057183, 0.1535733779611761, 0.17598918701125565, 0.16785802466896405, 0.1710747446339841, 0.1515752104126139, 0.2314445440000289, 0.18066918907296514, 0.17106741655771507, 0.10445718883967747, 0.12985397308716273, 0.10486996435760032, 0.11352865148798352, 0.12107457920174292, 0.1074853618643592, 0.11445711935041614, 0.122514753222848, 0.1217148982863635, 0.1517331601788685, 0.1547274347395734, 0.15932922570512853, 0.16761811544540928, 0.1505602194745086, 0.15857536865678734, 0.1585422364140877, 0.15818346953352325, 0.17418429267841984, 0.14047398108519937, 0.11730388466168462, 0.1367791549010413, 0.14211365027088618, 0.12475562705938115, 0.119231030103772, 0.10085770002471928, 0.1347336725327557, 0.10104170529229373, 0.10294930365137023, 0.13928034835014236, 0.15393576968911016, 0.13047111900874386, 0.14784776259837906, 0.14776768748764335, 0.12452414755675434, 0.12129604770613844, 0.09659653930500767, 0.12144652641250164, 0.14621480814918142, 0.11948382112055078, 0.15493787248137236, 0.09207251515697257, 0.08986969295791658, 0.10615062315445334, 0.1257435022242025, 0.13089031033551035, 0.19035494991413038, 0.20444509065439165, 0.17798888233939703, 0.19051968146239362, 0.1758270788188918, 0.19234038679106935, 0.2060263995956243, 0.1901920994515024, 0.20375019434103336, 0.051419252826767625, 0.0545654139494518, 0.04708801721282274, 0.06619828850317222, 0.06126784531402352, 0.05196344633605299, 0.05848711381099825, 0.052557905189108856, 0.05617713412056202]}, "mutation_prompt": null}
{"id": "676c9b98-6b1a-4a69-832b-d8ec1b4e390c", "solution": "import numpy as np\n\nclass HDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Crossover\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "HDEL", "description": "A Hybrid Differential Evolution with Local Search (HDEL) that combines global exploration and local exploitation to efficiently optimize complex functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a031689-7c06-47ab-9207-4c320654f4f4", "metadata": {"aucs": [0.20985158542090065, 0.19178559523220307, 0.18513216378107833, 0.21833151575919774, 0.23872006237022725, 0.22284517343932742, 0.218885237883769, 0.1813230503679324, 0.22128950172895245, 0.013060366575151638, 0.006995395400471671, 0.015422259035718033, 0.015569006113692385, 0.018610496421605838, 0.019118367494732946, 0.006414113063779259, 0.004242668102327873, 0.009605542437099213, 0.04583857884447751, 0.05609546439458013, 0.05073500508110451, 0.06005079085000564, 0.05617184222971883, 0.06441334445838076, 0.05297350124136424, 0.050835414281117264, 0.05120027560925333, 0.04175316048758959, 0.03718035299146982, 0.030823876617971813, 0.045247274297568585, 0.0346399964048969, 0.0338476644041692, 0.03922744851476323, 0.028801479354810144, 0.03226486648339055, 0.5818274652666973, 0.5776551673698218, 0.5778980369331765, 0.6018180109668302, 0.3542381510294158, 0.36371793741734904, 0.48324663641966703, 0.6400392710862324, 0.75352433749228, 0.08087168049727878, 0.08474584601703605, 0.04878869207167846, 0.05682215611202246, 0.038706259439387214, 0.06920157268396254, 0.0953203695123741, 0.09500263548738364, 0.09801520434084832, 0.14337146542883206, 0.13976608780756705, 0.14802856892448413, 0.12841669311792647, 0.14093570585690907, 0.11844766669533824, 0.12511704626214182, 0.15047440166399573, 0.13273017553264577, 0.0039896957656681, 0.016161560514479922, 0.016671886133970304, 0.019332514216161334, 0.02046819295270219, 0.024483884578936577, 0.03410924256517445, 0.009220002902835756, 0.03744543614546547, 0.037044189842361464, 0.025506862470586755, 0.018897077960784547, 0.0006752767569933038, 0.00527789040728599, 0.008242976731673846, 0.03450432201121345, 0.03520696809708457, 0.0026499779471043095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0733804941116234, 0.0895233016461301, 0.04852691288999189, 0.04319112731039476, 0.06103638273871925, 0.04424844080719981, 0.06328435968252433, 0.06471732142412334, 0.07340423468134527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003006222599410302, 0.004438771468566527, 0.007305890863607556, 0.007971821624589204, 0.004973223745005639, 0.017969648086800905, 0.009540947730343752, 0.013138964193374125, 0.00837286774927648, 0.20691384702580518, 0.1999596574186061, 0.20484226754045032, 0.21016201504659715, 0.2036547400321831, 0.21810703949159604, 0.2126624545519087, 0.19084572498497132, 0.20222378467804314, 0.04887685032286804, 0.06383129868688298, 0.05930565345953309, 0.05247100560401252, 0.045660560601151534, 0.053269123738492685, 0.06414090271184503, 0.055902220368076794, 0.05500810926893751, 0.11490880960595129, 0.10617914400700423, 0.1328706417026082, 0.11947346219568133, 0.11180431371501853, 0.12728134345428932, 0.12657479766381297, 0.12203381165538818, 0.1128449190760441, 0.1614673323057183, 0.1535733779611761, 0.17598918701125565, 0.16785802466896405, 0.1710747446339841, 0.1515752104126139, 0.2314445440000289, 0.18066918907296514, 0.17106741655771507, 0.10445718883967747, 0.12985397308716273, 0.10486996435760032, 0.11352865148798352, 0.12107457920174292, 0.1074853618643592, 0.11445711935041614, 0.122514753222848, 0.1217148982863635, 0.1517331601788685, 0.1547274347395734, 0.15932922570512853, 0.16761811544540928, 0.1505602194745086, 0.15857536865678734, 0.1585422364140877, 0.15818346953352325, 0.17418429267841984, 0.14047398108519937, 0.11730388466168462, 0.1367791549010413, 0.14211365027088618, 0.12475562705938115, 0.119231030103772, 0.10085770002471928, 0.1347336725327557, 0.10104170529229373, 0.10294930365137023, 0.13928034835014236, 0.15393576968911016, 0.13047111900874386, 0.14784776259837906, 0.14776768748764335, 0.12452414755675434, 0.12129604770613844, 0.09659653930500767, 0.12144652641250164, 0.14621480814918142, 0.11948382112055078, 0.15493787248137236, 0.09207251515697257, 0.08986969295791658, 0.10615062315445334, 0.1257435022242025, 0.13089031033551035, 0.19035494991413038, 0.20444509065439165, 0.17798888233939703, 0.19051968146239362, 0.1758270788188918, 0.19234038679106935, 0.2060263995956243, 0.1901920994515024, 0.20375019434103336, 0.051419252826767625, 0.0545654139494518, 0.04708801721282274, 0.06619828850317222, 0.06126784531402352, 0.05196344633605299, 0.05848711381099825, 0.052557905189108856, 0.05617713412056202]}, "mutation_prompt": null}
{"id": "41b477a1-23c4-4138-a0f4-bdc78cbca9b9", "solution": "import numpy as np\n\nclass HDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Crossover\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "HDEL", "description": "A Hybrid Differential Evolution with Local Search (HDEL) that combines global exploration and local exploitation to efficiently optimize complex functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a031689-7c06-47ab-9207-4c320654f4f4", "metadata": {"aucs": [0.20985158542090065, 0.19178559523220307, 0.18513216378107833, 0.21833151575919774, 0.23872006237022725, 0.22284517343932742, 0.218885237883769, 0.1813230503679324, 0.22128950172895245, 0.013060366575151638, 0.006995395400471671, 0.015422259035718033, 0.015569006113692385, 0.018610496421605838, 0.019118367494732946, 0.006414113063779259, 0.004242668102327873, 0.009605542437099213, 0.04583857884447751, 0.05609546439458013, 0.05073500508110451, 0.06005079085000564, 0.05617184222971883, 0.06441334445838076, 0.05297350124136424, 0.050835414281117264, 0.05120027560925333, 0.04175316048758959, 0.03718035299146982, 0.030823876617971813, 0.045247274297568585, 0.0346399964048969, 0.0338476644041692, 0.03922744851476323, 0.028801479354810144, 0.03226486648339055, 0.5818274652666973, 0.5776551673698218, 0.5778980369331765, 0.6018180109668302, 0.3542381510294158, 0.36371793741734904, 0.48324663641966703, 0.6400392710862324, 0.75352433749228, 0.08087168049727878, 0.08474584601703605, 0.04878869207167846, 0.05682215611202246, 0.038706259439387214, 0.06920157268396254, 0.0953203695123741, 0.09500263548738364, 0.09801520434084832, 0.14337146542883206, 0.13976608780756705, 0.14802856892448413, 0.12841669311792647, 0.14093570585690907, 0.11844766669533824, 0.12511704626214182, 0.15047440166399573, 0.13273017553264577, 0.0039896957656681, 0.016161560514479922, 0.016671886133970304, 0.019332514216161334, 0.02046819295270219, 0.024483884578936577, 0.03410924256517445, 0.009220002902835756, 0.03744543614546547, 0.037044189842361464, 0.025506862470586755, 0.018897077960784547, 0.0006752767569933038, 0.00527789040728599, 0.008242976731673846, 0.03450432201121345, 0.03520696809708457, 0.0026499779471043095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0733804941116234, 0.0895233016461301, 0.04852691288999189, 0.04319112731039476, 0.06103638273871925, 0.04424844080719981, 0.06328435968252433, 0.06471732142412334, 0.07340423468134527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003006222599410302, 0.004438771468566527, 0.007305890863607556, 0.007971821624589204, 0.004973223745005639, 0.017969648086800905, 0.009540947730343752, 0.013138964193374125, 0.00837286774927648, 0.20691384702580518, 0.1999596574186061, 0.20484226754045032, 0.21016201504659715, 0.2036547400321831, 0.21810703949159604, 0.2126624545519087, 0.19084572498497132, 0.20222378467804314, 0.04887685032286804, 0.06383129868688298, 0.05930565345953309, 0.05247100560401252, 0.045660560601151534, 0.053269123738492685, 0.06414090271184503, 0.055902220368076794, 0.05500810926893751, 0.11490880960595129, 0.10617914400700423, 0.1328706417026082, 0.11947346219568133, 0.11180431371501853, 0.12728134345428932, 0.12657479766381297, 0.12203381165538818, 0.1128449190760441, 0.1614673323057183, 0.1535733779611761, 0.17598918701125565, 0.16785802466896405, 0.1710747446339841, 0.1515752104126139, 0.2314445440000289, 0.18066918907296514, 0.17106741655771507, 0.10445718883967747, 0.12985397308716273, 0.10486996435760032, 0.11352865148798352, 0.12107457920174292, 0.1074853618643592, 0.11445711935041614, 0.122514753222848, 0.1217148982863635, 0.1517331601788685, 0.1547274347395734, 0.15932922570512853, 0.16761811544540928, 0.1505602194745086, 0.15857536865678734, 0.1585422364140877, 0.15818346953352325, 0.17418429267841984, 0.14047398108519937, 0.11730388466168462, 0.1367791549010413, 0.14211365027088618, 0.12475562705938115, 0.119231030103772, 0.10085770002471928, 0.1347336725327557, 0.10104170529229373, 0.10294930365137023, 0.13928034835014236, 0.15393576968911016, 0.13047111900874386, 0.14784776259837906, 0.14776768748764335, 0.12452414755675434, 0.12129604770613844, 0.09659653930500767, 0.12144652641250164, 0.14621480814918142, 0.11948382112055078, 0.15493787248137236, 0.09207251515697257, 0.08986969295791658, 0.10615062315445334, 0.1257435022242025, 0.13089031033551035, 0.19035494991413038, 0.20444509065439165, 0.17798888233939703, 0.19051968146239362, 0.1758270788188918, 0.19234038679106935, 0.2060263995956243, 0.1901920994515024, 0.20375019434103336, 0.051419252826767625, 0.0545654139494518, 0.04708801721282274, 0.06619828850317222, 0.06126784531402352, 0.05196344633605299, 0.05848711381099825, 0.052557905189108856, 0.05617713412056202]}, "mutation_prompt": null}
{"id": "8687de2c-bd19-4177-9be2-700a30f70819", "solution": "import numpy as np\n\nclass HDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Crossover\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "HDEL", "description": "A Hybrid Differential Evolution with Local Search (HDEL) that combines global exploration and local exploitation to efficiently optimize complex functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a031689-7c06-47ab-9207-4c320654f4f4", "metadata": {"aucs": [0.20985158542090065, 0.19178559523220307, 0.18513216378107833, 0.21833151575919774, 0.23872006237022725, 0.22284517343932742, 0.218885237883769, 0.1813230503679324, 0.22128950172895245, 0.013060366575151638, 0.006995395400471671, 0.015422259035718033, 0.015569006113692385, 0.018610496421605838, 0.019118367494732946, 0.006414113063779259, 0.004242668102327873, 0.009605542437099213, 0.04583857884447751, 0.05609546439458013, 0.05073500508110451, 0.06005079085000564, 0.05617184222971883, 0.06441334445838076, 0.05297350124136424, 0.050835414281117264, 0.05120027560925333, 0.04175316048758959, 0.03718035299146982, 0.030823876617971813, 0.045247274297568585, 0.0346399964048969, 0.0338476644041692, 0.03922744851476323, 0.028801479354810144, 0.03226486648339055, 0.5818274652666973, 0.5776551673698218, 0.5778980369331765, 0.6018180109668302, 0.3542381510294158, 0.36371793741734904, 0.48324663641966703, 0.6400392710862324, 0.75352433749228, 0.08087168049727878, 0.08474584601703605, 0.04878869207167846, 0.05682215611202246, 0.038706259439387214, 0.06920157268396254, 0.0953203695123741, 0.09500263548738364, 0.09801520434084832, 0.14337146542883206, 0.13976608780756705, 0.14802856892448413, 0.12841669311792647, 0.14093570585690907, 0.11844766669533824, 0.12511704626214182, 0.15047440166399573, 0.13273017553264577, 0.0039896957656681, 0.016161560514479922, 0.016671886133970304, 0.019332514216161334, 0.02046819295270219, 0.024483884578936577, 0.03410924256517445, 0.009220002902835756, 0.03744543614546547, 0.037044189842361464, 0.025506862470586755, 0.018897077960784547, 0.0006752767569933038, 0.00527789040728599, 0.008242976731673846, 0.03450432201121345, 0.03520696809708457, 0.0026499779471043095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0733804941116234, 0.0895233016461301, 0.04852691288999189, 0.04319112731039476, 0.06103638273871925, 0.04424844080719981, 0.06328435968252433, 0.06471732142412334, 0.07340423468134527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003006222599410302, 0.004438771468566527, 0.007305890863607556, 0.007971821624589204, 0.004973223745005639, 0.017969648086800905, 0.009540947730343752, 0.013138964193374125, 0.00837286774927648, 0.20691384702580518, 0.1999596574186061, 0.20484226754045032, 0.21016201504659715, 0.2036547400321831, 0.21810703949159604, 0.2126624545519087, 0.19084572498497132, 0.20222378467804314, 0.04887685032286804, 0.06383129868688298, 0.05930565345953309, 0.05247100560401252, 0.045660560601151534, 0.053269123738492685, 0.06414090271184503, 0.055902220368076794, 0.05500810926893751, 0.11490880960595129, 0.10617914400700423, 0.1328706417026082, 0.11947346219568133, 0.11180431371501853, 0.12728134345428932, 0.12657479766381297, 0.12203381165538818, 0.1128449190760441, 0.1614673323057183, 0.1535733779611761, 0.17598918701125565, 0.16785802466896405, 0.1710747446339841, 0.1515752104126139, 0.2314445440000289, 0.18066918907296514, 0.17106741655771507, 0.10445718883967747, 0.12985397308716273, 0.10486996435760032, 0.11352865148798352, 0.12107457920174292, 0.1074853618643592, 0.11445711935041614, 0.122514753222848, 0.1217148982863635, 0.1517331601788685, 0.1547274347395734, 0.15932922570512853, 0.16761811544540928, 0.1505602194745086, 0.15857536865678734, 0.1585422364140877, 0.15818346953352325, 0.17418429267841984, 0.14047398108519937, 0.11730388466168462, 0.1367791549010413, 0.14211365027088618, 0.12475562705938115, 0.119231030103772, 0.10085770002471928, 0.1347336725327557, 0.10104170529229373, 0.10294930365137023, 0.13928034835014236, 0.15393576968911016, 0.13047111900874386, 0.14784776259837906, 0.14776768748764335, 0.12452414755675434, 0.12129604770613844, 0.09659653930500767, 0.12144652641250164, 0.14621480814918142, 0.11948382112055078, 0.15493787248137236, 0.09207251515697257, 0.08986969295791658, 0.10615062315445334, 0.1257435022242025, 0.13089031033551035, 0.19035494991413038, 0.20444509065439165, 0.17798888233939703, 0.19051968146239362, 0.1758270788188918, 0.19234038679106935, 0.2060263995956243, 0.1901920994515024, 0.20375019434103336, 0.051419252826767625, 0.0545654139494518, 0.04708801721282274, 0.06619828850317222, 0.06126784531402352, 0.05196344633605299, 0.05848711381099825, 0.052557905189108856, 0.05617713412056202]}, "mutation_prompt": null}
{"id": "8e1dd2ab-8e06-477d-9900-fb8d1fc7f088", "solution": "import numpy as np\n\nclass HDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Crossover\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "HDEL", "description": "A Hybrid Differential Evolution with Local Search (HDEL) that combines global exploration and local exploitation to efficiently optimize complex functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a031689-7c06-47ab-9207-4c320654f4f4", "metadata": {"aucs": [0.20985158542090065, 0.19178559523220307, 0.18513216378107833, 0.21833151575919774, 0.23872006237022725, 0.22284517343932742, 0.218885237883769, 0.1813230503679324, 0.22128950172895245, 0.013060366575151638, 0.006995395400471671, 0.015422259035718033, 0.015569006113692385, 0.018610496421605838, 0.019118367494732946, 0.006414113063779259, 0.004242668102327873, 0.009605542437099213, 0.04583857884447751, 0.05609546439458013, 0.05073500508110451, 0.06005079085000564, 0.05617184222971883, 0.06441334445838076, 0.05297350124136424, 0.050835414281117264, 0.05120027560925333, 0.04175316048758959, 0.03718035299146982, 0.030823876617971813, 0.045247274297568585, 0.0346399964048969, 0.0338476644041692, 0.03922744851476323, 0.028801479354810144, 0.03226486648339055, 0.5818274652666973, 0.5776551673698218, 0.5778980369331765, 0.6018180109668302, 0.3542381510294158, 0.36371793741734904, 0.48324663641966703, 0.6400392710862324, 0.75352433749228, 0.08087168049727878, 0.08474584601703605, 0.04878869207167846, 0.05682215611202246, 0.038706259439387214, 0.06920157268396254, 0.0953203695123741, 0.09500263548738364, 0.09801520434084832, 0.14337146542883206, 0.13976608780756705, 0.14802856892448413, 0.12841669311792647, 0.14093570585690907, 0.11844766669533824, 0.12511704626214182, 0.15047440166399573, 0.13273017553264577, 0.0039896957656681, 0.016161560514479922, 0.016671886133970304, 0.019332514216161334, 0.02046819295270219, 0.024483884578936577, 0.03410924256517445, 0.009220002902835756, 0.03744543614546547, 0.037044189842361464, 0.025506862470586755, 0.018897077960784547, 0.0006752767569933038, 0.00527789040728599, 0.008242976731673846, 0.03450432201121345, 0.03520696809708457, 0.0026499779471043095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0733804941116234, 0.0895233016461301, 0.04852691288999189, 0.04319112731039476, 0.06103638273871925, 0.04424844080719981, 0.06328435968252433, 0.06471732142412334, 0.07340423468134527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003006222599410302, 0.004438771468566527, 0.007305890863607556, 0.007971821624589204, 0.004973223745005639, 0.017969648086800905, 0.009540947730343752, 0.013138964193374125, 0.00837286774927648, 0.20691384702580518, 0.1999596574186061, 0.20484226754045032, 0.21016201504659715, 0.2036547400321831, 0.21810703949159604, 0.2126624545519087, 0.19084572498497132, 0.20222378467804314, 0.04887685032286804, 0.06383129868688298, 0.05930565345953309, 0.05247100560401252, 0.045660560601151534, 0.053269123738492685, 0.06414090271184503, 0.055902220368076794, 0.05500810926893751, 0.11490880960595129, 0.10617914400700423, 0.1328706417026082, 0.11947346219568133, 0.11180431371501853, 0.12728134345428932, 0.12657479766381297, 0.12203381165538818, 0.1128449190760441, 0.1614673323057183, 0.1535733779611761, 0.17598918701125565, 0.16785802466896405, 0.1710747446339841, 0.1515752104126139, 0.2314445440000289, 0.18066918907296514, 0.17106741655771507, 0.10445718883967747, 0.12985397308716273, 0.10486996435760032, 0.11352865148798352, 0.12107457920174292, 0.1074853618643592, 0.11445711935041614, 0.122514753222848, 0.1217148982863635, 0.1517331601788685, 0.1547274347395734, 0.15932922570512853, 0.16761811544540928, 0.1505602194745086, 0.15857536865678734, 0.1585422364140877, 0.15818346953352325, 0.17418429267841984, 0.14047398108519937, 0.11730388466168462, 0.1367791549010413, 0.14211365027088618, 0.12475562705938115, 0.119231030103772, 0.10085770002471928, 0.1347336725327557, 0.10104170529229373, 0.10294930365137023, 0.13928034835014236, 0.15393576968911016, 0.13047111900874386, 0.14784776259837906, 0.14776768748764335, 0.12452414755675434, 0.12129604770613844, 0.09659653930500767, 0.12144652641250164, 0.14621480814918142, 0.11948382112055078, 0.15493787248137236, 0.09207251515697257, 0.08986969295791658, 0.10615062315445334, 0.1257435022242025, 0.13089031033551035, 0.19035494991413038, 0.20444509065439165, 0.17798888233939703, 0.19051968146239362, 0.1758270788188918, 0.19234038679106935, 0.2060263995956243, 0.1901920994515024, 0.20375019434103336, 0.051419252826767625, 0.0545654139494518, 0.04708801721282274, 0.06619828850317222, 0.06126784531402352, 0.05196344633605299, 0.05848711381099825, 0.052557905189108856, 0.05617713412056202]}, "mutation_prompt": null}
{"id": "ed635903-c121-4d70-a0ef-0b620858b36c", "solution": "import numpy as np\n\nclass HDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Crossover\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "HDEL", "description": "A Hybrid Differential Evolution with Local Search (HDEL) that combines global exploration and local exploitation to efficiently optimize complex functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a031689-7c06-47ab-9207-4c320654f4f4", "metadata": {"aucs": [0.20985158542090065, 0.19178559523220307, 0.18513216378107833, 0.21833151575919774, 0.23872006237022725, 0.22284517343932742, 0.218885237883769, 0.1813230503679324, 0.22128950172895245, 0.013060366575151638, 0.006995395400471671, 0.015422259035718033, 0.015569006113692385, 0.018610496421605838, 0.019118367494732946, 0.006414113063779259, 0.004242668102327873, 0.009605542437099213, 0.04583857884447751, 0.05609546439458013, 0.05073500508110451, 0.06005079085000564, 0.05617184222971883, 0.06441334445838076, 0.05297350124136424, 0.050835414281117264, 0.05120027560925333, 0.04175316048758959, 0.03718035299146982, 0.030823876617971813, 0.045247274297568585, 0.0346399964048969, 0.0338476644041692, 0.03922744851476323, 0.028801479354810144, 0.03226486648339055, 0.5818274652666973, 0.5776551673698218, 0.5778980369331765, 0.6018180109668302, 0.3542381510294158, 0.36371793741734904, 0.48324663641966703, 0.6400392710862324, 0.75352433749228, 0.08087168049727878, 0.08474584601703605, 0.04878869207167846, 0.05682215611202246, 0.038706259439387214, 0.06920157268396254, 0.0953203695123741, 0.09500263548738364, 0.09801520434084832, 0.14337146542883206, 0.13976608780756705, 0.14802856892448413, 0.12841669311792647, 0.14093570585690907, 0.11844766669533824, 0.12511704626214182, 0.15047440166399573, 0.13273017553264577, 0.0039896957656681, 0.016161560514479922, 0.016671886133970304, 0.019332514216161334, 0.02046819295270219, 0.024483884578936577, 0.03410924256517445, 0.009220002902835756, 0.03744543614546547, 0.037044189842361464, 0.025506862470586755, 0.018897077960784547, 0.0006752767569933038, 0.00527789040728599, 0.008242976731673846, 0.03450432201121345, 0.03520696809708457, 0.0026499779471043095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0733804941116234, 0.0895233016461301, 0.04852691288999189, 0.04319112731039476, 0.06103638273871925, 0.04424844080719981, 0.06328435968252433, 0.06471732142412334, 0.07340423468134527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003006222599410302, 0.004438771468566527, 0.007305890863607556, 0.007971821624589204, 0.004973223745005639, 0.017969648086800905, 0.009540947730343752, 0.013138964193374125, 0.00837286774927648, 0.20691384702580518, 0.1999596574186061, 0.20484226754045032, 0.21016201504659715, 0.2036547400321831, 0.21810703949159604, 0.2126624545519087, 0.19084572498497132, 0.20222378467804314, 0.04887685032286804, 0.06383129868688298, 0.05930565345953309, 0.05247100560401252, 0.045660560601151534, 0.053269123738492685, 0.06414090271184503, 0.055902220368076794, 0.05500810926893751, 0.11490880960595129, 0.10617914400700423, 0.1328706417026082, 0.11947346219568133, 0.11180431371501853, 0.12728134345428932, 0.12657479766381297, 0.12203381165538818, 0.1128449190760441, 0.1614673323057183, 0.1535733779611761, 0.17598918701125565, 0.16785802466896405, 0.1710747446339841, 0.1515752104126139, 0.2314445440000289, 0.18066918907296514, 0.17106741655771507, 0.10445718883967747, 0.12985397308716273, 0.10486996435760032, 0.11352865148798352, 0.12107457920174292, 0.1074853618643592, 0.11445711935041614, 0.122514753222848, 0.1217148982863635, 0.1517331601788685, 0.1547274347395734, 0.15932922570512853, 0.16761811544540928, 0.1505602194745086, 0.15857536865678734, 0.1585422364140877, 0.15818346953352325, 0.17418429267841984, 0.14047398108519937, 0.11730388466168462, 0.1367791549010413, 0.14211365027088618, 0.12475562705938115, 0.119231030103772, 0.10085770002471928, 0.1347336725327557, 0.10104170529229373, 0.10294930365137023, 0.13928034835014236, 0.15393576968911016, 0.13047111900874386, 0.14784776259837906, 0.14776768748764335, 0.12452414755675434, 0.12129604770613844, 0.09659653930500767, 0.12144652641250164, 0.14621480814918142, 0.11948382112055078, 0.15493787248137236, 0.09207251515697257, 0.08986969295791658, 0.10615062315445334, 0.1257435022242025, 0.13089031033551035, 0.19035494991413038, 0.20444509065439165, 0.17798888233939703, 0.19051968146239362, 0.1758270788188918, 0.19234038679106935, 0.2060263995956243, 0.1901920994515024, 0.20375019434103336, 0.051419252826767625, 0.0545654139494518, 0.04708801721282274, 0.06619828850317222, 0.06126784531402352, 0.05196344633605299, 0.05848711381099825, 0.052557905189108856, 0.05617713412056202]}, "mutation_prompt": null}
{"id": "24df9f91-6d50-441d-b254-7ae6e5c6957b", "solution": "import numpy as np\n\nclass HDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Crossover\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "HDEL", "description": "A Hybrid Differential Evolution with Local Search (HDEL) that combines global exploration and local exploitation to efficiently optimize complex functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a031689-7c06-47ab-9207-4c320654f4f4", "metadata": {"aucs": [0.20985158542090065, 0.19178559523220307, 0.18513216378107833, 0.21833151575919774, 0.23872006237022725, 0.22284517343932742, 0.218885237883769, 0.1813230503679324, 0.22128950172895245, 0.013060366575151638, 0.006995395400471671, 0.015422259035718033, 0.015569006113692385, 0.018610496421605838, 0.019118367494732946, 0.006414113063779259, 0.004242668102327873, 0.009605542437099213, 0.04583857884447751, 0.05609546439458013, 0.05073500508110451, 0.06005079085000564, 0.05617184222971883, 0.06441334445838076, 0.05297350124136424, 0.050835414281117264, 0.05120027560925333, 0.04175316048758959, 0.03718035299146982, 0.030823876617971813, 0.045247274297568585, 0.0346399964048969, 0.0338476644041692, 0.03922744851476323, 0.028801479354810144, 0.03226486648339055, 0.5818274652666973, 0.5776551673698218, 0.5778980369331765, 0.6018180109668302, 0.3542381510294158, 0.36371793741734904, 0.48324663641966703, 0.6400392710862324, 0.75352433749228, 0.08087168049727878, 0.08474584601703605, 0.04878869207167846, 0.05682215611202246, 0.038706259439387214, 0.06920157268396254, 0.0953203695123741, 0.09500263548738364, 0.09801520434084832, 0.14337146542883206, 0.13976608780756705, 0.14802856892448413, 0.12841669311792647, 0.14093570585690907, 0.11844766669533824, 0.12511704626214182, 0.15047440166399573, 0.13273017553264577, 0.0039896957656681, 0.016161560514479922, 0.016671886133970304, 0.019332514216161334, 0.02046819295270219, 0.024483884578936577, 0.03410924256517445, 0.009220002902835756, 0.03744543614546547, 0.037044189842361464, 0.025506862470586755, 0.018897077960784547, 0.0006752767569933038, 0.00527789040728599, 0.008242976731673846, 0.03450432201121345, 0.03520696809708457, 0.0026499779471043095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0733804941116234, 0.0895233016461301, 0.04852691288999189, 0.04319112731039476, 0.06103638273871925, 0.04424844080719981, 0.06328435968252433, 0.06471732142412334, 0.07340423468134527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003006222599410302, 0.004438771468566527, 0.007305890863607556, 0.007971821624589204, 0.004973223745005639, 0.017969648086800905, 0.009540947730343752, 0.013138964193374125, 0.00837286774927648, 0.20691384702580518, 0.1999596574186061, 0.20484226754045032, 0.21016201504659715, 0.2036547400321831, 0.21810703949159604, 0.2126624545519087, 0.19084572498497132, 0.20222378467804314, 0.04887685032286804, 0.06383129868688298, 0.05930565345953309, 0.05247100560401252, 0.045660560601151534, 0.053269123738492685, 0.06414090271184503, 0.055902220368076794, 0.05500810926893751, 0.11490880960595129, 0.10617914400700423, 0.1328706417026082, 0.11947346219568133, 0.11180431371501853, 0.12728134345428932, 0.12657479766381297, 0.12203381165538818, 0.1128449190760441, 0.1614673323057183, 0.1535733779611761, 0.17598918701125565, 0.16785802466896405, 0.1710747446339841, 0.1515752104126139, 0.2314445440000289, 0.18066918907296514, 0.17106741655771507, 0.10445718883967747, 0.12985397308716273, 0.10486996435760032, 0.11352865148798352, 0.12107457920174292, 0.1074853618643592, 0.11445711935041614, 0.122514753222848, 0.1217148982863635, 0.1517331601788685, 0.1547274347395734, 0.15932922570512853, 0.16761811544540928, 0.1505602194745086, 0.15857536865678734, 0.1585422364140877, 0.15818346953352325, 0.17418429267841984, 0.14047398108519937, 0.11730388466168462, 0.1367791549010413, 0.14211365027088618, 0.12475562705938115, 0.119231030103772, 0.10085770002471928, 0.1347336725327557, 0.10104170529229373, 0.10294930365137023, 0.13928034835014236, 0.15393576968911016, 0.13047111900874386, 0.14784776259837906, 0.14776768748764335, 0.12452414755675434, 0.12129604770613844, 0.09659653930500767, 0.12144652641250164, 0.14621480814918142, 0.11948382112055078, 0.15493787248137236, 0.09207251515697257, 0.08986969295791658, 0.10615062315445334, 0.1257435022242025, 0.13089031033551035, 0.19035494991413038, 0.20444509065439165, 0.17798888233939703, 0.19051968146239362, 0.1758270788188918, 0.19234038679106935, 0.2060263995956243, 0.1901920994515024, 0.20375019434103336, 0.051419252826767625, 0.0545654139494518, 0.04708801721282274, 0.06619828850317222, 0.06126784531402352, 0.05196344633605299, 0.05848711381099825, 0.052557905189108856, 0.05617713412056202]}, "mutation_prompt": null}
{"id": "c36bd0e3-08d4-4682-a6e8-1d408e898396", "solution": "import numpy as np\n\nclass HDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Crossover\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "HDEL", "description": "A Hybrid Differential Evolution with Local Search (HDEL) that combines global exploration and local exploitation to efficiently optimize complex functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a031689-7c06-47ab-9207-4c320654f4f4", "metadata": {"aucs": [0.20985158542090065, 0.19178559523220307, 0.18513216378107833, 0.21833151575919774, 0.23872006237022725, 0.22284517343932742, 0.218885237883769, 0.1813230503679324, 0.22128950172895245, 0.013060366575151638, 0.006995395400471671, 0.015422259035718033, 0.015569006113692385, 0.018610496421605838, 0.019118367494732946, 0.006414113063779259, 0.004242668102327873, 0.009605542437099213, 0.04583857884447751, 0.05609546439458013, 0.05073500508110451, 0.06005079085000564, 0.05617184222971883, 0.06441334445838076, 0.05297350124136424, 0.050835414281117264, 0.05120027560925333, 0.04175316048758959, 0.03718035299146982, 0.030823876617971813, 0.045247274297568585, 0.0346399964048969, 0.0338476644041692, 0.03922744851476323, 0.028801479354810144, 0.03226486648339055, 0.5818274652666973, 0.5776551673698218, 0.5778980369331765, 0.6018180109668302, 0.3542381510294158, 0.36371793741734904, 0.48324663641966703, 0.6400392710862324, 0.75352433749228, 0.08087168049727878, 0.08474584601703605, 0.04878869207167846, 0.05682215611202246, 0.038706259439387214, 0.06920157268396254, 0.0953203695123741, 0.09500263548738364, 0.09801520434084832, 0.14337146542883206, 0.13976608780756705, 0.14802856892448413, 0.12841669311792647, 0.14093570585690907, 0.11844766669533824, 0.12511704626214182, 0.15047440166399573, 0.13273017553264577, 0.0039896957656681, 0.016161560514479922, 0.016671886133970304, 0.019332514216161334, 0.02046819295270219, 0.024483884578936577, 0.03410924256517445, 0.009220002902835756, 0.03744543614546547, 0.037044189842361464, 0.025506862470586755, 0.018897077960784547, 0.0006752767569933038, 0.00527789040728599, 0.008242976731673846, 0.03450432201121345, 0.03520696809708457, 0.0026499779471043095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0733804941116234, 0.0895233016461301, 0.04852691288999189, 0.04319112731039476, 0.06103638273871925, 0.04424844080719981, 0.06328435968252433, 0.06471732142412334, 0.07340423468134527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003006222599410302, 0.004438771468566527, 0.007305890863607556, 0.007971821624589204, 0.004973223745005639, 0.017969648086800905, 0.009540947730343752, 0.013138964193374125, 0.00837286774927648, 0.20691384702580518, 0.1999596574186061, 0.20484226754045032, 0.21016201504659715, 0.2036547400321831, 0.21810703949159604, 0.2126624545519087, 0.19084572498497132, 0.20222378467804314, 0.04887685032286804, 0.06383129868688298, 0.05930565345953309, 0.05247100560401252, 0.045660560601151534, 0.053269123738492685, 0.06414090271184503, 0.055902220368076794, 0.05500810926893751, 0.11490880960595129, 0.10617914400700423, 0.1328706417026082, 0.11947346219568133, 0.11180431371501853, 0.12728134345428932, 0.12657479766381297, 0.12203381165538818, 0.1128449190760441, 0.1614673323057183, 0.1535733779611761, 0.17598918701125565, 0.16785802466896405, 0.1710747446339841, 0.1515752104126139, 0.2314445440000289, 0.18066918907296514, 0.17106741655771507, 0.10445718883967747, 0.12985397308716273, 0.10486996435760032, 0.11352865148798352, 0.12107457920174292, 0.1074853618643592, 0.11445711935041614, 0.122514753222848, 0.1217148982863635, 0.1517331601788685, 0.1547274347395734, 0.15932922570512853, 0.16761811544540928, 0.1505602194745086, 0.15857536865678734, 0.1585422364140877, 0.15818346953352325, 0.17418429267841984, 0.14047398108519937, 0.11730388466168462, 0.1367791549010413, 0.14211365027088618, 0.12475562705938115, 0.119231030103772, 0.10085770002471928, 0.1347336725327557, 0.10104170529229373, 0.10294930365137023, 0.13928034835014236, 0.15393576968911016, 0.13047111900874386, 0.14784776259837906, 0.14776768748764335, 0.12452414755675434, 0.12129604770613844, 0.09659653930500767, 0.12144652641250164, 0.14621480814918142, 0.11948382112055078, 0.15493787248137236, 0.09207251515697257, 0.08986969295791658, 0.10615062315445334, 0.1257435022242025, 0.13089031033551035, 0.19035494991413038, 0.20444509065439165, 0.17798888233939703, 0.19051968146239362, 0.1758270788188918, 0.19234038679106935, 0.2060263995956243, 0.1901920994515024, 0.20375019434103336, 0.051419252826767625, 0.0545654139494518, 0.04708801721282274, 0.06619828850317222, 0.06126784531402352, 0.05196344633605299, 0.05848711381099825, 0.052557905189108856, 0.05617713412056202]}, "mutation_prompt": null}
{"id": "7c2e4dac-e96d-4535-9390-2ee6c079ea57", "solution": "import numpy as np\n\nclass HDEL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Crossover\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "HDEL", "description": "A Hybrid Differential Evolution with Local Search (HDEL) that combines global exploration and local exploitation to efficiently optimize complex functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a031689-7c06-47ab-9207-4c320654f4f4", "metadata": {"aucs": [0.20985158542090065, 0.19178559523220307, 0.18513216378107833, 0.21833151575919774, 0.23872006237022725, 0.22284517343932742, 0.218885237883769, 0.1813230503679324, 0.22128950172895245, 0.013060366575151638, 0.006995395400471671, 0.015422259035718033, 0.015569006113692385, 0.018610496421605838, 0.019118367494732946, 0.006414113063779259, 0.004242668102327873, 0.009605542437099213, 0.04583857884447751, 0.05609546439458013, 0.05073500508110451, 0.06005079085000564, 0.05617184222971883, 0.06441334445838076, 0.05297350124136424, 0.050835414281117264, 0.05120027560925333, 0.04175316048758959, 0.03718035299146982, 0.030823876617971813, 0.045247274297568585, 0.0346399964048969, 0.0338476644041692, 0.03922744851476323, 0.028801479354810144, 0.03226486648339055, 0.5818274652666973, 0.5776551673698218, 0.5778980369331765, 0.6018180109668302, 0.3542381510294158, 0.36371793741734904, 0.48324663641966703, 0.6400392710862324, 0.75352433749228, 0.08087168049727878, 0.08474584601703605, 0.04878869207167846, 0.05682215611202246, 0.038706259439387214, 0.06920157268396254, 0.0953203695123741, 0.09500263548738364, 0.09801520434084832, 0.14337146542883206, 0.13976608780756705, 0.14802856892448413, 0.12841669311792647, 0.14093570585690907, 0.11844766669533824, 0.12511704626214182, 0.15047440166399573, 0.13273017553264577, 0.0039896957656681, 0.016161560514479922, 0.016671886133970304, 0.019332514216161334, 0.02046819295270219, 0.024483884578936577, 0.03410924256517445, 0.009220002902835756, 0.03744543614546547, 0.037044189842361464, 0.025506862470586755, 0.018897077960784547, 0.0006752767569933038, 0.00527789040728599, 0.008242976731673846, 0.03450432201121345, 0.03520696809708457, 0.0026499779471043095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0733804941116234, 0.0895233016461301, 0.04852691288999189, 0.04319112731039476, 0.06103638273871925, 0.04424844080719981, 0.06328435968252433, 0.06471732142412334, 0.07340423468134527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003006222599410302, 0.004438771468566527, 0.007305890863607556, 0.007971821624589204, 0.004973223745005639, 0.017969648086800905, 0.009540947730343752, 0.013138964193374125, 0.00837286774927648, 0.20691384702580518, 0.1999596574186061, 0.20484226754045032, 0.21016201504659715, 0.2036547400321831, 0.21810703949159604, 0.2126624545519087, 0.19084572498497132, 0.20222378467804314, 0.04887685032286804, 0.06383129868688298, 0.05930565345953309, 0.05247100560401252, 0.045660560601151534, 0.053269123738492685, 0.06414090271184503, 0.055902220368076794, 0.05500810926893751, 0.11490880960595129, 0.10617914400700423, 0.1328706417026082, 0.11947346219568133, 0.11180431371501853, 0.12728134345428932, 0.12657479766381297, 0.12203381165538818, 0.1128449190760441, 0.1614673323057183, 0.1535733779611761, 0.17598918701125565, 0.16785802466896405, 0.1710747446339841, 0.1515752104126139, 0.2314445440000289, 0.18066918907296514, 0.17106741655771507, 0.10445718883967747, 0.12985397308716273, 0.10486996435760032, 0.11352865148798352, 0.12107457920174292, 0.1074853618643592, 0.11445711935041614, 0.122514753222848, 0.1217148982863635, 0.1517331601788685, 0.1547274347395734, 0.15932922570512853, 0.16761811544540928, 0.1505602194745086, 0.15857536865678734, 0.1585422364140877, 0.15818346953352325, 0.17418429267841984, 0.14047398108519937, 0.11730388466168462, 0.1367791549010413, 0.14211365027088618, 0.12475562705938115, 0.119231030103772, 0.10085770002471928, 0.1347336725327557, 0.10104170529229373, 0.10294930365137023, 0.13928034835014236, 0.15393576968911016, 0.13047111900874386, 0.14784776259837906, 0.14776768748764335, 0.12452414755675434, 0.12129604770613844, 0.09659653930500767, 0.12144652641250164, 0.14621480814918142, 0.11948382112055078, 0.15493787248137236, 0.09207251515697257, 0.08986969295791658, 0.10615062315445334, 0.1257435022242025, 0.13089031033551035, 0.19035494991413038, 0.20444509065439165, 0.17798888233939703, 0.19051968146239362, 0.1758270788188918, 0.19234038679106935, 0.2060263995956243, 0.1901920994515024, 0.20375019434103336, 0.051419252826767625, 0.0545654139494518, 0.04708801721282274, 0.06619828850317222, 0.06126784531402352, 0.05196344633605299, 0.05848711381099825, 0.052557905189108856, 0.05617713412056202]}, "mutation_prompt": null}
{"id": "06f5fd14-8fd9-407d-9913-370a043a8134", "solution": "import numpy as np\n\nclass EHDEAP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self._mutate(population[a], population[b], population[c])\n\n                # Adaptive Crossover\n                self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                trial = self._crossover(population[i], mutant)\n\n                # Local Search with adaptive step size\n                refined_trial = self._local_search(trial, func)\n\n                # Selection\n                trial_fitness = func(refined_trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = refined_trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive Mutation Factor\n            self.mutation_factor = 0.5 + 0.5 * np.random.rand()\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "EHDEAP", "description": "Enhanced Hybrid Differential Evolution with Adaptive Parameters (EHDEAP) that dynamically adjusts mutation and crossover strategies to optimize performance across varying problem landscapes.", "configspace": "", "generation": 9, "fitness": 0.11500558552835267, "feedback": "The algorithm EHDEAP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.14.", "error": "", "parent_id": "5a031689-7c06-47ab-9207-4c320654f4f4", "metadata": {"aucs": [0.18943454765771994, 0.21440060298232144, 0.20827063539999413, 0.22548413875661177, 0.21764651922710865, 0.22833322540742684, 0.24866532381103357, 0.23697665742961427, 0.21969043243954745, 0.006233353539004782, 0.012585051108126244, 0.004907098212319383, 0.01549158936764139, 0.00570195917704952, 0.01144916816119168, 0.013975930472369669, 0.015177850900948031, 0.018658833795087815, 0.04898638312146231, 0.05638180312810859, 0.06295519562992036, 0.06458676556943488, 0.06593727903202451, 0.06547228761232693, 0.061314974695897084, 0.06640197431324923, 0.0622877796655279, 0.04118313976738641, 0.04966397608718198, 0.03919202857232451, 0.047668452637335434, 0.05026995530100853, 0.04065441008337434, 0.0442364769515603, 0.048603741239981346, 0.03789661430519786, 0.59630445567105, 0.662126136812431, 0.6878668679922852, 0.6225503583017964, 0.7223439422271674, 0.7675560536701631, 0.8342028645354213, 0.760421226131375, 0.4726217127869692, 0.0790987260776943, 0.0680535925168988, 0.053660257967790725, 0.06711711939725906, 0.06536729901927552, 0.07195482524848795, 0.06068365281868204, 0.07942544072009383, 0.0819422894570212, 0.12407613400756601, 0.1151312455278174, 0.12792644635009853, 0.10922700125354057, 0.1256885377530853, 0.13553690002009222, 0.11466623861904246, 0.1485980108467353, 0.1050579435878577, 0.01100747100687438, 0.024631004109383903, 0.01364361498525124, 0.018477407704888038, 0.023307963673433907, 0.025512296854587446, 0.02073422170671091, 0.025274256101034953, 0.023429934306794187, 0.010088622205993159, 0.025028424434428764, 0.0048152528981876275, 0.019606008097990846, 0.03040433041189139, 0.01917559002000402, 0.014585301735468792, 0.004289901412804498, 0.01713443786987423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05467927775666881, 0.05754568580365427, 0.0560660842875228, 0.02630956197871115, 0.031390647958136286, 0.06603186865608257, 0.05000485478590233, 0.05793067730443513, 0.042729443506324793, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009319994488207861, 0.009236402981198988, 0.04054012408640428, 0.004447364015545685, 0.0043197918759251275, 0.004143539569715138, 0.009392383601866783, 0.008653439497020243, 0.01537439234475002, 0.2265789906774146, 0.22233279654613292, 0.2083675344408259, 0.21092230486706098, 0.21309823633420077, 0.19577135488926534, 0.21635587537960588, 0.19432380104880353, 0.2077469530652416, 0.04424483472053875, 0.05184940860313514, 0.05555147338787936, 0.0563892336603643, 0.043574452410791276, 0.04887039219992306, 0.05950729608577254, 0.05236414369966391, 0.05055478132718072, 0.10922008781274384, 0.12068610092221921, 0.13368593449626565, 0.10590707618389383, 0.12771722769298977, 0.1218045873216872, 0.12356204478809252, 0.11829844958276226, 0.11075050438896028, 0.15593528676737878, 0.17634127521273713, 0.17434087109588836, 0.15451476788659602, 0.1473825554864039, 0.14997494057035, 0.17480382049794974, 0.17925660310670866, 0.150267835327491, 0.10255443458132618, 0.11339143277158126, 0.12948979318600717, 0.10752644465026884, 0.08878056723679872, 0.10139550254633445, 0.12894845709468028, 0.13289334758367533, 0.10491157707943544, 0.14664806722871493, 0.16481083845993905, 0.1681905966151347, 0.16083813336775687, 0.17927459998077866, 0.1785039257349308, 0.16190353033689464, 0.15603045901792179, 0.16457400427841407, 0.14871189917557293, 0.11157770817205692, 0.1285978994922099, 0.13702552183439654, 0.12022484220238916, 0.14352536379994818, 0.12071414533498215, 0.11769471011826849, 0.1292891986359297, 0.14151346637145412, 0.10813566308678146, 0.13386404631251148, 0.11416190180970776, 0.1207914665021157, 0.1398872998561128, 0.12361698143147315, 0.12700926430604487, 0.1388714796704924, 0.14512328497059612, 0.13403850074311707, 0.12282250361495395, 0.11192196254198139, 0.11533670192508017, 0.12130184333044725, 0.13740092219882394, 0.1406263852605656, 0.14390999455412679, 0.20544694030545518, 0.18463167441349437, 0.1872293114748098, 0.18067697583838616, 0.1829840619321118, 0.2012350760967614, 0.1777264644687211, 0.19016785482595977, 0.17822665773562618, 0.05660821454767606, 0.05796079332579196, 0.05909027726634919, 0.053509093273923614, 0.058486054475425986, 0.05522252076755818, 0.047522137896285344, 0.055803659233975456, 0.060421195848425535]}, "mutation_prompt": null}
{"id": "51a37119-1f35-4f91-8e8e-c5ad95061f5e", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Mutation\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Dynamic Interaction: Reinitialize worst subpopulation to maintain diversity\n                if (self.evaluations / self.budget) > 0.75:  # Trigger near end of budget\n                    worst_idx = np.argmax([f.min() for f in fitness])\n                    populations[worst_idx] = self._initialize_population()\n                    fitness[worst_idx] = np.array([func(ind) for ind in populations[worst_idx]])\n                    self.evaluations += self.subpop_size\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best", "name": "EHDEAP_MPD", "description": "Enhanced Hybrid Differential Evolution with Adaptive Multiple Population Dynamics (EHDEAP-MPD), which utilizes multiple subpopulations to balance exploration and exploitation via adaptive parameters.", "configspace": "", "generation": 10, "fitness": 0.12012811163734621, "feedback": "The algorithm EHDEAP_MPD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.14.", "error": "", "parent_id": "06f5fd14-8fd9-407d-9913-370a043a8134", "metadata": {"aucs": [0.2210579806507973, 0.2107076800539739, 0.19691232738298903, 0.23404929274723707, 0.22856051934834176, 0.20904023818216544, 0.2431571119011564, 0.23974758942644603, 0.2094809653770784, 0.00454085477544286, 0.011344487893161559, 0.00040204270813049003, 0.0018184818938150604, 0.024261189649775416, 0.023324006317234525, 9.999999999998899e-05, 0.015007819694944247, 0.00541013380194344, 0.05318203305341229, 0.062163146937453506, 0.07221503064225165, 0.06706391357282027, 0.058607107325857166, 0.05829305546813279, 0.06315520432724353, 0.055784627758756145, 0.06689334198519081, 0.04652966071994158, 0.04344112933341182, 0.033215644465177996, 0.04144203197238816, 0.03953044874012335, 0.0449812550928278, 0.04758378433277355, 0.048033732241740124, 0.04899641112100217, 0.756785024448368, 0.7158681369977048, 0.7035040507862557, 0.6870549330331975, 0.609376438152424, 0.6634680048223949, 0.8763117936805964, 0.5094828179026198, 0.7487940519448948, 0.08086140581841994, 0.05955217512307576, 0.0520528337637397, 0.0778098952726416, 0.052796280101343074, 0.07319254197965297, 0.0762304045290011, 0.09369061869621942, 0.06466777134945911, 0.1586793836564635, 0.1590753448898946, 0.15638482015188493, 0.13251891454616904, 0.1390332878440731, 0.12674883136269277, 0.09345503625016371, 0.12965333006771274, 0.12250824697407736, 0.051613214900121385, 0.005525937601916331, 0.011585816431019746, 0.03586383704968088, 0.05912387311885725, 0.02525458772401068, 0.013292542957304199, 0.03371667644213572, 0.035296944704878985, 0.025219601246930012, 0.022817582866203834, 0.042780407146785215, 0.03269811651101573, 0.009409055872727334, 0.03200416138120199, 0.05316584840824601, 0.0017885594174529285, 0.02527513450269292, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08493279174249291, 0.08259203339846555, 0.055517712813216935, 0.03187529413673351, 0.05676032461586766, 0.02661413477351393, 0.04809197756443606, 0.05524462356166715, 0.04097896382360211, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006799179021629076, 0.006555498401876525, 0.008295138054574491, 0.007676994516206848, 0.01467411908224947, 0.030382109527444467, 0.002984028097211877, 0.01084664483346609, 0.02460455999478728, 0.1920185136287218, 0.2447406497573893, 0.2522425184125937, 0.2255942989201809, 0.20334821300387407, 0.22175935149600667, 0.22313189590927485, 0.1948705143701882, 0.2263907609712288, 0.048417192014379884, 0.05691003320214516, 0.05377971364296996, 0.05637790330764292, 0.0434381534826227, 0.048400272123595434, 0.047395027225741626, 0.05520411442343687, 0.041266968576516905, 0.11604337358154493, 0.1168345211379852, 0.12843673635914543, 0.12285809491750443, 0.119114646806734, 0.1273274760987113, 0.11687534012025658, 0.11373187339225732, 0.10550392878694004, 0.16584924668190493, 0.16126950950607133, 0.17103709188902427, 0.16619780284381136, 0.16628151863129081, 0.17004242704977934, 0.1772282274663548, 0.18236428337976485, 0.1668540800416929, 0.10863837857957881, 0.12446854438903443, 0.1280151053927604, 0.11846282367524652, 0.11911472685551949, 0.11364996422694951, 0.11312935357270504, 0.1135771170105041, 0.1356935593787122, 0.16930415823174172, 0.19054074476176353, 0.17476099395739353, 0.16341392071871108, 0.16004047600180493, 0.16916241439142088, 0.18744076779643992, 0.16355984814383495, 0.18892173649427202, 0.12546022953366442, 0.15766816223193003, 0.1313710187213306, 0.13322868961635614, 0.11697554892636619, 0.12716815880625054, 0.1519239480462664, 0.13489271874213482, 0.1435554464987484, 0.11519911517180059, 0.12988653202970069, 0.13413911309818505, 0.1351666257314188, 0.13448934943435964, 0.13166888509131136, 0.11797213937051854, 0.14583117569677673, 0.11440040008345453, 0.13476064635876062, 0.1609386163688894, 0.13110097996703574, 0.17362444606247573, 0.12815831067185757, 0.12616578568269565, 0.15456761633850913, 0.16158767803542506, 0.17200397809554413, 0.1902331211659435, 0.18148021280969617, 0.2057257520782032, 0.19698410319704396, 0.18086014655216298, 0.20616573002341088, 0.19327232715405696, 0.17945380193882499, 0.1851069236302214, 0.059346656451465085, 0.07154206200992486, 0.0611891380475974, 0.06211650108887734, 0.06105710479481263, 0.05660231969588625, 0.05783412191391468, 0.06831615652828149, 0.07220103215411433]}, "mutation_prompt": null}
{"id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 11, "fitness": 0.14119438773185036, "feedback": "The algorithm EHDEAP_MPD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.11.", "error": "", "parent_id": "51a37119-1f35-4f91-8e8e-c5ad95061f5e", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "f55a84c7-fe20-4953-9431-58e92147dcf9", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "35bc2be4-6c3d-4969-b9b8-21a220a91abd", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "2ca34cc4-6406-4693-b070-ca7aae92752c", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "d883faab-8f10-4e34-908e-4d401f12fc13", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "152e3906-eff2-47d7-82b0-198a94be63be", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Chaotic Mutation Factor using Logistic Map\n                    self.mutation_factor = 0.9 * self.mutation_factor * (1 - self.mutation_factor)\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Dynamic Subpopulation Resizing\n                if (self.evaluations / self.budget) > 0.3:\n                    self._dynamic_resizing(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _dynamic_resizing(self, populations, fitness):\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        top_half = sorted_indices[:len(sorted_indices)//2]\n        for i in top_half:\n            additional_members = np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size // 2, self.dim))\n            populations[i] = np.vstack((populations[i], additional_members))\n            fitness[i] = np.append(fitness[i], [func(ind) for ind in additional_members])", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced EHDEAP-MPD with dynamic subpopulation resizing and chaotic map for mutation factor adaptation.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {}, "mutation_prompt": null}
{"id": "c5a4f3a4-aa74-458a-a854-a4a59f18ab67", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "3b4f703c-26a4-4d12-836e-299b3d1335be", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n        self.elitism_factor = 0.1  # New parameter for adaptive elitism\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Diversity-Driven Dynamic Mutation Factor\n                    diversity_factor = np.std(population, axis=0).mean()\n                    self.mutation_factor = 0.5 + 0.5 * (1 - diversity_factor / self.bounds[1])\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Chaotic Local Search\n                    refined_trial = self._chaotic_local_search(trial, func)\n\n                    # Selection with Adaptive Elitism\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n                    elite_threshold = np.percentile(fitness[s], self.elitism_factor * 100)\n                    if trial_fitness < fitness[s][i] and trial_fitness < elite_threshold:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _chaotic_local_search(self, trial, func):\n        step_size = 0.02 * np.sin(self.evaluations)  # Chaotic search step\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n\n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Enhanced EHDEAP-MPD by introducing diversity-driven dynamic mutation, adaptive elitism, and chaotic local search.", "configspace": "", "generation": 18, "fitness": 0.10589121219180596, "feedback": "The algorithm EHDEAP_MPD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.15.", "error": "", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.15520315046596556, 0.1516456427935573, 0.171169452751477, 0.16591087198508248, 0.1479980371394406, 0.19159572710640527, 0.16791188408141422, 0.15523204585796324, 0.1458216635249866, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004526288179663829, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022895558541470074, 0.04255251648128611, 0.04119139699033858, 0.04644100701646181, 0.03911337416818228, 0.03486941100083618, 0.051574892160838326, 0.04065795357022339, 0.03099702920881542, 0.02073189806159048, 0.014447570934161602, 0.04171113084094502, 0.03268330928553764, 0.020526846790150377, 0.037867798336285174, 0.03557328682428995, 0.03576870535236776, 0.020921357862008882, 0.7920323825783121, 0.8989034360713183, 0.795520029617117, 0.608612463092148, 0.8218276873599522, 0.7297507926435516, 0.45852224878156445, 0.7107987382021999, 0.8141358447694105, 0.06274794416174423, 0.04885928932400696, 0.050731918278492216, 0.050515040584933724, 0.03556395925169853, 0.06572321899637246, 0.05706576430407151, 0.07013605732468275, 0.04221690359065611, 0.12600793011348432, 0.09058934511167194, 0.07680728347408261, 0.08468549267133163, 0.10830451245314876, 0.09305646828419234, 0.11598723318025983, 0.08986223830014128, 0.12781668399275092, 0.012386996957926, 9.999999999998899e-05, 9.999999999998899e-05, 0.010087568089062748, 9.999999999998899e-05, 0.004218674004194289, 0.006304409350764595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006691234910785493, 0.02020955838238714, 9.999999999998899e-05, 9.999999999998899e-05, 0.01908044493938088, 0.011569454769141285, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05244837499453747, 0.01828529168293569, 0.05828670079734821, 0.043508515990874685, 0.062118202386477916, 0.03551401466837156, 0.03566283847395568, 0.03480762583010766, 0.04366320128173684, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00024159478183849448, 9.999999999998899e-05, 0.0010457791353166712, 9.999999999998899e-05, 0.0005990322677152937, 9.999999999998899e-05, 0.002601018904574093, 9.999999999998899e-05, 9.999999999998899e-05, 0.21453708000733518, 0.15756555760738078, 0.17650214059563074, 0.17415527540016862, 0.15977650068740257, 0.18992633351913701, 0.22761180057609154, 0.163826599846166, 0.1994750844054688, 0.04226964910015396, 0.0468857417380637, 0.034082072844868305, 0.039809161242994606, 0.049290356064398466, 0.03964060310735351, 0.03628687025704458, 0.041787561054705824, 0.03933847012622804, 0.13079396008099198, 0.11622915048920035, 0.14863737311286063, 0.12327945576949917, 0.11144229113944015, 0.13788545638214478, 0.1422307975455429, 0.1385389301585901, 0.11016974247536726, 0.15143424877779255, 0.14748119805252868, 0.1641412574029748, 0.1570240272167286, 0.1380905503182761, 0.14870904750412484, 0.13931973914719942, 0.17377774300845283, 0.15826696462161194, 0.08582675247230331, 0.08235461080611584, 0.10859772187537164, 0.10099219653938851, 0.09073214313350708, 0.13862319856027894, 0.09257518601080572, 0.11547017949888871, 0.0996275991982426, 0.15725528583440662, 0.1508618116871887, 0.15217374092030822, 0.15448845430578861, 0.16542624405604456, 0.152226379151561, 0.14695730196233558, 0.15268482001362105, 0.1695327434639763, 0.10431211940187546, 0.12684483583468753, 0.10231232972977433, 0.137867179818009, 0.09690974003821151, 0.08510428891809785, 0.12897790774526707, 0.08845475344967313, 0.0662638277465396, 0.1359036886254904, 0.15124895766991153, 0.13600016525145053, 0.19545797261423747, 0.13369467412968206, 0.11422812368861146, 0.11958902052145437, 0.12290910976563552, 0.12319789974302586, 0.11365184061761502, 0.14773176918507946, 0.1143127809387422, 0.15848343961070877, 0.1209285275207409, 0.07909553505060318, 0.11516362064794539, 0.10931704426914579, 0.11150344497441933, 0.18399709608551895, 0.1867917177065591, 0.17940437325793301, 0.19230009687839622, 0.18114391133478913, 0.18153942377876087, 0.1965809292094326, 0.18426946614636697, 0.18366608890981262, 0.051695595612818224, 0.048554820066087134, 0.06502255413167313, 0.06790053886036751, 0.04169390546467544, 0.05996895122686652, 0.04575717538358892, 0.05113208723388818, 0.06724209733739461]}, "mutation_prompt": null}
{"id": "2dd0a541-c41c-4be0-8f72-3c65c32342ca", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "52332b95-46aa-4c3a-8de6-177aa55bf33b", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n        self.adaptive_step_range = (0.001, 0.02)  # New\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._enhanced_local_search(trial, func)  # Changed\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _enhanced_local_search(self, trial, func):  # Changed\n        step_size = np.random.uniform(*self.adaptive_step_range)  # Changed\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(7):  # Changed\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced EHDEAP_MPD with adaptive learning rates and improved local search strategy.", "configspace": "", "generation": 20, "fitness": 0.13315209619639992, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.12.", "error": "", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.30916511851910655, 0.33257510469684914, 0.3058667255622942, 0.28123484473021, 0.3237105098235865, 0.3013290314973853, 0.3676913692155216, 0.3750700983398537, 0.33164252928418725, 0.07279065698708187, 0.06606617183300767, 0.06982953014232385, 0.09608759652891163, 0.09501671376177456, 0.09673489820262826, 0.07129525863671238, 0.09647167078715624, 0.08441703238304477, 0.06944811161829112, 0.06380052118862456, 0.07378973560008195, 0.06445744742131265, 0.07400857978774, 0.07904143188555646, 0.09688084502630623, 0.08582518931558192, 0.07149318457873055, 0.039011489471125094, 0.05120662200073456, 0.0688742991165533, 0.06709564204873586, 0.06833874980854249, 0.05148521384388127, 0.05836254926861295, 0.06708882961299201, 0.03967996698348397, 0.42002778342499747, 0.4235586629959236, 0.620081194719845, 0.449250491040298, 0.7516057344847324, 0.5770674828170486, 0.7421862996827967, 0.40229889292711574, 0.5460782804746152, 0.1152356681786576, 0.07188169975990555, 0.11141157753640751, 0.0642684374957807, 0.07448233386800962, 0.08597116694484064, 0.07406456068472056, 0.14392299309911216, 0.111366477128794, 0.1441993437958381, 0.14771724254126473, 0.12634375548267796, 0.1650960711477918, 0.15328879571456966, 0.14457044088099824, 0.13727239921887435, 0.1288761479560644, 0.1636030108405273, 0.059700116235703926, 0.05207664159263403, 0.04097483058181317, 0.05325867055523703, 0.059585437463442026, 0.035790031646756315, 0.06632431368133296, 0.05245728147326567, 0.07705546881048664, 0.03867035476716085, 0.08066217743943593, 0.06111450478312486, 0.04075533250548835, 0.06654115202982835, 0.05679455032071978, 0.0851309240926641, 0.06711157983531646, 0.05941188241823925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00018599310540734493, 9.999999999998899e-05, 9.999999999998899e-05, 0.06923629242691676, 0.06892598866611299, 0.10320216786759917, 0.09617745994632076, 0.041512878117747065, 0.05806601092509811, 0.07693552460409159, 0.07788920878070038, 0.07456501936096849, 9.999999999998899e-05, 0.003205340870356621, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006391899743227958, 0.003719265331055932, 9.999999999998899e-05, 0.005484524364249954, 0.03576279115696068, 0.03636115612003887, 0.047532852895391664, 0.004962755512625705, 0.013546274793077462, 0.03187618804639747, 0.030921410408138006, 0.023927264028122175, 0.02545168207913162, 0.28635795136657094, 0.2560203073038064, 0.2677500617361478, 0.2737997266697947, 0.25693095760365203, 0.268804183706975, 0.27731224426159673, 0.2714653820634838, 0.2671962730438504, 0.06524854215825959, 0.057994367268970226, 0.05755330179209317, 0.05837853634842649, 0.061940914927526514, 0.06449269150515424, 0.04771012653992479, 0.05218886719688598, 0.06526203940086084, 0.1375282516924966, 0.12712333242137208, 0.14122958294751786, 0.1193973685747256, 0.1445063448553341, 0.12458937573522011, 0.11296261525435802, 0.14143133930794716, 0.10165842504483535, 0.17127199441875451, 0.17761370698399181, 0.19076643320045383, 0.1668807278990344, 0.19438200326793753, 0.18519529878097563, 0.17574223335469197, 0.21099666708231812, 0.21503281062761548, 0.11935204591836823, 0.1396780310067125, 0.12538383915562623, 0.1352521234538424, 0.13693098958226035, 0.14205342547073108, 0.11430774334526417, 0.14890441984853264, 0.11700637233676736, 0.186565132624396, 0.18527620725626825, 0.1873335320633489, 0.1789063658230563, 0.17399115104785323, 0.1823764154377585, 0.18619524419229205, 0.1783344307688527, 0.1778097434634095, 0.12139387565046966, 0.12790208760490895, 0.13927114894464576, 0.1330815120192207, 0.14357285645718387, 0.13466531296566087, 0.1605111528595764, 0.12853789176492714, 0.16680489162073087, 0.14079578067912057, 0.11477502054211586, 0.13099800320721766, 0.14402010711694524, 0.1821087302970652, 0.13260706941946154, 0.14650593179651317, 0.1509362347527895, 0.14349281421309734, 0.1825924721961255, 0.15458116911294295, 0.1492930252391097, 0.14628571966670878, 0.15558918832794566, 0.12165861797171695, 0.15704067865096205, 0.11509350838321841, 0.14232925384484207, 0.192587440364265, 0.1899586836919177, 0.18437242454417535, 0.18275453852169066, 0.1945514567553761, 0.20112823767026233, 0.18370400973330914, 0.19662994334080208, 0.1914056274403121, 0.06733338005278455, 0.06585674253908658, 0.06141763173950732, 0.06327842590188015, 0.07113627340227391, 0.06696686178390265, 0.08022298848250353, 0.06777822017221746, 0.06978822410887786]}, "mutation_prompt": null}
{"id": "2fe369df-13c2-45c6-8a3d-7f9524bab7d6", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "2590c240-504d-43ae-9a44-b521d0541624", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "43ea5de5-f2ba-46c4-8d23-454d8a45297f", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "7d96f583-1722-4e72-a4de-097e241940b1", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "da384b3b-088a-48e0-9414-bf2dab400195", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor with decay\n                    self.mutation_factor *= 0.98  # Decay factor\n                    self.mutation_factor = max(0.4, self.mutation_factor)  # Lower bound\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Mixed Crossover Strategy\n                    if np.random.rand() < 0.5:\n                        trial = self._blend_crossover(population[i], mutant)\n                    else:\n                        trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Hybrid Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[s][i] or np.random.rand() < 0.1:  # Exploration\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _blend_crossover(self, target, mutant):\n        alpha = np.random.uniform(0.2, 0.8)\n        trial = alpha * target + (1 - alpha) * mutant\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Enhance EHDEAP-MPD with adaptive learning rates for mutation and crossover, and introduce a hybrid selection mechanism to improve convergence.", "configspace": "", "generation": 25, "fitness": 0.11458271495462713, "feedback": "The algorithm EHDEAP_MPD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.08.", "error": "", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.33342775891203913, 0.1836436188320818, 0.4230667871005189, 0.1371285524611089, 0.16234399320486992, 0.17013825825177553, 0.23113315548010338, 0.29931216422063256, 0.16357062292957159, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004146377528107759, 0.0210832602178862, 0.0010906868886968457, 0.04032538701405808, 9.999999999998899e-05, 9.999999999998899e-05, 0.0768628095788908, 0.08146002620377402, 0.08915824454411958, 0.07757097797726709, 0.04254694700897943, 0.08356761694499948, 0.04460055663619389, 0.08163380652682883, 0.05930998212046468, 0.03356689659630696, 0.03715754238179292, 0.042595655011199995, 0.05370503340162125, 0.05776385855127342, 0.041342385107436486, 0.056751333627221956, 0.025273066606804395, 0.03895778070542766, 0.06265208466588623, 0.0751058779722894, 0.07680576967249908, 0.09516961077346986, 0.05834534410661674, 0.0739946652210941, 0.09009314992470718, 0.06470212427449529, 0.0622734865522101, 0.1068185648028962, 0.04543371943491292, 0.06805502465419544, 0.07181807737609303, 0.059724098017669314, 0.04774006092579819, 0.07833211402190077, 0.05975436602288586, 0.07310537809782414, 0.14628202421432945, 0.20384418443351215, 0.15506189538214188, 0.19850331785331576, 0.15470076535584776, 0.06711074057469191, 0.12471932674716879, 0.13814793397766667, 0.1845794087073691, 0.10247974025510742, 0.006987505991030818, 0.1158573864016973, 0.08744933939564548, 0.06489422855505145, 0.03825004469096094, 0.07827050710931449, 0.08186330988516088, 0.12799392228308482, 0.07091400817327742, 0.08143115904801057, 0.09067292660806614, 0.07940542070759216, 0.09751573871412855, 0.1259153053860207, 0.05352617005528559, 0.09319894700951104, 0.07599629300488864, 0.013715105533367411, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005152184362386625, 9.999999999998899e-05, 0.0033951505019398365, 0.040906943691596975, 9.999999999998899e-05, 0.09580323299942117, 0.07376041308578118, 0.08996899706496697, 0.08280609933952454, 0.09216869944190598, 0.051140493873691906, 0.11360566310957287, 0.10700316523020514, 0.07044586945816023, 0.020897437370318017, 0.05316846384718721, 0.03964568159834814, 0.03833969357140754, 0.025041842382797386, 0.0030791866052791717, 0.017411249829495268, 0.003750395907978654, 0.039283426367339835, 0.005105319091265326, 0.0006347772948245289, 0.029213445933903293, 9.999999999998899e-05, 0.00876534473251378, 0.005595234562087881, 0.010268548169583336, 0.0031931998788177207, 0.06226897898763528, 0.25723932327413823, 0.31533483019223796, 0.2351817364269424, 0.15008830897401637, 0.15612807941681972, 0.22013490328571106, 0.3453722827193587, 0.23008738961892328, 0.27664418467572727, 0.021436491304935745, 0.03373029391626792, 0.04624935099882099, 0.05940019564976484, 0.062234822478889895, 0.06357327685209346, 0.0723512020479129, 0.0578655792154501, 0.05509579630389705, 0.15724180312610947, 0.11263784641082653, 0.13603203435770939, 0.13789843207379704, 0.1714396744979524, 0.12160958511764675, 0.13721222990979554, 0.14420080837045368, 0.13773584283210927, 0.1769865760136976, 0.18545500208592547, 0.2076642485893474, 0.1857557690290148, 0.19193908482788935, 0.2092018240113559, 0.1600722330069122, 0.1907866691044554, 0.1488799357846361, 0.14039268907632196, 0.14409259438158128, 0.1329982819914407, 0.15738089812021339, 0.16977869611472307, 0.17262186775343635, 0.10341756231161126, 0.17092702457659104, 0.14221795334145426, 0.21021568095545062, 0.21006403179719257, 0.21334460114913778, 0.2418634557642143, 0.2126426677211648, 0.20044361336012817, 0.2233847737625062, 0.2119613777822812, 0.23657080975501144, 0.1724938186223346, 0.1784033118601075, 0.18523475037901416, 0.16650571374707834, 0.18983174628131605, 0.1728113312825913, 0.17104658832493747, 0.16670228843183554, 0.16727779798597364, 0.15222866431204218, 0.16474235634009493, 0.16615342699589397, 0.22799466937148138, 0.16590429254166572, 0.16331137129914075, 0.20224674387174701, 0.1287692747836121, 0.21480890407004272, 0.2270313923670575, 0.27724796911126304, 0.2629525597437038, 0.15323769501820694, 0.28229913289586206, 0.12780241985458773, 0.11581810323316555, 0.1244365226508164, 0.1977469661513338, 0.1965016686443034, 0.18531204158494863, 0.1970802857871733, 0.17797510081979617, 0.18508697763390247, 0.21220557422673114, 0.17446018301903898, 0.20320856057165626, 0.18809836241602584, 0.08544426468400257, 0.08944451614868743, 0.08778059433327601, 0.081867527780067, 0.08041800580020486, 0.06984375920729324, 0.07198568796942928, 0.08010650329609836, 0.07642632510123826]}, "mutation_prompt": null}
{"id": "20857b12-5b8e-47d1-9030-f20b38b4c988", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "aa0647eb-bb01-4282-8301-04b61644150a", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor with learned updates\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand() * (1.5 - fitness[s][i] / (max(fitness[s]) + 1e-5))\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Hybrid Crossover Strategy\n                    if np.random.rand() < 0.5:\n                        trial = self._crossover(population[i], mutant)\n                    else:\n                        trial = self._blend_crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging with variance check\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    if np.var([f.min() for f in fitness]) > 0.1:\n                        self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _blend_crossover(self, target, mutant):\n        alpha = 0.5\n        trial = np.clip(alpha * target + (1 - alpha) * mutant, self.bounds[0], self.bounds[1])\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Enhanced EHDEAP-MPD with adaptive learning strategies and hybrid mutation crossover for robust search performance.", "configspace": "", "generation": 27, "fitness": 0.132633118119669, "feedback": "The algorithm EHDEAP_MPD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.09.", "error": "", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.21486952518930336, 0.3578696011225405, 0.3091704480462535, 0.16232393050352656, 0.19275771392445984, 0.4310488058858608, 0.40600696991475027, 0.3222589747926954, 0.11598131712369375, 9.999999999998899e-05, 9.999999999998899e-05, 0.006312769654979067, 0.006758434298705485, 0.11622047034496974, 9.999999999998899e-05, 9.999999999998899e-05, 0.10802668539423432, 0.058377818663844616, 0.06864878895876558, 0.07237914311883054, 0.07413392903263194, 0.0693331880501703, 0.0908706564516022, 0.07868926573275836, 0.05818697857360222, 0.07511551201939237, 0.08967275784554463, 0.04437560520096706, 0.048452031066922974, 0.07464956721994254, 0.06051590546305596, 0.05414353682626971, 0.08023212653921852, 0.0868672870280105, 0.06387950577356061, 0.058285219710569436, 0.11082247543374524, 0.3859773884294231, 0.08094810194596325, 0.07302299545067381, 0.1148289088190364, 0.143012461869081, 0.07593124838202625, 0.13356977837813355, 0.14230375084848657, 0.13062838483090478, 0.05871839941255497, 0.026483040529718394, 0.1173099039431611, 0.07657684465964754, 0.07637844614772749, 0.12068997745804477, 0.06838957884331198, 0.10870107220006175, 0.15467743253860666, 0.20647360781821944, 0.15572914660961035, 0.17637451637236568, 0.19291575257574411, 0.10809387851282903, 0.1305732493937647, 0.14721963884954692, 0.17750719708161578, 0.11536402501843024, 0.07017475824754327, 0.10183683530621024, 0.07667266320300825, 0.07764021630963869, 0.016168201791461945, 0.07376191229714546, 0.07977757495794979, 0.11733186449651911, 0.20248211428717777, 0.12833078737445158, 0.2363186756590303, 0.08245767381069724, 0.09117616207597934, 0.0719508894677725, 0.14049265983386472, 0.09988891005419498, 0.10396167815931079, 0.015688443968594035, 0.025867343307205748, 9.999999999998899e-05, 0.002228995253587218, 0.001746552996299, 9.999999999998899e-05, 0.05171217653658622, 0.0003894139728898294, 9.999999999998899e-05, 0.13080379025871047, 0.0800222211584134, 0.16087683115127638, 0.06847213019688148, 0.07250903191062752, 0.07803795084024623, 0.1478377429497183, 0.11012140100532675, 0.09851644781290192, 0.020819429766197217, 0.04580724188566909, 0.024143972184034412, 0.03051938361685802, 0.0588339563889102, 9.999999999998899e-05, 0.05140629402197405, 0.0004894212507139395, 0.06036221838269773, 0.0030935676613050855, 0.10704754675090045, 0.04008292558049775, 0.037709227575870696, 0.027558987085664732, 0.07223492117173613, 0.020466349012615903, 0.03672097324497159, 0.05720526993982644, 0.31856602128102907, 0.3256587757454974, 0.31854867364194506, 0.23659523915234681, 0.209186141054595, 0.28498729273138734, 0.39551609874605664, 0.35222272306347946, 0.2297065741471256, 0.052227183027627855, 0.05729943158745843, 0.08757419421824342, 0.06048394660454237, 0.06138730806484294, 0.052785813929027925, 0.05742231613777571, 0.05407329047604159, 0.04932428657699439, 0.12727133641783128, 0.11856923712218137, 0.1331316357644058, 0.13484974641793035, 0.12150198204909757, 0.20701996864921668, 0.17269322135162912, 0.12805296795495358, 0.12274571165918657, 0.17629926582629274, 0.20497374421266445, 0.2033695377669953, 0.19819877242134265, 0.2604019246415725, 0.21393328138318046, 0.18226209156752837, 0.22835620752214825, 0.17377372044252226, 0.1751991061104351, 0.1322588064845055, 0.15327057173021696, 0.1514096356093847, 0.17688228600319622, 0.2464689157175265, 0.15753592852738407, 0.2021654601962346, 0.11787614635969024, 0.20411581468238005, 0.2056754457786787, 0.22970519943950107, 0.19867588295652416, 0.1993696019034823, 0.210745567412008, 0.22570450199990366, 0.22247447304106605, 0.21807698213813598, 0.16596702500108929, 0.1599000916020683, 0.1692491271612303, 0.16741479517234037, 0.1762232719249689, 0.15463317063748128, 0.16170549445491522, 0.15669528074701244, 0.1791001489710894, 0.1981994193997113, 0.16203384870000193, 0.15198638232816997, 0.43868697169818616, 0.16569534932755647, 0.1505422593040876, 0.19080608970025337, 0.26405729815486023, 0.19459329167744188, 0.2167510624462029, 0.2999357259607872, 0.29157292413364255, 0.1460666474448894, 0.31071576664250855, 0.1480638305561568, 0.1959660362965786, 0.19329912956525752, 0.11644985753317305, 0.1946176669044556, 0.17979124038687366, 0.19182999387674649, 0.18481040748683963, 0.18750164002084402, 0.1998093336712674, 0.18986907232082006, 0.20183851079308435, 0.18909412850109275, 0.0868042941094127, 0.07719927933604753, 0.07459686459538517, 0.08995170348464399, 0.07827956274754921, 0.0849104194090824, 0.05952027043877284, 0.0659421503398202, 0.07130528144142756]}, "mutation_prompt": null}
{"id": "1266bf8d-46d9-4ad5-9b26-471d6e817475", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "8b330fe2-30f0-45d9-99ca-5d099a02ce01", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "fb8a81aa-9269-4720-9f6b-d4d89f87f110", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "be372694-1efe-4b8d-a53d-e30b2617da90", "solution": "import numpy as np\n\nclass EHDEAP_MPD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Start value, adaptively adjusted\n        self.crossover_prob = 0.9   # Start value, adaptively adjusted\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Local Search with adaptive step size\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):  # limited steps for local search\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Merge the worst half of subpopulations into the better half\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD", "description": "Improved EHDEAP-MPD by introducing adaptive dynamic mutation factor and strategic subpopulation merging.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.3470805597505604, 0.2987585022335818, 0.379484503237532, 0.30142437100118336, 0.32846531907877463, 0.3616950394424453, 0.346997573839794, 0.3559554199083974, 0.32599747629557685, 0.11597719242052751, 0.11553425995967992, 0.08714073880690654, 0.10721994463929063, 0.09971205965777286, 0.10214742910299812, 0.10316780105867218, 0.11140561310230168, 0.12274063193535001, 0.06869444850558415, 0.08041972323442592, 0.08408698005541504, 0.09012880708147164, 0.07782128859620785, 0.0925450752424345, 0.07906273236141315, 0.08398542798525688, 0.0775323450117863, 0.06774585573372427, 0.0619117032012686, 0.06141559992131296, 0.0783600005313736, 0.060701043046176295, 0.0770356578495186, 0.06730054989907708, 0.06265224063837393, 0.06980423836052674, 0.4877828710359938, 0.5370534608966369, 0.4261012552200153, 0.5560206531645372, 0.5781948139083253, 0.4666115324187833, 0.5831485256813742, 0.49286280825223705, 0.4583184580480836, 0.12301267378281633, 0.09334545538001093, 0.08016962546569939, 0.16457572074872262, 0.09229640193046018, 0.11053857096547293, 0.09686277962158585, 0.11326262289742739, 0.13096514492262035, 0.16430879058939007, 0.14225684227535385, 0.14476407428167226, 0.14321492578199835, 0.1714111919450535, 0.19569277386750306, 0.15890118647565432, 0.15964344670689878, 0.1748731438575838, 0.05220449743132327, 0.06565019268617911, 0.08324141604027357, 0.059849339763044185, 0.0696193416029951, 0.065754823262545, 0.0706777091216303, 0.05263406417790628, 0.1035521158224828, 0.10640352906789974, 0.1003437745550052, 0.05307743795664155, 0.061016300630941656, 0.0814520114402969, 0.07045186166973161, 0.06690315754792664, 0.06507767708304202, 0.05424809690752297, 9.999999999998899e-05, 0.003541754611550263, 0.00010984297240279606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10105709353679959, 0.09027391808783958, 0.08465406147938903, 0.07130739018590704, 0.09217453252160179, 0.04942276305404614, 0.07617059721057062, 0.07610887873265892, 0.05988525857262883, 9.999999999998899e-05, 0.011457487965557123, 9.999999999998899e-05, 0.02001057046913679, 0.003917528112835189, 9.999999999998899e-05, 0.024795620291397036, 0.015424084730895404, 0.018604051211757566, 0.02699053069233248, 0.0577581991666648, 0.05146053655572247, 0.028653051638916294, 0.03027944110630576, 0.06768937454946977, 0.035707299758069744, 0.03139594110755628, 0.04983052523794085, 0.3239407938565195, 0.26783376160667205, 0.2803617168791418, 0.3092584852014012, 0.2962202803802515, 0.2866992219911769, 0.2909630434026893, 0.2925998830861274, 0.2889102709674737, 0.057512460207532645, 0.06400831083188296, 0.05354956898189289, 0.08011942223555801, 0.05566158568529267, 0.06451993952993396, 0.07445194117867593, 0.06550840201884844, 0.053019269592521234, 0.12526859167756232, 0.11229906658510735, 0.12834335301848254, 0.15050703018362788, 0.12131558930327124, 0.12479075917765536, 0.11881194809303175, 0.10585952504059659, 0.11694384166548566, 0.218181781064401, 0.1913525058736052, 0.2057715513859677, 0.20095448663555582, 0.20584129715618837, 0.18996784053483817, 0.23684737237099285, 0.2155096874352086, 0.20779606772522807, 0.1372165273363466, 0.14426048603212216, 0.16981690144821082, 0.12615450330415046, 0.13632630947534485, 0.15297015449808093, 0.1705740543301676, 0.1719222411510526, 0.14461887424171405, 0.19270156095183166, 0.1823159781746233, 0.20935506409384474, 0.18285403999076444, 0.18356891626483507, 0.19856872596519615, 0.17507687466917687, 0.1777165205021478, 0.1760645199709734, 0.15724258299109772, 0.17162990267653644, 0.15350428879059386, 0.15930509256506997, 0.15080043181514502, 0.15300773662609757, 0.17765562306008031, 0.16658417511074186, 0.15410032773509885, 0.14334128441617777, 0.14174543735703937, 0.13598338068986815, 0.197012247684337, 0.13685800868907938, 0.16247603580975023, 0.14895562457823053, 0.13328899767148128, 0.14066259965871764, 0.16940703259854095, 0.16552378404090196, 0.12160593763410743, 0.21082063677210827, 0.12014976408148037, 0.15129841917706488, 0.1494515748850328, 0.16564872656088026, 0.122977853158319, 0.18205038572476073, 0.1865972667957927, 0.1918682379202732, 0.18084751208162575, 0.18340935129960223, 0.18669038545531402, 0.18359288895554404, 0.18458197461672676, 0.17798583471357765, 0.06647275787522633, 0.06543348417870043, 0.07916375336040615, 0.0710505149240982, 0.06013260887004457, 0.070361627393555, 0.06483770331448191, 0.06311456927750658, 0.06504089835193905]}, "mutation_prompt": null}
{"id": "070e473a-28b2-4cdb-b6df-6d4c80ee187c", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Dynamic Mutation Factor\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], population[b], population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Enhanced Local Search\n                    refined_trial = self._local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Dynamic Subpopulation Size\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._adjust_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _local_search(self, trial, func):\n        step_size = 0.01 * (0.5 + 0.5 * np.random.rand())\n        local_best = trial\n        local_best_fitness = func(local_best)\n        for _ in range(5):\n            candidate = local_best + step_size * np.random.normal(0, 1, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            candidate_fitness = func(candidate)\n            self.evaluations += 1\n            if candidate_fitness < local_best_fitness:\n                local_best = candidate\n                local_best_fitness = candidate_fitness\n        return local_best\n    \n    def _adjust_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = self._initialize_population()\n            fitness[sorted_indices[i]] = np.array([np.inf] * self.subpop_size)", "name": "EHDEAP_MPD_Improved", "description": "Enhance EHDEAP-MPD by incorporating dynamic subpopulation sizes and adaptive crossover strategies to improve convergence.", "configspace": "", "generation": 32, "fitness": 0.12333838618213219, "feedback": "The algorithm EHDEAP_MPD_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.24670777473751782, 0.22436852777813443, 0.2905029276612022, 0.24063919545722146, 0.2607735404946082, 0.2572096975455931, 0.25095866821092594, 0.2600098751470463, 0.230275251425192, 0.02823971632832234, 0.03270778901464888, 0.015971731988759008, 0.00954667791332553, 0.03464454185874821, 0.023003212149630636, 0.026724246373258542, 0.029957762378108987, 0.04772528795290076, 0.061102230148013414, 0.07817912043039321, 0.07801805912504278, 0.0821492505821878, 0.06914859788377692, 0.06626169815756455, 0.06968074433979488, 0.07565490914452822, 0.06663672942384513, 0.06602759216342768, 0.049406289414195226, 0.05239134589099581, 0.06256990250148942, 0.055130915907338984, 0.06407044922146887, 0.05429068469803788, 0.05106134862201761, 0.05874989248502838, 0.43680663082426485, 0.5370534608966369, 0.3286978653931991, 0.5560206531645372, 0.5781948139083253, 0.4272359193298889, 0.5831485256813742, 0.42757750543204565, 0.3843006790961635, 0.0913569642647204, 0.07415100476741499, 0.07507860821678769, 0.12950231913357235, 0.06118786441404078, 0.09448255816089768, 0.07542128059363062, 0.08493785849150759, 0.11137611183688823, 0.1583769772825071, 0.13220216847315192, 0.12772846824080586, 0.14268072097247897, 0.156530030682818, 0.18914871500297736, 0.1496541721371616, 0.14379309052918055, 0.1513005849356841, 0.045843408956579124, 0.06074365461192466, 0.08051567779803448, 0.044285758043415835, 0.05339913524292317, 0.057755875324079, 0.057263799417172634, 0.032204979481079476, 0.07012232928037032, 0.10478794116411738, 0.08606641830477424, 0.048657844453762866, 0.04428436345159481, 0.05818012226437841, 0.05146265703529718, 0.05069995487181422, 0.05286477970478498, 0.03530413711219316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09402427042127437, 0.05289651931424999, 0.0785386137379861, 0.06846142220832752, 0.08428488444733961, 0.03751664790309828, 0.07507474683564797, 0.06524594587659283, 0.05976012161943023, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012563856852898292, 0.0214732448235343, 0.03238900263422673, 0.01574334497882368, 0.03337992382528576, 0.032509530918401475, 0.02519875641593894, 0.026530586325463457, 0.019553921721424894, 0.2745587000137335, 0.21801781772769446, 0.25205311844187195, 0.2816116422673768, 0.24391685591360124, 0.2439906830495121, 0.2317751943061035, 0.245315634084727, 0.2444692384301843, 0.05413232436130799, 0.058223933896595526, 0.05322253586045922, 0.0730715429488531, 0.056573706046533334, 0.06623143090863215, 0.07305136069798868, 0.06085264889005726, 0.05558655425206649, 0.1146023954581582, 0.11191538803245205, 0.12932449456646988, 0.15050703018362788, 0.11843163049886041, 0.12479075917765536, 0.11994265761688816, 0.10587396665987459, 0.1153450226726862, 0.2108530968207072, 0.16475648054041392, 0.18840725596445895, 0.18904002469464298, 0.18664178403848097, 0.17874647309752423, 0.21749924525304443, 0.20184552358468177, 0.18641346746081622, 0.12977698770943336, 0.1406882847499854, 0.15068121524579292, 0.1206948989147808, 0.13110448725353674, 0.13469179942677056, 0.16221290562703738, 0.14652025815405034, 0.1258109646697403, 0.19250526067935736, 0.1823159781746233, 0.20935506409384474, 0.17692726452869934, 0.1788369828995524, 0.19856872596519615, 0.16086688543747585, 0.1777165205021478, 0.1738967645241688, 0.14793089700691775, 0.153076457239272, 0.148425529191203, 0.1596566679582564, 0.14981513383379674, 0.1462068365565421, 0.1684333815197553, 0.1627101653322225, 0.1513057653932941, 0.14367926141448406, 0.13806017546402727, 0.13598338068986815, 0.13650256411040373, 0.1345946966990752, 0.1552458561090554, 0.13940883796198855, 0.12978329237709496, 0.13911380956559882, 0.16162280052546607, 0.17937450426887103, 0.11884438452610413, 0.18136709615205537, 0.11317373030195699, 0.15069386514494776, 0.14374223480787407, 0.1539166105090911, 0.12081061247612346, 0.18042331674757084, 0.18051588880668024, 0.19109583767823457, 0.17658649322275344, 0.18159550012812808, 0.18067011929065535, 0.1814270799713077, 0.18491066985060833, 0.17521449847391013, 0.06154867327221325, 0.06543348417870043, 0.07916375336040615, 0.06762832567292076, 0.05940388165988475, 0.070361627393555, 0.06288402186059161, 0.0679959193487164, 0.06616099651824003]}, "mutation_prompt": null}
{"id": "825d3747-26d9-4a32-9e75-6fc529520241", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n        self.elite_fraction = 0.2  # Fraction of elite solutions\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Differential Elitism\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Adaptive Local Search using Lvy flights\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.01\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced EHDEAP-MPD by employing differential elitism and adaptive local search inspired by Lvy flights.", "configspace": "", "generation": 33, "fitness": 0.2181239247329921, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "d5606f61-38f0-49d0-a0b9-4d009c013e71", "metadata": {"aucs": [0.5140285604079206, 0.5094730199450579, 0.5286571068514563, 0.5637715825386076, 0.5098765461246832, 0.496552531893539, 0.4962947009007984, 0.48488173568364523, 0.5039308184884368, 0.20281539802401516, 0.23678088599359115, 0.22660511861409882, 0.13911960030952852, 0.20634924406644883, 0.23332961985698897, 0.2578802790058219, 0.21795311343935353, 0.21842867043662129, 0.10265492023917144, 0.10536257087186385, 0.11596519817105877, 0.12666762346127558, 0.1826651725076629, 0.10830501864976538, 0.1075059493702103, 0.19429402225777914, 0.11413531414492284, 0.09729971406873772, 0.10895851357779462, 0.1157864427022296, 0.10172472598209681, 0.10557598515793032, 0.105495896458624, 0.09644998630954527, 0.09780504001343182, 0.08941875771967733, 0.9435653128958781, 0.9273066664138279, 0.9814087864342814, 0.9814784861484398, 0.9634733240495225, 0.91946022977171, 0.9632525378842544, 0.9794743652293881, 0.9377373997740219, 0.1760978741943856, 0.2150307793514351, 0.2026518012720263, 0.19441152572093623, 0.184884582094197, 0.19291569207210646, 0.18214102232218554, 0.21238787578141516, 0.20949662649864798, 0.3888911543139896, 0.19098826566313953, 0.17009343145383138, 0.23155867409770403, 0.21631583546354005, 0.1923266794532681, 0.13586550013703802, 0.35282376623459755, 0.19447750277161513, 0.14701181067699431, 0.27881819493763527, 0.18558708677630031, 0.12534343484161692, 0.10440578442223636, 0.16934416489497728, 0.16558292815501285, 0.13320618788206462, 0.21236571563653583, 0.12995187192651925, 0.12084663963423758, 0.12959472933874971, 0.21085046320363676, 0.22013468230518052, 0.12284078585573821, 0.14001147440891382, 0.19141065265073554, 0.14224393587707418, 0.002370301635066796, 9.999999999998899e-05, 0.004102816937478604, 0.018485521024807716, 0.03861903863161764, 0.01534505869613223, 0.0371947704567307, 0.007038527426864838, 0.036271017528242355, 0.12056994043165992, 0.09830405041581802, 0.07272896423858799, 0.1261926353013867, 0.06611033946204403, 0.10968844919871445, 0.18686997019363139, 0.12982898053630165, 0.07229083931073188, 0.025529521293508717, 0.024971325299145586, 0.023658810819289444, 0.03285781815073119, 0.0475160039612329, 0.012462724321194774, 0.04023311195318635, 0.03368859617008635, 0.022082959690339576, 0.0821319985588389, 0.054952293999767754, 0.0868365142645201, 0.10351005978119487, 0.10916173206711377, 0.0983641278853733, 0.07293374501997163, 0.06655384684374821, 0.0674542069617321, 0.39972949429137483, 0.365124519260391, 0.3764081065513818, 0.37486245527966355, 0.3605115925296324, 0.3960198829166075, 0.4266333613945933, 0.4094139361228949, 0.3475957520463435, 0.1020693190800872, 0.08056326218279974, 0.07486664042300417, 0.0737533959630502, 0.08560245509695652, 0.08252085738316195, 0.08778505444189888, 0.08346879115998385, 0.07481658995416074, 0.1833943510584003, 0.15732660902840456, 0.19856983284693053, 0.2522100317762247, 0.19476503005756773, 0.17194311449881206, 0.17589754624797893, 0.20400520257200172, 0.13307793969492432, 0.28084480638315357, 0.20067332651574898, 0.24639456241526825, 0.2602856820755379, 0.24210878449186213, 0.22453294639360288, 0.2459142099903444, 0.2992797957293726, 0.29717343279310093, 0.16679337372223213, 0.15710687808139268, 0.17086390686023245, 0.16814856058250494, 0.15646942494858374, 0.16356131567482413, 0.21140992896852984, 0.21515166183527934, 0.1854555048234705, 0.19270488775937955, 0.17182251762751588, 0.18706627080944938, 0.22835026204690667, 0.15883385616433976, 0.22924847122526493, 0.19288918248123454, 0.19854371637285972, 0.16749002794340873, 0.1859847810229387, 0.17836217168494606, 0.1870596253524296, 0.19911034941777572, 0.2612809922920787, 0.1808272059614383, 0.17358470403301673, 0.27432431686873215, 0.18515692618066237, 0.18447946118053848, 0.3484076890585278, 0.17805287667158887, 0.5723985170045253, 0.18873748771703436, 0.47968307117637854, 0.4822096851854215, 0.3057604890951814, 0.19221795746462667, 0.4305818150259142, 0.19317696030915232, 0.16535925823942943, 0.18885721658270782, 0.2322305099077454, 0.14912291823818924, 0.19935357315456348, 0.18939270952945586, 0.33641425818645343, 0.19520618593457095, 0.19227284004365042, 0.24133656191967734, 0.20454907837751102, 0.2173389719329839, 0.19673379589652706, 0.2257678800300923, 0.26107755541909083, 0.20044175735765557, 0.06673154828242966, 0.07893616019348282, 0.0903624023454821, 0.07135968529222425, 0.08649290430998136, 0.07490778467897252, 0.07157719675636631, 0.07784006332049065, 0.08777918148629194]}, "mutation_prompt": null}
{"id": "49f5d574-c130-4528-a818-d86ec60856e7", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n        self.elite_fraction = 0.2  # Fraction of elite solutions\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Adaptive Differential Elitism\n                    self.elite_fraction = 0.1 + 0.9 * (self.evaluations / self.budget)\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    # Chaotic Crossover\n                    crossover_mask = self._chaotic_crossover(self.dim)\n                    trial = np.where(crossover_mask, mutant, population[i])\n\n                    # Chaotic Local Search\n                    refined_trial = self._chaotic_local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _chaotic_crossover(self, dim):\n        chaotic_seq = np.sin(np.arange(dim) + 1)  # Simple chaotic sequence\n        crossover_mask = (chaotic_seq > 0).astype(bool)\n        return crossover_mask\n\n    def _chaotic_local_search(self, trial, func):\n        gamma = 0.005 * np.sin(self.evaluations)  # Small chaotic perturbation\n        step_size = gamma * np.random.normal(0, 1, self.dim)\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD_Enhanced_Improved", "description": "Enhanced EHDEAP-MPD by integrating adaptive parameter control and chaotic local search to improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.09134477344170833, "feedback": "The algorithm EHDEAP_MPD_Enhanced_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "825d3747-26d9-4a32-9e75-6fc529520241", "metadata": {"aucs": [0.2181390325402992, 0.15374856177007623, 0.2302029970586127, 0.1640114435892327, 0.18883478100332274, 0.17123089587721374, 0.31371178902910546, 0.196602411045531, 0.2166123774303731, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0418869973433772, 0.07316247769361395, 0.06266909200283988, 0.07846444399995378, 0.05732297267097852, 0.04356684957903667, 0.06945191386447092, 0.05403212847531247, 0.048875971831953025, 0.012857858767875374, 0.06969116504526196, 0.044757159596141904, 0.06955498606447541, 0.07489081566419953, 0.043049985234294263, 0.05126832693829897, 0.03220115153955938, 0.04570999414975718, 0.097175921728484, 0.09275496078085876, 0.07816510979488067, 0.09748172022407287, 0.1016289816885525, 0.07822371169466225, 0.09624805847465123, 0.0875598389881459, 0.08117865427292303, 0.08046283158987244, 0.08945108244740752, 0.05522065606461879, 0.09314908305266167, 0.05431248240451114, 0.11000980180086994, 0.07241929196090313, 0.10349049144679634, 0.07862492918577157, 0.12120491342989936, 0.11279609952550584, 0.11696809289207155, 0.14213551346721764, 0.1552032483698922, 0.11903337426314742, 0.1453501283031059, 0.142421721299535, 0.12769040563210388, 0.05353424694453257, 9.999999999998899e-05, 0.023550499006116277, 9.999999999998899e-05, 0.0188153512053284, 0.03768995913039597, 0.04328263316308689, 9.999999999998899e-05, 0.07256538348726738, 0.023895803901047286, 9.999999999998899e-05, 0.016917007064692346, 0.008753599197530049, 0.00906305479637537, 0.037517014708896346, 0.01227523648032569, 0.028942771059457972, 0.0330869236124921, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046296120056437906, 0.028547967551989295, 0.025123579790942485, 0.02915237490159739, 0.03530278668995346, 0.021445899333526697, 0.02419024633091771, 0.07526015244526496, 0.025635458639503894, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00609258224026854, 9.999999999998899e-05, 0.00012509334399291028, 0.1564391650836453, 0.19347178417468158, 0.2629447450650423, 0.20592227487799597, 0.21366740993313726, 0.19040617793569303, 0.2479443890649473, 0.19429392894130837, 0.2276452314275802, 0.047431422162804715, 0.0664801283528268, 0.05116860565961778, 0.05319738344711589, 0.04767673567212183, 0.058989784401378476, 0.049372348198782445, 0.02691044934506648, 0.06751495827727882, 0.10947629023721162, 0.11674681232483342, 0.12975363405647677, 0.11246658847893176, 0.12270168272697335, 0.13902171648191708, 0.12649852977754106, 0.11567165418208492, 0.1096759425624827, 0.161217769705148, 0.16828565734741985, 0.18073741623075368, 0.17620900531923822, 0.17164886095772858, 0.1635931042343225, 0.15678595867542566, 0.18720460525136895, 0.14959857769196538, 0.09450752956092567, 0.12766733905335204, 0.10104718743133456, 0.10992335832382083, 0.13000358417733737, 0.11457181546804718, 0.09131088886946492, 0.11512294389217514, 0.11712470356767701, 0.18331128353519355, 0.17436376230467088, 0.16422012341004233, 0.1620023629976025, 0.15600417165874314, 0.17346319689363587, 0.17228664199513788, 0.18129955600293568, 0.2019589311614931, 0.10266529840674687, 9.999999999998899e-05, 0.15186191727127574, 0.11946349032059023, 0.11643645685910342, 0.1442945344374741, 0.11372961354815891, 0.1412567537285898, 0.12057825271490596, 0.1610191110825666, 0.253167774339358, 0.17015942278255713, 0.16536391233257652, 0.14058723631546144, 0.2026405578971885, 0.17401765696624405, 0.14756230937259185, 0.1450349845713077, 0.17787391247688444, 0.1297186623494213, 0.15627981691554504, 0.12042076486492714, 0.13037286719274288, 0.15838563263454986, 0.10902144268308478, 0.11776426014151797, 0.14565768888016284, 0.18549748798342647, 0.17217529855555036, 0.18374260932517172, 0.17504632291065048, 0.1966803042549432, 0.16540357739998435, 0.1686673629825125, 0.18129198570879057, 0.17580487053262073, 0.04804752798532519, 0.05071763906946758, 0.04345928355503914, 0.05707365838682055, 0.05218230177642258, 0.05352848056624293, 0.06017208983232836, 0.05362512602412939, 0.06522926723737288]}, "mutation_prompt": null}
{"id": "890f105e-76c4-451d-a673-e80d2cc4693e", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n        self.elite_fraction = 0.2  # Fraction of elite solutions\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    # Differential Elitism\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    # Adaptive Crossover\n                    self.crossover_prob = 0.9 * (1 - 0.5 * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Adaptive Local Search using Lvy flights\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    # Selection\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                # Strategic Subpopulation Merging\n                if (self.evaluations / self.budget) > 0.5 and (s == 0):\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.01\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.min() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced EHDEAP-MPD by employing differential elitism and adaptive local search inspired by Lvy flights.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "825d3747-26d9-4a32-9e75-6fc529520241", "metadata": {"aucs": [0.5140285604079206, 0.5094730199450579, 0.5286571068514563, 0.5637715825386076, 0.5098765461246832, 0.496552531893539, 0.4962947009007984, 0.48488173568364523, 0.5039308184884368, 0.20281539802401516, 0.23678088599359115, 0.22660511861409882, 0.13911960030952852, 0.20634924406644883, 0.23332961985698897, 0.2578802790058219, 0.21795311343935353, 0.21842867043662129, 0.10265492023917144, 0.10536257087186385, 0.11596519817105877, 0.12666762346127558, 0.1826651725076629, 0.10830501864976538, 0.1075059493702103, 0.19429402225777914, 0.11413531414492284, 0.09729971406873772, 0.10895851357779462, 0.1157864427022296, 0.10172472598209681, 0.10557598515793032, 0.105495896458624, 0.09644998630954527, 0.09780504001343182, 0.08941875771967733, 0.9435653128958781, 0.9273066664138279, 0.9814087864342814, 0.9814784861484398, 0.9634733240495225, 0.91946022977171, 0.9632525378842544, 0.9794743652293881, 0.9377373997740219, 0.1760978741943856, 0.2150307793514351, 0.2026518012720263, 0.19441152572093623, 0.184884582094197, 0.19291569207210646, 0.18214102232218554, 0.21238787578141516, 0.20949662649864798, 0.3888911543139896, 0.19098826566313953, 0.17009343145383138, 0.23155867409770403, 0.21631583546354005, 0.1923266794532681, 0.13586550013703802, 0.35282376623459755, 0.19447750277161513, 0.14701181067699431, 0.27881819493763527, 0.18558708677630031, 0.12534343484161692, 0.10440578442223636, 0.16934416489497728, 0.16558292815501285, 0.13320618788206462, 0.21236571563653583, 0.12995187192651925, 0.12084663963423758, 0.12959472933874971, 0.21085046320363676, 0.22013468230518052, 0.12284078585573821, 0.14001147440891382, 0.19141065265073554, 0.14224393587707418, 0.002370301635066796, 9.999999999998899e-05, 0.004102816937478604, 0.018485521024807716, 0.03861903863161764, 0.01534505869613223, 0.0371947704567307, 0.007038527426864838, 0.036271017528242355, 0.12056994043165992, 0.09830405041581802, 0.07272896423858799, 0.1261926353013867, 0.06611033946204403, 0.10968844919871445, 0.18686997019363139, 0.12982898053630165, 0.07229083931073188, 0.025529521293508717, 0.024971325299145586, 0.023658810819289444, 0.03285781815073119, 0.0475160039612329, 0.012462724321194774, 0.04023311195318635, 0.03368859617008635, 0.022082959690339576, 0.0821319985588389, 0.054952293999767754, 0.0868365142645201, 0.10351005978119487, 0.10916173206711377, 0.0983641278853733, 0.07293374501997163, 0.06655384684374821, 0.0674542069617321, 0.39972949429137483, 0.365124519260391, 0.3764081065513818, 0.37486245527966355, 0.3605115925296324, 0.3960198829166075, 0.4266333613945933, 0.4094139361228949, 0.3475957520463435, 0.1020693190800872, 0.08056326218279974, 0.07486664042300417, 0.0737533959630502, 0.08560245509695652, 0.08252085738316195, 0.08778505444189888, 0.08346879115998385, 0.07481658995416074, 0.1833943510584003, 0.15732660902840456, 0.19856983284693053, 0.2522100317762247, 0.19476503005756773, 0.17194311449881206, 0.17589754624797893, 0.20400520257200172, 0.13307793969492432, 0.28084480638315357, 0.20067332651574898, 0.24639456241526825, 0.2602856820755379, 0.24210878449186213, 0.22453294639360288, 0.2459142099903444, 0.2992797957293726, 0.29717343279310093, 0.16679337372223213, 0.15710687808139268, 0.17086390686023245, 0.16814856058250494, 0.15646942494858374, 0.16356131567482413, 0.21140992896852984, 0.21515166183527934, 0.1854555048234705, 0.19270488775937955, 0.17182251762751588, 0.18706627080944938, 0.22835026204690667, 0.15883385616433976, 0.22924847122526493, 0.19288918248123454, 0.19854371637285972, 0.16749002794340873, 0.1859847810229387, 0.17836217168494606, 0.1870596253524296, 0.19911034941777572, 0.2612809922920787, 0.1808272059614383, 0.17358470403301673, 0.27432431686873215, 0.18515692618066237, 0.18447946118053848, 0.3484076890585278, 0.17805287667158887, 0.5723985170045253, 0.18873748771703436, 0.47968307117637854, 0.4822096851854215, 0.3057604890951814, 0.19221795746462667, 0.4305818150259142, 0.19317696030915232, 0.16535925823942943, 0.18885721658270782, 0.2322305099077454, 0.14912291823818924, 0.19935357315456348, 0.18939270952945586, 0.33641425818645343, 0.19520618593457095, 0.19227284004365042, 0.24133656191967734, 0.20454907837751102, 0.2173389719329839, 0.19673379589652706, 0.2257678800300923, 0.26107755541909083, 0.20044175735765557, 0.06673154828242966, 0.07893616019348282, 0.0903624023454821, 0.07135968529222425, 0.08649290430998136, 0.07490778467897252, 0.07157719675636631, 0.07784006332049065, 0.08777918148629194]}, "mutation_prompt": null}
{"id": "ddecb47f-4dc2-4e73-aab1-29a567364b6a", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n        self.elite_fraction = 0.2  # Fraction of elite solutions\n        self.merging_interval = 50  # Interval for merging subpopulations\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    self.crossover_prob = 0.8 * (1 - (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.01\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with strategic subpopulation merging and adaptive elite-driven search inspired by Lvy flights.", "configspace": "", "generation": 36, "fitness": 0.2895110290770332, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "825d3747-26d9-4a32-9e75-6fc529520241", "metadata": {"aucs": [0.8383717938080022, 0.8651271929738631, 0.863423363982103, 0.845170427770355, 0.8306594875068842, 0.8358729666569946, 0.8668049848765482, 0.8498519317629076, 0.8539414460307202, 0.7000262652452004, 0.7327401253417105, 0.6731104721697483, 0.6122362780319706, 0.7384940717466526, 0.7429088465881537, 0.3386145816994248, 0.6679182313199226, 0.7016327456976706, 0.1530086991213908, 0.12070555842126673, 0.17445171240637314, 0.06402789324618441, 0.14821451939047092, 0.1395259803844574, 0.11623980794437305, 0.11289789382220372, 0.11553467779956206, 0.10345282368663333, 0.1514986887264682, 0.1429890407782194, 0.04044631297817525, 0.10125330520543252, 0.06627507932282717, 0.10053812342289692, 0.11630300935358628, 0.17363961536299666, 0.957445392221732, 0.9678598256624437, 0.9577521812460303, 0.9555009050920673, 0.9667382955436084, 0.9794248567004228, 0.9657539940039896, 0.9597116885423111, 0.9746289912969642, 0.39122259758544464, 0.44609318449312063, 0.5001963983787152, 0.627480242836963, 0.571586510090029, 0.4554637704878305, 0.4547086740559104, 0.5979773718427621, 0.4763860379042911, 0.31410741753740046, 0.3159774488229774, 0.21611881600048177, 0.2052606802249789, 0.5517004284914363, 0.5304658908387212, 0.22030538751319118, 0.11593951002438174, 0.38156357688236353, 0.2214463504528945, 0.17396152905657258, 0.29583394194249557, 0.20076507341571692, 0.21453941132755994, 0.21049211669694512, 0.12296747621302928, 0.3613610066368239, 0.28200905097669526, 0.23332250074895933, 0.08857229449808524, 0.12546448934970345, 0.3378423926494042, 0.30049568158438555, 0.36380347162739046, 0.27693682036117195, 0.22647024142854344, 0.2512991845748539, 0.08405658658637294, 0.11054436937274459, 0.009555703298764318, 0.09719335150869923, 9.999999999998899e-05, 0.05105544723160216, 0.049821672873219924, 0.054194066777983996, 0.057715513799303286, 0.03864839451359381, 0.03001723055814931, 0.09281483409471203, 0.09054125500027332, 0.02716820799592301, 0.18597549199452468, 0.29046715805388856, 0.11878746768181114, 0.2055819675077385, 0.0370253714743185, 0.08797251309586751, 0.03909498735980055, 0.07259604931501473, 0.34636280259918717, 0.07086119449176198, 0.1283019410444609, 0.07014004250495787, 0.07131595429471294, 0.17896846945126743, 0.14840717769272727, 0.2004097120489977, 0.17827555896368064, 0.1822026948027783, 0.1485440084799453, 0.12326307886297128, 0.18392207304022223, 0.1207218684908834, 0.5212414659783935, 0.5289598915534985, 0.5416576152863442, 0.572272499614856, 0.504599476178937, 0.5246152042482579, 0.5507070000318013, 0.554918947493749, 0.5446504023899619, 0.10518477426753947, 0.13180139308543493, 0.10699617220003366, 0.07753573878441133, 0.05338296677659782, 0.07887559924189302, 0.08432560239020481, 0.07772293501668903, 0.07989522609355937, 0.13454352430109195, 0.1489807074750824, 0.23519883698322508, 0.30269035452505544, 0.19873373147736118, 0.20653038283039993, 0.5054120784501319, 0.17320875381120293, 0.17868381608158546, 0.22461224282155579, 0.412064744060888, 0.37093687826416266, 0.20590405809081835, 0.39295940885851754, 0.1575514572281298, 0.27849391655908917, 0.3034910296694088, 0.4237286112996367, 0.17529564492125504, 0.2111382084875617, 0.2803550516236303, 0.21669391615490208, 0.2670604486785636, 0.2828567569142225, 0.19899970341559914, 0.1945530622275834, 0.27171215673138427, 0.18358812168877736, 0.20989030343463178, 0.2001894918151309, 0.23128421458522685, 0.19536290461049677, 0.19944246061363535, 0.23219691331222325, 0.1753112293103406, 0.19636677004882408, 0.21598842744624103, 0.1959313948283654, 0.17982146464259308, 0.1935286663125424, 0.19570708876093235, 0.19506969656821016, 0.21316407561491169, 0.16303909466135924, 0.1695050601194733, 0.19328241837548388, 0.17407323993113788, 0.16993724387252696, 0.12951221477008024, 0.14903169031662544, 0.19390647243217374, 0.16414016710424717, 0.15718471357187425, 0.2066469532287305, 0.12647369510661743, 0.201771671726661, 0.19847759983583968, 0.16448361946304957, 0.16468362134305203, 0.1670878799874359, 0.14523857093991044, 0.15262408184569287, 0.6469295422489431, 0.20990197939039612, 0.2025551764497081, 0.29848474644425427, 0.22757745522917106, 0.20437311548716186, 0.25150574469156795, 0.25027483243226134, 0.2104733570364682, 0.2468811320083113, 0.09248641593814699, 0.08549403428650715, 0.08424253522230152, 0.08342395021621729, 0.08305343657152098, 0.07833872716682322, 0.09161793599593548, 0.07800561405258355, 0.08760164566462025]}, "mutation_prompt": null}
{"id": "3998fa4d-7f6d-4367-84a3-15232e9ed47b", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n        self.elite_fraction = 0.2  # Fraction of elite solutions\n        self.merging_interval = 50  # Interval for merging subpopulations\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    self.crossover_prob = 0.8 * (1 - (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.01\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            populations[sorted_indices[i]] = populations[sorted_indices[i-half]]\n            fitness[sorted_indices[i]] = fitness[sorted_indices[i-half]]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with strategic subpopulation merging and adaptive elite-driven search inspired by Lvy flights.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddecb47f-4dc2-4e73-aab1-29a567364b6a", "metadata": {"aucs": [0.8383717938080022, 0.8651271929738631, 0.863423363982103, 0.845170427770355, 0.8306594875068842, 0.8358729666569946, 0.8668049848765482, 0.8498519317629076, 0.8539414460307202, 0.7000262652452004, 0.7327401253417105, 0.6731104721697483, 0.6122362780319706, 0.7384940717466526, 0.7429088465881537, 0.3386145816994248, 0.6679182313199226, 0.7016327456976706, 0.1530086991213908, 0.12070555842126673, 0.17445171240637314, 0.06402789324618441, 0.14821451939047092, 0.1395259803844574, 0.11623980794437305, 0.11289789382220372, 0.11553467779956206, 0.10345282368663333, 0.1514986887264682, 0.1429890407782194, 0.04044631297817525, 0.10125330520543252, 0.06627507932282717, 0.10053812342289692, 0.11630300935358628, 0.17363961536299666, 0.957445392221732, 0.9678598256624437, 0.9577521812460303, 0.9555009050920673, 0.9667382955436084, 0.9794248567004228, 0.9657539940039896, 0.9597116885423111, 0.9746289912969642, 0.39122259758544464, 0.44609318449312063, 0.5001963983787152, 0.627480242836963, 0.571586510090029, 0.4554637704878305, 0.4547086740559104, 0.5979773718427621, 0.4763860379042911, 0.31410741753740046, 0.3159774488229774, 0.21611881600048177, 0.2052606802249789, 0.5517004284914363, 0.5304658908387212, 0.22030538751319118, 0.11593951002438174, 0.38156357688236353, 0.2214463504528945, 0.17396152905657258, 0.29583394194249557, 0.20076507341571692, 0.21453941132755994, 0.21049211669694512, 0.12296747621302928, 0.3613610066368239, 0.28200905097669526, 0.23332250074895933, 0.08857229449808524, 0.12546448934970345, 0.3378423926494042, 0.30049568158438555, 0.36380347162739046, 0.27693682036117195, 0.22647024142854344, 0.2512991845748539, 0.08405658658637294, 0.11054436937274459, 0.009555703298764318, 0.09719335150869923, 9.999999999998899e-05, 0.05105544723160216, 0.049821672873219924, 0.054194066777983996, 0.057715513799303286, 0.03864839451359381, 0.03001723055814931, 0.09281483409471203, 0.09054125500027332, 0.02716820799592301, 0.18597549199452468, 0.29046715805388856, 0.11878746768181114, 0.2055819675077385, 0.0370253714743185, 0.08797251309586751, 0.03909498735980055, 0.07259604931501473, 0.34636280259918717, 0.07086119449176198, 0.1283019410444609, 0.07014004250495787, 0.07131595429471294, 0.17896846945126743, 0.14840717769272727, 0.2004097120489977, 0.17827555896368064, 0.1822026948027783, 0.1485440084799453, 0.12326307886297128, 0.18392207304022223, 0.1207218684908834, 0.5212414659783935, 0.5289598915534985, 0.5416576152863442, 0.572272499614856, 0.504599476178937, 0.5246152042482579, 0.5507070000318013, 0.554918947493749, 0.5446504023899619, 0.10518477426753947, 0.13180139308543493, 0.10699617220003366, 0.07753573878441133, 0.05338296677659782, 0.07887559924189302, 0.08432560239020481, 0.07772293501668903, 0.07989522609355937, 0.13454352430109195, 0.1489807074750824, 0.23519883698322508, 0.30269035452505544, 0.19873373147736118, 0.20653038283039993, 0.5054120784501319, 0.17320875381120293, 0.17868381608158546, 0.22461224282155579, 0.412064744060888, 0.37093687826416266, 0.20590405809081835, 0.39295940885851754, 0.1575514572281298, 0.27849391655908917, 0.3034910296694088, 0.4237286112996367, 0.17529564492125504, 0.2111382084875617, 0.2803550516236303, 0.21669391615490208, 0.2670604486785636, 0.2828567569142225, 0.19899970341559914, 0.1945530622275834, 0.27171215673138427, 0.18358812168877736, 0.20989030343463178, 0.2001894918151309, 0.23128421458522685, 0.19536290461049677, 0.19944246061363535, 0.23219691331222325, 0.1753112293103406, 0.19636677004882408, 0.21598842744624103, 0.1959313948283654, 0.17982146464259308, 0.1935286663125424, 0.19570708876093235, 0.19506969656821016, 0.21316407561491169, 0.16303909466135924, 0.1695050601194733, 0.19328241837548388, 0.17407323993113788, 0.16993724387252696, 0.12951221477008024, 0.14903169031662544, 0.19390647243217374, 0.16414016710424717, 0.15718471357187425, 0.2066469532287305, 0.12647369510661743, 0.201771671726661, 0.19847759983583968, 0.16448361946304957, 0.16468362134305203, 0.1670878799874359, 0.14523857093991044, 0.15262408184569287, 0.6469295422489431, 0.20990197939039612, 0.2025551764497081, 0.29848474644425427, 0.22757745522917106, 0.20437311548716186, 0.25150574469156795, 0.25027483243226134, 0.2104733570364682, 0.2468811320083113, 0.09248641593814699, 0.08549403428650715, 0.08424253522230152, 0.08342395021621729, 0.08305343657152098, 0.07833872716682322, 0.09161793599593548, 0.07800561405258355, 0.08760164566462025]}, "mutation_prompt": null}
{"id": "b843011b-d582-4885-976a-753bfe290c10", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Optimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n        self.elite_fraction = 0.2\n        self.merging_interval = 50\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Dynamic scaling factor\n\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    self.crossover_prob = 0.9 - 0.7 * (self.evaluations / self.budget)  # Adjust crossover probability\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._selective_merge(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.01\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _selective_merge(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        for i in sorted_indices[len(sorted_indices)//2:]:\n            if np.random.rand() < 0.5:\n                populations[i] = self._initialize_population()\n                fitness[i] = np.array([func(ind) for ind in populations[i]])", "name": "EHDEAP_MPD_Optimized", "description": "Optimized Differential Evolution with dynamic scaling factor and selective subpopulation replacement for improved convergence.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "ddecb47f-4dc2-4e73-aab1-29a567364b6a", "metadata": {}, "mutation_prompt": null}
{"id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations  # Changed from 10 to 12\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9  # Ensuring crossover adapts from a base\n        self.crossover_decay_rate = 0.1  # New variable to manage crossover decay\n        self.evaluations = 0\n        self.elite_fraction = 0.3  # Changed from 0.2 to 0.3\n        self.merging_interval = 100  # Changed from 50 to 100\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    # Adaptive dynamic crossover\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Improved local search with adaptive step size\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02  # Enhanced step size\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Preserving subpopulation diversity by mixing best and worst\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive dynamic crossover, improved local search, and subpopulation diversity preservation.", "configspace": "", "generation": 39, "fitness": 0.31026063975627094, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "ddecb47f-4dc2-4e73-aab1-29a567364b6a", "metadata": {"aucs": [0.757347120270937, 0.8015061297688133, 0.7957433060990762, 0.7945598946915255, 0.7764510840168528, 0.8291332447202154, 0.7862193589385387, 0.8082567778036185, 0.818879614857828, 0.6245100735696872, 0.5873581722180823, 0.608632988615576, 0.4904145687946695, 0.6441211309109858, 0.6541447348563718, 0.3017768737608095, 0.7069747190876027, 0.04899133298418801, 0.057500072775094835, 0.1257324776472949, 0.11192016196787513, 0.07079690689488094, 0.11951542465790077, 0.10402506841512293, 0.14744955358550282, 0.09430566879919211, 0.05239235707794343, 0.08671502661635799, 0.12658056576387045, 0.11137783193480988, 0.07880798069816408, 0.07925848204101826, 0.13118474814162928, 0.10692410952841835, 0.0800838266117676, 0.13849638946143272, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.5670117112870589, 0.5856833646654241, 0.554939348642451, 0.5182393090749666, 0.5790232422364466, 0.5766625657769026, 0.5651778469780755, 0.5918943772474383, 0.5106009954359898, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.3029404422648597, 0.12196841148698201, 0.4487158223025063, 0.5041716963556682, 0.12398239008625656, 0.1206786190011071, 0.36748565619747964, 0.3780397382211891, 0.4931491423616833, 0.27148164904193417, 0.19256948165665744, 0.2853847035198249, 0.45301037380425013, 0.30480749892123216, 0.351464076574985, 0.36280174973971946, 0.4927366140071684, 0.26157805495529185, 0.06470122189461724, 0.13749443486143753, 0.0698679995716941, 0.06174652298089445, 0.07418660825218792, 0.08970195168163608, 0.07828980973587019, 0.01653739830412504, 0.010506169569471924, 0.10478215094772492, 0.12222321269333059, 0.2555136708638853, 0.13735639517638587, 0.23583637294210402, 0.13338883339313012, 0.12975684422859357, 0.22742178662261237, 0.3534030189130737, 0.05626782048929091, 0.0813193764753456, 0.09413882829413522, 0.07639865153448644, 0.13581123102470882, 0.11018248175899936, 0.12411412682668965, 0.09292089721131724, 0.09145727514097235, 0.21216454927390827, 0.16924455557982931, 0.2040107014749245, 0.25484869855057224, 0.22461009883618221, 0.31203079505218534, 0.23894885909881736, 0.21634001966335192, 0.10483259540389611, 0.6530190649421141, 0.5765882547961352, 0.5805016413376833, 0.5270585755352151, 0.5550172680693004, 0.5868103222219114, 0.6003765524331197, 0.5363338644328739, 0.5432437439528294, 0.14432645639564, 0.07442893783085625, 0.08649406188989683, 0.10918537147192398, 0.05296829688280991, 0.10908999154943688, 0.11220301960643264, 0.1499933290081812, 0.171981635628095, 0.15276622655840222, 0.378779232834481, 0.15372856660051126, 0.22063404236932171, 0.14358381520985408, 0.14372067645325548, 0.187760549172712, 0.14334557829443562, 0.1318849698127731, 0.17667084993412463, 0.3518449029486661, 0.21144547841387917, 0.25404588553156815, 0.13615276594923853, 0.35618998331502105, 0.3800852462803831, 0.21090136849609986, 0.3890761036724806, 0.27255406396906545, 0.21539740905890048, 0.1835224388791743, 0.23997805790199533, 0.2719425271850444, 0.18975109721195726, 0.30102403422893664, 0.2449425888694411, 0.1825930654886765, 0.1951241843346334, 0.22063010838129038, 0.21516254949132485, 0.28792088115868497, 0.20933016483921685, 0.15253797820744364, 0.17967175026456994, 0.18169674172512318, 0.17265805937991696, 0.20380009624967943, 0.18465279439596372, 0.17530067174472863, 0.1993199710313477, 0.19727695792037658, 0.19065677839928885, 0.18499553417790726, 0.18852691633444474, 0.18001976586531365, 0.1773895239391613, 0.17801231234462667, 0.8379780216382431, 0.16421797501976432, 0.8194805257064142, 0.15641639245225447, 0.1388175284256702, 0.12481636461795409, 0.14346009300501883, 0.770358923072308, 0.7375158743912802, 0.7269443508917925, 0.16104727577694122, 0.1990978510536363, 0.12487359081289073, 0.2064877570570417, 0.761271438932476, 0.8439016063723915, 0.24608451263797615, 0.25569000337999237, 0.19604410803817274, 0.1647230019060626, 0.21404363957598416, 0.1892790193297944, 0.2672721974885133, 0.2458117764139881, 0.19131718412722754, 0.06706381052212673, 0.0942453368794055, 0.0881367396764352, 0.09182663399628932, 0.07940693830465828, 0.09613946294657794, 0.08209714840054672, 0.0901802964127415, 0.08264641281472707]}, "mutation_prompt": null}
{"id": "22786ac3-2774-464a-9cbc-7ce767d8b7d3", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # Increased for faster exploration\n        self.base_crossover_prob = 0.85  # Slightly reduced to enhance exploration\n        self.crossover_decay_rate = 0.15  # Increased decay for adaptive crossover\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 120  # Increased interval for better local search\n        self.greedy_prob = 0.3  # Probability for greedy selection\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Greedy exploration\n                    if np.random.rand() < self.greedy_prob:\n                        trial = self._greedy_exploration(trial, fitness[s][i], func)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n\n    def _greedy_exploration(self, trial, trial_fitness, func):\n        exploration_step = (np.random.rand(self.dim) - 0.5) * 0.1  # Small random perturbation\n        greedy_trial = np.clip(trial + exploration_step, self.bounds[0], self.bounds[1])\n        if func(greedy_trial) < trial_fitness:\n            return greedy_trial\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive crossover and greedy exploration for improved convergence.", "configspace": "", "generation": 40, "fitness": 0.1772481452933173, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.29950370095034085, 0.3762936839915194, 0.38942879663121277, 0.4039180479138349, 0.3904790217578602, 0.3743500202966342, 0.36809186396861415, 0.35838467849864264, 0.3246694263221036, 0.08748900894975975, 0.07060257060443398, 0.08437863897062803, 0.0692171779065327, 0.1094034596999669, 0.11625799762107669, 0.08191961339237208, 0.10204708792351935, 0.07941730933034052, 0.09231521591226699, 0.07816571260606253, 0.09708478808566001, 0.09925917205494461, 0.09411268989769528, 0.104157287795686, 0.10782746777846497, 0.08931648258268632, 0.1025093583277854, 0.09642341945680888, 0.07433200482705382, 0.07192469712438343, 0.10410475400888985, 0.08736369612011075, 0.06679469489961376, 0.08265094481057855, 0.10628529809861853, 0.08241634673781206, 0.9602352483342058, 0.9289340298927484, 0.9341215518944047, 0.8971463063799874, 0.9542380775716964, 0.9236290535315947, 0.9078918110888535, 0.9497795018930669, 0.9369934921916406, 0.12109766281519951, 0.14693920763499513, 0.13436598802210753, 0.16952747339851726, 0.14691998814954876, 0.1558872819239523, 0.13538695569385073, 0.15913670789437873, 0.13934945568208257, 0.1968804966940958, 0.1820173582607968, 0.1903749102269816, 0.20204039256883766, 0.21386236596157637, 0.14771243933224343, 0.21442593269910748, 0.16058763542194443, 0.18338867527802993, 0.09013941960461214, 0.09062715830129053, 0.10257480685944442, 0.11926813681606241, 0.09839188193993031, 0.08574496946981713, 0.10637217186857106, 0.1083629395169684, 0.13245961143456586, 0.11120153659093279, 0.08718367334363197, 0.08858625711868318, 0.096873169519053, 0.08037985325331065, 0.09984327674637827, 0.08587066913690522, 0.059688801368569355, 0.10904491525394677, 0.012723788341908904, 0.007233670904733258, 0.011954070430546748, 0.023763643931989487, 0.02192514531755818, 0.0024967172773556756, 0.005016756401252542, 0.006792427853690941, 0.0001946832911051688, 0.08473307419892828, 0.07111156093636362, 0.07687754401117852, 0.09798623892322611, 0.10651001145940842, 0.0704934401113273, 0.06710537012241202, 0.10502918235047598, 0.060069714069598046, 0.0001102894934343901, 9.999999999998899e-05, 0.005436361451229499, 0.0014422984802635597, 0.020588620984171357, 0.001684444257428197, 9.999999999998899e-05, 0.0030330638712932068, 0.009030415383543211, 0.058060663436914406, 0.042761069597124335, 0.04517662817055357, 0.05888369966635476, 0.056071789745175904, 0.07512786633750024, 0.0641815364483378, 0.09079394668648333, 0.06559219957166729, 0.3125935855868617, 0.3396132262934546, 0.30468238949019255, 0.3363994635927011, 0.35328048331408113, 0.3582329399963178, 0.33267455042433247, 0.3348523515038221, 0.3601589867281223, 0.07925102557154873, 0.07018821431471245, 0.06652366921790254, 0.10412982907846802, 0.06645562439085428, 0.08846239211188145, 0.06245498474358191, 0.07824589164948881, 0.0656688501135625, 0.15358755726255946, 0.15815296016343094, 0.14513057934318818, 0.1593784271513068, 0.20048638065560542, 0.15997732788684316, 0.13297820720728304, 0.15149897856380634, 0.12429622383815764, 0.24369723399091803, 0.2060145882836376, 0.1994459221391639, 0.21003268017887533, 0.2087829305187956, 0.19540246169266762, 0.2731490473855097, 0.2614981076188161, 0.22218526804954986, 0.1552290667550975, 0.1637049487497314, 0.1758440045197911, 0.16908459914883456, 0.1444367686440795, 0.162741657758101, 0.14157920208682095, 0.19216884807774004, 0.18282853226758633, 0.17986697555009545, 0.17137036035596576, 0.17872791715751768, 0.17272073541876176, 0.1766781095516453, 0.16526395291456208, 0.17311606916356703, 0.19411410969981957, 0.1717716738632067, 0.1581103280567968, 0.17033183719879874, 0.1695727335683116, 0.1630908523253678, 0.1777580979239778, 0.17151270111407213, 0.23709516366917693, 0.1587726005841742, 0.15860058102154395, 0.29278101997474437, 0.1627373011447737, 0.3146496368338294, 0.21348295011130924, 0.17513184828080863, 0.14608765520612144, 0.15468929140732557, 0.13991053785262575, 0.1798694476751449, 0.29662174909655936, 0.17659917085506893, 0.2898903744393657, 0.16047833795752942, 0.14657721403739343, 0.24995161649647035, 0.4226971317862259, 0.1991971900420444, 0.19322091321386137, 0.19150004117858377, 0.17920512664845156, 0.17705049653141414, 0.19458294569543455, 0.18806603931600607, 0.1722567629329349, 0.18654060760846647, 0.2037598994922739, 0.18603958752027916, 0.06625351666842494, 0.06524237527137444, 0.07450193279403539, 0.06845718942578605, 0.0675978375194527, 0.06867400413802138, 0.07745193152459018, 0.08161767242302709, 0.06800094511147037]}, "mutation_prompt": null}
{"id": "0d1287f8-b71d-4347-a6cb-48e652be841c", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                crowding_distances = self._crowding_distance(population, func)\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    crowding_selected = np.argmax(crowding_distances)\n                    elite = population[crowding_selected]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                        crowding_distances[i] = self._crowding_distance_single(refined_trial, population, func)\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n\n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]\n\n    def _crowding_distance(self, population, func):\n        distances = np.zeros(self.subpop_size)\n        for i in range(self.subpop_size):\n            distances[i] = self._crowding_distance_single(population[i], population, func)\n        return distances\n\n    def _crowding_distance_single(self, individual, population, func):\n        distances = np.linalg.norm(population - individual, axis=1)\n        sorted_indices = np.argsort(distances)\n        return np.sum(distances[sorted_indices[:3]])", "name": "EHDEAP_MPD_Enhanced", "description": "Introduction of Crowding Distance-based Selection in Differential Evolution to maintain population diversity.", "configspace": "", "generation": 41, "fitness": 0.23147310709045077, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.6260112507230075, 0.6450964170595102, 0.65765553875192, 0.6248804998706641, 0.5889244237665336, 0.6887710960426456, 0.6311344594396096, 0.6710348179915748, 0.6433328479173142, 0.519534445285592, 0.4497888465458211, 0.48643333050529347, 0.5493463413427631, 0.4275060469647569, 0.4770575853025625, 0.41404164230347573, 0.49535123252184077, 0.5744409476614991, 0.08411912654250209, 0.08607555492787689, 0.0952079336482009, 0.06583350773479779, 0.1029576121688851, 0.10878479041344857, 0.12980423841256505, 0.11326599092337897, 0.1647543640324104, 0.08412870044980059, 0.08706330549928698, 0.1004128871622475, 0.08374290781355287, 0.1039616468225315, 0.04699493238287755, 0.1314997821959618, 0.09115391326286337, 0.0962416122019154, 0.8302708225239408, 0.8317321966849301, 0.8615012676825475, 0.865746170783905, 0.8187738728189252, 0.8666619959236004, 0.7795374558391387, 0.88838139990451, 0.8784332749342006, 0.29940785594011, 0.2526726319328786, 0.2412317625151561, 0.244387997732595, 0.24732021020015793, 0.28651536242716835, 0.3049587390835995, 0.2746590879599097, 0.202637447712672, 0.17266978893101226, 0.29874142523119185, 0.2638470537813743, 0.27749331426141977, 0.5820615216564777, 0.48644484169018465, 0.22637037871624566, 0.26846220648440766, 0.5609319975124867, 0.07812911463855221, 0.09126071453776663, 0.14881262445502963, 0.12121753101766297, 0.15439585313766324, 0.07324943806175455, 0.12779443365898424, 0.16719283044956523, 0.16471958773007878, 0.08282653607585211, 0.09873016183343386, 0.08076633958034529, 0.1349108818524053, 0.17114215855234927, 0.16748079008477157, 0.12396984483450146, 0.17914223531111073, 0.10453434406620965, 0.08154727730611433, 0.09484417869247697, 0.11332830459677168, 0.08089309023412405, 0.12022559046355896, 0.07868002115329231, 0.07489238894264616, 0.05655523588156497, 0.03857375686879949, 0.19362057838177738, 0.20845329896539422, 0.14228161017858043, 0.1685115248214183, 0.22108017238242605, 0.1275785909797994, 0.19722975866703396, 0.20790465180224715, 0.25364665090406247, 0.00349216234284655, 0.08332451710574607, 0.02711517925304452, 0.024269426390569615, 0.02100966903651791, 0.06540244975352416, 0.017286670474546684, 0.029819001879883067, 0.05707592972460318, 0.1787755533387564, 0.17151290137663566, 0.14633885626350807, 0.20885590425938017, 0.2234517213277466, 0.1810684786024349, 0.18334586373446315, 0.13689417996578068, 0.15005473256551027, 0.4420281747537975, 0.418498219702058, 0.5472850480061074, 0.49326517577494755, 0.4817305452902281, 0.45116260869043534, 0.5378879651649768, 0.47169943861817876, 0.5022042108443509, 0.08382253183895261, 0.12292482072496336, 0.07365912737807301, 0.08528998226830353, 0.11180706226012493, 0.0959481725718686, 0.10115276530303385, 0.09528183656956857, 0.06700871186987312, 0.2267158805508327, 0.14300235924166682, 0.15297263969658892, 0.14050296056949596, 0.1329107905284993, 0.13887699029818046, 0.13492983094306, 0.14339625328783367, 0.1526028915240869, 0.19709173316130646, 0.16931876342715513, 0.1726205660935608, 0.18430790880832948, 0.23054593059125994, 0.2818821597831931, 0.23131907162512322, 0.2147326317110202, 0.24094670213747016, 0.15351434785429796, 0.1941220327411154, 0.19707022441865485, 0.12899586677596853, 0.16786284625578973, 0.1529496146974938, 0.19265213416355886, 0.1727544181486117, 0.1869519374019214, 0.20126810259576566, 0.16931615742581252, 0.17440214897915451, 0.19675333748927637, 0.175419712461637, 0.18538121768978189, 0.16840775625127968, 0.18963065579078364, 0.18910004064805086, 0.17665807720520021, 0.1935917449139033, 0.17885084105619775, 0.18107304755942266, 0.19744990506073268, 0.18075551784677135, 0.1793616452758381, 0.16633601207449178, 0.20837359202624672, 0.16284840603610096, 0.1579131954496379, 0.14868336001669613, 0.1189300880346833, 0.13438633352493756, 0.12745106870688871, 0.23377574810071844, 0.12053692928721449, 0.1582912832951484, 0.19457483535665276, 0.1508270645488866, 0.11511793084954025, 0.13669894916412828, 0.13905699538519167, 0.0992255382181354, 0.18950932678330867, 0.16474674981116189, 0.11603986943928157, 0.17277477492609394, 0.17611971714398955, 0.17726177750498173, 0.18697560232173827, 0.18949078693806765, 0.1785910546368592, 0.18605032729471827, 0.17763655616797847, 0.20131911392895097, 0.08725939679230776, 0.06341419889014777, 0.07530199365799295, 0.09206246654818773, 0.06895386783429425, 0.07300885992531825, 0.06202104515713125, 0.06436387274443567, 0.06922469474774895]}, "mutation_prompt": null}
{"id": "60a1f02c-0054-4347-a7aa-45d47aa15eeb", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations  # Changed from 10 to 12\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9  # Ensuring crossover adapts from a base\n        self.crossover_decay_rate = 0.1  # New variable to manage crossover decay\n        self.evaluations = 0\n        self.elite_fraction = 0.3  # Changed from 0.2 to 0.3\n        self.merging_interval = 100  # Changed from 50 to 100\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    # Adaptive dynamic crossover\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Improved local search with adaptive step size\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02  # Enhanced step size\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Preserving subpopulation diversity by mixing best and worst\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive dynamic crossover, improved local search, and subpopulation diversity preservation.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.757347120270937, 0.8015061297688133, 0.7957433060990762, 0.7945598946915255, 0.7764510840168528, 0.8291332447202154, 0.7862193589385387, 0.8082567778036185, 0.818879614857828, 0.6245100735696872, 0.5873581722180823, 0.608632988615576, 0.4904145687946695, 0.6441211309109858, 0.6541447348563718, 0.3017768737608095, 0.7069747190876027, 0.04899133298418801, 0.057500072775094835, 0.1257324776472949, 0.11192016196787513, 0.07079690689488094, 0.11951542465790077, 0.10402506841512293, 0.14744955358550282, 0.09430566879919211, 0.05239235707794343, 0.08671502661635799, 0.12658056576387045, 0.11137783193480988, 0.07880798069816408, 0.07925848204101826, 0.13118474814162928, 0.10692410952841835, 0.0800838266117676, 0.13849638946143272, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.5670117112870589, 0.5856833646654241, 0.554939348642451, 0.5182393090749666, 0.5790232422364466, 0.5766625657769026, 0.5651778469780755, 0.5918943772474383, 0.5106009954359898, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.3029404422648597, 0.12196841148698201, 0.4487158223025063, 0.5041716963556682, 0.12398239008625656, 0.1206786190011071, 0.36748565619747964, 0.3780397382211891, 0.4931491423616833, 0.27148164904193417, 0.19256948165665744, 0.2853847035198249, 0.45301037380425013, 0.30480749892123216, 0.351464076574985, 0.36280174973971946, 0.4927366140071684, 0.26157805495529185, 0.06470122189461724, 0.13749443486143753, 0.0698679995716941, 0.06174652298089445, 0.07418660825218792, 0.08970195168163608, 0.07828980973587019, 0.01653739830412504, 0.010506169569471924, 0.10478215094772492, 0.12222321269333059, 0.2555136708638853, 0.13735639517638587, 0.23583637294210402, 0.13338883339313012, 0.12975684422859357, 0.22742178662261237, 0.3534030189130737, 0.05626782048929091, 0.0813193764753456, 0.09413882829413522, 0.07639865153448644, 0.13581123102470882, 0.11018248175899936, 0.12411412682668965, 0.09292089721131724, 0.09145727514097235, 0.21216454927390827, 0.16924455557982931, 0.2040107014749245, 0.25484869855057224, 0.22461009883618221, 0.31203079505218534, 0.23894885909881736, 0.21634001966335192, 0.10483259540389611, 0.6530190649421141, 0.5765882547961352, 0.5805016413376833, 0.5270585755352151, 0.5550172680693004, 0.5868103222219114, 0.6003765524331197, 0.5363338644328739, 0.5432437439528294, 0.14432645639564, 0.07442893783085625, 0.08649406188989683, 0.10918537147192398, 0.05296829688280991, 0.10908999154943688, 0.11220301960643264, 0.1499933290081812, 0.171981635628095, 0.15276622655840222, 0.378779232834481, 0.15372856660051126, 0.22063404236932171, 0.14358381520985408, 0.14372067645325548, 0.187760549172712, 0.14334557829443562, 0.1318849698127731, 0.17667084993412463, 0.3518449029486661, 0.21144547841387917, 0.25404588553156815, 0.13615276594923853, 0.35618998331502105, 0.3800852462803831, 0.21090136849609986, 0.3890761036724806, 0.27255406396906545, 0.21539740905890048, 0.1835224388791743, 0.23997805790199533, 0.2719425271850444, 0.18975109721195726, 0.30102403422893664, 0.2449425888694411, 0.1825930654886765, 0.1951241843346334, 0.22063010838129038, 0.21516254949132485, 0.28792088115868497, 0.20933016483921685, 0.15253797820744364, 0.17967175026456994, 0.18169674172512318, 0.17265805937991696, 0.20380009624967943, 0.18465279439596372, 0.17530067174472863, 0.1993199710313477, 0.19727695792037658, 0.19065677839928885, 0.18499553417790726, 0.18852691633444474, 0.18001976586531365, 0.1773895239391613, 0.17801231234462667, 0.8379780216382431, 0.16421797501976432, 0.8194805257064142, 0.15641639245225447, 0.1388175284256702, 0.12481636461795409, 0.14346009300501883, 0.770358923072308, 0.7375158743912802, 0.7269443508917925, 0.16104727577694122, 0.1990978510536363, 0.12487359081289073, 0.2064877570570417, 0.761271438932476, 0.8439016063723915, 0.24608451263797615, 0.25569000337999237, 0.19604410803817274, 0.1647230019060626, 0.21404363957598416, 0.1892790193297944, 0.2672721974885133, 0.2458117764139881, 0.19131718412722754, 0.06706381052212673, 0.0942453368794055, 0.0881367396764352, 0.09182663399628932, 0.07940693830465828, 0.09613946294657794, 0.08209714840054672, 0.0901802964127415, 0.08264641281472707]}, "mutation_prompt": null}
{"id": "25f26805-0da1-4711-9967-e317c5d328a5", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.dynamic_mutation_factor = 0.5  # New dynamic mutation factor\n        self.evaluations = 0\n        self.elite_fraction = 0.4  # Increased elite fraction from 0.3 to 0.4\n        self.merging_interval = 50  # Reduced merging interval to enhance diversity\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    dynamic_factor = self.dynamic_mutation_factor * (1 - self.evaluations / self.budget)\n                    mutant = self._mutate_dynamic(population[a], elite, population[c], dynamic_factor)\n\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._stochastic_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._strategic_merge(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate_dynamic(self, a, b, c, factor):\n        mutant = np.clip(a + factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.base_crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _stochastic_local_search(self, trial, func):\n        beta = 0.05  # New stochastic step size\n        step_size = beta * np.random.standard_normal(self.dim)\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n\n    def _strategic_merge(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = np.where(np.random.rand(*populations[selected_idx].shape) < 0.5, populations[sorted_indices[i]], populations[selected_idx])\n            fitness[sorted_indices[i]] = np.array([func(ind) for ind in populations[sorted_indices[i]]])", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive mutation scaling, strategic subpopulation merging, and stochastic search intensification.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {}, "mutation_prompt": null}
{"id": "49913698-a78b-40f5-ba12-975102e9352a", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (10 * dim) // self.subpopulations  # Changed from 12 to 10\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # Changed from 0.8 to 0.85\n        self.base_crossover_prob = 0.8  # Changed from 0.9 to 0.8\n        self.crossover_decay_rate = 0.05  # Changed from 0.1 to 0.05\n        self.evaluations = 0\n        self.elite_fraction = 0.25  # Changed from 0.3 to 0.25\n        self.merging_interval = 150  # Changed from 100 to 150\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._adaptive_mutate(population[a], elite, population[c])\n\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._dynamic_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _adaptive_mutate(self, a, b, c):\n        # Introduced a new mutation strategy with randomness\n        rand_factor = np.random.rand()\n        mutant = np.clip(a + self.mutation_factor * (b - c) * rand_factor, self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _dynamic_local_search(self, trial, func):\n        # Introduced dynamic step size adjustment\n        alpha = 0.01 + 0.01 * (self.evaluations / self.budget)\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive crossover, multi-strategy mutation, and dynamic local search for improved convergence.", "configspace": "", "generation": 44, "fitness": 0.2393975363358969, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.8539287876021338, 0.711448811050636, 0.7165458973601, 0.6231985249531935, 0.8773790272706615, 0.7805480566461146, 0.8839785515289408, 0.6331358757763879, 0.8623727193659092, 0.2721246761252585, 0.07728280550060151, 0.05750462892725594, 0.11944318187144054, 0.18038686349743205, 0.0356597662950533, 0.193808757659386, 0.0516782856133261, 0.07757195724776467, 0.10962979264609962, 0.07495503539067827, 0.0973899933739325, 0.13247071799349708, 0.06825589748994076, 0.05243897155564736, 0.04879524862617368, 0.13933925658707635, 0.062204136799121956, 0.0717738458987115, 0.0546631774438574, 0.12626187341538098, 0.062092008257922826, 0.07400481906370493, 0.08106480123630977, 0.09700789496342332, 0.04838675680245652, 0.04691287553150392, 0.9710238586866681, 0.9589527096997242, 0.8600520086671652, 0.9361122339804845, 0.8708620270545799, 0.9139476775893577, 0.9275129706607382, 0.8775290019857845, 0.9347860347934783, 0.4908563716415191, 0.2959427465551677, 0.34894632112355495, 0.43629930419802254, 0.4504332995750181, 0.3399425354781208, 0.33444155130553, 0.38886392167967565, 0.5047712326938416, 0.15585517498290025, 0.1032212894571356, 0.09724212054810288, 0.18069341963770547, 0.12630560685455183, 0.09542668003164967, 0.05438971381470403, 0.17459564181709752, 0.1228605993439914, 0.12641955284869688, 0.07107285922537865, 0.17622584418579246, 0.3595692835154085, 0.09742380434839049, 0.23700418996818273, 0.3162633799405631, 0.18256463956707614, 0.20928924602037202, 0.09367133756323787, 0.1640617592717999, 0.332009457130519, 0.17125894827706456, 0.12356741162755858, 0.22154906757232018, 0.1653984482186437, 0.17990779920425926, 0.12737468450021716, 0.00483914606262148, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004945875786460552, 9.999999999998899e-05, 0.07953496168636542, 0.08229898668486291, 9.999999999998899e-05, 0.08400673479597098, 0.07459453163798002, 0.09934532898263537, 0.07789867487338287, 0.046467736528137515, 0.08151683489570172, 0.12325649707734787, 0.06822942294614753, 0.05023561878016791, 0.08754133926105201, 0.10962451535282214, 0.24007149191811628, 0.1206416468832947, 0.106911142956716, 0.09133251394186193, 0.10351985653683493, 0.19588538431016156, 0.10581811821996256, 0.13485841288555744, 0.061110396038701054, 0.07622503870190811, 0.0640557988978866, 0.10221693427371314, 0.0906581004898569, 0.06698420892137058, 0.09737435927676164, 0.07691048093895225, 0.4422632422893178, 0.5182265911110259, 0.5742716595219131, 0.4928942910321672, 0.5636917598683637, 0.5250957060357927, 0.5439708092728031, 0.497856307536268, 0.5101646179428956, 0.048372776767702685, 0.07925804709900619, 0.06807916808571302, 0.0837851803943217, 0.07823056096904657, 0.10894495200892818, 0.1056368815097618, 0.06658499930634498, 0.07771349430274388, 0.14061040566242666, 0.15325313556591136, 0.17891611359070214, 0.3071452124591425, 0.113226382996796, 0.20149058972303202, 0.13711533769558204, 0.19309553572286675, 0.17073073622763335, 0.1919623458853097, 0.16845225807367625, 0.17707106611393097, 0.23950800908185543, 0.16609266040558557, 0.14912070456984894, 0.18323846986052506, 0.290529026612967, 0.27667613982657446, 0.15259060896726062, 0.13211033866407584, 0.32421253297762487, 0.17801874462500478, 0.23892096903360494, 0.19883793914821246, 0.20787474369325842, 0.23432650013297074, 0.16172980009351667, 0.20226117564652468, 0.22309021356750058, 0.217283971875593, 0.20862689720686667, 0.18321257812547453, 0.23230560784667809, 0.1906752967725699, 0.2177285035090466, 0.2314381449775864, 0.24416574262501656, 0.20168563903659686, 0.19192246236618127, 0.17388780156392625, 0.1972427399366078, 0.15811184880516516, 0.18681626485986402, 0.19817795388607962, 0.2451823285492516, 0.1799651766848105, 0.8037942085302254, 0.10772554988374983, 0.1705478825458978, 0.766777019396977, 0.1232759559811728, 0.15073354568962127, 0.15474550147213595, 0.20668319831013826, 0.6042867968885652, 0.20802935901607256, 0.07336643406065191, 0.6124707197950092, 0.12086624601204077, 0.16451943755182763, 0.8128750533758138, 0.15244637744776335, 0.5890491273552962, 0.1958434815251031, 0.2446084079298002, 0.25670787180930754, 0.20869661943615703, 0.2241463751098972, 0.17919956076683463, 0.2618906314339464, 0.25359393689406495, 0.22412887497744383, 0.07151397611670895, 0.0645836749770875, 0.08572833501551669, 0.05301987053724644, 0.08376533807335795, 0.11199062550510386, 0.08532993975444692, 0.10167079002172652, 0.07402729029958022]}, "mutation_prompt": null}
{"id": "4aecc4f5-b216-4f54-903b-cdae8d4f3bd0", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (14 * dim) // self.subpopulations  # Changed from 12 to 14\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.7  # Changed from 0.9 to 0.7\n        self.crossover_decay_rate = 0.05  # Changed from 0.1 to 0.05\n        self.evaluations = 0\n        self.elite_fraction = 0.2  # Changed from 0.3 to 0.2\n        self.merging_interval = 150  # Changed from 100 to 150\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    self.crossover_prob = self.base_crossover_prob * np.exp(-self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._hybrid_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _hybrid_local_search(self, trial, func):\n        alpha = 0.01  # Reduced step size for finer local search\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        # Introduced global perturbation for exploration\n        global_step = np.random.uniform(-0.5, 0.5, self.dim)\n        global_trial = np.clip(trial + global_step, self.bounds[0], self.bounds[1])\n        global_trial_fitness = func(global_trial)\n        self.evaluations += 1\n        return global_trial if global_trial_fitness < local_best_fitness else trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced_V2", "description": "Enhanced Differential Evolution with adaptive crossover and hybrid local-global search strategy for efficient exploration and exploitation.", "configspace": "", "generation": 45, "fitness": 0.18795876011161894, "feedback": "The algorithm EHDEAP_MPD_Enhanced_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.49340213609723405, 0.3912375911057123, 0.3038234317085555, 0.48563462029355164, 0.6481985826206821, 0.5460232581311112, 0.3684312524869571, 0.3742549685390387, 0.3213598874918969, 0.23016851290795437, 0.40848645967231345, 0.043842551315907086, 0.16930063416685048, 0.15610057483812156, 0.05560495733541737, 0.208804726942721, 0.0626794059131478, 0.17838341187311524, 0.3152416748392306, 0.1251172798258272, 0.12608536331363362, 0.32488537025586883, 0.1102852646093565, 0.07569301478059243, 0.0939387424580953, 0.08769126247305192, 0.10099041454419821, 0.0751323427160796, 0.0774181967868608, 0.08681344959371051, 0.0863703982063384, 0.1087513705251626, 0.11884342049825958, 0.11989863460605887, 0.0936386038077871, 0.12256513693597115, 0.9294127357527542, 0.9075615271163878, 0.9552562990469441, 0.9034094660307843, 0.8852381069931822, 0.9752891580625753, 0.9774053387901149, 0.891759427194366, 0.9338293452267339, 0.18154989189410264, 0.15554719497445546, 0.1257000175133931, 0.14598972488813344, 0.13537296818069333, 0.20253536919021986, 0.27625809184080785, 0.27323417636911007, 0.16860451087681227, 0.18000677892840178, 0.16556905894881635, 0.15254076705905895, 0.26350274874612056, 0.16399314106766383, 0.15845076720132056, 0.14710116183511068, 0.19338534655774076, 0.246122733696315, 0.1519677481242525, 0.0847610138489272, 0.11432219905212915, 0.08073796878944872, 0.14478856266659135, 0.10028365084307622, 0.11485951097209601, 0.07280687637979333, 0.08549269978179197, 0.08110213557980128, 0.08220872803439938, 0.07102821954786998, 0.11212097044246383, 0.053902819754920506, 0.10425633361687447, 0.06799873023575542, 0.10083583186648681, 0.14836067405284126, 0.006161858839838552, 0.0010550114608915973, 0.019765701844632666, 0.01294195318700786, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08453124698165215, 0.07404543021564802, 0.0881268209794458, 0.06660044383543118, 0.03570360129198402, 0.08349697053170146, 0.07964277997248137, 0.051766256970522395, 0.12531248536654815, 0.008801309487775355, 0.007378165661927394, 9.999999999998899e-05, 0.0013860253086571683, 0.012507772000638018, 9.999999999998899e-05, 0.00025727033886746575, 0.04660758591294489, 0.056935421419068044, 0.04299685167924594, 0.031281643488036526, 0.11859759979886242, 0.08772725986603236, 0.10038006583870995, 0.08420171580364622, 0.06237689018512105, 0.06150498228096202, 0.08422413121749328, 0.3938665892179145, 0.28690524529328254, 0.4383892335641614, 0.3447074918207096, 0.4174547557884517, 0.28774375646830863, 0.41854605231607955, 0.3194515053998124, 0.29607219966088416, 0.1542664023045318, 0.0726671027537652, 0.07188686464708882, 0.08385669920161087, 0.08063932003049834, 0.07411357822322484, 0.07754032111079245, 0.0782319690735851, 0.058856390791867996, 0.13174096145072467, 0.1737131010045434, 0.13060697292226686, 0.1631760587862192, 0.13350006757356092, 0.12038509522816676, 0.19879853446501006, 0.14500507656597983, 0.15804805443649472, 0.28725447611100496, 0.1945187454406644, 0.27016440715100976, 0.23169592302047182, 0.21520451410284314, 0.21455319630019642, 0.2516795363303491, 0.2399126425188598, 0.2754137829810279, 0.14276301298996097, 0.1356124560726093, 0.15446006755434571, 0.12141333742116678, 0.142340093278018, 0.15547672148586156, 0.19998278386786705, 0.26328068636437074, 0.14859300095250672, 0.17572930472528425, 0.19083475404136796, 0.1696888163998963, 0.1720199766837197, 0.18142974637746012, 0.17955526625410934, 0.19710468838091333, 0.16175020540500096, 0.1757822211392418, 0.1813092698829888, 0.15909158997656414, 0.20919258478065694, 0.15944198618777283, 0.18337850411886825, 0.14917982438925959, 0.19040306174662802, 0.17620511138834427, 0.1608832099414138, 0.15884860557464142, 0.2576520877796714, 0.1639287507479994, 0.31804205984862144, 0.15457435220158144, 0.1655396986115527, 0.1623266747124108, 0.14404642079903662, 0.15879713325234512, 0.18988410069522965, 0.17997184323854165, 0.17958313033636297, 0.17134212143269034, 0.15832001789724803, 0.15912548722141273, 0.42353878274212187, 0.18883989475692775, 0.19831034734549424, 0.1798276909178278, 0.17953561806543927, 0.18424043953337899, 0.16753584840428615, 0.19182551662457958, 0.17879196734526837, 0.19461937414534558, 0.17809661138839505, 0.170892251132423, 0.062073794840700636, 0.054408680473539195, 0.07350281437965756, 0.07366998250128787, 0.08229616989381716, 0.06390462021778875, 0.0627745746045748, 0.057225162587522194, 0.08515796844402357]}, "mutation_prompt": null}
{"id": "27350f73-7d06-4853-a22e-4431dd6a1748", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations  # Changed from 10 to 12\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9  # Ensuring crossover adapts from a base\n        self.crossover_decay_rate = 0.1  # New variable to manage crossover decay\n        self.evaluations = 0\n        self.elite_fraction = 0.3  # Changed from 0.2 to 0.3\n        self.merging_interval = 100  # Changed from 50 to 100\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    # Adaptive dynamic crossover\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Improved local search with adaptive step size\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02  # Enhanced step size\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Preserving subpopulation diversity by mixing best and worst\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive dynamic crossover, improved local search, and subpopulation diversity preservation.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.757347120270937, 0.8015061297688133, 0.7957433060990762, 0.7945598946915255, 0.7764510840168528, 0.8291332447202154, 0.7862193589385387, 0.8082567778036185, 0.818879614857828, 0.6245100735696872, 0.5873581722180823, 0.608632988615576, 0.4904145687946695, 0.6441211309109858, 0.6541447348563718, 0.3017768737608095, 0.7069747190876027, 0.04899133298418801, 0.057500072775094835, 0.1257324776472949, 0.11192016196787513, 0.07079690689488094, 0.11951542465790077, 0.10402506841512293, 0.14744955358550282, 0.09430566879919211, 0.05239235707794343, 0.08671502661635799, 0.12658056576387045, 0.11137783193480988, 0.07880798069816408, 0.07925848204101826, 0.13118474814162928, 0.10692410952841835, 0.0800838266117676, 0.13849638946143272, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.5670117112870589, 0.5856833646654241, 0.554939348642451, 0.5182393090749666, 0.5790232422364466, 0.5766625657769026, 0.5651778469780755, 0.5918943772474383, 0.5106009954359898, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.3029404422648597, 0.12196841148698201, 0.4487158223025063, 0.5041716963556682, 0.12398239008625656, 0.1206786190011071, 0.36748565619747964, 0.3780397382211891, 0.4931491423616833, 0.27148164904193417, 0.19256948165665744, 0.2853847035198249, 0.45301037380425013, 0.30480749892123216, 0.351464076574985, 0.36280174973971946, 0.4927366140071684, 0.26157805495529185, 0.06470122189461724, 0.13749443486143753, 0.0698679995716941, 0.06174652298089445, 0.07418660825218792, 0.08970195168163608, 0.07828980973587019, 0.01653739830412504, 0.010506169569471924, 0.10478215094772492, 0.12222321269333059, 0.2555136708638853, 0.13735639517638587, 0.23583637294210402, 0.13338883339313012, 0.12975684422859357, 0.22742178662261237, 0.3534030189130737, 0.05626782048929091, 0.0813193764753456, 0.09413882829413522, 0.07639865153448644, 0.13581123102470882, 0.11018248175899936, 0.12411412682668965, 0.09292089721131724, 0.09145727514097235, 0.21216454927390827, 0.16924455557982931, 0.2040107014749245, 0.25484869855057224, 0.22461009883618221, 0.31203079505218534, 0.23894885909881736, 0.21634001966335192, 0.10483259540389611, 0.6530190649421141, 0.5765882547961352, 0.5805016413376833, 0.5270585755352151, 0.5550172680693004, 0.5868103222219114, 0.6003765524331197, 0.5363338644328739, 0.5432437439528294, 0.14432645639564, 0.07442893783085625, 0.08649406188989683, 0.10918537147192398, 0.05296829688280991, 0.10908999154943688, 0.11220301960643264, 0.1499933290081812, 0.171981635628095, 0.15276622655840222, 0.378779232834481, 0.15372856660051126, 0.22063404236932171, 0.14358381520985408, 0.14372067645325548, 0.187760549172712, 0.14334557829443562, 0.1318849698127731, 0.17667084993412463, 0.3518449029486661, 0.21144547841387917, 0.25404588553156815, 0.13615276594923853, 0.35618998331502105, 0.3800852462803831, 0.21090136849609986, 0.3890761036724806, 0.27255406396906545, 0.21539740905890048, 0.1835224388791743, 0.23997805790199533, 0.2719425271850444, 0.18975109721195726, 0.30102403422893664, 0.2449425888694411, 0.1825930654886765, 0.1951241843346334, 0.22063010838129038, 0.21516254949132485, 0.28792088115868497, 0.20933016483921685, 0.15253797820744364, 0.17967175026456994, 0.18169674172512318, 0.17265805937991696, 0.20380009624967943, 0.18465279439596372, 0.17530067174472863, 0.1993199710313477, 0.19727695792037658, 0.19065677839928885, 0.18499553417790726, 0.18852691633444474, 0.18001976586531365, 0.1773895239391613, 0.17801231234462667, 0.8379780216382431, 0.16421797501976432, 0.8194805257064142, 0.15641639245225447, 0.1388175284256702, 0.12481636461795409, 0.14346009300501883, 0.770358923072308, 0.7375158743912802, 0.7269443508917925, 0.16104727577694122, 0.1990978510536363, 0.12487359081289073, 0.2064877570570417, 0.761271438932476, 0.8439016063723915, 0.24608451263797615, 0.25569000337999237, 0.19604410803817274, 0.1647230019060626, 0.21404363957598416, 0.1892790193297944, 0.2672721974885133, 0.2458117764139881, 0.19131718412722754, 0.06706381052212673, 0.0942453368794055, 0.0881367396764352, 0.09182663399628932, 0.07940693830465828, 0.09613946294657794, 0.08209714840054672, 0.0901802964127415, 0.08264641281472707]}, "mutation_prompt": null}
{"id": "dbc0d425-e88f-4467-a880-541b5f631daf", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n        self.dynamic_mutation_factor = (0.5, 1)  # New dynamic mutation factors\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._dynamic_mutate(population[a], elite, population[c])  # Use dynamic mutation\n\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _dynamic_mutate(self, a, b, c):  # New method for dynamic mutation\n        mutation_factor = np.random.uniform(*self.dynamic_mutation_factor)\n        mutant = np.clip(a + mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive crossover, dynamic mutation strategy, and genetic algorithm-inspired selection to improve convergence rate and diversity.", "configspace": "", "generation": 47, "fitness": 0.30940501295091216, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.8139438218194986, 0.8041573827435979, 0.7626035132141806, 0.7969489378281545, 0.8012247994195674, 0.7560798909580627, 0.8178342953034189, 0.8009105518692881, 0.7789992015210324, 0.6799232550528208, 0.6515377263104862, 0.6444101700063387, 0.3471100819566453, 0.6093164169777296, 0.04239346961621837, 0.7187553919415859, 0.6940029845166176, 0.5554438044221689, 0.07075500650571542, 0.12136956679293509, 0.11450448539778646, 0.10376688236804599, 0.14183311192153436, 0.06874127742453251, 0.11236510771769481, 0.10125755201358622, 0.13171994717704616, 0.13229230534055347, 0.14125948530030696, 0.10690243944703959, 0.0979029079493795, 0.05739473733327283, 0.10694184105933913, 0.1263602216778279, 0.13014688619360237, 0.12796942327394245, 0.9463654544906909, 0.8790197226197353, 0.9356993044814418, 0.9416640987160633, 0.9186747537000217, 0.9459701426249707, 0.9507041154260426, 0.9531970840694495, 0.9517456555269352, 0.5076700517970467, 0.5290055479013904, 0.5071941387460512, 0.6073692324859553, 0.6008538145274989, 0.5743614558636412, 0.5598099966243274, 0.5674421469070909, 0.6082994735140012, 0.16595422639512303, 0.3452023900310548, 0.23196357807348755, 0.2630074810723563, 0.7790560613195887, 0.7639449525549566, 0.1376804977851268, 0.8045209737877961, 0.17162379901814562, 0.14707881600568584, 0.21271327112842908, 0.29121055095902504, 0.26712032797293916, 0.12148929319395252, 0.2886589082411648, 0.21651375106633552, 0.3628866637875424, 0.5642852038595813, 0.5309136676398194, 0.311317743705253, 0.4530650840253816, 0.28765312669352827, 0.3492352334248283, 0.270702240636685, 0.10526077453225047, 0.28324246210593707, 0.3192671908282656, 0.07438738122600075, 0.09941588776030097, 0.009680011474394457, 0.12973086023686464, 0.06685464965811805, 0.03561280525926891, 0.08826244206901424, 0.10540721101999007, 0.13639658370144447, 0.0860542047858116, 0.14746741908800554, 0.12249671980342158, 0.1185351610794545, 0.13621270364914795, 0.06715132448301175, 0.30494313932714445, 0.13935054939028357, 0.09363001653459124, 0.16314376358038918, 0.11346533456495855, 0.04623973952706906, 0.10297861866359759, 0.09778646871398755, 0.08852551104185313, 0.08513830020907576, 0.15310039652860963, 0.06809479530482876, 0.158702898002537, 0.16469591770854897, 0.15670721653025343, 0.24335637822839018, 0.1292441508172053, 0.23617452366699188, 0.18184360780614428, 0.2593086441056608, 0.16849930068163343, 0.5461181369585613, 0.5510610231569202, 0.5525492162513717, 0.5471851042508808, 0.5553019876448837, 0.5310413176212732, 0.6949146266886757, 0.5277618447520402, 0.581009445232016, 0.05601670556169247, 0.05962121364212436, 0.0913283045069333, 0.10549855815876885, 0.16634344281399094, 0.14429490586972227, 0.09713843647979647, 0.14002725001429261, 0.14057602088985044, 0.25265819951151547, 0.1820791935098367, 0.19368990331330282, 0.15423467859818651, 0.46108949191012427, 0.2390268470950656, 0.18334173880185023, 0.15125764037132372, 0.192702702946435, 0.41322711626015185, 0.3847643853269568, 0.4298891970395432, 0.39022017866886716, 0.287155502661252, 0.33394136120537554, 0.41462811505380337, 0.40366497634983023, 0.17249569608881266, 0.20083344305868145, 0.20322796290868683, 0.2172602354167319, 0.25826894297277614, 0.19528436942303617, 0.20133530188918614, 0.23648555327336418, 0.18760057388565654, 0.14924337614342853, 0.19309026584936773, 0.19731139867657055, 0.2221107304601846, 0.20574022590391128, 0.269075093721463, 0.18558124574608603, 0.19676371720564967, 0.22685800067600892, 0.27671179955308933, 0.2103028156699298, 0.19699544014559667, 0.19648329127966346, 0.18825219027301632, 0.21575572231417184, 0.19237841413820944, 0.18894279326874186, 0.19835579510358992, 0.20682258855114344, 0.16447708527059857, 0.20268382710599664, 0.1614477582532634, 0.8690302902821817, 0.16885582323563997, 0.12096898580756821, 0.8391646040475667, 0.19527265116452697, 0.20284126273286018, 0.8299005466118726, 0.20581763999943536, 0.20641533327176043, 0.20211123998935399, 0.20184360628402054, 0.15755695027071015, 0.2053255706201862, 0.7839284107174631, 0.2052842450628758, 0.2162192900660127, 0.20567652680662418, 0.1826304688904694, 0.2255059657029579, 0.27023731285941544, 0.19321164324469298, 0.23575647887765694, 0.2462575625734046, 0.24234381855641707, 0.09268220099680147, 0.09593712054331027, 0.06657022246343425, 0.07564221192484388, 0.07519478189248308, 0.09601563487383957, 0.07673186155459621, 0.10048311381800978, 0.08824702184406763]}, "mutation_prompt": null}
{"id": "a2a76beb-ecfb-47f4-a0ec-ce506824ecd3", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations  # Changed from 10 to 12\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9  # Ensuring crossover adapts from a base\n        self.crossover_decay_rate = 0.1  # New variable to manage crossover decay\n        self.evaluations = 0\n        self.elite_fraction = 0.3  # Changed from 0.2 to 0.3\n        self.merging_interval = 100  # Changed from 50 to 100\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    # Adaptive dynamic crossover\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Improved local search with adaptive step size\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02  # Enhanced step size\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        # Preserving subpopulation diversity by mixing best and worst\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive dynamic crossover, improved local search, and subpopulation diversity preservation.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.757347120270937, 0.8015061297688133, 0.7957433060990762, 0.7945598946915255, 0.7764510840168528, 0.8291332447202154, 0.7862193589385387, 0.8082567778036185, 0.818879614857828, 0.6245100735696872, 0.5873581722180823, 0.608632988615576, 0.4904145687946695, 0.6441211309109858, 0.6541447348563718, 0.3017768737608095, 0.7069747190876027, 0.04899133298418801, 0.057500072775094835, 0.1257324776472949, 0.11192016196787513, 0.07079690689488094, 0.11951542465790077, 0.10402506841512293, 0.14744955358550282, 0.09430566879919211, 0.05239235707794343, 0.08671502661635799, 0.12658056576387045, 0.11137783193480988, 0.07880798069816408, 0.07925848204101826, 0.13118474814162928, 0.10692410952841835, 0.0800838266117676, 0.13849638946143272, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.5670117112870589, 0.5856833646654241, 0.554939348642451, 0.5182393090749666, 0.5790232422364466, 0.5766625657769026, 0.5651778469780755, 0.5918943772474383, 0.5106009954359898, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.3029404422648597, 0.12196841148698201, 0.4487158223025063, 0.5041716963556682, 0.12398239008625656, 0.1206786190011071, 0.36748565619747964, 0.3780397382211891, 0.4931491423616833, 0.27148164904193417, 0.19256948165665744, 0.2853847035198249, 0.45301037380425013, 0.30480749892123216, 0.351464076574985, 0.36280174973971946, 0.4927366140071684, 0.26157805495529185, 0.06470122189461724, 0.13749443486143753, 0.0698679995716941, 0.06174652298089445, 0.07418660825218792, 0.08970195168163608, 0.07828980973587019, 0.01653739830412504, 0.010506169569471924, 0.10478215094772492, 0.12222321269333059, 0.2555136708638853, 0.13735639517638587, 0.23583637294210402, 0.13338883339313012, 0.12975684422859357, 0.22742178662261237, 0.3534030189130737, 0.05626782048929091, 0.0813193764753456, 0.09413882829413522, 0.07639865153448644, 0.13581123102470882, 0.11018248175899936, 0.12411412682668965, 0.09292089721131724, 0.09145727514097235, 0.21216454927390827, 0.16924455557982931, 0.2040107014749245, 0.25484869855057224, 0.22461009883618221, 0.31203079505218534, 0.23894885909881736, 0.21634001966335192, 0.10483259540389611, 0.6530190649421141, 0.5765882547961352, 0.5805016413376833, 0.5270585755352151, 0.5550172680693004, 0.5868103222219114, 0.6003765524331197, 0.5363338644328739, 0.5432437439528294, 0.14432645639564, 0.07442893783085625, 0.08649406188989683, 0.10918537147192398, 0.05296829688280991, 0.10908999154943688, 0.11220301960643264, 0.1499933290081812, 0.171981635628095, 0.15276622655840222, 0.378779232834481, 0.15372856660051126, 0.22063404236932171, 0.14358381520985408, 0.14372067645325548, 0.187760549172712, 0.14334557829443562, 0.1318849698127731, 0.17667084993412463, 0.3518449029486661, 0.21144547841387917, 0.25404588553156815, 0.13615276594923853, 0.35618998331502105, 0.3800852462803831, 0.21090136849609986, 0.3890761036724806, 0.27255406396906545, 0.21539740905890048, 0.1835224388791743, 0.23997805790199533, 0.2719425271850444, 0.18975109721195726, 0.30102403422893664, 0.2449425888694411, 0.1825930654886765, 0.1951241843346334, 0.22063010838129038, 0.21516254949132485, 0.28792088115868497, 0.20933016483921685, 0.15253797820744364, 0.17967175026456994, 0.18169674172512318, 0.17265805937991696, 0.20380009624967943, 0.18465279439596372, 0.17530067174472863, 0.1993199710313477, 0.19727695792037658, 0.19065677839928885, 0.18499553417790726, 0.18852691633444474, 0.18001976586531365, 0.1773895239391613, 0.17801231234462667, 0.8379780216382431, 0.16421797501976432, 0.8194805257064142, 0.15641639245225447, 0.1388175284256702, 0.12481636461795409, 0.14346009300501883, 0.770358923072308, 0.7375158743912802, 0.7269443508917925, 0.16104727577694122, 0.1990978510536363, 0.12487359081289073, 0.2064877570570417, 0.761271438932476, 0.8439016063723915, 0.24608451263797615, 0.25569000337999237, 0.19604410803817274, 0.1647230019060626, 0.21404363957598416, 0.1892790193297944, 0.2672721974885133, 0.2458117764139881, 0.19131718412722754, 0.06706381052212673, 0.0942453368794055, 0.0881367396764352, 0.09182663399628932, 0.07940693830465828, 0.09613946294657794, 0.08209714840054672, 0.0901802964127415, 0.08264641281472707]}, "mutation_prompt": null}
{"id": "62e0882b-e2a8-4cf8-8889-251561de3323", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.15  # Adjusted decay rate\n        self.evaluations = 0\n        self.elite_fraction = 0.35  # Changed elite fraction\n        self.merging_interval = 80  # Adjusted merging interval\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._mutate(population[a], elite, population[c])\n\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, b, c):\n        mutant = np.clip(a + self.mutation_factor * (b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.03  # Adjusted step size\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = self._shuffle_and_merge(populations[selected_idx], populations[sorted_indices[i]])\n            fitness[sorted_indices[i]] = np.array([func(ind) for ind in populations[sorted_indices[i]]])\n\n    def _shuffle_and_merge(self, pop1, pop2):\n        combined = np.vstack((pop1, pop2))\n        np.random.shuffle(combined)\n        return combined[:self.subpop_size]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive crossover and a novel fitness-based elitism merging strategy.", "configspace": "", "generation": 49, "fitness": 0.19869143169763268, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.38910674651346, 0.3730753571887516, 0.39513422362533546, 0.38990705106974, 0.4506542696704995, 0.4447353086319351, 0.5109740955659707, 0.40251730717535816, 0.40415368952178976, 0.1096368401865302, 0.07296650847427777, 0.11158099432210311, 0.08819895394925459, 0.0708401775372729, 0.1061165642344094, 0.0932882325561406, 0.1938045035438697, 0.14514329783494628, 0.08616705678579495, 0.11799967160630853, 0.08901283536539117, 0.10650504151994522, 0.09509176496859506, 0.08316985760125739, 0.1599070701833929, 0.09769917246193183, 0.0939879454572321, 0.08367847724300514, 0.08509135186230399, 0.08098443643681963, 0.09570440414029235, 0.082909740990176, 0.08230339328182656, 0.08169037709607996, 0.11198414642275745, 0.09562385829242337, 0.933023652943741, 0.930305588650814, 0.9789140154016972, 0.9125583409086855, 0.9119501297773503, 0.9253495027069911, 0.8883633855192758, 0.9463086869234946, 0.9507971885170711, 0.1593471899472252, 0.14255155096795025, 0.18259042407278792, 0.1509241858807303, 0.19958881025833042, 0.17851061611664498, 0.1765079781366925, 0.18010643609694976, 0.1817041852510609, 0.3065376622247822, 0.24968491923593983, 0.20378061187024998, 0.56135601857341, 0.2941602977497626, 0.19319280407953654, 0.24139593592030628, 0.23434556276680274, 0.25550671128782965, 0.12454399108650871, 0.1205396776362957, 0.14121612171601516, 0.14790062996142062, 0.1060471442902341, 0.08958339550127725, 0.144523146880861, 0.13563696105858147, 0.12447848656756577, 0.17089028686907493, 0.15354117854324145, 0.0880761442927287, 0.13008991507228984, 0.14216766587036034, 0.15411862330685033, 0.09959467065936167, 0.10275434270635941, 0.12407382504115427, 0.03329354923175709, 0.03986631882938796, 0.0013261807756361765, 0.018124390791670497, 0.02944240632232087, 0.010798895825574473, 0.018708871770069524, 0.005567189150192053, 0.00042687858141998714, 0.09091924481810942, 0.08975162603756359, 0.09876942879578032, 0.11642445420355474, 0.07108956903090569, 0.04474954849768842, 0.11406883992051264, 0.10244553375412235, 0.12031804454668704, 0.024515564399980927, 0.015852907784400294, 0.014765140315667669, 0.009384452235020269, 0.02168496950965959, 0.015746030623200236, 0.005176193106146254, 0.006167737735517265, 0.008343124413055736, 0.075125890571349, 0.07963346263055315, 0.09505096821005277, 0.07123555735374465, 0.0796943377588264, 0.08042494633323316, 0.07640961067510776, 0.07235104749745402, 0.11975838354580814, 0.32733133098504397, 0.34831968376936795, 0.3835399109651687, 0.3410204099168507, 0.3512559758028613, 0.3175179042783206, 0.3578393093177721, 0.40397031903374403, 0.38767981086749126, 0.08144745519251917, 0.0832597901315848, 0.08330952276596815, 0.07765916735421907, 0.06243850915335569, 0.0990335915107231, 0.08785927741105626, 0.11620350355268871, 0.0787001714817891, 0.17622285268232285, 0.1914802174779925, 0.1909288640009177, 0.20223496308667077, 0.2919782088528148, 0.1783430073064346, 0.1724419577348213, 0.23585408393077834, 0.23223237824052512, 0.2006157676099405, 0.24073086126560062, 0.2317046411638305, 0.2173845209212849, 0.20658542994285922, 0.2221339153473162, 0.21970158567240627, 0.2551308181722478, 0.24380000446271433, 0.19503434850746026, 0.19317943151062922, 0.1875088555316493, 0.1863799598899103, 0.15787287328077892, 0.15633427785032195, 0.18258734350441652, 0.1731856464199123, 0.1896599588313289, 0.18530927812281484, 0.15688693250003416, 0.17950299608606124, 0.1838568390176275, 0.18841088020766605, 0.16403561833350722, 0.17613668306608088, 0.1834542348621251, 0.17811371429006018, 0.20556027439313063, 0.18850382822071066, 0.1961490573762954, 0.1952676094956698, 0.20506144830672124, 0.19124857361123393, 0.18312139823775175, 0.19475165949845763, 0.17303530700054293, 0.17246938130115907, 0.17021259181140214, 0.40434485058202974, 0.16798790942840902, 0.18889642644775817, 0.1730524182028612, 0.15226995914266772, 0.15178531513625293, 0.5741521986889981, 0.3949391261769031, 0.32499140376124735, 0.2505101170210622, 0.1797739656814782, 0.18939079590389485, 0.21377673639816308, 0.25951097933458034, 0.2890496139000437, 0.2826699339848956, 0.17663567339236796, 0.19109124258472532, 0.21062955075738266, 0.19744958689230518, 0.2020424027643296, 0.21228676692651482, 0.20204179382296272, 0.18780558056276275, 0.18212646533653953, 0.07520482585444754, 0.07135945637599561, 0.07202583342989388, 0.07322494969251059, 0.07828333186221081, 0.06208645126330048, 0.06959403939452058, 0.06870804271532505, 0.06903616309664318]}, "mutation_prompt": null}
{"id": "4042e5d2-8f35-4205-90f3-1d6d6d91e0d7", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.subpopulations = 5\n        self.subpop_size = (12 * dim) // self.subpopulations  \n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.base_crossover_prob = 0.85  # Adjusted base crossover probability\n        self.crossover_decay_rate = 0.15  # Adjusted crossover decay rate\n        self.evaluations = 0\n        self.elite_fraction = 0.35  # Adjusted elite fraction\n        self.merging_interval = 120  # Adjusted merging interval\n        self.global_best = None  # Track global best solution\n\n    def __call__(self, func):\n        populations = [self._initialize_population() for _ in range(self.subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * self.subpopulations\n        \n        self.global_best = self._get_global_best(populations, fitness)\n        \n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._hybrid_mutate(population[a], elite, population[c])\n\n                    # Adaptive dynamic crossover\n                    self.crossover_prob = self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget))\n                    trial = self._crossover(population[i], mutant)\n\n                    # Enhanced random spatial restructuring\n                    trial = self._random_restructuring(trial)\n\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = trial\n                        fitness[s][i] = trial_fitness\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _hybrid_mutate(self, a, b, c):\n        rand_vector = np.random.uniform(self.bounds[0], self.bounds[1], self.dim)\n        mutant = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (rand_vector - a), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _random_restructuring(self, trial):\n        if np.random.rand() < 0.1: \n            trial += np.random.normal(0, 0.1, self.dim)\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n    \n    def _get_global_best(self, populations, fitness):\n        best_fit = np.inf\n        best_sol = None\n        for s, pop in enumerate(populations):\n            min_idx = np.argmin(fitness[s])\n            if fitness[s][min_idx] < best_fit:\n                best_fit = fitness[s][min_idx]\n                best_sol = pop[min_idx]\n        return best_sol\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Stochastic swarm-based adaptive differential evolution with enhanced search capability through random spatial restructuring and hybrid mutation strategies.", "configspace": "", "generation": 50, "fitness": 0.17551113798237242, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.11.", "error": "", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.4076537649388168, 0.39254036988276464, 0.39021496312920134, 0.39180456322739, 0.38161652085195497, 0.36505099583868805, 0.3766577667766907, 0.3727680802110006, 0.40454373697839396, 0.08613226230165871, 0.055066309377596934, 0.06666288063577597, 0.054553819506440226, 0.10573500361190313, 0.08942077349325739, 0.08088394713312352, 0.07151559947651731, 0.10158390751415314, 0.1259670310140737, 0.12465013188696061, 0.11819530899853725, 0.11420842561199152, 0.11143006421554802, 0.11215531785443911, 0.10259258872570576, 0.11311760263039339, 0.11176743213954055, 0.1187908802877069, 0.09603941827276719, 0.12726115890173262, 0.10777940485176551, 0.10203024844479658, 0.10604888351325703, 0.09457237857282597, 0.09665459559384204, 0.11552360144728069, 0.21747004410427107, 0.20569188822710516, 0.1849621619728148, 0.24083861528036388, 0.23634860945348624, 0.2581963346356173, 0.24107643886677266, 0.31161046423769134, 0.24087924462438393, 0.24110018534376, 0.258337135203178, 0.25317791275323454, 0.2564811322929845, 0.24254831213725958, 0.2257011364826601, 0.23833191845318247, 0.25608123716017295, 0.22853262822374887, 0.30637239650488823, 0.3003390284049706, 0.283885113887964, 0.30448284213769516, 0.2706472827054789, 0.2604245591690014, 0.27393577208963593, 0.2530334003830812, 0.2982935412429748, 0.14718282880987021, 0.14489505184070162, 0.14938517470279689, 0.1882565695452213, 0.18188288395451557, 0.14650528706856858, 0.14704498835804314, 0.13844247790450193, 0.13722092356686877, 0.14690366156748913, 0.14069209186111953, 0.14893803743116818, 0.16457992705679847, 0.14452833813996335, 0.1442373988494332, 0.15448401096567577, 0.1502242958443437, 0.16104797568352625, 9.999999999998899e-05, 9.999999999998899e-05, 0.005559983114787115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024740215876276173, 9.999999999998899e-05, 0.006157942547658224, 0.06424166301130496, 0.0708755032201418, 0.0847372031596133, 0.04093087237311843, 0.10323573229466787, 0.06934492646167822, 0.07248342768467375, 0.04912746112395505, 0.08666472960750071, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07169553401829876, 0.07595343908419816, 0.09287530776248931, 0.07812885502222766, 0.07738573621545841, 0.06962842295189109, 0.07383807425277422, 0.053444693107200014, 0.06032296785523339, 0.3818938267308082, 0.39006853756133564, 0.3718916692928764, 0.3828439701935329, 0.3534854417116421, 0.3677686843264435, 0.37000111982429906, 0.373271643655811, 0.37791221682799114, 0.08404591567287845, 0.08604627724672032, 0.09315592975864895, 0.09708323948991238, 0.09899125192073355, 0.0934324599800117, 0.09443296700634307, 0.1218086707289141, 0.09795046766355331, 0.164379604070662, 0.16813622333281564, 0.17152636083879713, 0.2314328875725321, 0.16196307635279372, 0.1400421710054237, 0.1738403815487587, 0.16554751809988588, 0.17316283899112006, 0.27009918412556266, 0.26047727130694154, 0.276142210596648, 0.2815948335823276, 0.2774689329613549, 0.2756885236831429, 0.263642703442973, 0.25469786282140827, 0.27626849031324496, 0.19929680295155683, 0.1952352994898353, 0.18258995677728873, 0.2083907786798871, 0.1962530219955283, 0.20110602109170617, 0.19390718364864434, 0.19863396456002325, 0.21001946016075834, 0.18166605585896922, 0.1835180299172865, 0.18268167188915385, 0.19256274864160683, 0.17825605521078747, 0.1887103898257978, 0.190074228154691, 0.18319095839934896, 0.1953458615807212, 0.2182520016353655, 0.18558064611821334, 0.18683943567549244, 0.21348624988072362, 0.19531079677359353, 0.18538255964739747, 0.19915216111590728, 0.18024079692217188, 0.19657052520653884, 0.15741297287964717, 0.15340190382241925, 0.1513669585651165, 0.6227007495942436, 0.5476946120744172, 0.5548091999157123, 0.16536806285713535, 0.1514423621532497, 0.15728607505985348, 0.20454005462594738, 0.20975137069683358, 0.44607114093592215, 0.20593318179263276, 0.20335540767620564, 0.1668065102512284, 0.20850613855052302, 0.44387934686459185, 0.20655294901355425, 0.1897770607599265, 0.1785577381277299, 0.18581913142945272, 0.1947859129148345, 0.18441489138165246, 0.17358128152213592, 0.18137871063907673, 0.18199692625946173, 0.17273626694561572, 0.0765719857893109, 0.07966225904127511, 0.07889830252730712, 0.0770935952504257, 0.08323823460756863, 0.07940282336652871, 0.08231206863497431, 0.08250386772421514, 0.0750530361712548]}, "mutation_prompt": null}
{"id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 51, "fitness": 0.3110242936088587, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "b2cc9b73-c26a-44b7-8fc2-5626ee260cb4", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "527cfa6e-6e91-49e1-be1c-4502f2b3e198", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_clusters = 3\n        self.cluster_size = (15 * dim) // self.initial_clusters\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.evaluations = 0\n        self.elite_fraction = 0.4\n        self.adaptation_interval = 150\n\n    def __call__(self, func):\n        clusters = self.initial_clusters\n        populations = [self._initialize_population() for _ in range(clusters)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.cluster_size * clusters\n        \n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.cluster_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.cluster_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.cluster_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._advanced_mutate(population[a], elite, population[b], population[c])\n                    \n                    trial = self._crossover(population[i], mutant)\n                    refined_trial = self._adaptive_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.adaptation_interval == 0:\n                    self._cluster_adaptation(populations, fitness)\n\n            if clusters > 1 and self.evaluations % (4 * self.adaptation_interval) == 0:\n                clusters = max(1, clusters // 2)\n                populations = populations[:clusters]\n                fitness = fitness[:clusters]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.cluster_size, self.dim))\n\n    def _advanced_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c + np.random.randn(*a.shape) * 0.1), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_search(self, trial, func):\n        step_size = 0.01 * np.random.normal(0, 1, self.dim)\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _cluster_adaptation(self, populations, fitness):\n        cluster_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(cluster_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced_Improved", "description": "Improved EHDEAP algorithm with adaptive population clustering and advanced mutation strategies to enhance convergence rate and solution quality.", "configspace": "", "generation": 52, "fitness": 0.14525461988656183, "feedback": "The algorithm EHDEAP_MPD_Enhanced_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.25545494528714685, 0.24237709808196406, 0.23937112234263036, 0.29584617403731306, 0.2993522592708603, 0.2874054018129074, 0.3169996847349096, 0.28509615952154, 0.297115506078265, 0.008425956370377241, 0.004225656956661994, 0.012221042541355254, 0.005471239716640097, 0.0039044552790823417, 0.00233680902978195, 0.005005108597741725, 0.013853518201542792, 0.014546279971148435, 0.07001745444231566, 0.07050583697661517, 0.07158356462260274, 0.07353962930351865, 0.0715216200900044, 0.08536686324317655, 0.07419419657534365, 0.06425830509764396, 0.07396243689328552, 0.06901908318389394, 0.051158582674519115, 0.049847317686599335, 0.0653340919990052, 0.05306687411883426, 0.06671084110527425, 0.05206013273872501, 0.054635542554876126, 0.04483084758516054, 0.9568556473579131, 0.9285505132140994, 0.9263320856758761, 0.9064781084014553, 0.9105581680728575, 0.8815129051317712, 0.9096984632334719, 0.8695073742210263, 0.949219599490907, 0.1036373379676504, 0.10701092913667998, 0.10377872603678318, 0.10829426722525315, 0.13785994757356224, 0.12292943426016878, 0.11888673596655375, 0.09587865793247963, 0.11760476222642391, 0.1494821301280721, 0.13819514028356883, 0.14277815763935664, 0.17071976913685394, 0.154062455971953, 0.15517254642536682, 0.14440328977129835, 0.19494895316794214, 0.16020580425378483, 0.05341959150011244, 0.05119947718932638, 0.05082863715825259, 0.03231532386367142, 0.04894121151812947, 0.07476468367627365, 0.07593614328953957, 0.07827214780345804, 0.07656354422684175, 0.058458660739548196, 0.06822181400915128, 0.07379851178751629, 0.05373969583579308, 0.05358676680252539, 0.05240805908961943, 0.03040643864166992, 0.05146617423985245, 0.07108312867424815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010810771981026868, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04999964006407753, 0.018070219753381966, 0.05835864368924504, 0.05709046667578277, 0.022888933704225067, 0.06923689160713109, 0.07874588689718565, 0.0565930758078792, 0.05596565791116204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033322866025255804, 0.013395311163424739, 0.01988226305286367, 0.01649818941296799, 0.044362117776930554, 0.02922487062353263, 0.036982033606612785, 0.03416066335386225, 0.03582269779352498, 0.26346943708351955, 0.24266419042204745, 0.2689354350456291, 0.2732487887152887, 0.2760972780494768, 0.25303569500814327, 0.28546110738906283, 0.2774723009894725, 0.253063685633357, 0.07815124280679198, 0.06277447836427186, 0.06077382631286854, 0.05680842235540495, 0.05962627072689486, 0.06455249202840185, 0.04936018063837233, 0.05995391618491608, 0.06741305762573935, 0.13957101674536565, 0.14086202657926628, 0.13085255703324017, 0.13766266535167793, 0.1443635700680186, 0.164236989612063, 0.13121220580807091, 0.1304819579634623, 0.1429629869248682, 0.17560839563164932, 0.1716084312634628, 0.18698965218761532, 0.1780084740507234, 0.16480211407643053, 0.1844109698236971, 0.19869862863343202, 0.21297090004924335, 0.19387433142661226, 0.1268669406667552, 0.12829507623785374, 0.13579174664482885, 0.1231902005673271, 0.12427400717684922, 0.11387185794218091, 0.13974877784271522, 0.14235040068398308, 0.1567207473716944, 0.15347613302045593, 0.17135526728141648, 0.174353731726144, 0.18556646374523944, 0.15867567798581173, 0.16203257930170745, 0.18055367754966445, 0.16530254152588042, 0.1916675364966942, 0.12871665784058184, 0.1394658416807577, 0.1770472631401686, 0.14964281515422684, 0.15865454212824115, 0.15009192038024544, 0.14446592818897697, 0.14371647943267085, 0.14875955044094002, 0.13969738600268644, 0.16000193103758342, 0.2288326357679039, 0.13117436511220515, 0.15626007358526672, 0.13317522799217785, 0.1669475802822764, 0.12538128321104436, 0.15941058560294075, 0.1510365591917927, 0.1965775804985035, 0.1865859097439272, 0.14643432109696009, 0.1494073056746854, 0.1731076347694489, 0.19038444553713274, 0.21550302697940238, 0.23215386483694034, 0.1832841824312863, 0.18677217407175473, 0.18174204455890208, 0.18626451042143477, 0.18212595055375036, 0.17797266749001062, 0.18427190857608788, 0.17502821778157052, 0.1752756032446694, 0.0569734935477858, 0.06385151149245616, 0.060001751954464666, 0.07022159090778202, 0.05029089861610536, 0.053546920273866094, 0.060573045320597374, 0.064125793950506, 0.05993480782980154]}, "mutation_prompt": null}
{"id": "373dc7e1-cd34-4403-9da8-6e1759de71b3", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "d5b2b82f-dfce-4175-bf0a-26cce4c1ce1b", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n        self.adaptive_factor = 0.1  # New parameter for adaptive mutation\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    niche_factor = self._calculate_niche_factor(population, i)  # New niche factor\n\n                    mutant = self._adaptive_mutate(population[a], elite, population[b], population[c], niche_factor)  # Changed method\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _adaptive_mutate(self, a, elite, b, c, niche_factor):\n        adaptive_factor = self.mutation_factor * niche_factor\n        mutant = np.clip(a + adaptive_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n\n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]\n\n    def _calculate_niche_factor(self, population, idx):\n        # New method to calculate niche factor based on population diversity\n        differences = np.linalg.norm(population - population[idx], axis=1)\n        niche_factor = 1 / (1 + np.mean(differences))\n        return niche_factor", "name": "EHDEAP_MPD_Enhanced_Refined", "description": "Enhanced Differential Evolution with adaptive niche-based mutation and dynamic parameter control for improved diversity and convergence.", "configspace": "", "generation": 54, "fitness": 0.2866234972789877, "feedback": "The algorithm EHDEAP_MPD_Enhanced_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.8103454311266912, 0.7367082123380179, 0.8149518919458675, 0.7934080130872171, 0.7936734152315108, 0.8025209987083082, 0.7655973787705443, 0.7722630243568922, 0.7628987566955436, 0.5728508238354477, 0.493237503266288, 0.05515660868258876, 0.673457788087453, 0.37755137270840333, 0.5233876430901488, 0.6685477894878441, 0.5941209624083201, 0.5869917676144839, 0.10720275183498651, 0.07125146389945514, 0.037603709919281525, 0.12497891204184053, 0.04911252351046891, 0.09548756452304219, 0.10169918106094589, 0.1204205403074935, 0.06957463582699308, 0.09348135014868586, 0.012361454716559472, 0.048399843751117944, 0.08119780591782799, 0.01645581713246025, 0.012396585602483579, 0.0881914456553432, 0.0414522983318697, 0.06314084437203582, 0.8401645151716777, 0.8390324461257406, 0.867095229132401, 0.8175025415173249, 0.8550175794427882, 0.9002356830136901, 0.8497483709395027, 0.8636627158046073, 0.8635635582698562, 0.5911742259138328, 0.4991527306817376, 0.4285768234512286, 0.5956303817581079, 0.5461453587657217, 0.5896612833377926, 0.589750291389715, 0.4514741244982886, 0.6331460520064873, 0.10027683525177622, 0.16610671559156687, 0.19809276180034974, 0.21545857347936637, 0.14101190435117683, 0.08604198415047215, 0.10619560709292186, 0.7577599526805782, 0.2314304303429361, 0.36782347031837126, 0.11487095604582487, 0.3048624171578477, 0.2889295393290904, 0.47152660216749276, 0.27774523814419705, 0.3791211147253605, 0.12010112803093254, 0.2269687790260968, 0.25835251596004716, 0.24995186835121785, 0.36430860060516856, 0.2878569982519589, 0.26804149311297176, 0.11521796458714961, 0.26906815047550525, 0.3709528253413594, 0.12109415017620062, 0.08986689947237048, 0.21820002616568768, 0.060970788192896364, 0.16738654741201697, 0.06031540102482413, 0.02953326337829565, 0.06505732860683489, 0.09263277143729842, 0.07473506449703637, 0.21238192386434807, 0.14919040029400255, 0.11742942227101227, 0.10908337920551525, 0.18836762938179474, 0.08014800694155733, 0.07205555076018211, 0.19116006277406783, 0.11197246575352238, 0.2881464285130648, 0.10091466692574325, 0.11168577251601075, 0.08228849000573935, 0.1086831716875678, 0.18965362017326493, 0.11556217957263526, 0.13947910089305138, 0.19235278451410864, 0.21290191481118503, 0.2255726454263487, 0.2087574872050293, 0.21108393735766406, 0.32059652907288705, 0.20554837358339706, 0.11091067130497145, 0.2333917116953227, 0.17240748780984327, 0.514287663052922, 0.5525995559382946, 0.5675072492272673, 0.577300964262151, 0.51477935108011, 0.5488540525557193, 0.6277132088452566, 0.5629779885777098, 0.5290858692745686, 0.061341394176055664, 0.11882007814661244, 0.024971883704984266, 0.15150961365021154, 0.040497687199834376, 0.0685894047662039, 0.08647911092069882, 0.06967587445742918, 0.0711016132986273, 0.2658334212318634, 0.3465067337227352, 0.13518205740217326, 0.6002346044842122, 0.17285212247559778, 0.5981919876174225, 0.43089477509461793, 0.13355564938678177, 0.16685978161110848, 0.17428659350107123, 0.1775536779916339, 0.16531399132468627, 0.26288188921972055, 0.22051121480403713, 0.23124675884230816, 0.23063696480470708, 0.24021302771022324, 0.1637914825320338, 0.17262428297612353, 0.1050742236769886, 0.22121617933726934, 0.1080904621324027, 0.13607257878310997, 0.08231277299107675, 0.19665860265390356, 0.16369186076146958, 0.2389558887130152, 0.23287348941226926, 0.16866670140173123, 0.21181391898013013, 0.19290116531668766, 0.15685252316682585, 0.2417952725489777, 0.20368821948623983, 0.20263387470702232, 0.2009625965095133, 0.20198727645820125, 0.18074663569789007, 0.17465237544311663, 0.20180790826773132, 0.18033611059085541, 0.20316068081163885, 0.166946968016927, 0.14936580584990933, 0.15770917819593266, 0.17711822084226947, 0.18104017576829134, 0.8253462542745174, 0.16662495765651708, 0.19434927395290424, 0.19462651702499612, 0.15694157176284784, 0.16528997546043533, 0.14927594313826598, 0.8481641092413612, 0.15832634077079477, 0.8607539688252377, 0.15955406921799187, 0.15342566230345978, 0.14888342842406432, 0.16297742158483075, 0.8439952111688245, 0.7353286035163622, 0.19061094985540428, 0.1852584526612716, 0.19383484125886818, 0.3662201146836346, 0.25579417094885215, 0.1914018783834074, 0.25687850675839863, 0.20675456477473542, 0.19790320569599873, 0.0698144538719967, 0.08061600265327196, 0.06151968039549138, 0.09032631993371565, 0.08251183226377035, 0.06047709722082073, 0.07071588256658867, 0.09352835197996279, 0.08384604937864004]}, "mutation_prompt": null}
{"id": "c393a64e-e128-4ced-8b0e-cdd1f75e2adb", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "419fc2d6-3e96-4ca6-a23f-76a299907fa9", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "6e6b0c9a-bbc0-4163-bf46-592d37344ceb", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "c3b2da65-4df3-43d4-a5cf-7051ee940e6b", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "dfa7bb0f-6ea0-4dbf-9bd8-309a5c49ff1e", "solution": "import numpy as np\n\nclass EnhancedEvoSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 4\n        self.subpop_size = (10 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9\n        self.base_crossover_prob = 0.85\n        self.crossover_increment = 0.05\n        self.evaluations = 0\n        self.top_elite_fraction = 0.2\n        self.secondary_elite_fraction = 0.4\n        self.adaptive_interval = 50\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    top_elite_indices = np.argsort(fitness[s])[:int(self.top_elite_fraction * self.subpop_size)]\n                    secondary_elite_indices = np.argsort(fitness[s])[int(self.top_elite_fraction * self.subpop_size):int(self.secondary_elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(top_elite_indices)]\n                    secondary_elite = population[np.random.choice(secondary_elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._adaptive_mutate(population[a], elite, secondary_elite, population[b], population[c])\n\n                    self.crossover_prob = min(1.0, self.base_crossover_prob + (self.crossover_increment * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    trial = self._dynamic_local_search(trial, func)\n\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.adaptive_interval == 0:\n                    self._balance_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.adaptive_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _adaptive_mutate(self, a, elite, secondary_elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + secondary_elite - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _dynamic_local_search(self, trial, func):\n        gamma = 0.01\n        step_size = gamma * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 5))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _balance_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EnhancedEvoSearch", "description": "Adaptive Evolutionary Search with multi-level elite selection and dynamic step-size adjustment.", "configspace": "", "generation": 59, "fitness": 0.22775218837874314, "feedback": "The algorithm EnhancedEvoSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.49517507443116315, 0.4848126549283034, 0.5344074827994273, 0.5449495564516182, 0.5509693058321486, 0.5921938538881368, 0.6397297360340679, 0.5076296783965462, 0.5572265095554858, 0.3108940088170079, 0.2528128929965082, 0.3346104707104246, 0.34000269518220716, 0.3553216834966162, 0.30438862168110203, 0.3644903366797062, 0.3317089579492104, 0.27759494954261577, 0.09800182554108672, 0.10010020328752711, 0.11025564524698717, 0.08383642300410354, 0.08953067194670239, 0.10761896687708172, 0.12281572706449573, 0.10323752429740884, 0.08948835020220558, 0.15062731305607246, 0.1050662854014478, 0.10042763992804737, 0.11438543377879307, 0.10519718707536851, 0.09154124828955268, 0.1146554843314902, 0.0963378756281712, 0.09847913714737389, 0.955093426602447, 0.9625140884034638, 0.9577361561599338, 0.9445836160722054, 0.9755327519908248, 0.9565929878384144, 0.968700134405445, 0.9735427853963384, 0.9817710918978797, 0.26299856341292527, 0.23473883580552124, 0.2629298364940833, 0.1874725734621756, 0.24443135354720125, 0.2225696001930597, 0.27966473703416106, 0.2830967316695333, 0.229469028881072, 0.2800723867299656, 0.12882349067897125, 0.3929163499280076, 0.17055262955780204, 0.40182525839357897, 0.2984379279462611, 0.14741176485327523, 0.38122843208749146, 0.14092590494428625, 0.21397428773766425, 0.17043732777373666, 0.15282608178547885, 0.12296649052191133, 0.18785254691810005, 0.10319754522945335, 0.14734029022308837, 0.11190818865591479, 0.16772572833921062, 0.20612421939786996, 0.17167062436209612, 0.19522867151231194, 0.19960996303667466, 0.14791423468543108, 0.19184198398343255, 0.21565332568549522, 0.18038887620738786, 0.09270131655475888, 0.09030081524848066, 0.1429475130172334, 0.1309175908088891, 0.12550360747843747, 0.03955082000134136, 0.055138405126606393, 0.057260158248266135, 0.12279813262180272, 0.12005854817779504, 0.23219132379645613, 0.14963759226353923, 0.16132974383140464, 0.15200957887853606, 0.05951766218126486, 0.11942021687100002, 0.2705020145207071, 0.1769220689703761, 0.17902382540816286, 0.03122379706852285, 0.020355604336782185, 0.047751370369481294, 0.0708252892055602, 0.04558262556470549, 0.04712721789609098, 0.05819101761926415, 0.023428233554263156, 0.054370850472158616, 0.09501427551100461, 0.1670608007940968, 0.1117323492812784, 0.11591997555248401, 0.1156711499517834, 0.10831560318626088, 0.11235523906180911, 0.10955560980679313, 0.14015634453825188, 0.4135016518957797, 0.41051936793179644, 0.428400171358558, 0.44631353833935083, 0.40933952657837813, 0.3822072578553096, 0.43368940787970656, 0.4249007165889437, 0.42959945686250955, 0.07669419007239975, 0.08824801920385994, 0.06528431955310043, 0.1126814857962336, 0.05821903548569496, 0.08991189331836247, 0.07443433156026569, 0.07408870801742451, 0.11416443334128268, 0.17564575197955523, 0.16585810112636645, 0.143451448741455, 0.206758524950569, 0.1762194412408662, 0.1658827465512539, 0.1672324340175605, 0.15237395972838363, 0.17962660003813258, 0.21979238846350468, 0.23860064613110854, 0.2215925784443944, 0.2660975787878582, 0.241199683044367, 0.18486826346801055, 0.2889983379848774, 0.2730569649798317, 0.2737399531829239, 0.18189172964909517, 0.17583893376073956, 0.18077881377612393, 0.2003570156454384, 0.16028403633921207, 0.14911087538520074, 0.1982156504703375, 0.2037361155786761, 0.21418709755742027, 0.17433551519393364, 0.15982409302583633, 0.1776633933649453, 0.159896504656457, 0.1715530546015609, 0.17961398629257797, 0.18205489888112947, 0.16270055398383143, 0.1740594955309802, 0.15342520562143003, 0.18428738334971428, 0.16634175354407166, 0.21994604153246655, 0.15558076209042715, 0.17222427231302995, 0.16538311424929342, 0.24240628972188327, 0.15540171180631734, 0.1575438458316063, 0.15925904514316425, 0.16534687212209553, 0.1772191798567173, 0.17575637820472545, 0.14823217136661515, 0.17416921697815613, 0.15446570580870556, 0.1497610451524839, 0.465952137686958, 0.538645179107264, 0.18074737684581865, 0.5411963858763661, 0.15592691696983785, 0.1796590241691438, 0.2083558112025028, 0.12051070239557271, 0.16037642279113185, 0.18394454717505915, 0.2259367261870069, 0.18773726222082054, 0.2030742998055588, 0.18864452256032682, 0.19950679695608198, 0.21454924637970674, 0.19675282118404058, 0.215041848298683, 0.06498409805834038, 0.056991144983131736, 0.05348250358230566, 0.057616483088239745, 0.06419298161502962, 0.06711760637858011, 0.07021576009206398, 0.056981450177542636, 0.055105431441588526]}, "mutation_prompt": null}
{"id": "cf73b6d1-cec8-431f-bd97-526ee0261952", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "6575be16-ba39-4307-a9f6-db3fb91a05bf", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "d88a09de-3101-4fa5-a30f-b6356bc1c875", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "2cf2c101-6f48-4fe1-a753-37b2b0435125", "solution": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EHDEAP_MPD_Enhanced_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.base_mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                self._cluster_and_update(population, fitness[s], func)\n                \n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _adaptive_mutation_factor(self):\n        return self.base_mutation_factor + (0.3 * (1 - self.evaluations / self.budget))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutation_factor = self._adaptive_mutation_factor()\n        mutant = np.clip(a + mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n\n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]\n\n    def _cluster_and_update(self, population, fitness, func):\n        kmeans = KMeans(n_clusters=min(5, len(population)//2))\n        kmeans.fit(population)\n        cluster_labels = kmeans.labels_\n        for i in range(self.subpop_size):\n            if self.evaluations >= self.budget:\n                break\n            cluster_indices = np.where(cluster_labels == cluster_labels[i])[0]\n            elite_indices = np.argsort(fitness[cluster_indices])[:int(self.elite_fraction * len(cluster_indices))]\n            elite = population[np.random.choice(elite_indices)]\n            indices = list(range(self.subpop_size))\n            indices.remove(i)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n            trial = self._crossover(population[i], mutant)\n            refined_trial = self._levy_local_search(trial, func)\n\n            trial_fitness = func(refined_trial)\n            self.evaluations += 1\n\n            if trial_fitness < fitness[i]:\n                population[i] = refined_trial\n                fitness[i] = trial_fitness", "name": "EHDEAP_MPD_Enhanced_Refined", "description": "Enhanced Differential Evolution with adaptive mutation factor and cluster-based search to improve diversity and convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {}, "mutation_prompt": null}
{"id": "67c3df61-6ca4-4abc-8970-37d4150fc061", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "d4e4ab5f-df4d-4feb-a843-0b1af2c423be", "solution": "import numpy as np\n\nclass EHDEAP_Hybrid_Clustering:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 4  # Reduced initial subpopulations\n        self.subpop_size = (10 * dim) // self.initial_subpopulations  # Adjusted subpopulation size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # Adjusted mutation factor\n        self.base_crossover_prob = 0.85  # Adjusted crossover probability\n        self.crossover_decay_rate = 0.05  # Adjusted decay rate\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 80  # Reduced merging interval\n        self.constriction_factor = 0.729  # Constriction factor for convergence\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._constriction_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._adaptive_clustering_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (4 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _constriction_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.constriction_factor * self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _adaptive_clustering_search(self, trial, func):\n        cluster_radius = 0.1\n        perturbation = cluster_radius * np.random.normal(0, 1, self.dim)\n        local_best = np.clip(trial + perturbation, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n\n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_Hybrid_Clustering", "description": "Hybrid Differential Evolution with Adaptive Clustering and Constriction, incorporating adaptive clustering for diversity maintenance and constriction factor for enhanced convergence.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EHDEAP_Hybrid_Clustering' object has no attribute '_crossover'\").", "error": "AttributeError(\"'EHDEAP_Hybrid_Clustering' object has no attribute '_crossover'\")", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {}, "mutation_prompt": null}
{"id": "db1897f9-cf91-4337-970b-ae9e95921526", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "5672ef73-c94c-40a4-9780-1a18442ca041", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "66077581-bf1b-473c-ad78-11d2b07bc110", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "a36b8e0a-6d8e-4619-bfc8-a424018671a2", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._guided_local_search(trial, func, fitness[s][i])  # Use guided local search\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _guided_local_search(self, trial, func, current_fitness):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < current_fitness:\n            return local_best\n        diversity_step = 0.05 * (np.random.rand(self.dim) - 0.5)  # Introduce diversity\n        return np.clip(trial + diversity_step, self.bounds[0], self.bounds[1])\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Improved Enhanced Differential Evolution with adaptive mutation factor, diversity preservation, and guided local search for better convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' cannot be empty unless no samples are taken\").", "error": "ValueError(\"'a' cannot be empty unless no samples are taken\")", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {}, "mutation_prompt": null}
{"id": "6d120145-9248-4b55-aee2-d9c41a71f7c8", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "325dfa0d-1de8-40d7-a908-b8f087e8a10f", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "84f16e6c-5bda-43c6-914b-262c92835076", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "c871621b-df7b-4c7d-8121-fafad05289d0", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # Increased mutation factor\n        self.base_crossover_prob = 0.85  # Slightly reduced base crossover probability\n        self.crossover_decay_rate = 0.05  # Adjusted decay rate\n        self.evaluations = 0\n        self.elite_fraction = 0.25  # Reduced elite fraction\n        self.merging_interval = 80  # Reduced merging interval\n        self.adaptive_factor = 0.1  # New adaptive scaling factor\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._adaptive_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._multi_stage_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _adaptive_mutate(self, a, elite, b, c):\n        # Adaptive mutation scaling based on current evaluations\n        scale_factor = self.mutation_factor + self.adaptive_factor * (self.evaluations / self.budget)\n        mutant = np.clip(a + scale_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _multi_stage_local_search(self, trial, func):\n        # Improved local search with two phases\n        for _ in range(2):\n            alpha = 0.02\n            step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n            local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n            local_best_fitness = func(local_best)\n            self.evaluations += 1\n            if local_best_fitness < func(trial):\n                trial = local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive population control, multilevel local search, and fitness-based subpopulation merging.", "configspace": "", "generation": 73, "fitness": 0.2553223427818346, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.722400002294022, 0.5834880002685165, 0.7047789496552981, 0.6538701457849969, 0.6492821035372589, 0.6777501496676994, 0.6408975212917883, 0.6639581719085772, 0.7090302779757662, 0.3889113544943248, 0.5321661843827625, 0.3230287397218653, 0.45852495282048433, 0.39179640827122053, 0.37644685297098446, 0.2649091775275527, 0.34644965965646557, 0.28546969169756053, 0.15045500646349974, 0.1315745826701168, 0.15895984116902617, 0.12300467808520976, 0.12050220696142899, 0.09641926717544558, 0.09105000375809158, 0.061457468434164886, 0.08535160083053683, 0.12946864720798223, 0.1096409372471091, 0.1444932744190237, 0.3473654254107158, 0.11637718448457968, 0.10379983923528924, 0.13534424692424252, 0.1268756533679456, 0.10477221305963125, 0.9667242109194375, 0.9366812870580151, 0.9507219120052842, 0.9511337149162845, 0.950281183581058, 0.9385689113168051, 0.9489837782260727, 0.930234585918138, 0.9652492172069648, 0.35753452398785224, 0.36207386932170804, 0.37106005878166104, 0.2731174583588135, 0.3652462397927523, 0.3650042663722083, 0.3353452333721614, 0.3635065755585162, 0.30862815127145393, 0.5952781630122805, 0.14590438500082947, 0.19945281670269055, 0.654248183938819, 0.1886254984286604, 0.637906836947532, 0.33954424317528686, 0.21355724949941168, 0.21259663885393887, 0.1733386557545571, 0.19571921323126873, 0.1473726042250686, 0.253459853887098, 0.23368766073477998, 0.284417966474399, 0.20749902314512603, 0.22404089852066034, 0.23667968791781946, 0.20738539619187268, 0.169403472683741, 0.237563513856908, 0.21705989238864531, 0.24505996383226114, 0.09930471926021489, 0.2671208794793293, 0.11412636932785081, 0.20134945080747635, 0.13714128171696216, 0.05508030371595929, 0.06869921146054625, 0.020424517490501448, 0.05215665035193928, 0.01819423213500282, 0.014715537580350935, 0.007626392147447203, 0.026969162251200163, 0.0625160568715013, 0.13550601490020786, 0.19140186842380258, 0.09110702713494356, 0.04659037891472895, 0.16197939075256895, 0.19652624208487968, 0.1285008989470292, 0.18073266111318775, 0.05505151999802693, 0.042146335751926056, 0.035247604194517446, 0.053909204910801756, 0.05397859305983599, 0.061202723758450706, 0.06186246324541422, 0.06431373751335412, 0.05049247586516614, 0.18723455943461786, 0.13712349362262666, 0.13375217041833842, 0.13525416963112113, 0.18388446416118254, 0.19515884777404835, 0.1472171418917123, 0.15880619707842036, 0.11051348064237154, 0.4799588969765701, 0.4714125220299553, 0.4771352497408816, 0.4594306755617835, 0.46269692138808893, 0.4468480003967811, 0.46972367510608015, 0.45356555108143326, 0.459466907280065, 0.1119525768235704, 0.1056196055733657, 0.10534688210692422, 0.42493620241262675, 0.095902224204648, 0.07266863840840687, 0.12149247377080719, 0.06820356665109994, 0.08660374815528193, 0.12897429461618481, 0.22156753944815588, 0.19254162802929364, 0.2003661927121021, 0.25290786694471956, 0.23491246011322953, 0.13820569466391663, 0.25392399367610907, 0.288826531023592, 0.2912973365807293, 0.26313024156673215, 0.2948919707713903, 0.19976542853282986, 0.2493817721494873, 0.31766408159293136, 0.1929144268091585, 0.31834813144219476, 0.20315439367597476, 0.2273210497010616, 0.08067500359365098, 0.1989883454899054, 0.231178754376004, 0.18757543603837568, 0.17990613084106466, 0.19124172291491504, 0.23116890009862678, 0.1783921944556478, 0.19637752438911782, 0.18182676014374, 0.1804059445219386, 0.18372555838042337, 0.1751061386970314, 0.15470335201011554, 0.18323205352668093, 0.20134341309890869, 0.17736968245992157, 0.1870678613078961, 0.17712549201202388, 0.18978514987020356, 0.20746165734330047, 0.20589944845134145, 0.43938214449615465, 0.192601584720416, 0.1663107150237747, 0.19454002680022386, 0.10294610166715068, 0.18371491854067412, 0.6181801600500477, 0.17505486381081647, 0.19148943118115969, 0.15966610627062616, 0.16238918734576313, 0.152784875465943, 0.11120567205122134, 0.14804116118880595, 0.5956722053044636, 0.10931017311717228, 0.11510780573939738, 0.6631743024993553, 0.14717832813256138, 0.1133136564176157, 0.14703315330808564, 0.12181389762317507, 0.1809899392665133, 0.20217340308080156, 0.20816833976310922, 0.2177911235313239, 0.21545758158342876, 0.20324632131909826, 0.19568160565465764, 0.20401884070591636, 0.19284427268089388, 0.07206252833566074, 0.07737754106390216, 0.076369912314172, 0.0689691433500993, 0.06515511297563226, 0.08180180175551088, 0.07229215262894173, 0.08890856926881319, 0.07690565808460725]}, "mutation_prompt": null}
{"id": "bf7412cd-a494-441e-a612-9fd3aae343d1", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "98c57010-6c01-44a0-8e76-3343630eefd6", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.base_mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.05\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                diversity = np.std(population, axis=0).mean()\n                mutation_factor = self._adaptive_mutation(diversity)\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._adaptive_mutate(population[a], elite, population[b], population[c], mutation_factor)\n\n                    self.crossover_prob = self._adaptive_crossover(diversity)\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _adaptive_mutate(self, a, elite, b, c, mutation_factor):\n        mutant = np.clip(a + mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]\n\n    def _adaptive_crossover(self, diversity):\n        return max(0.1, self.base_crossover_prob - self.crossover_decay_rate * diversity)\n\n    def _adaptive_mutation(self, diversity):\n        return self.base_mutation_factor * (1 + diversity / self.diversity_threshold)", "name": "EHDEAP_MPD_Enhanced_V2", "description": "Enhanced Differential Evolution with dynamic strategy selection, introducing adaptive mutation and crossover probabilities based on population diversity.", "configspace": "", "generation": 75, "fitness": 0.16775478320564335, "feedback": "The algorithm EHDEAP_MPD_Enhanced_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.20.", "error": "", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.40715651126157537, 0.38841462877251187, 0.46896146531258887, 0.47355722263020916, 0.47942261892124993, 0.5578451485627469, 0.3643928985626449, 0.573113460982259, 0.4079418056087656, 0.019417426176471242, 0.044609346685608564, 0.002937269612527049, 0.11550090210608288, 0.10682088815916158, 0.06989288383545011, 0.11523592250371151, 0.14218042196486258, 0.025993291972715493, 0.08941167068352374, 0.07605512169544293, 0.09606885572054469, 0.030702032197163498, 0.035061305317543145, 0.05066802261952197, 0.049322158540068495, 0.05913377746375814, 0.05708019156273603, 0.05572358921995202, 0.055289293611168966, 0.06871849771552097, 0.06561324467803165, 0.0382714190073955, 0.041399786939336436, 0.05537120496819514, 0.08482032507545445, 0.09141583587168134, 0.9784372996189412, 0.9744502665050604, 0.9635863741743094, 0.9888966081193036, 0.9939239269544031, 0.9887679943506268, 0.9889680480308172, 0.9772671153495163, 0.9728322656291939, 0.21375195166540573, 0.12854641519664534, 0.07709750687742412, 0.08217887888693132, 0.06661831493021708, 0.054287185610581545, 0.12489939874061695, 0.1579273704298514, 0.16271776336353072, 0.10190372066504716, 0.2082216570594685, 0.059900573290109005, 0.11665516180449798, 0.07285119553694963, 0.15531122091732652, 0.09477274421323423, 0.07630354612810608, 0.18178860278243614, 0.08604028748639125, 0.06254236041971672, 0.07038443613454604, 0.07683962925958443, 0.13004166015211227, 0.06565552483794868, 0.05687771249912987, 0.07605785698276835, 0.08457424179283624, 0.09836524835397686, 0.10471787674078259, 0.12927013613042238, 0.11684277157421563, 0.10659583242940862, 0.09427394954430635, 0.16001484781181496, 0.06975094127572068, 0.048768736498489895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014982331703050633, 9.999999999998899e-05, 0.0425263090891429, 0.0028762684964475094, 9.999999999998899e-05, 0.04976233201585034, 0.04329572727262909, 0.07378866126098238, 0.06885932156258678, 0.12986752094083365, 0.0811017433190373, 0.036196959246847515, 0.04352481402822794, 0.04663390871714579, 0.00037108002563746023, 0.02537824497232155, 0.024499708682749977, 0.04330450153597809, 0.04657179502918929, 0.09782835215873542, 0.04154950001759228, 0.0989826946964264, 0.03332475309512051, 0.05951100718481883, 0.03391642334306999, 0.043300020541459316, 0.056892953866097384, 0.0866180182629891, 0.16003685340070917, 0.10008047963714017, 0.0635902910230014, 0.061533760159261375, 0.26664284986418707, 0.20607122145308399, 0.24750649622569432, 0.2651269046460242, 0.21307095720995395, 0.2924711830868776, 0.38073549629597214, 0.1639336061227019, 0.48322401844734264, 0.05547369301437288, 0.040880219774451, 0.0818252313977349, 0.04236601035742382, 0.09377525537614673, 0.06623894352978676, 0.07258390925140479, 0.05677840883755947, 0.05953336118457386, 0.1517114448411836, 0.14912866225160848, 0.15206032880494347, 0.21837825986360904, 0.16535922216316123, 0.2903789074233959, 0.12855539691036832, 0.15652542721263563, 0.14038647903330204, 0.18507353347844957, 0.11735523812995219, 0.274934164269813, 0.15303404425275113, 0.1682735512697946, 0.15210903025128097, 0.2791128517217688, 0.21660301171284824, 0.31182655842323237, 0.12567039141451808, 0.09750980262694442, 0.1263275948001772, 0.11354276552677944, 0.13605302927274332, 0.06500548772970871, 0.12759523959846797, 0.16375047165238943, 0.09942125137634339, 0.15114746622562747, 0.17174680107009643, 0.194377286818896, 0.1663354063082334, 0.1927699088391751, 0.13689298353349355, 0.18897499254422567, 0.1805199271046649, 0.15975716845824572, 0.10625899563293095, 0.1434607261692732, 0.1300483589521969, 0.094367260853784, 0.1641471535095801, 0.13804327087215373, 0.1709455178778242, 0.1261452329201258, 0.1381206349561317, 0.14031934121357392, 0.14144938161958998, 0.15232408146751386, 0.1416443378113399, 0.16694298241491656, 0.11785449247750335, 0.7000281708112222, 0.14410181356631324, 0.13034981954244595, 0.1264719024220009, 0.1488290073664461, 0.10342327931671702, 0.10200009300072865, 0.15081425981255958, 0.1828263933194949, 0.19538905562113018, 0.11161248050960038, 0.3957325068190196, 0.2100800020692717, 0.18189885316927934, 0.18294298597793646, 0.20727148191452338, 0.19501426168994562, 0.19746276672119734, 0.20211140827822505, 0.20267066628103703, 0.20486487028028122, 0.05666984950965703, 0.07781832974390779, 0.07817523278875527, 0.057307945053635345, 0.07473227331764143, 0.0784306562194319, 0.06069355122815401, 0.06164662987027736, 0.06984506590159112]}, "mutation_prompt": null}
{"id": "c1fdc8eb-a601-4857-80f6-23315d25265e", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "c3a1445b-73c8-4232-90d0-c6a2cb34885c", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "0d859bc3-0039-45ae-85ac-ff31d805d8e8", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "a379c659-176f-4f27-846a-51d9958ee5e2", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "0e0487b9-ffc7-455a-b36e-1e040b79a2ec", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "18b3e8d2-a34c-4faf-a536-554a08af0484", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "f4734d7a-2d60-492d-9eba-7e5786e50e15", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "6c3fc246-c2ee-4b5f-ac87-3ee4d305962f", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "34f4afdf-7b1f-4ec4-8a0c-36567a04274e", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "1b18c920-31d4-4d48-9906-c67c9d1b4e11", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n        self.elitism_decay = 0.2\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._hybrid_mutation(population[i], elite, population[a], population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._dynamic_subpop_merge(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _hybrid_mutation(self, target, elite, a, b, c):\n        random_choice = np.random.rand()\n        if random_choice < 0.5:\n            mutant = np.clip(target + self.mutation_factor * (a - b + elite - c), self.bounds[0], self.bounds[1])\n        else:\n            mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _dynamic_subpop_merge(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        elite_subpop = populations[sorted_indices[0]]\n        for idx in sorted_indices[1:]:\n            if np.random.rand() < self.elitism_decay:  # Adaptive elitism decay\n                populations[idx] = elite_subpop.copy()\n                fitness[idx] = np.array([func(ind) for ind in elite_subpop])", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with adaptive elitism, dynamic subpopulation restructuring, and hybrid mutation strategies.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {}, "mutation_prompt": null}
{"id": "26a0fe30-510d-4204-8f8d-480664ad6f2b", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.mutation_decay_rate = 0.2 # New adaptive mutation rate\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    self.mutation_factor = max(0.4, self.mutation_factor - (self.mutation_decay_rate * (self.evaluations / self.budget))) # Adaptive mutation\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._dynamic_merge_subpopulations(populations, fitness) # Improved merging strategy\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _dynamic_merge_subpopulations(self, populations, fitness): # Improved merging strategy\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        worst_idx = sorted_indices[-1]\n        best_idx = sorted_indices[0]\n        populations[worst_idx] = populations[best_idx] + np.random.normal(0, 0.1, populations[best_idx].shape)\n        fitness[worst_idx] = np.array([func(ind) for ind in populations[worst_idx]])", "name": "EHDEAP_MPD_Enhanced_Refined", "description": "Enhanced Differential Evolution with adaptive mutation rate, dynamic subpopulation management, and local search refinement for improved convergence.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {}, "mutation_prompt": null}
{"id": "97ecb556-21c3-4d83-8e6a-7b0088fa9003", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n        self.memory_size = 5\n        self.memory = []\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._memory_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                        self._update_memory(refined_trial)\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations_stochastic(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _memory_mutate(self, a, elite, b, c):\n        if self.memory:\n            memory_ref = self.memory[np.random.randint(len(self.memory))]\n            mutant = np.clip(a + self.mutation_factor * (elite - b + c - memory_ref), self.bounds[0], self.bounds[1])\n        else:\n            mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations_stochastic(self, populations, fitness):\n        best_half = np.argsort([f.min() for f in fitness])[:len(populations) // 2]\n        for i in range(len(populations)):\n            if np.random.rand() < 0.5:\n                selected_idx = np.random.choice(best_half)\n                populations[i] = populations[selected_idx]\n                fitness[i] = fitness[selected_idx]\n\n    def _update_memory(self, solution):\n        if len(self.memory) >= self.memory_size:\n            self.memory.pop(0)\n        self.memory.append(solution)", "name": "EHDEAP_MPD_Enhanced_v2", "description": "Enhanced Differential Evolution with adaptive memory-based mutation, dynamic crossover, and stochastic subpopulation regrouping.", "configspace": "", "generation": 87, "fitness": 0.22414756336780997, "feedback": "The algorithm EHDEAP_MPD_Enhanced_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.5677309606531441, 0.5688578019322263, 0.5037016676954269, 0.6369931389317396, 0.6492820005065707, 0.5739292380399974, 0.6351145844461833, 0.5369586082198574, 0.5797499933852908, 0.39027066252198783, 0.24799031228829704, 0.3171442501213464, 0.3922052796943616, 0.31987333127643636, 0.2772333714893105, 0.33439114666924885, 0.2873573433527611, 0.2568899677609081, 0.09521264663216766, 0.07825184246055594, 0.07556964655931064, 0.0941434323114676, 0.1178988624096079, 0.08658431471916594, 0.07147941745650022, 0.08463662148509776, 0.08000891080154293, 0.07171051981097065, 0.06988461049610595, 0.05725775347624262, 0.0851077138282541, 0.08592584971793227, 0.07684263430111282, 0.11766406357251435, 0.08072046791349496, 0.06431803485479737, 0.9517712451668114, 0.9287229963669634, 0.9190630247501199, 0.9477189543268594, 0.908873239800478, 0.9083237998368471, 0.9341123497750514, 0.9223857286895463, 0.9696797162778393, 0.2222591606470189, 0.21336357523063676, 0.2296067218354384, 0.31646057223702173, 0.24990592633172004, 0.24950679017587596, 0.3209092036943534, 0.31694103792506034, 0.25592811065114474, 0.20412754675867462, 0.357253676510618, 0.4280701950178135, 0.593439073108906, 0.41719510651505776, 0.39763102775839343, 0.49158066426131264, 0.5239863637451903, 0.494123176906464, 0.09324591541017913, 0.2472271348590771, 0.1397550927041986, 0.1843580135778079, 0.13471069577586992, 0.09676234676836215, 0.17324736069746327, 0.08527311942874771, 0.10958747922349521, 0.1493631396835512, 0.15953055142210015, 0.15037615242960878, 0.20534203893236946, 0.09658182310107644, 0.18099411098231566, 0.2749097737855224, 0.13140224169281733, 0.15083922356949697, 0.04255236022443443, 0.03562033873557413, 0.07023771002454071, 0.0458800271089953, 0.07509624659494274, 0.02384456495037013, 0.048725552426254426, 0.06907890505113867, 0.08944192987365718, 0.17637841627486883, 0.1956016892033916, 0.22254419664575065, 0.15648256787570136, 0.1845899915755057, 0.08449277015419521, 0.07610989154676628, 0.24700942025883033, 0.15318983368391814, 0.025810506890812213, 9.999999999998899e-05, 0.02854752383488779, 0.02054566946994474, 0.033856126019235266, 0.004032303352586641, 0.0239481348773124, 0.02740703016581192, 0.033307828956558705, 0.1264044100449191, 0.12384709989200016, 0.1229279151039746, 0.14628366796707337, 0.10364643649382144, 0.1372032570105044, 0.14136792594946856, 0.07560439431349064, 0.11861725547319635, 0.4088360093517265, 0.5057633584858306, 0.38073845821133645, 0.49829995926889314, 0.44109827351383035, 0.39456846370868925, 0.4719249483525818, 0.3801837273341584, 0.3928254910738629, 0.08752844808551219, 0.06498427994631872, 0.064005891553513, 0.07516664898835168, 0.0781119733435669, 0.07139622629494391, 0.07447690231989634, 0.07796521453371497, 0.0735080442477769, 0.14851882302642805, 0.1493436541827261, 0.1608917498827881, 0.14758184798611962, 0.1401548123228289, 0.14999952855360787, 0.1671873120396502, 0.20328992803541845, 0.13533715821485726, 0.24004679079003244, 0.2556192690101228, 0.2071093371827969, 0.20819749901190066, 0.2444058482050776, 0.21022552239157888, 0.28782469271471656, 0.2772654862890068, 0.24041392819602714, 0.18935907678494823, 0.1952836369220381, 0.20335206571328668, 0.18771016874312907, 0.18427528165238238, 0.1657938174561483, 0.1950134008546235, 0.1743730112829408, 0.19284859826282685, 0.19021225839753564, 0.17057145408876817, 0.16481691981572877, 0.16388412865892643, 0.1999892543837909, 0.1479668757676632, 0.1830723497108081, 0.18369764822968693, 0.16448558033022742, 0.15216181777026627, 0.14736813112755132, 0.16294351668880303, 0.26076628399486135, 0.18820429550834616, 0.14291015257101847, 0.15053102853602873, 0.17303864718046535, 0.1670976384843359, 0.1569229726434369, 0.15791156207978474, 0.1687232165342235, 0.16623048878175595, 0.16718844822906154, 0.16916109583463235, 0.17498291716135228, 0.12863573358352764, 0.16713166128480916, 0.12535311162935125, 0.16068348564524726, 0.15433227475931943, 0.1579059001453934, 0.182885369225956, 0.17136486012711283, 0.1202639554853111, 0.19760730434007456, 0.14096101499735336, 0.19638300514582108, 0.19020240019738344, 0.2005496654023483, 0.22375844204532336, 0.20929773720608347, 0.18067094550609364, 0.1811481659283709, 0.19492265234276995, 0.2161903319048385, 0.060824511935767434, 0.062297790994783275, 0.061975305050343765, 0.0607888891391567, 0.05772962290357775, 0.0580413474014263, 0.06326633800839643, 0.05747909785497196, 0.059909422262830914]}, "mutation_prompt": null}
{"id": "30306915-2fb0-49b2-82a0-d4768045a665", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "55dfb3ea-c328-4819-88d3-c6dd258338b0", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.adaptive_factor_min = 0.5\n        self.adaptive_factor_max = 1.0\n        self.merging_interval = 50  # Modified\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    self.mutation_factor = self._adaptive_mutation(fitness[s])  # Adaptive mutation\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        if subpopulations > 1:\n            selected_idx = sorted_indices[:len(sorted_indices)//2]  # Retain only the top half\n            populations = [populations[i] for i in selected_idx]\n            fitness = [fitness[i] for i in selected_idx]\n\n    def _adaptive_mutation(self, fitness):\n        fitness_range = fitness.max() - fitness.min()\n        if fitness_range > 0:\n            return self.adaptive_factor_min + ((self.adaptive_factor_max - self.adaptive_factor_min) * (fitness.min() / fitness_range))\n        return self.mutation_factor", "name": "EHDEAP_MPD_Enhanced_Refined", "description": "Improved EHDEAP_MPD_Enhanced by integrating adaptive mutation scaling and a convergence-based subpopulation merging strategy.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'subpopulations' is not defined\").", "error": "NameError(\"name 'subpopulations' is not defined\")", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {}, "mutation_prompt": null}
{"id": "03e1a4ca-3110-4c12-805e-6ea9fffa5333", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "c12925e0-f5b2-48dd-b8d9-ec4115db9eca", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Fuzzy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n        self.evaluations = 0\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = self._fuzzy_logic_crossover(fitness[s][i], fitness[s].mean())\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_flight_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_flight_search(self, trial, func):\n        step_size = np.random.standard_cauchy(self.dim)\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n\n    def _fuzzy_logic_crossover(self, fitness_i, fitness_mean):\n        improvement = max(0.01, fitness_mean - fitness_i)\n        return np.clip(0.9 - 0.5 * improvement, 0.1, 0.9)\n\n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Fuzzy", "description": "Enhanced Differential Evolution with adaptive population size, elite mutation using Levy flights, and adaptive crossover using Fuzzy Logic.", "configspace": "", "generation": 91, "fitness": 0.2777112048118249, "feedback": "The algorithm EHDEAP_MPD_Fuzzy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7922262431331377, 0.7765948690389115, 0.7714547501106419, 0.7562742256214785, 0.8121260780035616, 0.5576287139079583, 0.7989057515303589, 0.7885799535302395, 0.8029030425806062, 0.7506490556601506, 0.5809385532768467, 0.03765541819749629, 0.6485325822305924, 0.6321158650592102, 0.6966778303341266, 0.2214371169301098, 0.006134298154009454, 0.6751036481371662, 0.11787018787784198, 0.15660491531015108, 0.15260170525203243, 0.1134061570546897, 0.10898040456238922, 0.21344334675878152, 0.14877973014891666, 0.6862372932532618, 0.14041922062161483, 0.13070698919485635, 0.10105646064724982, 0.16441495721162447, 0.13053100696952646, 0.11475549538913798, 0.1356105593056205, 0.12065297077335313, 0.1149627528272642, 0.10060041150123233, 0.9920154870039372, 0.9488255054234831, 0.955158510238282, 0.9524675792021927, 0.9545800101382527, 0.9572292739999101, 0.965334714024523, 0.9724225173507677, 0.9531297828844811, 0.4543878225606097, 0.5263182172478286, 0.47361755949088924, 0.5194706569671597, 0.6000076207712663, 0.5226518765798089, 0.5712201776446442, 0.5105571044826684, 0.5148222393179839, 0.15959452217170855, 0.2892796947054975, 0.1660510153254452, 0.17383875312705843, 0.33616199569168226, 0.189505789788197, 0.19287359858514241, 0.21564203990222808, 0.3068699126410823, 0.16450145135644723, 0.4836543203350595, 0.22379549126544418, 0.2625574076803304, 0.21829110285173248, 0.12333446670604176, 0.5577121425537732, 0.19218329007076196, 0.19681784231144617, 0.02363327038323093, 0.1757820577444632, 0.2594095444291542, 0.33507076666560853, 0.19731732968698523, 0.23085364113171158, 0.22300734456543114, 0.23207146005969503, 0.11884215528475983, 0.05155997932297651, 0.01750459439707064, 0.009478403895962995, 0.05369186181883612, 0.006281519428873117, 9.999999999998899e-05, 9.999999999998899e-05, 0.05872774371516476, 0.06810664960708002, 0.22952383675703192, 0.04609198709065421, 0.0653189807629102, 0.08097296384353725, 0.07528096016883778, 0.05917294663529815, 0.04049399838613643, 0.02072427777831176, 0.13808813582457713, 0.036857219043343825, 0.11408098870118355, 0.11470466440100302, 0.06492546641366259, 0.11212952492479233, 9.999999999998899e-05, 0.06469356925662828, 0.23997709142415202, 0.08957142694606224, 0.10315383842449155, 0.21763207229062542, 0.12433585137632508, 0.14934993467264246, 0.23573358521261356, 0.24074857345185852, 0.13143929064542537, 0.21593747710681632, 0.1928987061098154, 0.496360404514831, 0.5378337127390167, 0.4431065644023793, 0.5101713932782961, 0.5254907936161821, 0.5432982227763903, 0.5484549404551173, 0.4740616910679776, 0.5395616156866831, 0.08973094914577484, 0.11318810985379346, 0.09785365917861566, 0.12984725170891398, 0.11597122514491875, 0.0973861082137113, 0.07469078750526004, 0.06411251055795841, 0.13910676753849416, 0.18740076193518684, 0.14486447003917036, 0.14941588757570368, 0.194477685860857, 0.1432598345856173, 0.15063740320647412, 0.1321855969940765, 0.18665640099111602, 0.16749335889258476, 0.1560048138185608, 0.2725481069982931, 0.24898097335863956, 0.27142144996936546, 0.29234230114508386, 0.22433943794056077, 0.2978063497356296, 0.42214192439904896, 0.3214396104543915, 0.16861480545657692, 0.3301906796968678, 0.2094641354505442, 0.16559328060722933, 0.24148842706785845, 0.18373649455043028, 0.2428438158838363, 0.24515679820732728, 0.25464716477064553, 0.1973800861138666, 0.17801920065390564, 0.15489427512649623, 0.16966576450376192, 0.1873728738097601, 0.18081067838587228, 0.181734391607136, 0.20053893997220174, 0.17365421581889073, 0.18061662901494824, 0.17192053981995847, 0.1614898614621172, 0.20213544439702547, 0.2373536197866397, 0.1799596028437438, 0.16779552828599664, 0.1921076032273552, 0.17979434047456633, 0.1785459826988678, 0.16325792839842002, 0.19012855431505127, 0.17194869349285236, 0.18271668797043017, 0.7376970652710799, 0.18184461796527585, 0.1874169596880989, 0.8291224863717074, 0.7701904782744197, 0.20269323820084906, 0.19817313579495854, 0.1620969925585558, 0.7390577929713457, 0.1629345260829972, 0.19329072632706357, 0.2816784378606628, 0.20348455187325676, 0.18789698709723934, 0.19270246079891407, 0.17873027364554417, 0.17019356867007573, 0.16948256263911388, 0.18734425252359377, 0.1748604545744874, 0.16368926584183952, 0.20113551090406212, 0.09531141048389713, 0.06676977214395341, 0.08033961825082536, 0.06358408466164278, 0.07242039636392095, 0.06501255942607931, 0.06837113413094142, 0.07640663874330944, 0.0725384177789623]}, "mutation_prompt": null}
{"id": "165ea58b-0c96-4d17-aafd-78c2e48de95c", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.2  # adjusted elite fraction\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite_idx = np.random.choice(elite_indices, p=self._softmax_selection(fitness[s][elite_indices]))\n                    elite = population[elite_idx]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n                    elif np.random.rand() < 0.1:  # Stochastic tournament replacement\n                        population[i] = self._initialize_population()[0]  # reinitialize randomly selected solutions\n                        fitness[s][i] = func(population[i])\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]\n\n    def _softmax_selection(self, fitness):\n        max_fitness = np.max(fitness)\n        exp_fitness = np.exp(max_fitness - fitness)\n        return exp_fitness / exp_fitness.sum()", "name": "EHDEAP_MPD_Enhanced_Refined", "description": "Enhanced Differential Evolution with adaptive elite selection, stochastic tournament replacement, and reinitialization for diversity preservation.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {}, "mutation_prompt": null}
{"id": "d533adb9-35d4-4220-9315-1a4b2ca06ea8", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "b2d44940-9d7b-4c85-be5d-d0d091738cf9", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "5bd13589-4744-4c21-8b13-cc5e40f2c234", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "50fab50a-d391-4ff7-8f47-e95a9e0f17f6", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n        self.dynamic_elite_selection_prob = 0.8\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n\n                    if np.random.rand() < self.dynamic_elite_selection_prob:\n                        a, b, c = np.random.choice(indices, 3, replace=False)\n                        mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n                    else:\n                        candidates = np.random.choice(elite_indices, 2, replace=False)\n                        mutant = self._cluster_mutate(population[i], population[candidates[0]], population[candidates[1]])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _cluster_mutate(self, target, elite1, elite2):\n        step = self.mutation_factor * (elite1 - elite2)\n        return np.clip(target + step, self.bounds[0], self.bounds[1])\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Improved", "description": "Enhanced Differential Evolution with adaptive clustering, improved mutation strategies, and multi-elite selection for diversity.", "configspace": "", "generation": 96, "fitness": 0.2945739466840498, "feedback": "The algorithm EHDEAP_MPD_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7424469324116132, 0.7510665706381615, 0.7815619658420256, 0.7911686035117312, 0.8112658314889543, 0.8010655658753252, 0.7817837503094289, 0.8025386669182739, 0.7596110282886996, 0.6338825135373268, 0.6279316674803157, 0.5438740697564213, 0.5725415462090622, 0.5930512475122083, 0.6166559100919311, 0.5827760188322058, 0.648250933061251, 0.6074149740886832, 0.06917975122503683, 0.12402041072712144, 0.13504255388154907, 0.14505448823194178, 0.06989423485645418, 0.11095646492567501, 0.13199915118447336, 0.11512662409998242, 0.13385066824598324, 0.12635750179472394, 0.10579733019789272, 0.08614498785689251, 0.10316937703048767, 0.03851006975809501, 0.10435219942577711, 0.11020864236801409, 0.12925433295782984, 0.1391038828633544, 0.9550975624644197, 0.8919204430974804, 0.9572676990100132, 0.9024419999857691, 0.9321031668929741, 0.9751017030871137, 0.9592188142260294, 0.9414229083284231, 0.9525211042702597, 0.5834718662815856, 0.47358174496211736, 0.4639654398341472, 0.4326843054298082, 0.6201828034575008, 0.477642070922373, 0.5402851931098898, 0.4543633667671073, 0.5017695027726969, 0.23860563269518953, 0.1529235808752234, 0.10993132990221166, 0.6956773360977443, 0.2675139106870076, 0.14726929834246205, 0.20698879687096616, 0.18819744535109273, 0.22257601291049545, 0.1206472713742891, 0.3664900011584321, 0.39557612169543965, 0.22007124502501862, 0.3052048500664527, 0.4007888333141151, 0.10972964548707498, 0.28811942653994893, 0.4038904797794879, 0.6157269673268707, 0.37786973809579427, 0.3605059517769844, 0.5678847196554797, 0.2794187887699717, 0.34227576928444803, 0.24068500651534053, 0.33000047812630195, 0.4141636146606922, 0.07233213566161723, 0.2027664974882568, 0.09957981614025935, 0.09588564922894416, 0.04838883879723255, 0.08863797611788082, 0.08904466107950826, 0.21849778354775928, 0.05197006068383103, 0.09351680465756196, 0.19851791674730002, 0.10253888025539348, 0.2558467988059614, 0.06160877509230467, 0.11283854431830131, 0.3045132262445679, 0.06767610698500814, 0.3560967285896325, 0.058258769106835695, 0.1648637925719746, 0.05738808917072491, 0.07118016602632893, 0.07750818386108604, 0.08332757889721665, 0.1884331666304041, 0.06753940679142034, 0.13301685475678582, 0.18626459111664362, 0.29619871230116857, 0.2682374369556745, 0.23347918382673238, 0.2558583977866823, 0.22518843627550944, 0.17473252501225323, 0.20735989370786, 0.18781191605974157, 0.5028509549395086, 0.6041985591487873, 0.5025099188314146, 0.5874633149856641, 0.5373700547994935, 0.58554657808551, 0.5746339624589396, 0.499161534404868, 0.6201479261733022, 0.06876987925214761, 0.06861357694846815, 0.08299195263448322, 0.07689035474184525, 0.06220665456921415, 0.07625685048822328, 0.07597682911075387, 0.1085617305163118, 0.11281943039702147, 0.19985240914682523, 0.20363434980943862, 0.1370567282853712, 0.2301342756332756, 0.2593451970304955, 0.19758586431596803, 0.23629819525792917, 0.20166247127681736, 0.22563331083861615, 0.346990886261879, 0.1360003759518702, 0.2090563722271328, 0.3740982652691076, 0.16587089475298344, 0.28442070067957104, 0.32744390884666574, 0.27143816029395307, 0.2001009753611438, 0.3049896664249061, 0.13774568855901193, 0.2717933885655123, 0.2916575126504496, 0.15683372731815803, 0.2829467986058789, 0.21952967999160533, 0.266402210993561, 0.18630621015636384, 0.20459348098784014, 0.2513963258932522, 0.17285369712899978, 0.2069163964365469, 0.18606874521705363, 0.2365145757667816, 0.22880309128059462, 0.2099493992296969, 0.1879127282671419, 0.18178441403223367, 0.18605718324648568, 0.16906276179696345, 0.19196721386374915, 0.17666425604142644, 0.5125995240023299, 0.20788011614739854, 0.17612901925981128, 0.22305247330693911, 0.18180116002703106, 0.16497022525324956, 0.16443168009824727, 0.17827140099149952, 0.18408264776321626, 0.17674161626690243, 0.15924264472747074, 0.14319025933800167, 0.1538483300757567, 0.19765027200297136, 0.1525930164620004, 0.16373455230876044, 0.6583917623885901, 0.1437205971796962, 0.14358616153879034, 0.20188621028374587, 0.20728070539282728, 0.19349633673409428, 0.2450359595450271, 0.19640729728879658, 0.3425387048376475, 0.21721376402795545, 0.2029224529235365, 0.1955367996030427, 0.19926806900902072, 0.20202095315949664, 0.26161515002974134, 0.09079256885890497, 0.07519766953562723, 0.06475494703585938, 0.08282142892923916, 0.0723753872982128, 0.09121315824627219, 0.08496437537108503, 0.099861349120555, 0.08492046514067608]}, "mutation_prompt": null}
{"id": "17a79314-eae4-46d3-92f8-605d790371f0", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
{"id": "49e8b561-200f-486c-90d3-97fdf6fc0c37", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.base_mutation_factor = 0.5  # Adjusted mutation factor\n        self.crossover_prob = 0.9\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    current_mutation_factor = self._adaptive_mutation_factor(fitness[s][i], np.mean(fitness[s]))\n\n                    mutant = self._mutate(population[a], elite, population[b], population[c], current_mutation_factor)\n                    \n                    trial = self._crossover(population[i], mutant)\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = trial\n                        fitness[s][i] = trial_fitness\n\n                    trial_fitness = min(trial_fitness, self._multi_trial_search(trial, func, fitness[s][i]))\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _mutate(self, a, elite, b, c, mutation_factor):\n        mutant = np.clip(a + mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_mutation_factor(self, current_fitness, mean_fitness):\n        return self.base_mutation_factor + 0.5 * (1 - np.exp(-np.abs(current_fitness - mean_fitness)))\n\n    def _multi_trial_search(self, trial, func, current_fitness):\n        best_fitness = current_fitness\n        for _ in range(3):\n            perturbed_trial = self._perturb(trial)\n            fitness = func(perturbed_trial)\n            self.evaluations += 1\n            if fitness < best_fitness:\n                best_fitness = fitness\n        return best_fitness\n\n    def _perturb(self, solution):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(solution + perturbation, self.bounds[0], self.bounds[1])\n\n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Improved EHDEAP_MPD with adaptive mutation factor and multi-trial evaluation strategy to enhance convergence and diversity.", "configspace": "", "generation": 98, "fitness": 0.16615692256400164, "feedback": "The algorithm EHDEAP_MPD_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.20.", "error": "", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.42181158745773606, 0.29166102527925464, 0.29311395195305767, 0.32574438533407135, 0.20158460728519134, 0.19201243201029083, 0.6982889603552054, 0.640600290645458, 0.1784597480319544, 9.999999999998899e-05, 9.999999999998899e-05, 0.026774352018750558, 9.999999999998899e-05, 0.018366505057592075, 9.999999999998899e-05, 0.016532607529492482, 0.07265242576803399, 0.02689459830239449, 0.10303171441461567, 0.035462579589128684, 0.06755987599887614, 0.0437056725426912, 0.053777848556270325, 0.1332307962919338, 0.08036766503546611, 0.09558445741797628, 0.11570825302486487, 0.055170101176265196, 0.12091388046158824, 0.11325152849042985, 0.060009962225968216, 0.10954796085787188, 0.10147209252885003, 0.11449113541364841, 0.0850234644941178, 0.062323686774277354, 0.9297045882260851, 0.9717035465173135, 0.9640334237622896, 0.9524304239046499, 0.9572495788291457, 0.9680603392925775, 0.9607914295210168, 0.9463192876349794, 0.9711724970741035, 0.10570434632593517, 0.055590137475716395, 0.12981538833823347, 0.10646399355247049, 0.08333125083439663, 0.241785472031267, 0.08169570923012703, 0.05749314001263306, 0.08608643289740758, 0.31962692222807054, 0.173036971387041, 0.1151746974066149, 0.18340694203335994, 0.19456638747798327, 0.08565096609904521, 0.13616915799470775, 0.347901282259106, 0.10476896259938617, 0.02061024607193973, 9.999999999998899e-05, 0.10850067459093238, 0.03816851384266717, 0.10626060002319393, 0.047905987703646846, 0.0778391652779139, 0.11833252764907343, 0.10384125758201257, 9.999999999998899e-05, 0.02782505723376527, 0.02758162864416247, 0.1606218833052937, 9.999999999998899e-05, 0.028468025385298135, 0.06983876980469228, 0.031929188064558356, 0.1026589899654331, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05629292238018624, 0.047155953519949945, 0.08640360338300124, 0.02264255916613822, 0.05268111110874907, 0.019699894805248697, 0.0426832337478974, 0.052115649668784125, 0.05040199501296916, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18892019262448412, 9.999999999998899e-05, 0.06763507093782828, 0.0008107832777617396, 0.043089630036393656, 0.02456789290073136, 0.04671005968511366, 0.3834175936033257, 0.3518706346892524, 0.3718802593716811, 0.4026896062781653, 0.18911193183759822, 0.3941694880027786, 0.41025486781346077, 0.2698016504345342, 0.4746653391045881, 0.05464095641150657, 0.10347288387258924, 0.08630598758519192, 0.052768246278729, 0.05439285860052101, 0.08811841779934582, 0.09445756690359508, 0.08474280523099065, 0.07520570883193356, 0.19127391542137606, 0.25377040174752596, 0.16475632246815808, 0.14202517312054463, 0.1469731633556557, 0.14346843381773322, 0.18232119571869598, 0.11173574509534812, 0.1348956524667274, 0.2574933692978363, 0.2485317534653565, 0.34691830020572767, 0.22113382693903705, 0.28715961318535344, 0.26617547403922703, 0.3247285826960695, 0.18932121693845672, 0.24070573056077182, 0.1838653048046608, 0.1794203732604447, 0.16154681584785868, 0.11910790315400466, 0.2282169728190745, 0.14338520124838672, 0.18874258378954578, 0.14106301934270227, 0.1399377032338096, 0.20067284737896218, 0.21861379037781115, 0.17593082659756232, 0.21745847160581877, 0.20920562881531235, 0.19132185876876007, 0.23360328206469017, 0.19118930586144645, 0.1773804275205253, 0.14340045662580592, 0.19004740722347047, 0.15491992872607208, 0.20649835264745375, 0.18548078780075827, 0.193173525419172, 0.148881039284687, 0.14378199434174455, 0.18768883026432082, 0.1375826048624753, 0.14988297745698198, 0.1143007148761449, 0.15681841490301263, 0.19539554642483414, 0.16218202066812282, 0.10758819399140052, 0.16313407765639132, 0.1528388682595545, 0.15685032769144858, 0.15204455165567832, 0.16023567449214438, 0.2849522721220752, 0.21134850475399758, 0.11393557670845333, 0.11174121534755055, 0.11604389642574875, 0.1838962774524585, 0.1954292318707921, 0.18438344415976882, 0.18911237694401062, 0.18680956960890138, 0.192858387368674, 0.1910242696938934, 0.18631502604454842, 0.18698577489703783, 0.21010065092542818, 0.056744309398273796, 0.08145968379252921, 0.0696790947448358, 0.05940131599753007, 0.058210723751010884, 0.10706550034044537, 0.062756852545645, 0.060577224162248755, 0.07046431514724938]}, "mutation_prompt": null}
{"id": "f04091df-e260-454b-bdf3-bc6dda6f9124", "solution": "import numpy as np\n\nclass EHDEAP_MPD_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_subpopulations = 5\n        self.subpop_size = (12 * dim) // self.initial_subpopulations\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.base_crossover_prob = 0.9\n        self.crossover_decay_rate = 0.1\n        self.evaluations = 0\n        self.elite_fraction = 0.3\n        self.merging_interval = 100\n\n    def __call__(self, func):\n        subpopulations = self.initial_subpopulations\n        populations = [self._initialize_population() for _ in range(subpopulations)]\n        fitness = [np.array([func(ind) for ind in pop]) for pop in populations]\n        self.evaluations += self.subpop_size * subpopulations\n\n        while self.evaluations < self.budget:\n            for s, population in enumerate(populations):\n                if self.evaluations >= self.budget:\n                    break\n                for i in range(self.subpop_size):\n                    if self.evaluations >= self.budget:\n                        break\n\n                    elite_indices = np.argsort(fitness[s])[:int(self.elite_fraction * self.subpop_size)]\n                    elite = population[np.random.choice(elite_indices)]\n                    indices = list(range(self.subpop_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self._elite_mutate(population[a], elite, population[b], population[c])\n\n                    self.crossover_prob = max(0.1, self.base_crossover_prob - (self.crossover_decay_rate * (self.evaluations / self.budget)))\n                    trial = self._crossover(population[i], mutant)\n\n                    refined_trial = self._levy_local_search(trial, func)\n\n                    trial_fitness = func(refined_trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < fitness[s][i]:\n                        population[i] = refined_trial\n                        fitness[s][i] = trial_fitness\n\n                if self.evaluations % self.merging_interval == 0:\n                    self._merge_subpopulations(populations, fitness)\n\n            if subpopulations > 1 and self.evaluations % (5 * self.merging_interval) == 0:\n                subpopulations = max(1, subpopulations // 2)\n                populations = populations[:subpopulations]\n                fitness = fitness[:subpopulations]\n\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_subpop = populations[best_idx]\n        best_fit_idx = np.argmin(fitness[best_idx])\n        return best_subpop[best_fit_idx]\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.subpop_size, self.dim))\n\n    def _elite_mutate(self, a, elite, b, c):\n        mutant = np.clip(a + self.mutation_factor * (elite - b + b - c), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _levy_local_search(self, trial, func):\n        alpha = 0.02\n        step_size = alpha * np.random.normal(0, 1, self.dim) / (np.abs(np.random.normal(0, 1, self.dim)) ** (1 / 3))\n        local_best = np.clip(trial + step_size, self.bounds[0], self.bounds[1])\n        local_best_fitness = func(local_best)\n        self.evaluations += 1\n        if local_best_fitness < func(trial):\n            return local_best\n        return trial\n    \n    def _merge_subpopulations(self, populations, fitness):\n        subpop_fitness = np.array([f.mean() for f in fitness])\n        sorted_indices = np.argsort(subpop_fitness)\n        half = len(sorted_indices) // 2\n        for i in range(half, len(sorted_indices)):\n            selected_idx = np.random.choice(sorted_indices[:half])\n            populations[sorted_indices[i]] = populations[selected_idx]\n            fitness[sorted_indices[i]] = fitness[selected_idx]", "name": "EHDEAP_MPD_Enhanced", "description": "Enhanced Differential Evolution with self-adaptive population size, elite-enhanced mutation, and dynamic adaptive crossover.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1c1ef90-1791-4ff6-8880-728ee570dad7", "metadata": {"aucs": [0.7587239956616378, 0.8002037516043431, 0.8017401002616914, 0.7961777003352999, 0.776175219537386, 0.8299858911890459, 0.7836237821676709, 0.8126328490209755, 0.8188525621148645, 0.6516535931691101, 0.6195073773905604, 0.6244225844255379, 0.523529400164773, 0.6244908226307793, 0.6468718853118468, 0.44236496343443876, 0.7066137767448891, 0.0489926470995552, 0.05750004625911442, 0.12573235250739767, 0.11192016205909405, 0.06894543634377481, 0.11940441589633577, 0.10402506089901054, 0.14745074529057767, 0.0943053918762875, 0.052391899380067164, 0.08671475062702427, 0.12656919727734384, 0.11137590882001402, 0.07880799654362358, 0.07925847965270028, 0.13118508614385116, 0.10691965191646546, 0.08009465402024141, 0.13852141527373152, 0.9514783469518969, 0.919336863823208, 0.955669725246296, 0.952546747655257, 0.9596562524597531, 0.9440475754140571, 0.9726870762136471, 0.9500652731788052, 0.9625443221262203, 0.551078698680235, 0.5697629027650839, 0.5365498120285934, 0.4837269926810319, 0.5013833166091434, 0.5427525123012054, 0.5998706623157828, 0.5488429509143886, 0.5220410095944292, 0.23764112701995765, 0.09302941239313334, 0.08452901788155032, 0.2645032878165646, 0.176366897297916, 0.2476471602939182, 0.204076765934314, 0.8017300321075403, 0.7647802339036947, 0.5530270090907028, 0.12196370213692176, 0.39548093543836993, 0.47035800329729105, 0.12422969648578275, 0.12108711105848324, 0.5408364058679563, 0.3397248611980984, 0.46066527057572393, 0.3014920151950786, 0.17400944918601158, 0.30640714558734417, 0.26736028329055106, 0.4339944214231751, 0.38001219993226487, 0.3676036859602354, 0.34745348805324205, 0.29524123252764933, 0.06475835857600887, 0.12243263403730253, 0.07234874699422777, 0.06159006437140635, 0.07703123946811252, 0.10605148282382748, 0.07813187561488344, 0.013905959822841929, 0.040534328948221066, 0.08979397543174694, 0.22832524463811166, 0.23245431986997533, 0.1206447128317808, 0.22716987909727115, 0.07745715507283057, 0.1288093846207803, 0.2868059237514059, 0.2598645541685054, 0.06085000263692841, 0.07569763295342258, 0.09849883647831614, 0.09144126906417427, 0.1459373371602487, 0.10873769435668601, 0.12285809420059901, 0.09466976829307461, 0.0909391012159716, 0.22266088445580212, 0.1737426522544243, 0.18828132569883815, 0.2737817079097754, 0.22955596829474278, 0.2912996924889175, 0.23812305551859136, 0.21300583096967007, 0.14739951796361073, 0.6842933424193204, 0.5889374101227105, 0.5697926738985852, 0.5085043074768643, 0.5630403272900213, 0.5950354934255646, 0.5382801217922897, 0.50608610339749, 0.5807039429151277, 0.14432647247784713, 0.07437027428720233, 0.08649713683499682, 0.10915646994094408, 0.05296833343106533, 0.1091092836858445, 0.11220334159719147, 0.14999387616691273, 0.17198167610019122, 0.15276622655795158, 0.37558434019348175, 0.1537285887082559, 0.22028122634049507, 0.14396621515221708, 0.1438125045593015, 0.18675306163452288, 0.14429413509072675, 0.13172074849064297, 0.17654871356969393, 0.3118880624119943, 0.21134321282903967, 0.25300484690377156, 0.13615276594923853, 0.3805564197077892, 0.3963009056421981, 0.21373305116556396, 0.38169843845912144, 0.28078409974533447, 0.21610041442007677, 0.1845564044986645, 0.2397433993062592, 0.27605331896518104, 0.18907616857871323, 0.3004133772206823, 0.24022460974463078, 0.1923273914724265, 0.1956794956177994, 0.22105310811930845, 0.21580429390992972, 0.2879380981259543, 0.2030069811507027, 0.1525379782074444, 0.17967175026456994, 0.18017670295839894, 0.17296683339551855, 0.20380015425118836, 0.18465219816195888, 0.1752678529966737, 0.1993200563309595, 0.19727695725108108, 0.19065656907734707, 0.18499610221827678, 0.1885270762506306, 0.18001919346417783, 0.17738952473454683, 0.17801231246413518, 0.8379780216382431, 0.16421797510460256, 0.819480525706416, 0.15641577348974256, 0.1388175275349015, 0.12481632200091586, 0.14346009960001826, 0.7681185904289625, 0.7137761621074001, 0.7186069291529993, 0.16104726393860713, 0.19909787667943146, 0.12487358990745434, 0.20648775693802124, 0.7499288630773973, 0.8436900264423671, 0.24608646241747756, 0.23886323348960536, 0.19415426765628052, 0.1647230019060626, 0.21404440669505997, 0.18994564240391987, 0.2638697247834889, 0.2460737336254879, 0.19131718576373447, 0.06706383046402009, 0.094124143688328, 0.08805740887117697, 0.09169166292694064, 0.07938742755331529, 0.09617912635683401, 0.08210863206940089, 0.09006235226782233, 0.08266774228168705]}, "mutation_prompt": null}
