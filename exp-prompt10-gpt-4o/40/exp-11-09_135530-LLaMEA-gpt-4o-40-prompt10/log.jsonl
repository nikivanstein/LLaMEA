{"id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 0, "fitness": 0.35841917272604157, "feedback": "The algorithm SwarmBasedAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": null, "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "0edcaa71-1467-431c-a652-ec4f6497cee8", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "8adfc1a9-f523-40e4-8ff8-87c0c7eb82b9", "solution": "import numpy as np\n\nclass QuantumSwarmCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.7  # Increased cognitive component\n        self.c2 = 1.3  # Reduced social component\n        self.w = 0.4  # Reduced inertia weight\n        self.alpha = 0.6  # Increased crossover rate\n        self.quantum_factor = 0.1  # Quantum-inspired exploration\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def quantum_update(self, particle, best_position):\n        delta = np.random.uniform(-self.quantum_factor, self.quantum_factor, self.dim)\n        return np.clip(particle + delta * (best_position - particle), self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.quantum_update(particles[i], global_best_position)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "QuantumSwarmCrossover", "description": "Quantum Swarm Crossover (QSC) integrates quantum-inspired exploration with adaptive crossover to enhance convergence speed and maintain diversity.", "configspace": "", "generation": 2, "fitness": 0.35183300817384083, "feedback": "The algorithm QuantumSwarmCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.8792283784526467, 0.8771286760186869, 0.8910561624191671, 0.8877405620967367, 0.8783335080411988, 0.8738566398087175, 0.8840825203070019, 0.8667530904955605, 0.8925696096627772, 0.6590737071125097, 0.6887676094411475, 0.5189944388741676, 0.5701129647011602, 0.6952932286117541, 0.07857688241428207, 0.43387985029653686, 0.6281186264165011, 0.7310946988813312, 0.13174058266074384, 0.182533899079793, 0.1600739963314901, 0.09605568648966833, 0.15860928995623147, 0.12044037385347606, 0.15802034456181158, 0.18589302805446795, 0.14334726318520985, 0.14027304889603853, 0.11015528536677355, 0.11307023771633662, 0.11085544628577448, 0.10715897620022186, 0.11427106134165965, 0.11608046853008813, 0.12205163071204583, 0.09962371454610053, 0.9616470014511902, 0.9789926294395911, 0.9765252886220944, 0.9602032735808754, 0.9825113868234697, 0.9696727400304973, 0.9630733494564273, 0.9664566535029928, 0.9612765611327027, 0.7516541138496828, 0.6346641340629318, 0.6680909550357881, 0.5796713613276209, 0.6730853504777092, 0.6410444297260072, 0.728648948859659, 0.6060179156543732, 0.5819703445730577, 0.226285686543944, 0.35068873886720986, 0.38863237794689, 0.2223766752192181, 0.3500168906483847, 0.21819493835734072, 0.12956632151682734, 0.23671152077235702, 0.4049099415543924, 0.7429265778646433, 0.6444288154708386, 0.30273818768640626, 0.16466680429081493, 0.13201395100358637, 0.2433677909747144, 0.6001602625636803, 0.6322971087391758, 0.3367143755659424, 0.48102057478639626, 0.24467142925291496, 0.6569961609551258, 0.4722339415715545, 0.6671796916391773, 0.2546111927065374, 0.2244597597127912, 0.3305903158042579, 0.3418795533579714, 9.999999999998899e-05, 0.1924029104113404, 9.999999999998899e-05, 0.038984496977931826, 0.05089332645225619, 9.999999999998899e-05, 0.09123219969197527, 0.06305600947434009, 0.24965231488624506, 0.07851469383428122, 0.09466526476600867, 0.12246004490247653, 0.08153143690079201, 0.03651627846859029, 0.0826084255255557, 0.05606974167058165, 0.07897356592816762, 0.10271664871268638, 0.14170976157874537, 0.09568261833503255, 0.0886065371548368, 0.12470417256833954, 0.15793199936360558, 0.16652943344632054, 0.2226625280542417, 0.131831567948699, 0.2193907431859783, 0.42769192471233364, 0.27762620263412363, 0.18739080225307247, 0.26411157994825984, 0.1533386086862092, 0.2564036720937888, 0.16085626578220313, 0.25137249297370867, 0.0883118861122133, 0.5941024624621942, 0.6048419867391163, 0.6295695807742057, 0.5567067679201055, 0.5848376648653337, 0.6419356340729483, 0.6579850897872896, 0.6431289690019465, 0.572266673005011, 0.0892147885829081, 0.11273977746553532, 0.12374708678382773, 0.08369469737634594, 0.09283834232823152, 0.13328272371594596, 0.1399770875234797, 0.144098771458247, 0.09985299305767603, 0.1940708091300608, 0.21829885712535346, 0.1917511543477387, 0.20242778217551394, 0.5746505303152791, 0.15706867672685532, 0.6111424503184365, 0.333322338796746, 0.18633432571906383, 0.24506536912220267, 0.43665270846722337, 0.2944957856556233, 0.3133846774923883, 0.35507776586229733, 0.597670897222078, 0.2669917218345397, 0.4665696230182048, 0.2678068450522262, 0.19452136128715292, 0.2705126719762774, 0.289444610027244, 0.2755245805532076, 0.22385067495974875, 0.31403217278618145, 0.26122782907426423, 0.32138017772678706, 0.2673757399258496, 0.2880784770396928, 0.2653355576999413, 0.23944663147689704, 0.24928798365018, 0.2139245918000957, 0.28119691572718597, 0.24764165185586495, 0.214602975507021, 0.22823539467795273, 0.20909556779451355, 0.17843408055188703, 0.19011854664298777, 0.18142421010555831, 0.20938075410218604, 0.2075650699616427, 0.20992086278226807, 0.2242071609197286, 0.21030423795084074, 0.18762663331027285, 0.1869438482430681, 0.18555738336053595, 0.9120935124785023, 0.19999053984671256, 0.20031659667931923, 0.14298645547207356, 0.9066435654025368, 0.9037126681058852, 0.9157401643237904, 0.2128554024725493, 0.8322252135493682, 0.8026914077908757, 0.16792693168139505, 0.15126029512998962, 0.8754191430485555, 0.8142123775036683, 0.8711740898573807, 0.24972051175418286, 0.2201113554925903, 0.2098359731919801, 0.18892201815330334, 0.20945750046324607, 0.18901879181662307, 0.2571535620469696, 0.20762411137621972, 0.24182969557158263, 0.09569456461353965, 0.11727934452288957, 0.10100764758926672, 0.09865341688228213, 0.10464209763798915, 0.11238319627761517, 0.1105621460321865, 0.09993985605045652, 0.10185217772036959]}, "mutation_prompt": null}
{"id": "2babbfa5-d157-47c2-8bcb-d0b44b3f7c9a", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "72c3cac8-5d2a-4525-ad42-bdf45d5154ef", "solution": "import numpy as np\n\nclass QuantumInspiredSwarmAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 2.0  # Increased cognitive component\n        self.c2 = 2.0  # Increased social component\n        self.w = 0.4  # Reduced inertia weight for faster convergence\n        self.alpha = 0.6  # Enhanced crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def quantum_update(self, position, best_position):\n        quantum_prob = 0.1  # Quantum probability factor\n        for d in range(self.dim):\n            if np.random.rand() < quantum_prob:\n                position[d] += np.random.normal(0, abs(best_position[d] - position[d]))\n        return position\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Apply quantum-inspired updates\n            for i in range(self.population_size):\n                particles[i] = self.quantum_update(particles[i], global_best_position)\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "QuantumInspiredSwarmAdaptiveCrossover", "description": "Quantum-Inspired Swarm-based Adaptive Crossover (QSAC) integrates quantum-inspired position updates with swarm intelligence and adaptive crossover for enhanced convergence speed and exploration in continuous optimization.", "configspace": "", "generation": 4, "fitness": 0.33469760844878715, "feedback": "The algorithm QuantumInspiredSwarmAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.8023206028474927, 0.7914242308909499, 0.7984496973565725, 0.8442180543404131, 0.8230799527827487, 0.8716091255716357, 0.8152516263156561, 0.8587276471120173, 0.819368562946349, 0.5775471941858675, 0.5847213189400577, 0.5704625438675897, 0.5961159271490998, 0.6029173368612919, 0.6306004840275987, 0.6081607223314665, 0.5797415082655354, 0.5998865045813706, 0.1412506281755035, 0.17676442903748069, 0.15813939684083256, 0.18190786663587655, 0.14006004835540242, 0.15874636240898377, 0.16153954192442632, 0.6905466515677402, 0.6499227670685519, 0.12094550100022083, 0.07954617235766037, 0.09479332913614458, 0.11561207285127983, 0.10910236114550531, 0.10886874429504456, 0.12238545984042482, 0.10437541467223133, 0.11261917619517658, 0.9852773711470066, 0.9842027000056089, 0.9847580938829146, 0.9714929065810013, 0.9846090452042742, 0.9779618371568473, 0.9846635644421299, 0.9712177599935989, 0.9719671773550117, 0.5461480441841224, 0.4849729569794089, 0.4891063572519948, 0.49386600101790334, 0.43291238089519035, 0.511258721940639, 0.557750287165206, 0.4167767593926016, 0.5132905681571791, 0.34159623820043283, 0.67245659700286, 0.34632217859056724, 0.27972849049565196, 0.6000227222629961, 0.2735754459215207, 0.7382391668041071, 0.3394843636785565, 0.2329301473408536, 0.4818679708254926, 0.13163707611177689, 0.13247853133463305, 0.11517042661385735, 0.2204975234819606, 0.21071564941579413, 0.25148867459635327, 0.36189523647899713, 0.23536617954058514, 0.27208560489158395, 0.224091070365949, 0.2218037517523973, 0.6084870600196757, 0.31495770798679645, 0.23778574505429828, 0.29028325012746314, 0.2247098641812142, 0.26939252375179223, 0.07408385142454443, 0.10213859379238, 0.06502931398080924, 0.040010732377722014, 0.0032887411181474757, 0.023620416716658488, 0.042953857227441605, 0.08541975521221645, 0.13661982420007157, 0.13767795271473748, 0.1607019004582273, 0.24619877649112865, 0.07654967282218572, 0.1096116934480238, 0.05148003473612839, 0.09536485381610305, 0.11322294841927016, 0.03776535242316037, 0.10716945704229963, 0.11758820045379303, 0.2595827932974244, 0.1228537768300082, 0.08233467348598611, 0.09759462505447991, 0.15630763513896784, 0.17981965329962057, 0.14935708540391113, 0.25959362057433744, 0.14461873226067856, 0.14339153703660812, 0.025751792376122462, 0.20302295777850488, 0.13623362873876488, 0.13953968519934512, 0.0696792444132529, 0.0894659877181524, 0.561239939258295, 0.5936918334940824, 0.5401462731913527, 0.5277280217276628, 0.5086309807599052, 0.5837150155202014, 0.5592379622217163, 0.556830882044852, 0.5863074519447542, 0.10747739058048411, 0.11971047335457696, 0.11276077833630993, 0.14024325581903008, 0.12318058605979854, 0.18412915873851365, 0.0936303753519685, 0.12142271200538912, 0.18429663352157188, 0.326256067084264, 0.2141567158614689, 0.1734166385383643, 0.5488452337764449, 0.2862428752999071, 0.2588467214973684, 0.17975483238364687, 0.1744659180748349, 0.23432050635073565, 0.22861114412582062, 0.3193520971269871, 0.33534060975252356, 0.28936374509588303, 0.3671591550916784, 0.3504502040155072, 0.40743825554031765, 0.3974608889362453, 0.2721332013755594, 0.2004811728682685, 0.18151626941278587, 0.29468069019776, 0.25875801654569863, 0.27913350357101785, 0.4593529509133295, 0.1681772456930597, 0.1975243155202605, 0.1846282084607398, 0.2219193197528364, 0.34145798346063005, 0.26357303630290685, 0.21967031474490173, 0.2461236971506272, 0.22372655205970615, 0.21285592285100718, 0.20824251501710778, 0.250512851092099, 0.6139477770015322, 0.206767868133804, 0.222310533240216, 0.20926233033112507, 0.17137281089261047, 0.18871153340947044, 0.18444227590530926, 0.229354385720833, 0.21896599433102493, 0.8700487563370545, 0.1859109735418737, 0.15313971454198105, 0.8609997599964239, 0.7185502148274007, 0.19961924702962774, 0.14283078683856398, 0.8793162144653078, 0.8627636380680093, 0.8208195422552017, 0.21233008705102674, 0.8867203154231946, 0.8241335807322843, 0.16904647774910353, 0.14111575502491835, 0.10484803640104523, 0.16782760976006117, 0.8729068945324449, 0.19902819754794543, 0.19889772866892907, 0.1974357503505656, 0.2540769835576169, 0.19266241025361397, 0.20579386070455175, 0.20862052584841362, 0.1874761693013518, 0.2188155741171307, 0.09416307759502418, 0.11410757243450531, 0.10543757256673725, 0.11085692571541694, 0.10740719504474705, 0.08792694254561906, 0.133478753793714, 0.10215753778842196, 0.09927438314530646]}, "mutation_prompt": null}
{"id": "fc560d6e-f74e-4e5b-973d-3496d43d6956", "solution": "import numpy as np\n\nclass AdaptiveDynamicNeighborhood:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.7  # Slightly increased cognitive component\n        self.c2 = 1.3  # Slightly decreased social component\n        self.w_init = 0.9  # Initial inertia weight\n        self.w_end = 0.4   # Final inertia weight\n        self.alpha = 0.6   # Increased crossover rate\n        self.evaluations = 0\n        self.neighbor_count = 5  # Dynamic neighborhood size\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def update_inertia_weight(self):\n        return self.w_end + (self.w_init - self.w_end) * (1 - self.evaluations / self.budget)\n    \n    def dynamic_neighborhood_best(self, scores, positions):\n        neighbors = np.random.choice(self.population_size, self.neighbor_count, replace=False)\n        best_neighbor = neighbors[np.argmin(scores[neighbors])]\n        return positions[best_neighbor]\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions with dynamic neighborhood\n            inertia_weight = self.update_inertia_weight()\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                neighborhood_best = self.dynamic_neighborhood_best(personal_best_scores, personal_best_positions)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (neighborhood_best - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "AdaptiveDynamicNeighborhood", "description": "Adaptive Dynamic Neighborhood (ADN) enhances Swarm-based optimization by incorporating dynamic neighborhood structures and adaptive velocity components for improved exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.25633307007153294, "feedback": "The algorithm AdaptiveDynamicNeighborhood got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.6824922419437216, 0.7210727932303507, 0.7497102018121282, 0.6544264566159044, 0.7103009936832307, 0.6938592789348197, 0.7165107916195319, 0.7120294521489892, 0.6617825401477095, 0.21125399693244895, 0.2636608703951351, 0.09439800232900963, 0.05077168365449247, 0.0565713037688329, 0.09899366870648496, 0.2114069780003448, 0.22245924352090163, 0.10845408031033366, 0.13422308784074521, 0.17721564405781387, 0.135588443993106, 0.17556512764591703, 0.10885555873565267, 0.14304786638364075, 0.154093876833033, 0.1412393088571674, 0.5049509184397689, 0.09423952676624758, 0.14091959010051947, 0.10802725441684835, 0.1042049319142423, 0.10514100757448108, 0.11249909162629246, 0.09926036284077122, 0.10920391961319276, 0.0924205495765813, 0.9750992403245206, 0.9779864402130196, 0.9757441848331051, 0.9779015780594751, 0.9762174636102596, 0.9697591398222135, 0.9710148901870521, 0.9742090014707675, 0.9809021990494491, 0.4379330253587642, 0.40063865074974303, 0.44322023309477543, 0.41554902993985343, 0.4291289077462781, 0.3814175976612836, 0.3822902077217446, 0.12403513675092814, 0.4165846889085989, 0.33815179435220966, 0.22365415167730762, 0.22442150649429682, 0.27082173064742, 0.27156702430212, 0.24902161621400853, 0.21784805361157888, 0.3427167148238781, 0.3311891893584832, 0.21231005537815917, 0.12042720838905951, 0.19016282885479974, 0.19022332609880765, 0.17472775702646504, 0.17148513410715238, 0.16662167486559043, 0.11535451616553505, 0.17552032904483716, 0.12463423740540658, 0.17527656565077554, 0.19304360675755383, 0.15388260367738382, 0.16298311314207514, 0.21237888456098453, 0.18994465212887268, 0.13941902418714747, 0.15575149302412394, 0.13621341943523735, 0.03384863075223221, 0.06903373513594857, 0.00533267801259063, 0.02262790408066595, 0.011562981397975625, 0.04752188249482692, 0.01727708052735344, 0.035911942861011625, 0.20263510282823838, 0.07704307546017641, 0.21369409691457308, 0.054791942058107446, 0.06916289839282219, 0.04523502157706538, 0.1148823706179779, 0.13547891098592058, 0.13820960325191067, 0.08815293351505404, 0.14377020201811463, 0.1592263054696509, 0.10527264954740023, 0.10239290184073002, 0.09560328757755632, 0.09335683444730236, 0.10258290564761263, 0.08789158893754923, 0.14206828878094058, 0.2448213393045845, 0.1719940542217575, 0.07209031075291839, 0.11980832900578153, 0.07094593382384917, 0.1464798141768071, 0.1342409011458825, 0.08262970217946441, 0.5148799024952979, 0.48178238687648833, 0.462390805884067, 0.5036379194635217, 0.4903012477123455, 0.5134417196256285, 0.47160163559607704, 0.4822327476396401, 0.4751843084604034, 0.10639511612537411, 0.14951982559408228, 0.10674403268577626, 0.15138987805205995, 0.1026102071344096, 0.1349061886610371, 0.08883322084835743, 0.13465553048912948, 0.10681209262497104, 0.16955974933373386, 0.20539851652835328, 0.18872899862235093, 0.28869926542768576, 0.26266482124317236, 0.18930913132163896, 0.2169664149970152, 0.19047853768504508, 0.1387865948546454, 0.2574023600621508, 0.31802675666118085, 0.3016214325937624, 0.2834715241981457, 0.23217291916070237, 0.2943268105893311, 0.3065742485904971, 0.33079518153207377, 0.2609966118720567, 0.2121533702420617, 0.24810452244874082, 0.30278337832958035, 0.24490081589354873, 0.15641596697879834, 0.23391901146834937, 0.24972363230626082, 0.19839944183195968, 0.21457742507910127, 0.22865690324785193, 0.2061421209941261, 0.2173223920940891, 0.24103019172946616, 0.22532282647208424, 0.21068099061161216, 0.2333516869360508, 0.23045857282084348, 0.25835048997041554, 0.18187854331174358, 0.18745907553240704, 0.1922466998849659, 0.19886578902918028, 0.21565902276346982, 0.19984918504344118, 0.19706888358273456, 0.17424063259067712, 0.19014512496194202, 0.18662148929699318, 0.18644196975871374, 0.18086550215492325, 0.721280168343422, 0.19533869970667872, 0.19654185493190435, 0.1409236435316379, 0.16733017638166148, 0.17336475242431992, 0.6262535714873476, 0.2110487206856263, 0.6638664237359528, 0.6408594820526365, 0.16711427475291296, 0.15250507544465053, 0.2088749740749014, 0.20931343940660374, 0.20615747864573664, 0.20306792748623426, 0.2111504291900106, 0.22418594335056186, 0.23130061838104765, 0.2050996296201415, 0.20796173136919338, 0.21008463732768523, 0.22244115019524258, 0.20737716671015438, 0.09613171007527233, 0.10539933005994184, 0.09682317520067918, 0.0978155657912988, 0.09086594636749545, 0.10424453555594626, 0.09746729312547919, 0.10820084813558406, 0.09280585169896016]}, "mutation_prompt": null}
{"id": "5112f6d0-afec-4e20-a165-34767b023bfc", "solution": "import numpy as np\n\nclass EnhancedSwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50  # Increased population size\n        self.c1 = 2.0  # Adjusted cognitive component\n        self.c2 = 2.0  # Adjusted social component\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha_1 = 0.6  # Increased crossover rate\n        self.alpha_2 = 0.3  # Second crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha_1:\n            child = parent1 + np.random.rand(self.dim) * (parent2 - parent1)\n        elif np.random.rand() < self.alpha_2:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedSwarmBasedAdaptiveCrossover", "description": "Enhanced Swarm-Based Adaptive Crossover (ESAC) incorporates dynamic inertia weight and diverse crossover strategies to accelerate convergence in continuous optimization.", "configspace": "", "generation": 6, "fitness": 0.22846192607117344, "feedback": "The algorithm EnhancedSwarmBasedAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.47769773079240296, 0.4652352488355148, 0.6112816688842946, 0.5079993967990151, 0.4737576312747045, 0.5475307829966148, 0.5271656985904203, 0.5287983442850226, 0.5117719896742448, 0.07453158726479436, 0.0633736665831528, 0.006689057093704265, 0.025251732639318458, 0.061787029807960026, 0.014707462550030304, 0.04058535849670697, 0.09436940317928844, 0.030751003856397396, 0.14480916031773816, 0.17769064796568856, 0.1460711009920126, 0.1221161790434111, 0.10424005242018375, 0.12083803025876805, 0.15453326752024243, 0.11483306033256702, 0.1087383738617218, 0.10287614592429584, 0.09557803498289064, 0.10862809307214394, 0.1039851660759139, 0.07791409103165647, 0.0977307843138886, 0.07727849694100208, 0.10910650775164665, 0.0941972286863092, 0.98058348650383, 0.9626834923143474, 0.9831793250305795, 0.9724024524378831, 0.976762203996537, 0.9768317081291976, 0.9798901052159305, 0.9726591203004489, 0.9802734624223204, 0.23201356978685506, 0.255001922484388, 0.05984255070774147, 0.2055311069918042, 0.23262661910959226, 0.17846429674790576, 0.27472714201139126, 0.08923528536575798, 0.25748927453316783, 0.30683364992738826, 0.8794061233233843, 0.2144199007601727, 0.2191530061316349, 0.26993666877663314, 0.21079759487788452, 0.43281362635631826, 0.21800758965109535, 0.3001019593613752, 0.2253641056929464, 0.13255378397556472, 0.14629895673507876, 0.18377833140431254, 0.23122398026876478, 0.13701140957648716, 0.18291436646515158, 0.1920890699349168, 0.15670090271760273, 0.12072245827264427, 0.12678251229609827, 0.12127856521234648, 0.11960787755099667, 0.13459402358486205, 0.22157630842321718, 0.17816769104149244, 0.125250790319415, 0.13287819101194598, 0.00395403219000745, 0.047402482485337405, 9.999999999998899e-05, 0.017435918075842882, 0.022225233199202332, 0.024066026893696968, 0.000365063206800742, 0.05086998037192625, 0.05803059981213754, 0.20266692246935858, 0.06774650972119811, 0.17382998992495557, 0.10312116209477773, 0.04944190773056456, 0.1479151307024662, 0.1070567049341884, 0.18124726383022527, 0.1263164676191203, 0.04141688174325031, 0.03769380195349459, 0.036201282194088025, 0.05995283550475761, 0.04261435559226012, 0.0379361088768968, 0.05476601450388552, 0.014458248472591695, 0.04558675983347804, 0.15220417372510964, 0.17169498322668408, 0.09460909732722134, 0.04039603652928636, 0.1049591681663905, 0.0831390544640559, 0.12275285170961037, 0.13648620091382035, 0.07149678275261506, 0.40411768123294234, 0.3895687721051113, 0.38958197187498667, 0.4284799898489672, 0.41176047004058014, 0.4358854756794973, 0.41917917380088554, 0.4274850049750808, 0.4471345639861657, 0.10774343937191311, 0.10070179040761973, 0.08936154765759752, 0.1075722470477718, 0.10166494872914222, 0.15777487169259052, 0.10086388074229258, 0.12544772618569044, 0.10258226699582373, 0.1545697198477758, 0.1464425508036169, 0.2616709663611757, 0.24403558414135007, 0.20805623262727513, 0.27898663266807155, 0.18925923270572342, 0.22716175308773845, 0.1954744765450358, 0.20909562415069982, 0.26905768536497665, 0.23632730280001346, 0.32024822268621533, 0.2519472109821176, 0.29353812540661406, 0.2673295863481635, 0.2978961047114729, 0.22540603005109172, 0.2267944395323367, 0.19496871704624597, 0.22153239402228853, 0.22473028678187967, 0.3202533657840546, 0.2679149386110189, 0.19119005151597812, 0.2061135549758476, 0.24361208001426804, 0.21192893336092844, 0.2201044524797242, 0.2046717766746331, 0.2165911668329925, 0.21044070772339485, 0.22142416149232602, 0.27514486897114654, 0.2550959977129653, 0.25054896136890326, 0.18167982638952285, 0.16645069747300745, 0.1745317206772823, 0.2022673716712906, 0.18032900949948294, 0.1902099784265443, 0.17544236676172553, 0.17741438137234256, 0.17699264859596842, 0.5438378169614537, 0.18427849182416456, 0.18154663458907894, 0.5558887590040709, 0.1982445730108091, 0.11616156455382332, 0.14217711999682014, 0.15178287063315732, 0.5369229479384154, 0.5961814459010095, 0.20552551485268855, 0.5621498552239601, 0.19989333282494015, 0.22425408839491578, 0.13836740896126465, 0.20566183183789544, 0.5111731909735198, 0.34120940799152255, 0.20765513685866155, 0.19890988851202474, 0.20219241435755397, 0.18842438466016986, 0.18953610494885387, 0.1838854104030555, 0.1969228067422718, 0.1926688268091623, 0.20882080632651245, 0.09252224513746299, 0.08043597821590098, 0.09019981662204646, 0.09341032608960709, 0.09652095209406653, 0.09431267359672635, 0.09249990035984579, 0.09187674814289126, 0.09287122100487322]}, "mutation_prompt": null}
{"id": "827626d5-d38f-464c-9b11-ccfef0775fe7", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "d667ab4f-2a5b-4a0f-bda4-35dad2be57e2", "solution": "import numpy as np\n\nclass EnhancedSwarmCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 2.0  # Increased cognitive component\n        self.c2 = 2.0  # Increased social component\n        self.initial_w = 0.9  # Dynamic inertia weight\n        self.final_w = 0.4\n        self.alpha = 0.7  # Higher crossover rate\n        self.evaluations = 0\n        self.elite_fraction = 0.1  # Fraction of elite solutions retained\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Reduced initial velocity range\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def tournament_selection(self, scores):\n        indices = np.random.choice(self.population_size, 2, replace=False)\n        return indices[0] if scores[indices[0]] < scores[indices[1]] else indices[1]\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        elite_count = int(self.population_size * self.elite_fraction)\n        \n        while self.evaluations < self.budget:\n            # Dynamic inertia weight calculation\n            w = self.final_w + (self.initial_w - self.final_w) * ((self.budget - self.evaluations) / self.budget)\n            \n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Sort based on personal best scores and retain elites\n            elite_indices = np.argsort(personal_best_scores)[:elite_count]\n            elites = personal_best_positions[elite_indices]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                if i not in elite_indices:\n                    r1, r2 = np.random.rand(2)\n                    velocities[i] = (w * velocities[i] +\n                                     self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                     self.c2 * r2 * (global_best_position - particles[i]))\n                    particles[i] = particles[i] + velocities[i]\n                    # Ensure particle position within bounds\n                    particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover using tournament selection\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1_idx = self.tournament_selection(personal_best_scores)\n                    parent2_idx = self.tournament_selection(personal_best_scores)\n                    parent1, parent2 = personal_best_positions[parent1_idx], personal_best_positions[parent2_idx]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedSwarmCrossover", "description": "Enhanced Swarm Crossover (ESC) incorporates dynamic inertia, tournament selection, and elite retention to boost convergence speed while maintaining robust exploration.", "configspace": "", "generation": 8, "fitness": 0.23281704319891414, "feedback": "The algorithm EnhancedSwarmCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.6433968607942153, 0.6198790097054039, 0.6227282108667465, 0.6064584393744441, 0.6082868503863119, 0.7284525934893621, 0.635467683825151, 0.6173706032671447, 0.6332283963641157, 0.11405076133343395, 0.11022134204760947, 0.10945420010703599, 0.09390847002398006, 0.03384603421504451, 0.05919007517603203, 0.10451224345355326, 0.048152642743518714, 0.07987427616456166, 0.12145468547914318, 0.08043791230836728, 0.13737675231688296, 0.15858881699319627, 0.07185033749198777, 0.09993952579282539, 0.1324973009930287, 0.15009835164805485, 0.11720859868967004, 0.12122872546299568, 0.08488625236856373, 0.07036810579695663, 0.09382262531700614, 0.13378887323433597, 0.0725934770893224, 0.08162745843782104, 0.0967526533935179, 0.08035164959672114, 0.9798611756515923, 0.9855021738102718, 0.985379478852509, 0.9704781325308258, 0.9780175955009464, 0.9716909943974564, 0.9763266290396064, 0.9721023434867937, 0.9844240887162987, 0.33079258696198544, 0.3960752078719656, 0.3725008923115892, 0.36767438086477033, 0.3022129633516676, 0.2846324498345124, 0.3311133671684523, 0.31691085734090385, 0.37272291603417795, 0.2582817416908798, 0.3365074189744146, 0.14117326490352766, 0.20001540003862095, 0.20301288156162345, 0.21275026808848185, 0.25158374050489396, 0.17885921512927694, 0.2068883695239393, 0.22034079860967748, 0.11669016847223834, 0.16625929217199842, 0.20389506058960327, 0.11286575247220221, 0.2100352497229776, 0.22238462569181217, 0.12647441634542378, 0.18514986240372122, 0.22096507225653672, 0.19644531126293774, 0.11338836292754151, 0.24569858776331843, 0.15597199905150283, 0.19100418446774026, 0.21895884201037397, 0.20174505075565397, 0.14128454878656416, 0.008055722476979499, 0.012957855062458612, 9.999999999998899e-05, 0.000285521394768562, 9.999999999998899e-05, 9.999999999998899e-05, 0.0061128405641464045, 0.05796165460016067, 0.00980273288314204, 0.13981247033208022, 0.09429126360977935, 0.09334158689933392, 0.08479319716011091, 0.027023994300824805, 0.04292166683408871, 0.1563208185505489, 0.12333474135709244, 0.04867383546497128, 0.027512981554284166, 0.06461386180870554, 0.08436242978083264, 0.0553170248598146, 0.07858489816453784, 0.14433445230709308, 0.11281848875524536, 0.1265641730501511, 0.07916283785090694, 0.08124869259851508, 0.1927882311710064, 0.1127756025746448, 0.0876598919162127, 0.1439677494041116, 0.11309458060637412, 0.10587254999453599, 0.13598340740535153, 0.08145468418939328, 0.4468975972426702, 0.49534436768000767, 0.4393910120761856, 0.4502710958442253, 0.46173462955466194, 0.44171422081056755, 0.4361521464780235, 0.44019361638523746, 0.41003106201683237, 0.08057117516901147, 0.10172353234383336, 0.077182894026541, 0.13862360251542927, 0.08800757008564397, 0.1286748033216536, 0.10370013677254208, 0.12646609222177307, 0.1012948130943645, 0.15614489150712596, 0.21390580394225, 0.1546853091659941, 0.17355022495617578, 0.20334121538551042, 0.15399522352225758, 0.16045696166077217, 0.13101827094176277, 0.16562211327869225, 0.289036053672712, 0.26004805894217764, 0.2051179878719882, 0.26077895180067157, 0.2185857448269456, 0.18668674560132292, 0.309555213751874, 0.2689550760821485, 0.2583204271916796, 0.2446822598170023, 0.203635137304368, 0.2129122365845335, 0.22064339026126478, 0.20318886712683193, 0.25058484537924464, 0.19742353165845616, 0.25919192160699667, 0.20528155062356568, 0.2018302129957894, 0.19864237020940656, 0.17484093154657854, 0.21252906067830368, 0.18659216619580965, 0.2148657072990079, 0.21665626349065426, 0.24021479646980592, 0.21726316686804292, 0.18702677761325193, 0.17423793090486617, 0.17315878766313597, 0.18105813735772158, 0.18439249091026755, 0.17803548739529107, 0.18162661621143883, 0.18746717502871546, 0.1826202499619498, 0.18534089582097057, 0.1258696037968522, 0.11294964661613482, 0.6679588156533754, 0.19508786353185537, 0.19862988193254316, 0.1430550419890858, 0.1672642066361817, 0.20265639669127844, 0.6765583459097787, 0.20760074246938442, 0.657087395659524, 0.4395319233125615, 0.16861895341583455, 0.14418486004073583, 0.18764909691194787, 0.20120461216594487, 0.5793241199672414, 0.19450435499402097, 0.2025871698714845, 0.18495796368837747, 0.21075809305424653, 0.19792567635697556, 0.1994548549162377, 0.21119817582756473, 0.2128058856783267, 0.20369942472833413, 0.08693051710679578, 0.08357652536777482, 0.08565282449177214, 0.08900868208377466, 0.09923432846719515, 0.07076701267613239, 0.08260533705288231, 0.08665912869362002, 0.07269730735107294]}, "mutation_prompt": null}
{"id": "7d46532a-4326-4ff5-87c9-71b1f4d4fec4", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "d765f237-5a9c-42f0-a451-bfb39c227fb2", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "602dbdcb-b740-4de7-9af4-c6661b846d41", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "64987d90-c845-4e90-aaa0-33e49ff26aff", "solution": "import numpy as np\n\nclass AdaptiveVelocityCrossoverSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50  # Increased population for better diversity\n        self.initial_c1 = 1.5\n        self.initial_c2 = 1.5\n        self.w = 0.7  # Increased inertia to maintain exploration\n        self.alpha = 0.7  # Increased crossover rate for more aggressive recombination\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Reduced initial velocity range\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def update_parameters(self, iteration, max_iterations):\n        # Reduce cognitive and social components over time\n        self.c1 = self.initial_c1 * (1 - iteration / max_iterations)\n        self.c2 = self.initial_c2 * (iteration / max_iterations)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        max_iterations = self.budget // self.population_size\n        \n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            potential_new_evals = self.evaluations + self.population_size\n            if potential_new_evals <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "AdaptiveVelocityCrossoverSwarm", "description": "Adaptive Velocity and Crossover Enhanced Swarm Optimization integrates dynamically adjusted velocities and crossover rates based on convergence trends to accelerate exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.2949522942341163, "feedback": "The algorithm AdaptiveVelocityCrossoverSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.780040269423443, 0.7273103376332206, 0.7607958793198221, 0.7460597783132581, 0.7531335219212539, 0.7208054672819457, 0.7426080331145448, 0.7379885454103028, 0.762618921205265, 0.17083504241301284, 0.38419073133565673, 0.24220771402162578, 0.21724300750766368, 0.08483298499162761, 0.19403643062784415, 0.15808741473309396, 0.004652845291398977, 0.1690471314178401, 0.12918335588929042, 0.13659014906139988, 0.1544750635544886, 0.1389592084086516, 0.1418582647389971, 0.17408033597182127, 0.12157183944969807, 0.1817587413842935, 0.1332217034656087, 0.11432361958202453, 0.1088628622345652, 0.11145926868898948, 0.10698670768625795, 0.11858990747844944, 0.11418311892079513, 0.09117594809408669, 0.13168247187505078, 0.11621777187327209, 0.929183969205074, 0.9327290903798056, 0.9695588087410364, 0.9321940628129588, 0.9489930603428486, 0.9454084226579124, 0.9429790430902956, 0.9346775618344115, 0.9339935299650761, 0.44023770984372745, 0.42271721337742396, 0.42798044346676645, 0.399285427655633, 0.4036998629089569, 0.4146949733510543, 0.41943415843846255, 0.4055501694728386, 0.4005318829115727, 0.738317098431984, 0.8483208266930989, 0.6966718662766294, 0.6775600380794018, 0.2742635153807146, 0.27647777224284276, 0.728179953764701, 0.552030715392992, 0.6500732358244952, 0.18514531017491231, 0.18654123200679218, 0.20639462060104674, 0.27654831036937566, 0.2120961608297358, 0.2737632657135338, 0.24880788410679378, 0.3047769590339511, 0.36540984313406255, 0.19769397845289582, 0.1723969634878889, 0.14116530607626465, 0.14798680386863083, 0.151376920315885, 0.1320079014443305, 0.17502923010828475, 0.1795856249868808, 0.21632711033533547, 0.07293319281377642, 0.14312670894908974, 0.03710004466264305, 0.23089857631513522, 0.07337919984879504, 0.03511083702574802, 0.08164842201205846, 0.010758151027075669, 0.09195106711075518, 0.26449451686001324, 0.1880390643833103, 0.21036177884328844, 0.15438390462012763, 0.15138946021420907, 0.08924477502373485, 0.16094985522123628, 0.18716984602341302, 0.12628915304539823, 0.15727531444720932, 0.09481507581849313, 0.12559226709405502, 0.06627918650615916, 0.08790885117368907, 0.06478233045312076, 0.16718024858007807, 0.1481794563817631, 0.08398644102016728, 0.2436429829357193, 0.20585080840456704, 0.17879673390568984, 0.05972016411636338, 0.14954196171636236, 0.09104920713021569, 0.13228780208054636, 0.19274897652389955, 0.09054491541116438, 0.5563195684678808, 0.48433331590394024, 0.4707068371185119, 0.511028000096492, 0.5036014611227553, 0.48024588566459137, 0.4961786134177806, 0.4816554513469232, 0.4990375357356486, 0.1155981098361557, 0.162054336250676, 0.10566293918034919, 0.15313333782844474, 0.08923271081499684, 0.1416389005122286, 0.14000475962565329, 0.1293848618340917, 0.13265783104108142, 0.24755838054005042, 0.17619534796095992, 0.16957152607654247, 0.28849252897085975, 0.263477148425028, 0.13892813101230206, 0.1821704716324679, 0.1720521215944958, 0.16129250692920982, 0.30181888938616175, 0.2585421476606321, 0.2811382858080962, 0.35000456602549457, 0.3523142086803307, 0.39085012334751623, 0.2418613398531041, 0.3012440353539467, 0.3152313899073871, 0.21626043328223632, 0.18466927240785147, 0.21924064383831143, 0.36384869719714175, 0.24712869900666568, 0.3122729875110556, 0.17671083335085291, 0.2550422260228722, 0.24531758658848668, 0.23345453084598666, 0.2186855273481767, 0.2664396158741509, 0.21785558995125032, 0.2353856411434092, 0.2279185580666545, 0.22818071760292646, 0.25388218428930986, 0.24803996693153407, 0.19126797991977562, 0.2138193986113216, 0.18728091038195627, 0.2056112107812974, 0.19088004938118275, 0.20049762351512257, 0.23584938207549944, 0.1955658551218371, 0.1831251224701439, 0.48478199014435, 0.18562679760601064, 0.18419058799443688, 0.7777325246075989, 0.6494674628070959, 0.8039958272163578, 0.15832402397715362, 0.16445791280543764, 0.5888821054040112, 0.7635206018993326, 0.20800862370428508, 0.5426052575709308, 0.6843701149668588, 0.37958761926203743, 0.16906001377348634, 0.20303528049090214, 0.7074708141980562, 0.20080233058339447, 0.196278679777542, 0.1907495667210155, 0.18825792986196255, 0.2029591071807032, 0.21910059345878585, 0.1891236712606672, 0.18740781007818264, 0.19951484484363213, 0.20949256386608395, 0.08857573991574264, 0.13598386429604759, 0.09803016584281177, 0.09824552569405587, 0.09415166323684698, 0.10224847916247104, 0.07772296476333518, 0.10087303303220074, 0.12572710447655977]}, "mutation_prompt": null}
{"id": "71b2f044-b81d-431a-a2ac-d5f3f10bfd6f", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50  # Increased population size\n        self.c1 = 1.3  # Adjusted cognitive coefficient\n        self.c2 = 1.7  # Adjusted social coefficient\n        self.w = 0.4  # Adjusted inertia weight\n        self.alpha = 0.6  # Adjusted crossover rate\n        self.beta = 0.05  # Quantum rotation angle\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def quantum_operator(self, particle):\n        rotation = np.random.uniform(-self.beta, self.beta, self.dim)\n        particle = particle * np.cos(rotation) + np.sin(rotation) * (self.ub - self.lb)\n        return np.clip(particle, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.quantum_operator(particles[i])\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "QuantumInspiredAdaptiveCrossover", "description": "Quantum-inspired Adaptive Crossover (QAC) incorporates quantum mechanisms alongside swarm intelligence and adaptive crossover to enhance search efficiency in continuous spaces.", "configspace": "", "generation": 13, "fitness": 0.2310814671044403, "feedback": "The algorithm QuantumInspiredAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.5974954297031093, 0.4701452552918114, 0.4105569625396297, 0.5436984058940457, 0.5232125418805212, 0.378095398207863, 0.3632434181329772, 0.6083776102007696, 0.43836045782616195, 9.999999999998899e-05, 0.05139914283782743, 9.999999999998899e-05, 9.999999999998899e-05, 0.00017467361460909991, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04807207730980312, 0.1267804660992906, 0.15789413324671153, 0.15261635236409343, 0.15819201128205784, 0.1536602508504824, 0.14312713308083658, 0.14658757561476665, 0.12066960091578349, 0.12261460191515072, 0.10110837816347062, 0.1154359758781276, 0.11603017577171815, 0.08968814337331332, 0.09873809590224647, 0.10709098372602732, 0.1429978775854197, 0.11502716792025569, 0.1270705932408771, 0.9731373705516438, 0.9700374605957798, 0.9728936341398084, 0.8899621215889044, 0.9626236035764674, 0.9600195894621498, 0.9692414322576742, 0.9636136681930901, 0.9724102788178538, 0.21417120888125796, 0.2300745914548994, 0.2051186075630551, 0.22102840068219853, 0.24848894208140881, 0.23134577546102209, 0.20620678514215884, 0.20217691352206457, 0.23692353807734923, 0.3584757071284209, 0.39551510002862256, 0.3039250873488767, 0.2208430596962896, 0.24330723791258102, 0.2760232706793099, 0.22043828648719443, 0.29976521952841395, 0.7988277257941674, 0.21163506488570305, 0.22087119415565126, 0.12308156578797314, 0.13991223048778434, 0.15421970978012756, 0.19564785413864327, 0.15612439602833306, 0.1268635357497434, 0.15810013736698114, 0.13634902490405998, 0.14075832281565526, 0.1334647540006687, 0.12459271606768885, 0.12300912434141187, 0.12475709088315323, 0.1276984951136494, 0.13385143133601118, 0.12605652596363381, 9.999999999998899e-05, 9.999999999998899e-05, 0.06554066074140896, 0.020085497167987576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08687617647181012, 0.20515163068333941, 0.050930953063475726, 0.12817825620484236, 0.09588092501346424, 0.02538622751085673, 0.04036690810010224, 0.13725793987547952, 0.12403828589079036, 0.05575681345386019, 9.999999999998899e-05, 0.05853855050220225, 0.0643211517809632, 9.999999999998899e-05, 0.008853445498859358, 9.999999999998899e-05, 0.017540641700048987, 0.056989220407279606, 9.999999999998899e-05, 0.09294634558378856, 0.08897754146084047, 0.14076997950684655, 0.024019028324644753, 0.07645399325036739, 0.07850230191158591, 0.06438121750057324, 0.10136138653643978, 0.11629444024936786, 0.4744801446332465, 0.45096989248734054, 0.3511916854303212, 0.49795104177908256, 0.4401412037454069, 0.3689817885337404, 0.44133512559481836, 0.4730836071230815, 0.4683825412442606, 0.0872078532639966, 0.10838821421539757, 0.08517689791146477, 0.108888000150406, 0.14500934133600218, 0.12231105998332747, 0.1517358230949054, 0.1667789438948417, 0.1033441955380473, 0.21268079941910778, 0.23912070372785899, 0.27606639568268454, 0.33485904995469085, 0.323999119206256, 0.26561349535768886, 0.2776932789072787, 0.2793160120818525, 0.22563825751128652, 0.2930819617054915, 0.32589172754143214, 0.39727472171683453, 0.3157274802615354, 0.2878907886279267, 0.32182599228533326, 0.3232385503177442, 0.3416417457504336, 0.3180242461754641, 0.2042493784182562, 0.2702331877196541, 0.28737759684812236, 0.26433845215725404, 0.2713684080512154, 0.20123809817782246, 0.20618340263838186, 0.2812099628292922, 0.2444592521853134, 0.22788352294444592, 0.19707007307826074, 0.2297509250265981, 0.2331461630086349, 0.2453430615452349, 0.259477644607502, 0.2399962019720826, 0.24171058023476033, 0.2036987550579521, 0.2731909442675535, 0.19962481802727472, 0.188520314013487, 0.22585593600337228, 0.20582556775140803, 0.1832549772422316, 0.1928008360297092, 0.2029386570575934, 0.23408825733166572, 0.5378717915005571, 0.1678608602216325, 0.15243811459052636, 0.5368509117199052, 0.19955169785121074, 0.5139246254404068, 0.1425606423483914, 0.16309284272928237, 0.2117458291847666, 0.3935268082059682, 0.2113153235058216, 0.4655470027478631, 0.46897193570195783, 0.4454320612644086, 0.15352102906142684, 0.10392560620407254, 0.1674185284641102, 0.29571437412960144, 0.22903376230132277, 0.2095052771213496, 0.21633165174782065, 0.2210236135291147, 0.20260538132499029, 0.20443185326572821, 0.18487215316628292, 0.20459986309287004, 0.2007847599089645, 0.08798807419956556, 0.0932976805827378, 0.1288851866377032, 0.09248174644899376, 0.10182557225766109, 0.1276917100934264, 0.09659024517297954, 0.1056438245886957, 0.0962096946108042]}, "mutation_prompt": null}
{"id": "76a7d060-94c4-468a-ae68-441870185619", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "230e7a81-2857-4463-9852-d72c6772f8e8", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "2bc97c81-e231-489c-90e6-5d664898767a", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "fe07ca68-9e44-409e-b4be-8a95cec6ee33", "solution": "import numpy as np\n\nclass HybridSwarmCrossoverEliteLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.7  # Increased cognitive parameter\n        self.c2 = 1.7  # Increased social parameter\n        self.w = 0.9  # Adaptive inertia weight initialized\n        self.alpha = 0.6  # Crossover rate\n        self.evaluations = 0\n        self.elitism_rate = 0.1  # Elite learning rate\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def update_inertia(self):\n        self.w = 0.4 + 0.5 * (self.budget - self.evaluations) / self.budget\n    \n    def elite_learning(self, particles, global_best_position):\n        elite_count = int(self.elitism_rate * self.population_size)\n        for i in np.argsort([func(p) for p in particles])[:elite_count]:\n            particles[i] = particles[i] + self.elitism_rate * (global_best_position - particles[i])\n            particles[i] = np.clip(particles[i], self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            self.update_inertia()\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            self.elite_learning(particles, global_best_position)\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "HybridSwarmCrossoverEliteLearning", "description": "Hybrid Swarm-Crossover with Elite Learning (HS-CEL) integrates elite learning mechanisms and adaptive inertia into swarm and crossover dynamics for accelerated convergence in optimization.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {}, "mutation_prompt": null}
{"id": "a23c9cb5-f153-4ae3-90de-bafb913fb195", "solution": "import numpy as np\n\nclass DynamicSwarmAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 2.0  # Increased social coefficient\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.7  # Increased crossover rate\n        self.evaluations = 0\n        self.temp = 1.0  # Initial temperature for annealing\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        cross_point = np.random.randint(1, self.dim)\n        if np.random.rand() < self.alpha:\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def update_temperature(self):\n        self.temp = max(0.01, self.temp * 0.95)  # Cool down\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * (self.evaluations / self.budget))\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                if np.random.rand() < np.exp(-np.abs(func(particles[i]) - global_best_score) / self.temp):\n                    particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            self.update_temperature()\n            \n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "DynamicSwarmAnnealing", "description": "Dynamic Swarm Intelligence with Temperature-Driven Annealing (DSITDA) integrates dynamic inertia weight adjustment and temperature-driven simulated annealing for enhanced exploration and exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.12350089036671735, "feedback": "The algorithm DynamicSwarmAnnealing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.09.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.311822489978974, 0.2819350881510735, 0.3749043725119806, 0.21459400943985696, 0.2380589635151279, 0.23399376459500865, 0.278878929812856, 0.275513445551094, 0.21877749444249428, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0924694436847947, 0.10965663270946702, 0.09288020966384447, 0.12178561471458216, 0.09847979094957704, 0.11934282836698917, 0.08668284982021601, 0.12761825448901387, 0.10482694997401942, 0.07929438152775525, 0.05572652221673147, 0.10226475546395053, 0.08855540958369978, 0.10135410129776012, 0.05099734212792917, 0.06301481360383676, 0.12969949134994618, 0.0698583909982079, 0.08567072840453949, 0.07296894300413692, 0.062444287025753, 0.10876709712180943, 0.07927030048132255, 0.08347520228808958, 0.10625766568150097, 0.08016235672695116, 0.08481287168733465, 0.08567937061830777, 0.05915313924566157, 0.03654922039527153, 0.10388153778916043, 0.05240591777350001, 0.04033181110306483, 0.07173726288256799, 0.05386142072419697, 0.05805308666765463, 0.17902477220040436, 0.15479440444209447, 0.13284334626323502, 0.19080039215890954, 0.18839222662281163, 0.24366753250553352, 0.13640618383137548, 0.16501402892049755, 0.1866163627229569, 0.06506553387279856, 0.025113231462431718, 0.02709102904571714, 0.07453687748234483, 0.08637162062641968, 9.999999999998899e-05, 0.1557955823818058, 0.025940649705559204, 0.10323173644223094, 0.15776435073468498, 0.0855732170016017, 0.12599521649772338, 9.999999999998899e-05, 0.11793952726062729, 0.09333998925947795, 0.17182222061016605, 0.1173432501525089, 0.14437247410429122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.23028652157734464, 0.08910756123817787, 0.19701082803897674, 0.04494611587512831, 0.04837305605637143, 0.04496428479748371, 0.11133705120739834, 0.1004126562711104, 0.08399683085661913, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07996666402236241, 9.999999999998899e-05, 0.03578100824782027, 9.999999999998899e-05, 0.045138835955458645, 0.019173276859965838, 0.03856042900973733, 9.999999999998899e-05, 9.999999999998899e-05, 0.27423306064925324, 0.26902773751330533, 0.3243230438644258, 0.2607796863657047, 0.17790862683484887, 0.21763208323267258, 0.2738738201142338, 0.2899245427268309, 0.4213118630255681, 0.05835761742030465, 0.0750872831557916, 0.0721007748400958, 0.11157834850964077, 0.042653943877395295, 0.06871024005254822, 0.08017207903020485, 0.07164840469240785, 0.0763430478561482, 0.17011290500705667, 0.09949498393933354, 0.13045391566244635, 0.11133968768656943, 0.1411727751269769, 0.10229411943735123, 0.13625862822086143, 0.14139803013407692, 0.12652172075506674, 0.18189449023078608, 0.21203589820564428, 0.16575071278426545, 0.2544272318112135, 0.2488920536457636, 0.2480752654207199, 0.16612283363817282, 0.285010114198304, 0.1908706868594945, 0.13005079976713385, 0.1294910804140249, 0.12228319277108946, 0.24410118529276292, 0.22585688213532307, 0.14768661362167734, 0.1535047943968484, 0.14940592158153154, 0.18995352445379166, 0.188297916795642, 0.21231946443855243, 0.21377489753857226, 0.17120730071286128, 0.19630986204272005, 0.20253437398227658, 0.20092838492563914, 0.20770190749584905, 0.18362936688722475, 0.17328405302432637, 0.16885607874462116, 0.2140944925120336, 0.17808076832904696, 0.16793583767856324, 0.16780827911147733, 0.17291072728643686, 0.1848364534543402, 0.16141117668884652, 0.16730397765985927, 0.15679347195667492, 0.16328336743613092, 0.3205889544142545, 0.375467809211405, 0.1678683384029842, 0.1199564085105036, 0.1641029273156206, 0.17477031106914565, 0.49799311077166175, 0.20198895225128222, 0.1780683210083991, 0.12341287397034573, 0.15561073146216786, 0.09891071699881082, 0.09630538655406673, 0.15125368966260722, 0.12305182578500806, 0.17802366358794175, 0.18225891417627538, 0.16962474132750727, 0.17619059787152835, 0.1757839791651632, 0.19642867780145634, 0.17597696563282172, 0.188761644479444, 0.1772805940304486, 0.06368297241134169, 0.07837985309348494, 0.06909563094729132, 0.09434130941658969, 0.09418329493383115, 0.06390884659056428, 0.0769227615927015, 0.09056374354845753, 0.07632592507070224]}, "mutation_prompt": null}
{"id": "15529b6f-dc12-43bb-abd3-cd7776d08c18", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "6621ffb3-214a-4c3b-b9c8-0c9fc88ab285", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "f7321130-7341-470a-ba30-4107972a3d37", "solution": "import numpy as np\n\nclass DynamicDualPhasePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.3  # Crossover rate\n        self.evaluations = 0\n\n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            child = (parent1 + parent2) / 2\n        else:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        return np.clip(child, self.lb, self.ub)\n\n    def adjust_inertia_weight(self):\n        return self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            w = self.adjust_inertia_weight()\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "DynamicDualPhasePSO", "description": "Dynamic Dual-Phase PSO (DDPPSO) incorporates dynamic inertia adjustment and dual-phase search strategies to enhance convergence speed in high-dimensional search spaces.", "configspace": "", "generation": 21, "fitness": 0.2351445212877582, "feedback": "The algorithm DynamicDualPhasePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.6230086538029296, 0.5522142463242057, 0.5811019678594057, 0.6372021885049257, 0.5808525627317906, 0.6101459111405411, 0.6124607501710984, 0.5047779721373175, 0.7061305897709739, 0.05081190782770939, 0.11562318062768795, 0.08356197195454429, 0.092777324752087, 0.0667360979141236, 0.043944770894948304, 0.08159258756603482, 0.11433718174026108, 0.12903393521725026, 0.13653660375475007, 0.1763470968249118, 0.14419431935374505, 0.15269475599227922, 0.13064490658468841, 0.15629206692568898, 0.34345033118319224, 0.15822191773723426, 0.30911668758390876, 0.07117487947115897, 0.08484035815231417, 0.08935907064719473, 0.09806512774260823, 0.11353303410916815, 0.12582591039759772, 0.10955756834966068, 0.12430719459792439, 0.1242231523425793, 0.9804587864180367, 0.9628810068238539, 0.9830364017312829, 0.8294618302826064, 0.9703085155124124, 0.9727712714783242, 0.9804778686465475, 0.9724970307411903, 0.9719300081290887, 0.2397445429305155, 0.19901445465020884, 0.3114787710714586, 0.19211071585464, 0.2606845680559231, 0.24828771915394932, 0.2610662743641635, 0.08632485657407729, 0.2084583912911504, 0.2851748028497283, 0.22916335364094487, 0.21507364766457426, 0.21974656953846794, 0.26063370060341895, 0.39356617634851576, 0.16074925437472953, 0.24658202861097733, 0.22909510098968855, 0.14917757861563608, 0.1423736410015194, 0.139365319962664, 0.1287346899166507, 0.2697028002768843, 0.13991824766676164, 0.1897640383327408, 0.12621694594890087, 0.1575577994765679, 0.1921550357159102, 0.15815855042739602, 0.15956069519114535, 0.13699591650058573, 0.13108842093598672, 0.14411652920054863, 0.18408914860905667, 0.2464389740148073, 0.11195206739553887, 0.0349847585247367, 0.03374351661798414, 0.024120523664636684, 0.008777525291724153, 0.01131972588585628, 9.999999999998899e-05, 0.0020665948557603286, 0.05173535229320059, 0.08844940126124734, 0.1388086384982158, 0.10692190515522182, 0.13592905108151632, 0.09795389326058523, 0.056522152943271786, 0.05904166510484832, 0.15922863991210157, 0.12020878485510733, 0.06627809001943952, 0.07493605226245004, 0.07486272849073772, 0.18439865868764604, 0.05034505775526543, 0.05612727284585084, 0.06515774026086252, 0.0626371952182504, 0.06921857333514503, 0.034616311864429594, 0.11625271331486564, 0.08936768953654395, 0.1534464327152033, 0.03705352711030041, 0.15777717747971087, 0.1526736925460429, 0.15806544722773486, 0.1282232892716536, 0.07470131241316247, 0.4340090209605131, 0.38683224367885116, 0.4698896125735128, 0.41648758685763654, 0.4074785156653118, 0.4971492272882361, 0.44347570299609995, 0.42192181075795976, 0.3972391042121134, 0.13746301299052754, 0.1092101417099226, 0.0927997905144401, 0.09286511482005644, 0.10192979662293422, 0.15720784945798438, 0.13711740349082124, 0.11133269623454811, 0.12450783775530039, 0.17022553940907692, 0.1604686948268389, 0.17497313775596135, 0.2596349379755225, 0.3385677569646989, 0.21598672665858376, 0.20626461159961873, 0.21416484520329293, 0.1412471236170877, 0.279951316513367, 0.3405654725626268, 0.3879427729663988, 0.3214517322689431, 0.26776127820656725, 0.29312352404083364, 0.24562271639092337, 0.280536515453624, 0.23662592567005036, 0.20373613322862083, 0.29072815139171426, 0.2787237850047739, 0.2494382046180995, 0.304814696112753, 0.2340032089372619, 0.2214885056687219, 0.22199099241693843, 0.2960711144344138, 0.2228962534969764, 0.21194440829174876, 0.1972292612689882, 0.23089662553291446, 0.2250797357717298, 0.2110862979788678, 0.2888243802206517, 0.18344578921994747, 0.19951634546929686, 0.17741375733207765, 0.18897975913493437, 0.17761268573953892, 0.19743503587784428, 0.19113815376165266, 0.17175912170718488, 0.20861977984009428, 0.23779959473668488, 0.17407494424171288, 0.18412310295980894, 0.18654115782765768, 0.17518174523744878, 0.587816230315189, 0.1970253424315197, 0.3565985571305471, 0.14141332329529344, 0.16095768712833214, 0.6526306201594622, 0.6688292360606849, 0.20326540590601827, 0.19634705331801228, 0.4595302538085939, 0.16859618688175337, 0.150612560108204, 0.16367970609908788, 0.20355947767575433, 0.2843690796713416, 0.2064567915625366, 0.19553144210034357, 0.19008453626930855, 0.19910157797402783, 0.18924816591013716, 0.2014170989798496, 0.195596524055768, 0.1902630021407915, 0.19629086946163699, 0.0984280562947133, 0.09155866517769395, 0.0994639222821686, 0.09064739675580935, 0.09448208312778783, 0.10080759538873951, 0.10571397742070643, 0.09621836746026224, 0.08915805990232262]}, "mutation_prompt": null}
{"id": "63809f8d-c3b7-4b6d-8fc7-9b72764d26f1", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "273873a6-85fc-4303-b3ab-4b50cc80cfb9", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "0c459d01-0087-4e12-bdab-08ad766a6e90", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "769a9f4f-7dce-4b0e-b7a4-9077f5017305", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "852441d9-e979-4811-baa8-84889b493470", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "127e47fa-3653-4a93-80ab-6c686593a263", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "b269fa02-53da-4795-9003-a6a4d5049188", "solution": "import numpy as np\n\nclass DynamicVelocityAdjustmentPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.9  # Increased cognitive coefficient\n        self.c2 = 1.9  # Increased social coefficient\n        self.w = 0.7  # Increased inertia weight for better exploration\n        self.alpha = 0.6  # Slightly increased crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def dynamic_velocity_adjustment(self, velocities, iteration, max_iterations):\n        # Adjust velocity dynamically based on the progress of iterations\n        decay = 1 - (iteration / max_iterations)\n        return velocities * decay\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        max_iterations = self.budget // self.population_size\n        \n        for iteration in range(max_iterations):\n            if self.evaluations >= self.budget:\n                break\n            \n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                velocities[i] = self.dynamic_velocity_adjustment(velocities[i], iteration, max_iterations)\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "DynamicVelocityAdjustmentPSO", "description": "Dynamic Velocity Adjustment Particle Swarm Optimizer (DVAPSO) enhances traditional PSO by dynamically adjusting velocities based on convergence trends, coupled with adaptive crossover for robust exploration.", "configspace": "", "generation": 28, "fitness": 0.31069586460609094, "feedback": "The algorithm DynamicVelocityAdjustmentPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.7754268809015012, 0.7285698906286979, 0.7859317899245654, 0.7868309288836507, 0.7635545849302382, 0.789901471762476, 0.7957983325228221, 0.7838004619987091, 0.7676771534078924, 0.411359860913065, 0.24323707057427968, 0.4102480684159613, 0.5029771404456228, 0.4320225883672544, 0.3859871797770097, 0.14556287396737622, 0.4727638850631044, 0.47671825258437883, 0.11282114027775458, 0.13778833427297776, 0.1066391616811534, 0.13168059478643368, 0.15564328598780808, 0.10216668202604795, 0.1530769842304751, 0.15950562590118356, 0.12318936105378175, 0.07987070998919588, 0.07527648596970338, 0.07243498490335643, 0.101729635047077, 0.11483512877815938, 0.14123224960880398, 0.1074543285293803, 0.10763082833178017, 0.08423261058699971, 0.9850684516115891, 0.985073514547336, 0.9850446781099647, 0.9770061751466329, 0.9783128207395719, 0.970110477728904, 0.983884567840072, 0.9783266404053275, 0.9842237626936107, 0.5120250138071802, 0.46537624249667053, 0.4026640683556355, 0.4835510796553726, 0.4796234525166474, 0.1443628904065547, 0.42025586992191233, 0.4412233374213147, 0.1520549375889817, 0.374643144208178, 0.6982805155954059, 0.22659855503446946, 0.27767295762317157, 0.2715114662100274, 0.19203383801862417, 0.8263443564684885, 0.23012584934312896, 0.7323708432138789, 0.25531186882244383, 0.12604679694114806, 0.41258938268163914, 0.10287160761484282, 0.5379802628263878, 0.3884586943440973, 0.32628396118218894, 0.47228078895764924, 0.301153858788188, 0.44304498524122604, 0.5220588085591551, 0.525364551099361, 0.19085521093978897, 0.19077890738185665, 0.5331931988073892, 0.22156658582304822, 0.11937330616081343, 0.42233799802265637, 0.0854019257493921, 0.12789677283214984, 0.14640525775829505, 0.0287078345668077, 9.999999999998899e-05, 9.999999999998899e-05, 0.0399803189511978, 0.07182538685969342, 0.11552998025585326, 0.10252026838887363, 0.07130210379147117, 0.15630701405255043, 0.0835333540136266, 0.05207749195404432, 0.14599466019901264, 0.08452021056146986, 0.1786088601354371, 0.10704203700071901, 0.18801360687912771, 0.08144696862367473, 0.17481971291142362, 0.14402425566695687, 0.1564849713042693, 0.12371760053845426, 0.20445516520934592, 0.07738784274735921, 0.12403728512596424, 0.19536590232164164, 0.13795018920520052, 0.14150699247931153, 0.058802537404121225, 0.10851182469840204, 0.16258308911299357, 0.14441783824255328, 0.14245544619826012, 0.11343545901785856, 0.5721470705873748, 0.5434515083959708, 0.5568439322995669, 0.5613429001093952, 0.5693408129510611, 0.4474844431432178, 0.49568727498846765, 0.5780166658405086, 0.5887153418278446, 0.10752791236273518, 0.11188117639260708, 0.11313329660730886, 0.140228933983071, 0.1165941476796345, 0.1573750344537067, 0.1371143211239796, 0.14792256500727186, 0.07521181604927751, 0.17770102762738604, 0.310321075395277, 0.1713009241666814, 0.3766630378916306, 0.29229145285415603, 0.28332978594748714, 0.34110653481153363, 0.1825915544145501, 0.20578052509775502, 0.23658642900718996, 0.2582679476127534, 0.26572082466000146, 0.3371363085108494, 0.23499299530525486, 0.34363883450545296, 0.34651130189520774, 0.2993251105971694, 0.4780163832068277, 0.23985407082477705, 0.27322661732946607, 0.21061705265124198, 0.25346026351978557, 0.20856719978646454, 0.21671779582167172, 0.2029535156082346, 0.3001156132615316, 0.2376505956504842, 0.23810984098770616, 0.24886527975854955, 0.21045286175237787, 0.21070627475084747, 0.2501128545744683, 0.2532296350911495, 0.49402402026942016, 0.23814896073673464, 0.27282123139375447, 0.2012359891438842, 0.18497200823924165, 0.19388666118300846, 0.20770455729266546, 0.19031700545237396, 0.18795391818577312, 0.1879187340746361, 0.2458792841692592, 0.1743661165143391, 0.8118422569788948, 0.18744972325430476, 0.1537261990551213, 0.8488676440031854, 0.19713738056573482, 0.198754681954167, 0.171047327102551, 0.666090326377002, 0.8406599144550955, 0.7932712975799526, 0.2117536309487068, 0.7797568242339248, 0.10447836177585923, 0.1663271735800277, 0.1498573510912249, 0.6245175445589763, 0.21043363730907183, 0.7349694791831387, 0.26779873197384463, 0.2318512940217935, 0.19133915564213821, 0.19015810365310026, 0.2050924787076044, 0.20367110696460966, 0.22344052164262984, 0.2247659322417398, 0.2449883798452408, 0.10558479616798233, 0.10609954673783673, 0.08988217205855176, 0.10507239852953953, 0.09261027765373142, 0.1356174920133444, 0.1058362408498944, 0.09324519918997665, 0.09497601499041353]}, "mutation_prompt": null}
{"id": "fee1db6d-8a7a-4820-8db4-df9ec5847df1", "solution": "import numpy as np\n\nclass HybridSwarmDifferentialLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.w = 0.6\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def differential_mutation(self, particles, best_idx):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), best_idx), 3, replace=False)\n        mutant = particles[a] + self.mutation_factor * (particles[b] - particles[c])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return np.clip(offspring, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    mutant = self.differential_mutation(particles, i)\n                    child = self.crossover(particles[i], mutant)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "HybridSwarmDifferentialLearning", "description": "Hybrid Swarm Intelligence with Differential Learning combines particle swarm optimization with adaptive differential mutation strategies to enhance exploration and exploitation for faster convergence.", "configspace": "", "generation": 29, "fitness": 0.266540443676964, "feedback": "The algorithm HybridSwarmDifferentialLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.6703653541673631, 0.6562014765180695, 0.725507690161272, 0.5780592117970564, 0.6362307765333806, 0.5979204411062473, 0.6245424671413612, 0.648631467359162, 0.6452143627152764, 0.22259970524639405, 0.1571043296660286, 0.2728272070810184, 0.2150306406418132, 0.20929943861971745, 0.24585807604958643, 0.20580599753752526, 0.23943956122896026, 0.1587468425417552, 0.11549725115912823, 0.12243277710810396, 0.07070137316303626, 0.10316076662203377, 0.12149619223827068, 0.09756693359869373, 0.13499247993140762, 0.13420807252556843, 0.12488358053366266, 0.089008740814148, 0.11914675013133369, 0.12415420488688977, 0.11723943232210166, 0.06855803776329972, 0.14128121213004852, 0.1053674773288692, 0.12183459512060801, 0.12068460299748185, 0.9839319953133517, 0.9710077230943914, 0.9862226337813856, 0.09951857661184205, 0.9736362340735856, 0.9755459911123249, 0.9856619843560153, 0.977375036454685, 0.9756727940582661, 0.40981647842167035, 0.3438368981882455, 0.2584476532511577, 0.4263679440742487, 0.22939012018392557, 0.32631151733866004, 0.3944507623632867, 0.08827297728811989, 0.3790669204711208, 0.3449035790618279, 0.22491990150781183, 0.7123337331606614, 0.19278157670235385, 0.7924756901793292, 0.20373624391516654, 0.6415505044439894, 0.5238772975277484, 0.6401428329339303, 0.2771822578367733, 0.3359226037279843, 0.3018759986760483, 0.10593522547785139, 0.15505137006555048, 0.12556201657771604, 0.39991774820043424, 0.3199354343041868, 0.3109959775828862, 0.11966085098110402, 0.15469610490953822, 0.11025114377935274, 0.34447275581066106, 0.11969302625483103, 0.15750331194568679, 0.3305592300297482, 0.10918721969678336, 0.2436463283774144, 0.016904577806978738, 0.018629505269194158, 0.10541206346325671, 9.999999999998899e-05, 0.07164502048167998, 0.027216117102842108, 0.0821095716167829, 0.060668661501101284, 0.11500954996908952, 0.2206702697187335, 0.1019384868340385, 0.23380423311247467, 0.26150477489816193, 0.1738418340557253, 0.10230105558018476, 0.2669192190194756, 0.20436370322381958, 0.1398253565311003, 0.021434944867962935, 0.024349265924149766, 0.05618643959324088, 0.08319445728298891, 0.055502529474426465, 0.051982571062041294, 0.057615767284180386, 0.18280347640364447, 0.0801304269337848, 0.14992544326836688, 0.14692291470105012, 0.13188640572890165, 0.15285052644756247, 0.1723762169336287, 0.21786216526204716, 0.07870592311786606, 0.08727306843697147, 0.07268855402807561, 0.4937479874095123, 0.4521340175907148, 0.47232115954175213, 0.520761623709453, 0.5329317850985742, 0.47182269277152633, 0.5374672975053227, 0.5471800172163535, 0.5156755448407422, 0.11204998607751948, 0.1083003463165827, 0.09499884105705458, 0.11823464848218812, 0.1270438762895696, 0.10405320901578363, 0.08342251250458799, 0.09909013098266928, 0.11589052795074373, 0.34870455842104053, 0.28475901309344864, 0.17831598790483016, 0.20334705848146495, 0.22528597541330042, 0.20935932694720827, 0.42672394332629515, 0.23068909484441436, 0.21123574598459383, 0.32101755527931497, 0.3417816430402292, 0.25436139137127634, 0.2142968672890262, 0.33288429135791653, 0.3465426644797932, 0.34330009000314343, 0.3436570600448996, 0.3416971153774577, 0.272419286795611, 0.2178855375186174, 0.21487671276178788, 0.17692469221683316, 0.21738780275147707, 0.28649212365543886, 0.325635887321718, 0.2498160112242872, 0.15796739126101544, 0.20167475079561004, 0.20682425796059767, 0.20010797215401377, 0.21847145809779256, 0.2399779548456603, 0.18699344403425155, 0.2431641803608573, 0.20740429119886716, 0.20794532960909762, 0.20717747825034738, 0.2133225484877137, 0.18810863564787628, 0.19096694726178243, 0.22605545359699986, 0.2147653603539187, 0.20938539688654467, 0.18080638583995312, 0.2052031541848427, 0.8269723332250581, 0.16815072520894714, 0.1526669425495769, 0.7439707555712343, 0.19911385326336317, 0.16705819129004706, 0.13976688326450548, 0.16231604278726186, 0.7561101941896504, 0.7654439619425843, 0.21207171807403402, 0.16511433246862595, 0.19619214224127834, 0.21671097740949308, 0.15444274333309782, 0.20922879880765, 0.14651485328302483, 0.21023011429500116, 0.19382544500707255, 0.19429075028644005, 0.23421047466461542, 0.18306494263727713, 0.20770311464762592, 0.17824317183214422, 0.20226832767335023, 0.17815780522860336, 0.19609717631450085, 0.11188798085387408, 0.08792563984009061, 0.09827219695333422, 0.08739775405231154, 0.079231059102158, 0.0891363307019577, 0.09438922243642445, 0.09172445655923933, 0.0885295626090914]}, "mutation_prompt": null}
{"id": "69565410-83c1-4f1e-b6aa-876920de34d6", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "93adc0e4-4f00-4624-befa-da2f14fbc5c0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.F = 0.8  # Differential mutation factor\n        self.CR = 0.9  # Crossover probability for DE\n        self.evaluations = 0\n    \n    def initialize_population(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def differential_evolution_mutation(self, particles):\n        indices = np.arange(self.population_size)\n        np.random.shuffle(indices)\n        for i in range(self.population_size):\n            a, b, c = particles[indices[i]], particles[indices[(i+1)%self.population_size]], particles[indices[(i+2)%self.population_size]]\n            mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n            cross_points = np.random.rand(self.dim) < self.CR\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            child = np.where(cross_points, mutant, particles[i])\n            yield child\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_population()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # DE mutation and crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i, child in enumerate(self.differential_evolution_mutation(particles)):\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n            # Update velocities and positions (PSO)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n        \n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Hybrid Differential Evolution and Particle Swarm Optimization (DEPSO) algorithm combines population-based differential mutation and self-adaptive velocity control to enhance exploration and exploitation for faster convergence.", "configspace": "", "generation": 31, "fitness": 0.3498937910687515, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.7779555526532939, 0.7712523281575531, 0.7761869733360502, 0.7634597454123884, 0.7745383493002898, 0.7687320408559837, 0.7574191063798839, 0.7534305384007163, 0.7639187393522052, 9.999999999998899e-05, 0.45106714934754877, 0.5471759248066128, 0.49631600691468825, 0.4841096688580814, 0.5046927853867946, 0.5207539233684088, 0.4295145836844475, 0.47207027236893506, 0.12710088216308046, 0.1115395172994984, 0.13887782717541053, 0.14701075254624685, 0.1544780646557854, 0.12249959355273354, 0.12198192544255804, 0.11092069498534729, 0.13560889029534284, 0.09906614071428521, 0.07961880823231315, 0.10128337079994476, 0.09356124922963027, 0.09485145459946798, 0.11515440739648108, 0.09434852641866487, 0.1049778071866615, 0.10630269637612078, 0.9636782021205079, 0.9850702009690938, 0.9731708390155571, 0.987368863147292, 0.98769741938388, 0.968174314429809, 0.9784568664644578, 0.9857006571019795, 0.9850500529296343, 0.5790370476405249, 0.5674123803723512, 0.5113971389944134, 0.5512914435327472, 0.6136457195256185, 0.5414753251468118, 0.12089154907010724, 0.5525257913094368, 0.5910397960070276, 0.84061724613008, 0.8836070784012034, 0.809137227018097, 0.191555295074332, 0.2629924404616216, 0.2125523038581082, 0.23368012708979546, 0.8369643326418761, 0.7902285565628298, 0.5450946042389244, 0.12957448789433001, 0.11749757770052716, 0.12341868863581495, 0.47936699430114593, 0.5277203686396567, 0.5318128919423497, 0.5529151745096738, 0.4888680346673746, 0.47670940096337877, 0.4620749862663577, 0.43282745518999244, 0.47834884292147895, 0.3285390999057932, 0.49943809641010595, 0.325870185753126, 0.47764224749994066, 0.4858486417073641, 0.06893167185387594, 0.2551126703206723, 0.16282190787478013, 0.0005100187824657043, 0.4617541546631855, 0.16181526308901362, 0.4486460075206371, 0.3557778733664976, 0.25895972897624575, 0.5099250000876573, 0.2013230770298413, 0.5680271261066605, 0.42778958153664637, 0.07624589476447108, 0.2600387178493707, 0.4583202012653562, 0.5736460705667354, 0.4673560561696529, 0.04254084675620762, 9.999999999998899e-05, 0.06495488635990931, 0.3220261455294794, 0.08099203304562341, 0.13514913839506915, 0.13168891632527924, 0.10428697634430262, 0.1709323106970343, 0.153938713883791, 0.3122064529524998, 0.31077624670532045, 0.0059712824932471875, 0.03691678313859825, 0.16413761336850874, 0.04829268089977745, 0.24517455947868916, 0.09600600612265475, 0.6294693845969803, 0.7017054299066499, 0.7414029828301665, 0.651139746984872, 0.6549740623548419, 0.7097178819190978, 0.6893661946330623, 0.70038692424786, 0.6722329631471959, 0.1210307418852753, 0.12491138228440068, 0.1288509351281929, 0.08613162617847958, 0.10265606807230543, 0.11871693275758566, 0.14975165275312707, 0.1440579321805331, 0.15184776061460326, 0.21110863447530315, 0.19566232254734284, 0.2118609848042018, 0.23910457807056773, 0.1694794063932259, 0.19213938003401632, 0.28045760449797685, 0.19621758541843193, 0.18148239450587167, 0.2418978066602131, 0.3810373284188018, 0.4988475069616668, 0.4697430047595115, 0.35589039935219546, 0.42058884915190065, 0.4079989705671204, 0.4362683935857741, 0.4843413920399955, 0.19541773117340577, 0.24976067617251296, 0.19697870239854764, 0.3117221556868318, 0.21195677094979914, 0.2717926714155192, 0.2128225942456613, 0.22479290613415237, 0.2666981252552677, 0.26953097484726596, 0.18514899066767554, 0.2471269340963711, 0.23828546287276997, 0.2055988507272366, 0.20082345517465972, 0.22741431946122215, 0.2310183473181684, 0.21754806715060404, 0.19846727977114165, 0.22137495979919009, 0.21151181527658347, 0.19895704015293747, 0.18493214042110373, 0.1821600733911548, 0.2430764295974902, 0.23057621907816772, 0.18201050635441585, 0.16474133920168332, 0.175234433773356, 0.15262139166248256, 0.16142994088689833, 0.1987413769366433, 0.16656147190558424, 0.8003156599457839, 0.8239765233480756, 0.1673323724366914, 0.8535382448018196, 0.21076508322567533, 0.8580581514105233, 0.8621908439228658, 0.1268968488197948, 0.7456750909058735, 0.20894807141965088, 0.15285393382233847, 0.15468829052305277, 0.19222920581561853, 0.18108859012097178, 0.19691877955335202, 0.18425353114193754, 0.18325430267965404, 0.22762257221240834, 0.19673986744370286, 0.23808386270896642, 0.19283417394418279, 0.11891384352165202, 0.15001405433413506, 0.09797145876882474, 0.10581751973048414, 0.09457520710886769, 0.10719114176892652, 0.08497375709384547, 0.08776025424324596, 0.09931142988181185]}, "mutation_prompt": null}
{"id": "540ac181-8454-44a7-b34c-a897524c9b62", "solution": "import numpy as np\n\nclass EnhancedSwarmAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.7  # Crossover rate increased for better diversity\n        self.evaluations = 0\n        self.velocity_clamp = 0.5  # Velocity clamping to prevent excessive exploration\n\n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        elite_position = None  # For elite preservation\n        elite_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n                    if score < elite_score:  # Update elite if necessary\n                        elite_score = score\n                        elite_position = particles[i]\n\n            # Dynamic inertia weight\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n                    if score < elite_score:\n                        elite_score = score\n                        elite_position = child\n\n        # Return best found solution\n        return global_best_position, global_best_score if elite_position is None else (elite_position, elite_score)", "name": "EnhancedSwarmAdaptiveCrossover", "description": "Enhancing SAC by incorporating dynamic inertia weights, velocity clamping, and elite preservation to improve convergence speed and solution accuracy.", "configspace": "", "generation": 32, "fitness": 0.2883419025796282, "feedback": "The algorithm EnhancedSwarmAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.7539779407738145, 0.7356334100117505, 0.6887290131978456, 0.72820503249719, 0.6807368993713286, 0.6991293310120893, 0.8062978200582117, 0.7182803215205997, 0.790533095855207, 0.2783066708835188, 0.12778742458254, 0.25542178563608464, 0.09047386254544021, 0.1335920433119041, 0.11558631052491442, 0.11871747041303138, 0.2436921895757156, 0.20848160023083018, 0.1558688289845177, 0.13113214288856834, 0.11129524558256376, 0.12354352847174199, 0.44668060096328965, 0.17938180952714378, 0.17343626817349833, 0.13956872808773446, 0.15424665573095064, 0.12317480648994283, 0.11738624246708551, 0.11024530405207456, 0.11369180762333475, 0.11901325917959582, 0.10459104603672209, 0.10556016449725181, 0.1323494710703852, 0.12060686714126201, 0.8784551791812765, 0.8634585782302286, 0.8569535250428002, 0.8591974932439376, 0.864592607824375, 0.8713656983062325, 0.8651259866000955, 0.8430665612190822, 0.878668675261493, 0.39247223473816994, 0.4336489090880695, 0.3967253020255608, 0.3722011913056733, 0.4301254760374612, 0.4105336370248829, 0.3898132191859385, 0.3167452843910893, 0.4227930519160433, 0.22773919467559622, 0.2229833055924385, 0.21553090350787796, 0.25951174886156136, 0.371597589169545, 0.21361664580170647, 0.17374626500593326, 0.17437160242742977, 0.2305687113412649, 0.21516220605793102, 0.12856723851002405, 0.22620719409466317, 0.32302806145752994, 0.3228843545793697, 0.2708539232324503, 0.2481677886791842, 0.47907753714904566, 0.37424011439099636, 0.20031454080753042, 0.1857212663111366, 0.34449063505693844, 0.16743983708135968, 0.2144240812180146, 0.12961726368364324, 0.19332616176113182, 0.17566582545994391, 0.20331201808774735, 0.01270097608164411, 0.019182384907811878, 0.036396270830832744, 0.06838885315100651, 0.0814581744505527, 0.047767172453534346, 0.057862248523052995, 0.02334248826767249, 0.023795597693885062, 0.18533238490190596, 0.11917302008456776, 0.1527883687866699, 0.10090722081781456, 0.06798541132508051, 0.13485259688104612, 0.1558716728030286, 0.21353865604031752, 0.186275502643115, 0.05618369165606951, 0.21656267237865456, 0.13133218341511022, 0.08322555149228195, 0.10335255640496199, 0.08610361074251505, 0.22557487666010811, 0.1413015074926618, 0.16192020368965188, 0.21397116045458364, 0.12396466703635234, 0.21162230024665485, 0.09932066626695357, 0.19881936561099844, 0.09227591446524386, 0.15294056780133491, 0.15730610180759597, 0.15450446098103365, 0.49866460034211546, 0.48869724739963794, 0.5212553968534062, 0.4854620228404013, 0.4567660762729031, 0.4711304761811692, 0.5490685099539148, 0.5361518573255238, 0.5168693149116899, 0.08769199213602219, 0.17693890901201426, 0.08543222106067772, 0.15076992800713107, 0.11229821651810323, 0.12250898873538685, 0.1290295612938981, 0.15116669340144417, 0.13646862165699003, 0.227385776684078, 0.549864663222798, 0.38921306526754984, 0.23834783629455403, 0.27364621050455096, 0.1832814514945399, 0.2440784112456017, 0.3349078596381211, 0.4062391062622517, 0.2574942442806465, 0.267159288277938, 0.20177366601549052, 0.3474754411768486, 0.3026927049755026, 0.2651378664330879, 0.2268826591126678, 0.32191925347269323, 0.25944637786257563, 0.30301102230737753, 0.20105470121911662, 0.2161969434509886, 0.24752446623426472, 0.23961024498404726, 0.1796409382123082, 0.2079606734215338, 0.22556920136190117, 0.22674032473568828, 0.23025157809938301, 0.21404460456899654, 0.5483611500751739, 0.2420463019997351, 0.2957729501367592, 0.23244082523448706, 0.2592779045157342, 0.24574883244700618, 0.22168697914953928, 0.17448511869993066, 0.19220891872219203, 0.1825807945526109, 0.20702770208577226, 0.18780897783595019, 0.20357574034510828, 0.20440359933722096, 0.19039688678764255, 0.2156768740076762, 0.18359618811201206, 0.18642616736232653, 0.8405537165124108, 0.8537750332649451, 0.9043179525561251, 0.8017543234603501, 0.1583075530528284, 0.1678624532057471, 0.8483156453530305, 0.6698904551819256, 0.725368691951277, 0.7103050083674127, 0.7366895805990057, 0.1662020529525391, 0.15309238285418192, 0.1562166091663617, 0.5741135587304181, 0.5462014379455014, 0.18708321576836007, 0.19524439636948387, 0.17431230718423163, 0.19056618752917742, 0.19662615124005967, 0.2015113264063173, 0.21115092446708672, 0.21043372504328306, 0.20410598006579583, 0.10097914785633133, 0.10114879504836172, 0.07491290676328077, 0.11091423675135081, 0.09948772999801991, 0.12339943081294824, 0.10265285011150738, 0.08574435342295217, 0.08880302824028719]}, "mutation_prompt": null}
{"id": "1c49a28b-84ac-4dfe-a0ae-7bf56429356b", "solution": "import numpy as np\n\nclass EnhancedSwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.7  # Increased crossover rate for faster exploration\n        self.evaluations = 0\n        self.mutation_factor = 0.8  # Differential evolution mutation factor\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def differential_mutation(self, pop, i):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        indices = indices[indices != i]\n        a, b, c = pop[indices]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.lb, self.ub)\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            # Dynamically update inertia weight\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover and differential mutation\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    mutant = self.differential_mutation(particles, i)\n                    child_score = func(child)\n                    mutant_score = func(mutant)\n                    self.evaluations += 2\n                    if child_score < personal_best_scores[i]:\n                        personal_best_scores[i] = child_score\n                        personal_best_positions[i] = child\n                    if mutant_score < personal_best_scores[i]:\n                        personal_best_scores[i] = mutant_score\n                        personal_best_positions[i] = mutant\n                    if child_score < global_best_score:\n                        global_best_score = child_score\n                        global_best_position = child\n                    if mutant_score < global_best_score:\n                        global_best_score = mutant_score\n                        global_best_position = mutant\n        \n        return global_best_position, global_best_score", "name": "EnhancedSwarmBasedAdaptiveCrossover", "description": "Enhanced Swarm-based Adaptive Crossover (ESAC) integrates differential evolution strategies with improved inertia weight adaptation for faster convergence in diverse optimization landscapes.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('not enough values to unpack (expected 3, got 2)').", "error": "ValueError('not enough values to unpack (expected 3, got 2)')", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {}, "mutation_prompt": null}
{"id": "ffbef76d-afc8-4767-bd39-c039b525bc2e", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "38970219-ec32-476e-801f-362573f298d5", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "11916c8e-f497-4805-8d7e-7d033326853b", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "6eabbbe1-9693-408d-8d61-228e44bd31d4", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "3df1af38-20b8-4afa-9f54-6ff7c4fbc138", "solution": "import numpy as np\n\nclass EnhancedSwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.7\n        self.c2 = 1.7\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.alpha = 0.6  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def elite_guided_crossover(self, elite, candidate):\n        if np.random.rand() < self.alpha:\n            return self.adaptive_crossover(elite, candidate)\n        else:\n            return np.clip((elite + candidate) / 2, self.lb, self.ub)\n    \n    def update_inertia_weight(self):\n        return self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            w = self.update_inertia_weight()\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply elite-guided crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    candidate = personal_best_positions[np.random.choice(self.population_size)]\n                    child = self.elite_guided_crossover(global_best_position, candidate)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedSwarmBasedAdaptiveCrossover", "description": "Enhanced SAC incorporates dynamic inertia weight adjustment and elite-guided crossover to improve convergence speed and robustness.", "configspace": "", "generation": 38, "fitness": 0.2283292635791858, "feedback": "The algorithm EnhancedSwarmBasedAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.5675481597517167, 0.5764223812990054, 0.6382944498475814, 0.5595751477045362, 0.6742063520931036, 0.5406398752159532, 0.5615732183974496, 0.6004999822790851, 0.5800274159575999, 9.999999999998899e-05, 0.10000785859032402, 0.10817865989977005, 0.1485423410394524, 0.025556401263349127, 0.023727420859582016, 0.10994009781885505, 0.18810288579438994, 0.02458105526902654, 0.0536390420137044, 0.10696691430252936, 0.1260796082937803, 0.10192801879401647, 0.10650041430193702, 0.0817490674601784, 0.08587646663633608, 0.15634692162989305, 0.09618461757291885, 0.053951801456193826, 0.058169366499232766, 0.10851844221066587, 0.10066364948011453, 0.10241125510619786, 0.08404061056041068, 0.1199706089234096, 0.10322270874223582, 0.08786899787932312, 0.9885034856959214, 0.9850306046330185, 0.9885773903550797, 0.8885266808758494, 0.9813288699063677, 0.9778946077894871, 0.988710903676636, 0.9814487255683513, 0.988466503346447, 0.31706591501601755, 0.31943336569316394, 0.37156886968004, 0.2792230468322895, 0.1431202776525704, 0.2649054517714743, 0.3668674422203716, 0.345745429822807, 0.35048629781314633, 0.3135935387150519, 0.17242087604850276, 0.21199255895850877, 0.19431370426866357, 0.1148943442043332, 0.19296707994848117, 0.14495992930454138, 0.3130323057539065, 0.23681497579928723, 0.2132489095383272, 0.11938981470594989, 0.16608136454097056, 0.24238827536689422, 0.13952367255501574, 0.10719529005476902, 0.3197344283489624, 0.15709819072992726, 0.24948446562487958, 0.12695627111384167, 0.11462078298737377, 0.2842255722269429, 0.12552929871390517, 0.1457671912175711, 0.2393789669963693, 0.22307154945144192, 0.1395533143977996, 0.0034666367174149837, 0.024115944463531935, 9.999999999998899e-05, 0.021551608318048032, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06393071242364856, 0.018274660462149983, 0.059713769097986535, 0.0942534605038734, 0.04473131681597475, 0.08482558537366691, 0.04946945937532432, 0.013996128027542909, 0.0472818488992649, 0.1326852344084587, 0.012448038665546446, 0.04435323066203478, 0.05131844487177606, 0.11010730791010848, 0.03615213779518234, 0.14256205524755583, 0.046762991348705873, 0.08353422127918397, 0.06628230475749464, 0.23452681956893628, 0.08583041826195803, 0.18462891607280774, 0.08112948137330933, 0.12051651406384478, 0.06849744765945542, 0.11688869134156354, 0.07318313940964494, 0.09607116755871248, 0.05222913040236565, 0.10155036608214085, 0.4419403099878445, 0.46613566091024594, 0.4129720427895255, 0.4307100294111865, 0.40374115979488334, 0.2894376230144047, 0.3879951624610807, 0.4073622309089099, 0.43504354425653546, 0.06570559864984493, 0.089728142825927, 0.11775320489499186, 0.11118005476879567, 0.09342542001899878, 0.12916537994675814, 0.08852085935940979, 0.050844425761924716, 0.07215502242438598, 0.22760098211624635, 0.16953635659248045, 0.17058704329844965, 0.18157575722931396, 0.18240025475514243, 0.17398375330758975, 0.20271820261057938, 0.1800566264068837, 0.20166348492202446, 0.16694029144793165, 0.208965527573287, 0.23806686302383195, 0.28008139448609193, 0.22452151598283288, 0.2637306650171748, 0.21382147132149587, 0.2613359004755479, 0.2314215034647601, 0.16729439707673188, 0.21137382263558524, 0.18969577574466945, 0.1810090917401891, 0.19384286244074767, 0.2204515479834931, 0.19251709689498597, 0.21677201810451774, 0.19160330626821664, 0.206271925958458, 0.19544532987460672, 0.2430537238322198, 0.23203369391381334, 0.2121025209604288, 0.1883387457309419, 0.23718195109913476, 0.2102833675416006, 0.1972892583518644, 0.18333550030629875, 0.17262951123710357, 0.1802246133257015, 0.20933628106053936, 0.20530415795045875, 0.19313310560315122, 0.1972522024198401, 0.20648621108014587, 0.1784257936186301, 0.6998740883957522, 0.187806832729576, 0.15453485914675258, 0.7644698197049713, 0.19634565448050256, 0.19287889750096654, 0.14151582091212345, 0.16717512586229355, 0.7130967222521492, 0.6476377028611757, 0.2089096495978452, 0.3580694792819915, 0.33477078342189415, 0.1632109190251707, 0.14270142506876582, 0.5567010281481736, 0.18315674635372303, 0.5347958295616231, 0.20547155481569368, 0.21292008669747664, 0.1962191434898839, 0.2111377451565768, 0.1858435495252423, 0.21878624163422578, 0.18138883733596267, 0.18059879209409013, 0.19697041299693652, 0.08098410203230466, 0.07889140214782697, 0.06821160530056658, 0.07210952741464005, 0.08244312736405068, 0.08730250322827193, 0.0863234841505175, 0.08593193910426233, 0.09040227125442912]}, "mutation_prompt": null}
{"id": "53da69a7-8f0b-483c-983f-4d4a7c53ad4b", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "7b03f05a-2802-46b7-b369-39c1d1be7871", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "991f2bed-218c-4edf-89ab-594b96c159e2", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "27908845-cce1-4822-b456-bab709ceb975", "solution": "import numpy as np\n\nclass EnhancedSwarmBasedCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 2.0  # Increased cognitive component\n        self.c2 = 2.0  # Increased social component\n        self.w = 0.9   # Start with larger inertia weight\n        self.alpha = 0.7  # Higher initial crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def dynamic_inertia(self):\n        return max(0.4, self.w - 0.5 * (self.evaluations / self.budget))\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        restart_threshold = self.budget // 4  # Resume search strategy\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            self.w = self.dynamic_inertia()\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            if self.evaluations % restart_threshold == 0:  # Restart strategy\n                worst_idx = np.argmax(personal_best_scores)\n                particles[worst_idx] = np.random.uniform(self.lb, self.ub, self.dim)\n                velocities[worst_idx] = np.random.uniform(-1, 1, self.dim)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedSwarmBasedCrossover", "description": "Enhanced Swarm-Based Crossover (ESC) incorporates adaptive inertia, dynamic particle interaction, and strategic restart mechanisms to accelerate convergence and improve solution quality.", "configspace": "", "generation": 42, "fitness": 0.32124752343343066, "feedback": "The algorithm EnhancedSwarmBasedCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.8027037973198168, 0.8016754461270079, 0.8141940894180961, 0.8167924508867668, 0.7836165076968276, 0.8060163385583489, 0.7729030175406, 0.8261621697738393, 0.8098413005405115, 0.5009283618689682, 0.540307028791337, 0.3389195203295009, 0.4915274077589996, 0.4126986461775356, 0.4860002226323672, 0.4700535621936367, 0.5476535228858013, 0.5547771619633687, 0.6775866097365649, 0.113165992368224, 0.11436704304637058, 0.1158181621856762, 0.1813634997732012, 0.08240556036364288, 0.18239498241425434, 0.15708832240403103, 0.11445997571777367, 0.09805385893553697, 0.11475648355170665, 0.09240549813156562, 0.09494086325203421, 0.08759123977009786, 0.1315037136101177, 0.09351177404932409, 0.10646158666846628, 0.10063842625640007, 0.9852039669454321, 0.9852276273667172, 0.9851529084041885, 0.9771799035995596, 0.9825148086341852, 0.9704515400257788, 0.9855976597020559, 0.9780964686053771, 0.9842440915904322, 0.5235395620426159, 0.5644498994740794, 0.5150618996307427, 0.48238131296534525, 0.48982015751477215, 0.37669802768584926, 0.4821247482518417, 0.46132868579897157, 0.3992864370539023, 0.23733875455666886, 0.13897897442253215, 0.24049540581733986, 0.21487451039446992, 0.27043334096728255, 0.18988742155039462, 0.7687725175757808, 0.15119263817642348, 0.17887030588515807, 0.5275695273989528, 0.13023041011905556, 0.4246596812983421, 0.3511748157963389, 0.5857649196301224, 0.34246338371891705, 0.47533753563395054, 0.5901072842744242, 0.4455317953199158, 0.18453993631338872, 0.37548754290838693, 0.1239739967949749, 0.31574068562313606, 0.33237217251928775, 0.11947737043803786, 0.4128697169488136, 0.2686066094909684, 0.3484575461916224, 0.2123607482468014, 0.1215221537987089, 0.031080818078158656, 0.029414346648725775, 0.018733622263214733, 0.04187454124507206, 0.05604833408630072, 0.1795196290085549, 0.3204137735868504, 0.234147895593386, 0.2051513677200245, 0.1711332983483329, 0.16669926129823176, 0.06124689513032011, 0.1591853944581546, 0.130202747235883, 0.16907158959107582, 0.16500990452181663, 0.2289279876618141, 0.1499172319702875, 0.10238444961817861, 0.10216566686827677, 0.22976066603293632, 0.13746664991034907, 0.13641619276425976, 0.18681314027667062, 0.09792029134316504, 0.1694944649577983, 0.22202338196724436, 0.16271436718011356, 0.19357424959100133, 0.13173889241809378, 0.085422744258563, 0.2016993228301962, 0.22449907795535762, 0.1035369204692248, 0.6735846722545766, 0.6512743178242972, 0.6776612461469051, 0.6447647474054158, 0.6019265416193442, 0.5301286691175369, 0.5937932134321644, 0.6253808975131638, 0.6335920501512582, 0.09414617183231644, 0.1008321692485602, 0.08760410466205826, 0.17700912791246515, 0.18092175667445787, 0.10990542279214643, 0.12145400847251675, 0.10825456940917788, 0.09152078387139717, 0.2605327540541976, 0.16395599764990498, 0.20894189326096346, 0.41547837247553876, 0.6858140179389713, 0.2675541771607899, 0.4392119670883702, 0.18030827777991143, 0.18554440235533742, 0.28197573721817637, 0.4094118914712336, 0.3656330276702757, 0.27160222133278733, 0.4587922323503447, 0.26935796631030684, 0.2896475651788557, 0.26299693126143797, 0.4178359087568795, 0.23660676801211888, 0.301875364171736, 0.31372767344529884, 0.23481399127417113, 0.23273777465099177, 0.2892330894522406, 0.2649899366305871, 0.31480049706987956, 0.24634917046668048, 0.2316773311767768, 0.2204035954339031, 0.22675617353834832, 0.24399110304065974, 0.2320107709883128, 0.20305348435481796, 0.31266781952890565, 0.21596855129701664, 0.2143370611162143, 0.17899938699694107, 0.2233772706556194, 0.19246277939174328, 0.1885837275385226, 0.2374480202410304, 0.18332303045662568, 0.1830009574998862, 0.22203832413788727, 0.19995500242674003, 0.8712825708819054, 0.18660313474496737, 0.15266861461647974, 0.19865992377553898, 0.19882375222602844, 0.1991015956269534, 0.17088917742193754, 0.1693422186435679, 0.8751832147876993, 0.7384551996996607, 0.21174000497212608, 0.7694123033693872, 0.10379001404841404, 0.16700062519077474, 0.15264291440253164, 0.16743851766096962, 0.21001742087857334, 0.7904711816803601, 0.20672159145662772, 0.20376486776533542, 0.21136462604781048, 0.19914746192736965, 0.19609603084394533, 0.21490899377102646, 0.21341731472772985, 0.21112517278444953, 0.20674672108570824, 0.08261250757297345, 0.10302257526074898, 0.10070040472209962, 0.0966776510988584, 0.09452465613352268, 0.07809434873816934, 0.11097149536093498, 0.10021768664319475, 0.09414543571694611]}, "mutation_prompt": null}
{"id": "5196102b-d739-41e7-ba2f-7b33155731c0", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.c1 = 2.0  # Increased cognitive component\n        self.c2 = 2.0  # Increased social component\n        self.w = 0.4  # Reduced inertia weight for quicker convergence\n        self.alpha = 0.6  # Higher crossover rate\n        self.evaluations = 0\n        self.v_max = (self.ub - self.lb) / 5.0  # Adaptive velocity clamping\n        \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = parent1 * np.random.rand(self.dim) + parent2 * (1 - np.random.rand(self.dim))\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = np.clip(self.w * velocities[i] +\n                                        self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                        self.c2 * r2 * (global_best_position - particles[i]),\n                                        -self.v_max, self.v_max)\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedSwarmOptimizer", "description": "Enhanced Particle Swarm Optimization with Adaptive Velocity Clamping and Dynamic Crossover for improved convergence speed.", "configspace": "", "generation": 43, "fitness": 0.35419401207211715, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.8010285364715417, 0.78874519580255, 0.7932948707656111, 0.746171173597953, 0.7950095045700434, 0.7704303246416939, 0.7838861238600088, 0.7895151297225176, 0.7903712158015505, 0.5476976693904252, 0.4763834199935, 0.4445041015195713, 0.5320778943182909, 0.5683968135095452, 0.5105453090596435, 0.46933582113711814, 0.42568690667255316, 0.5100424666552263, 0.17684990017113122, 0.15451238397221445, 0.17448977908580832, 0.15810814320113242, 0.49948903352408935, 0.12679922412554168, 0.5238304772333038, 0.1284251358825097, 0.15470229536904878, 0.16239007249893345, 0.1521925673959268, 0.11878590546040868, 0.13623463954048642, 0.12570187213494688, 0.13659423158896788, 0.13758496696646838, 0.17922516233110963, 0.17849837270743396, 0.9355741594695868, 0.9256233660615696, 0.9414356691626037, 0.9359995618130674, 0.9335437148989054, 0.9357423167995844, 0.9385793207649865, 0.9333302217362882, 0.9425837311058316, 0.497700424411906, 0.5097732918817535, 0.4611195279844963, 0.4697291377840147, 0.4299219838295889, 0.5016028476163512, 0.508713879118396, 0.48390980575864606, 0.4368697181936617, 0.8463916893765251, 0.8579674335594478, 0.717477217475953, 0.35587046502290653, 0.8701275759835174, 0.7383592332728801, 0.764811131463447, 0.17663714719137424, 0.22680264599577438, 0.400367907840782, 0.563655447291607, 0.4685884908643183, 0.5206979562390708, 0.4423872008203079, 0.3085321833010427, 0.36774620139829084, 0.3018249642916919, 0.2812211701486361, 0.28633633183947493, 0.3974269473234461, 0.3488500399087522, 0.34338706038529987, 0.5123358800996825, 0.4485376675471392, 0.2892029289997907, 0.24274528132145146, 0.4870551315379935, 0.08757565519812394, 0.13072962352180306, 0.1752826617374259, 0.1656156391982435, 0.05038821267910931, 0.09776102735301995, 0.10656568580701464, 0.37469888853674804, 0.18323634161748448, 0.18419428041152397, 0.09584909834999034, 0.2776560989348439, 0.07208401216381155, 0.06231899488686854, 0.13098606245678124, 0.17763451877317438, 0.1730340864734573, 0.20987997147062976, 0.18304551340419328, 0.28513190985563674, 0.09096266483901849, 0.16577517236173844, 0.06395022288968033, 0.07922392952025947, 0.08152274738642518, 0.1874421117060059, 0.2007325690571391, 0.16704463369854838, 0.24077915646642345, 0.24305402047695945, 0.2170287554137087, 0.21522650180248382, 0.16140323995277028, 0.27699504178444445, 0.29352427417085314, 0.07896509755181347, 0.6555940114794883, 0.643805450480904, 0.6074875363880758, 0.6744687097346866, 0.5962208786613066, 0.6978246096610532, 0.7071595023344821, 0.5739914245785891, 0.6260377468838602, 0.1103650272813066, 0.15227905465485236, 0.16357643702869795, 0.12181228654686183, 0.09173973340964914, 0.12577602299272073, 0.10680359288511787, 0.1092791947395011, 0.1373050692521478, 0.16105303962740003, 0.14703457622108418, 0.21633820104079682, 0.361274562946576, 0.3483166453821004, 0.4539618611055313, 0.36854962607697117, 0.22248377382135176, 0.1761907454393098, 0.39045916842346573, 0.35109644807407514, 0.3309357357287812, 0.32554714301988474, 0.30635659590108155, 0.4044805997979942, 0.4548134752940939, 0.4043990529561018, 0.3747765800711075, 0.26306136486948717, 0.27797573821026267, 0.3063657832368616, 0.27745841738140764, 0.3093876684093366, 0.3015650869702615, 0.20872907388165973, 0.3004074286688482, 0.3468125218346455, 0.23303998252216618, 0.27203376442873584, 0.21002926813423606, 0.25662948145003206, 0.2582995917798948, 0.25845705531496166, 0.25559271822583407, 0.24180980437312805, 0.2223080457317438, 0.6498380689687812, 0.22669735839073923, 0.19729586690833478, 0.22172504058061604, 0.18112189765172793, 0.22249131860195337, 0.1826462532370483, 0.1996104450528725, 0.24756962444682906, 0.186221026987335, 0.18835240553947563, 0.18685830174432605, 0.1725118016295748, 0.7746003408583575, 0.19534683431787492, 0.14209759340081984, 0.8761386091363457, 0.8567049689616384, 0.8406520477373278, 0.21052165849967952, 0.8407025727822869, 0.21180086237118434, 0.15503478134598658, 0.1523075912142764, 0.10414538587480271, 0.814466793983764, 0.809468892019827, 0.19748020113381803, 0.19580252586383906, 0.21240682032381164, 0.18956318159871666, 0.23379357499860776, 0.19977007229881616, 0.22051068092235515, 0.18690572890072443, 0.19375842085944106, 0.08434219035304469, 0.09672101708003578, 0.09956712376497368, 0.10883058018577718, 0.10086225298434581, 0.10279531320722746, 0.08771789804045838, 0.10810160479337105, 0.09856109120084589]}, "mutation_prompt": null}
{"id": "e7a02a76-e43f-49de-a1a0-c6f9b5c2c76d", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "e73ca59c-48e8-4906-a069-b18abeef676a", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "abfb525f-9bab-41fd-9f25-4a7d746bb0d7", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "c665ba0d-656e-4f7e-b58b-94db6d893e61", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "6acf7458-4ee5-433b-a3c1-187011b7a972", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "f6c02784-9ea1-44ee-8e12-f5bb67f60f08", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "44bc0796-431e-4e9a-ba23-0ec756832644", "solution": "import numpy as np\n\nclass SwarmBasedEnhancedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 2.0  # Increased cognitive component\n        self.c2 = 2.0  # Increased social component\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.5\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            w = self.w_max - ((self.w_max - self.w_min) * (self.evaluations / self.budget))\n            \n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            elite_index = np.argmin(personal_best_scores)\n            for i in range(self.population_size):\n                if i == elite_index:  # Elitism: keep the best particle unchanged\n                    continue\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedEnhancedAdaptiveCrossover", "description": "The Swarm-based Enhanced Adaptive Crossover (SEAC) leverages dynamic inertia weights and elitist selection to accelerate convergence and enhance solution quality.", "configspace": "", "generation": 50, "fitness": 0.25499950525543197, "feedback": "The algorithm SwarmBasedEnhancedAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.6439371878092455, 0.6240106090851848, 0.6140036513599865, 0.6812494366567254, 0.64013119674837, 0.6308424351410042, 0.6729055859430544, 0.6243009745324744, 0.6207831614908914, 0.036737477261094664, 0.0666752511943074, 0.14482219316636658, 0.05930218782833674, 0.060324044957487444, 0.18222699211190985, 0.1452628800498622, 0.10961118742245146, 0.1966035955218396, 0.12019567058000025, 0.14993550648387077, 0.12186415824075536, 0.1547682101846518, 0.4013773160650723, 0.10690441976699017, 0.13066526206643558, 0.13271313015004216, 0.15321163218984946, 0.08350542604828481, 0.09098510727400955, 0.0706154445416931, 0.1360001066453066, 0.08162125860693847, 0.11984019353714981, 0.14134102654980052, 0.0886064706853158, 0.086544834515908, 0.9841998443532443, 0.9901838138084164, 0.9853680186854828, 0.9770139049505822, 0.9771808199669254, 0.9709666726024443, 0.9827652805991764, 0.9758614113630777, 0.9848094076350187, 0.4022315821345851, 0.34221520761644464, 0.31101035610406935, 0.31993687541605087, 0.29468482382451644, 0.345252890602069, 0.3243620181366802, 0.30694880176654726, 0.3564691720764479, 0.22937834609458474, 0.30104173971989967, 0.7328881656064848, 0.27760758147851816, 0.33072193869393984, 0.21288201780194593, 0.27147836305200446, 0.46132704427445703, 0.6178559925812483, 0.2963178889408371, 0.11501183698653072, 0.18386949194581692, 0.20292638252687234, 0.1042186826976691, 0.17085403735004911, 0.19724169000844016, 0.1233638946856328, 0.24400134652143335, 0.19770969325061094, 0.25059343139812384, 0.18956121476080368, 0.1588027551214244, 0.14133395009901129, 0.3554911641439932, 0.16029043957459366, 0.18461656376440228, 0.16720312016647076, 0.12403302544291306, 0.0017352797547665055, 0.0811298232013643, 0.04781077148681634, 0.03313948402511668, 0.0076131516050707004, 0.016508624527455718, 0.0441540939870696, 0.04635648186023389, 0.15111388461518305, 0.07129611318479567, 0.11249944892928543, 0.1275346387852876, 0.062415898386826485, 0.12315169379814872, 0.1242000373137716, 0.13447973216168796, 0.14705644552288466, 0.14027338499981035, 0.08023186863310061, 0.10855674718457142, 0.0692344663571337, 0.06035931218643997, 0.06227329076294297, 0.06380914862100195, 0.1563848520745209, 0.06408767972355656, 0.15865056051453108, 0.20414362531746577, 0.12783096481945466, 0.06765239433253478, 0.09214329192075077, 0.06083458458138924, 0.25618205624644375, 0.040375429872941404, 0.08086333681325286, 0.43590527289331316, 0.47534014965226357, 0.5032287658203649, 0.4425949109782231, 0.4203597250274562, 0.29568194464277886, 0.4592221008464704, 0.4598368476269733, 0.45798203237042834, 0.10562093386296201, 0.09295332620385433, 0.09383114216125288, 0.0895714979997132, 0.09825147266282952, 0.15024767802473837, 0.11150175837196652, 0.09391472760722386, 0.11995094657843952, 0.24564003875458473, 0.18430418223322265, 0.24266357746326417, 0.15673313828808622, 0.20442824343628319, 0.25314050265245025, 0.17026386788778092, 0.19426729273752052, 0.345581829063762, 0.23392115554563386, 0.3568259087989516, 0.27368647767840526, 0.2763350434225397, 0.21910536326913088, 0.2730645733830279, 0.236628998927912, 0.2817709264488739, 0.22626433361238718, 0.2247795746348421, 0.24941661369978185, 0.2243801820838125, 0.23625395391178583, 0.18657902350702804, 0.29467837950770426, 0.19163413986712596, 0.2634623713176546, 0.19909703619057417, 0.22182887880686497, 0.18245549257755878, 0.21923234309727613, 0.2108536349597473, 0.21025269842474859, 0.24010032655797098, 0.2157150979594289, 0.23275453212521535, 0.24448849963022512, 0.21155151846053244, 0.18933308341341915, 0.17262836409016158, 0.2120122776005655, 0.18841628047447423, 0.19251259164672752, 0.278116356046639, 0.2248609951912367, 0.1915056709704167, 0.18737316295707784, 0.6734908373426052, 0.15356174862240513, 0.7135100244118316, 0.2006709946110412, 0.1974671735338438, 0.1425904477519343, 0.1692871435157618, 0.6257493671323584, 0.6876060239042114, 0.2115919073749618, 0.6982883226721399, 0.19174360703858395, 0.1650607605098885, 0.15041355770436826, 0.20797596375838323, 0.20759020793396155, 0.5145673197269939, 0.18996470546177302, 0.20484215092266767, 0.195662679548409, 0.1868198049289862, 0.19977713820393372, 0.19637121934579238, 0.21428996483068363, 0.19832970094048719, 0.19941339522088042, 0.0859159347311812, 0.09518463320685933, 0.09102301903372678, 0.08527380565306975, 0.08944462836940492, 0.09744974108133975, 0.09708089586977386, 0.09328973070889401, 0.08711029207374288]}, "mutation_prompt": null}
{"id": "8688184c-3b33-45fb-a298-8ede3f6a5e9d", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "f86a3a99-d8c2-4bc2-89cf-67ef31d40f44", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "412f1a62-6f55-4e8d-8965-7df7ec70d300", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "7db8ca80-8f8b-4a9b-b977-15465ef54d24", "solution": "import numpy as np\n\nclass SwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.5\n        self.alpha = 0.5  # Crossover rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                # Ensure particle position within bounds\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "SwarmBasedAdaptiveCrossover", "description": "Swarm-based Adaptive Crossover (SAC) utilizes particle swarm intelligence augmented with adaptive crossover mechanisms for efficient exploration and exploitation in continuous domains.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.839682790682101, 0.8395076308509112, 0.8655554368970247, 0.8641161203145349, 0.8404390931100114, 0.8598284449431934, 0.8810385259085677, 0.8653024932636653, 0.8521505170943202, 0.4641555293803593, 0.5639903219593287, 0.4867795894014021, 0.5485448467390469, 0.5790811815487658, 0.6065790343845304, 0.3806656203839297, 0.3927394932826249, 0.614917203908897, 0.18080603987057609, 0.18583389082331092, 0.13547044600663571, 0.11682450237571484, 0.18512059029019856, 0.08253778067129658, 0.11724694241280997, 0.15985678042702656, 0.15581687334800065, 0.08238874717922395, 0.1420299993188432, 0.08236403608185461, 0.11200906060394977, 0.11482052097900375, 0.1040825529563495, 0.6173120048436909, 0.10447828324901187, 0.11158619931335356, 0.9827189476983442, 0.9849898383712541, 0.9788961979590098, 0.9697239056841069, 0.9773781446926193, 0.9569923671661861, 0.9778034484614542, 0.9692755362708484, 0.9773851465116317, 0.6011007372083949, 0.5972438963228246, 0.5380627391596473, 0.6573580641042656, 0.6380286023619761, 0.6341466480006791, 0.6027698632375562, 0.5761154539172251, 0.6660991955362405, 0.9013764548131258, 0.8630352913431556, 0.3779486379453819, 0.28244583409213164, 0.8677398725360985, 0.2060192634272192, 0.23641694393749413, 0.15178065638935023, 0.3471005855759054, 0.6754143773159871, 0.13369033537047215, 0.5374101061665204, 0.4727010266203995, 0.46370496306755127, 0.512984933725362, 0.426936093358682, 0.6408382876051628, 0.5325909394217083, 0.580078764158645, 0.17531953618780283, 0.5154412990280139, 0.19693743819739984, 0.5306308863986464, 0.44032678755855137, 0.45573961607681635, 0.3649838375533404, 0.4166702998694167, 0.06936113269052635, 0.07047344977654901, 0.4729568613349494, 0.05886213639637461, 9.999999999998899e-05, 0.014576591725381727, 0.35111977910562786, 0.331216814337263, 0.27732717168229404, 0.12966926564657244, 0.14097352160983556, 0.18596833126693724, 0.10590730281713445, 0.07773333916958125, 0.14068745710092934, 0.18277123945477802, 0.16898618582380587, 0.16177373604081569, 0.10720550073913182, 0.06999121498470062, 0.11574323871089909, 0.18549198592484872, 0.09573663204281857, 0.1586898432157262, 0.15556480815131746, 0.08400043633985477, 0.1088920464803863, 0.20444103204896114, 0.1745580852397185, 0.26193980704138486, 0.21838488105795328, 0.26737170237512464, 0.12651465597051414, 0.2111767394990628, 0.257584242130241, 0.18758707387022078, 0.650249012800441, 0.6728650808968989, 0.6359418127317038, 0.6075154185587621, 0.7343603003867534, 0.646025433476128, 0.6443705722232862, 0.516018217835075, 0.7133051724640428, 0.11500504885923912, 0.13730571534880187, 0.08331336812483026, 0.156182613754143, 0.0707526865805801, 0.11051799174899113, 0.13774167371278712, 0.09346243980141877, 0.11498498968936965, 0.3547984577445692, 0.24195770554130624, 0.2619259373491496, 0.37576773758822424, 0.3519063061956491, 0.3250066830695312, 0.24482138167327105, 0.18918433235312493, 0.4361170248037399, 0.40625921388461217, 0.4559233333416419, 0.3009836158166288, 0.318337337648529, 0.3033566702272976, 0.41870248718833103, 0.33615875388446137, 0.4907699042649796, 0.2678590646187685, 0.2630100741408059, 0.24618298376056136, 0.2790695768657009, 0.322166370158409, 0.2236281632615864, 0.26708295667049164, 0.2597350623839416, 0.29132529946665686, 0.2513351875082972, 0.2663055815721578, 0.23305487216885556, 0.23685815721224002, 0.2196751470491427, 0.29645398114455634, 0.27642964453404617, 0.2651555691900187, 0.21928909999374369, 0.2641850357741813, 0.19274283337968623, 0.18920016749863278, 0.24899682850065297, 0.20920565564413196, 0.18080671101474077, 0.20930540195815583, 0.2078537517459651, 0.17603001929510498, 0.24580887947733476, 0.1868369669059845, 0.18707375504624735, 0.1541129291004799, 0.8969905382473042, 0.19935839767354158, 0.1998557886368112, 0.1427531385384203, 0.16920962592846678, 0.8318558167606794, 0.9119435838262793, 0.21273294097915263, 0.8232681064494032, 0.20753304781281945, 0.39891795537665464, 0.1537571299335987, 0.16920325448871176, 0.753358396472099, 0.8549412162048459, 0.2241963170736303, 0.2045104399246408, 0.2130086228926601, 0.20887549395135097, 0.2174684451744091, 0.251399536603377, 0.20889498466555212, 0.20510651122474044, 0.23785332543961213, 0.10486235609079109, 0.1101510605339232, 0.08758186413653635, 0.10076466134725137, 0.09446638043375077, 0.08519430641483738, 0.098785734910385, 0.10178224555272375, 0.08994075950556257]}, "mutation_prompt": null}
{"id": "fdc6c6ee-039c-4c4d-ac05-da6809092900", "solution": "import numpy as np\n\nclass DynamicParticleSwarmOptimizationADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9  # Dynamic adjustment of inertia weight\n        self.w_min = 0.4\n        self.F = 0.5  # Differential mutation factor\n        self.CR = 0.9  # Crossover probability for differential mutation\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def differential_mutation(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(pop[a] + self.F * (pop[b] - pop[c]), self.lb, self.ub)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            w = self.w_max - ((self.w_max - self.w_min) * (self.evaluations / self.budget))\n            \n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply differential mutation and crossover\n            if self.evaluations + self.population_size <= self.budget:\n                new_population = np.copy(particles)\n                for i in range(self.population_size):\n                    mutant = self.differential_mutation(particles, i)\n                    trial = self.crossover(particles[i], mutant)\n                    score = func(trial)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n                    new_population[i] = trial if score < func(particles[i]) else particles[i]\n                particles = new_population\n        \n        return global_best_position, global_best_score", "name": "DynamicParticleSwarmOptimizationADM", "description": "Dynamic Particle Swarm Optimization with Adaptive Differential Mutation (DPSO-ADM) enhances classical PSO by integrating an adaptive differential mutation mechanism to achieve rapid convergence and robust exploration.", "configspace": "", "generation": 55, "fitness": 0.15475926825308742, "feedback": "The algorithm DynamicParticleSwarmOptimizationADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.3193487468867592, 0.29565403354228215, 0.3037721157930362, 0.3840107419710562, 0.29116081264743277, 0.3177459389979328, 0.2580908460450839, 0.3003966073530352, 0.21971344055458708, 0.05870379499965639, 9.999999999998899e-05, 0.02614675639096642, 0.05848205998550415, 0.023227709521178475, 9.999999999998899e-05, 0.02197932163120364, 0.0446196721447224, 9.999999999998899e-05, 0.0729821559844126, 0.07044300105778745, 0.0607001681809326, 0.07079520505591497, 0.068130558822736, 0.056213136635319794, 0.0642632543252023, 0.07912230494056205, 0.05052828269716447, 0.04460248642017017, 0.04005410342503113, 0.057896749098357625, 0.060114122465024455, 0.049970280274745926, 0.07686856841805112, 0.035021222975475386, 0.07604381524380444, 0.0543247775981367, 0.9835007830797822, 0.985089940821959, 0.9844750321567289, 0.9000480838591056, 0.9637028482271858, 0.9647335386047532, 0.985401079141949, 0.9738870887654375, 0.9748621111397405, 0.12578290633203393, 0.11604959622014721, 0.047662282239599674, 0.12265488525247237, 0.14970478168514945, 0.12162695545268476, 0.14000794869251787, 0.08452360011233906, 0.1711769769151784, 0.20014652104838526, 0.15605872690524558, 0.2020028433195481, 0.1827836301290524, 0.22470026947955124, 0.17734116017527557, 0.16324507732499038, 0.2628108151251407, 0.19381538324434233, 0.048702161547433565, 0.018594325116983557, 0.022568046695558563, 0.052065891402671705, 0.05524461862714469, 0.08522025340340456, 0.08926905347007619, 0.04521626222070796, 0.11624062420450976, 0.07535611283412258, 0.07717642390508805, 0.06578629271115355, 0.05030631088146986, 0.03340673080022716, 0.0925224144600516, 0.051707775292495706, 0.06343202153420169, 0.09118635929975427, 9.999999999998899e-05, 0.01433287263459515, 0.0014341162472195634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027762396360201058, 0.009361157253899854, 0.05163300900977197, 0.044247112925316245, 0.03329146988412557, 0.026948069413017084, 0.06581020989557218, 0.06343465404231119, 0.01535793562452381, 0.06332269993507322, 0.041172679267128864, 0.028437507535742923, 0.003927786648135201, 0.0003436985529878811, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014050735447869167, 9.999999999998899e-05, 9.999999999998899e-05, 0.07789949034110599, 0.062205423205366595, 0.037716431950798546, 0.03284282786015591, 0.030354082032226115, 0.05758688432944692, 9.999999999998899e-05, 0.0349744326821283, 0.019979315502419603, 0.32420533724082545, 0.2650490429005893, 0.28631528730438216, 0.28367028366765823, 0.2307753288409018, 0.19974099318328853, 0.2781992387676606, 0.27191980938113447, 0.2979125861169316, 0.056726237542805036, 0.051969528692293876, 0.05998405643884741, 0.08672991137964814, 0.06759896449285474, 0.07483778457085044, 0.07516787625157995, 0.06740607116363917, 0.06255555159216297, 0.13610437195513336, 0.11855669954225923, 0.1644970728630929, 0.1357907428387971, 0.11864350867522933, 0.1428549637873886, 0.1682546950010665, 0.12990166954086857, 0.1567009438983905, 0.18273952276348504, 0.18051337048653204, 0.2128188296099235, 0.2138401989765253, 0.18627469471383995, 0.18636284975955397, 0.21697184914448786, 0.22490061838432407, 0.23345563662162894, 0.13567166840367595, 0.15038409582162782, 0.15280135406094864, 0.14884660274830408, 0.13642158463067589, 0.13397311129522127, 0.1307219781161142, 0.2230061146420288, 0.1909469333967284, 0.15598620287273302, 0.16988976051070237, 0.17261251695183688, 0.18652833742967, 0.16287744391593884, 0.15343555498508754, 0.17821725218384854, 0.17724028275594794, 0.175833514663415, 0.1763763400213093, 0.15615845009497953, 0.16187368012746395, 0.17933928582627834, 0.1503831233649222, 0.15429188980193054, 0.16075699152983358, 0.16524147978545645, 0.165002556551742, 0.15058191264845866, 0.1764728169750155, 0.15234880132742168, 0.16371942792868655, 0.16414297600044825, 0.16880178893391784, 0.13123943431954954, 0.15840136635007007, 0.18538074192562615, 0.17337710804198647, 0.1865176800939118, 0.16002508880627941, 0.19342293145213452, 0.18058068049360376, 0.1534466776724881, 0.20320502501463966, 0.1857221659446876, 0.21978893309674263, 0.19337617372411542, 0.1785559972264411, 0.17784337717649634, 0.16966615034606314, 0.1785467523160067, 0.17694247617609804, 0.17830856096227654, 0.20230636946924374, 0.18873539225604163, 0.07485760456581281, 0.047862182535063025, 0.06563497875711877, 0.056676873380178794, 0.07251099667722971, 0.05873965649587298, 0.07150966882001852, 0.06781951023794919, 0.05606475732150762]}, "mutation_prompt": null}
{"id": "2d5196c8-1231-4ad7-93d9-d8a7ed1327e2", "solution": "import numpy as np\n\nclass EnhancedSwarmBasedAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 2.0  # Increased cognitive component\n        self.c2 = 2.0  # Increased social component\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.7  # Increased crossover rate\n        self.mutation_rate = 0.1\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def mutate(self, particle):\n        if np.random.rand() < self.mutation_rate:\n            mutation_vector = np.random.normal(0, 0.1, self.dim)\n            particle += mutation_vector\n        return np.clip(particle, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.mutate(particles[i])\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedSwarmBasedAdaptiveCrossover", "description": "Enhanced Swarm-based Adaptive Crossover (ESAC) utilizes dynamic inertia weight, mutation strategy, and adaptive crossover mechanisms to balance exploration and exploitation for faster convergence.", "configspace": "", "generation": 56, "fitness": 0.23361284247942513, "feedback": "The algorithm EnhancedSwarmBasedAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.5233783039731861, 0.5240308278747111, 0.5228611128354168, 0.551768964115953, 0.5381455668258757, 0.602656048437077, 0.5842840180304978, 0.5815793752630478, 0.5625339138145602, 0.19830131630086212, 0.22593963543040907, 0.0001886748483741485, 9.999999999998899e-05, 0.032247269444313886, 0.07621376441245808, 0.04820026075086248, 9.999999999998899e-05, 0.11256018590166772, 0.1167830941440583, 0.12349486067830273, 0.12664738525046282, 0.12614827161107822, 0.1816288739966505, 0.09826590700171489, 0.09248926708734673, 0.12365675785636554, 0.1523810947253762, 0.10184501127383172, 0.09444152653404858, 0.09344631503770384, 0.1075272785301229, 0.08880549888764033, 0.09347202064366289, 0.10721677377220462, 0.0921728399624393, 0.09548891810135718, 0.985092774417966, 0.9858593448955397, 0.9849008441979634, 0.9754352482798282, 0.9789742698617926, 0.9777991730259791, 0.9828725811864436, 0.9702372009372753, 0.9819794366494913, 0.2642687171131778, 0.26576040530616707, 0.19681939193692732, 0.24987946981763043, 0.19993255547315247, 0.24582048771680076, 0.17237145060198678, 0.2531440579709002, 0.22146232597047522, 0.3450312508175255, 0.22014938558339903, 0.21310015389090486, 0.20992322849315947, 0.21030329225032451, 0.24729688035809527, 0.2457772715489004, 0.19712142324785586, 0.6549144442794012, 0.31068030693990834, 0.1335280888711351, 0.15422493378032776, 0.11571379865196707, 0.1738296430972689, 0.13843339445608394, 0.16348055362086233, 0.2238667516651438, 0.15093726497497884, 0.1975911958625175, 0.12488501970314847, 0.23616010973691115, 0.13489684589902207, 0.17027603413322634, 0.1295295065107237, 0.1656527897488701, 0.12812198162437505, 0.1387515975976481, 0.00114449417144602, 0.01936532803559765, 0.055206738791896526, 0.0113754541539689, 0.022472731172312854, 9.999999999998899e-05, 0.03862875193448201, 0.006607512738395438, 0.018902109759868613, 0.17081461196855685, 0.08955326067198943, 0.10955092178054748, 0.1314088266747998, 0.008320572834053519, 0.07041429520331655, 0.0839594565116617, 0.1323370523492915, 0.07503474157410528, 0.10986851298420275, 0.04585252390259975, 0.05065862435939705, 0.07365389794602184, 0.08483522708308011, 0.0656298948561782, 0.05804403343825704, 0.05760449059346229, 0.05805412104558949, 0.11265489628773961, 0.12617735987789624, 0.12160117718286934, 0.07558415162069965, 0.08657141361430931, 0.07467179318717865, 0.266469507692651, 0.09697737647391824, 0.09348565338899684, 0.37356970074909224, 0.4527204345177631, 0.4021043042793715, 0.42935101733375236, 0.3921364623780038, 0.4279570415436761, 0.4546612191645477, 0.39666954811420274, 0.4074521572045531, 0.09475899500467388, 0.12749403815171767, 0.09317460257502519, 0.10758979043043915, 0.1411653978840337, 0.12327281160612313, 0.15853919408090955, 0.11414953258731109, 0.07758039525818472, 0.17016012445994855, 0.22228290230348202, 0.14660943224711098, 0.23362315754545193, 0.2218217770939669, 0.14200480343266086, 0.2154130128697619, 0.2573777920892256, 0.20043233967248242, 0.2720103750891957, 0.36463928920581146, 0.27979910140644004, 0.24557061552659665, 0.238680079279041, 0.2494609569847206, 0.21458438321484252, 0.33656572216054714, 0.2496575771689722, 0.1704625076006121, 0.2418240407132084, 0.23718524990456158, 0.2011490549278624, 0.20929097623821524, 0.21693882282090948, 0.20510370045234172, 0.20581287834577966, 0.21426030297895116, 0.20649412229206077, 0.2103934427677686, 0.23912017910425576, 0.2108459271721398, 0.20641170076603554, 0.20941505025313178, 0.2415725435704137, 0.197756961736563, 0.20041313870542787, 0.22299264589120726, 0.19020532311409954, 0.17782276878664705, 0.2040288001031073, 0.1825220692710955, 0.19740811734769903, 0.203757716459806, 0.21024281011843626, 0.18715314730054933, 0.5144291618622694, 0.16539093117137094, 0.15247710688895, 0.6486326004658189, 0.725439885643383, 0.19944143630029953, 0.14302846692165416, 0.16932068711776083, 0.7161551807478705, 0.6823108011455767, 0.21053121774655048, 0.5890653524237319, 0.20124049036461644, 0.16723483540070105, 0.14633981040983268, 0.2080868410506994, 0.20541942253852818, 0.4933924378035419, 0.18214208702204238, 0.2082455912626937, 0.19174721200697153, 0.18327539651305624, 0.20689772952567032, 0.208852263742778, 0.22873905428638241, 0.2151433236136454, 0.2163814783556608, 0.09115320897617007, 0.09822299177342797, 0.07715692780362537, 0.09671961355815217, 0.07551139986195743, 0.07668557155756384, 0.10818448709157069, 0.09315209077293751, 0.09722346655367675]}, "mutation_prompt": null}
{"id": "fac20cfd-7ea9-4602-a01f-e8e0a421185a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 2.0  # Increased social coefficient\n        self.w = 0.7   # Increased inertia weight\n        self.alpha = 0.6  # Crossover rate\n        self.evaluations = 0\n        self.velocity_clamp = 1.5  # Velocity clamping for stability\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def update_params(self, iteration, max_iterations):\n        self.w = 0.9 - 0.5 * (iteration / max_iterations)  # Dynamic inertia\n        self.c1 = 1.5 + 1.0 * (iteration / max_iterations)  # Increasing cognitive influence\n        self.c2 = 2.5 - 1.0 * (iteration / max_iterations)  # Decreasing social influence\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        max_iterations = self.budget // self.population_size\n        \n        for iteration in range(max_iterations):\n            self.update_params(iteration, max_iterations)\n            \n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = np.clip(self.w * velocities[i] +\n                                        self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                        self.c2 * r2 * (global_best_position - particles[i]),\n                                        -self.velocity_clamp, self.velocity_clamp)\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n            \n            # Apply elitist selection and crossover\n            elitist_indices = np.argsort(personal_best_scores)[:self.population_size // 2]\n            for i in range(self.population_size // 2, self.population_size):\n                parent1, parent2 = personal_best_positions[np.random.choice(elitist_indices, 2, replace=False)]\n                child = self.adaptive_crossover(parent1, parent2)\n                score = func(child)\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = child\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmCrossover", "description": "Enhanced Adaptive Swarm Crossover (EASC) optimizes convergence speed by introducing dynamic parameter tuning, velocity clamping, and elitist selection to efficiently explore and exploit search spaces.", "configspace": "", "generation": 57, "fitness": 0.27427764286853823, "feedback": "The algorithm EnhancedAdaptiveSwarmCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.7144138926144707, 0.7163505059052859, 0.5832662325525939, 0.6768568671127846, 0.6568423728935274, 0.6234779932066343, 0.8091019729805021, 0.7306995559765683, 0.692682319061634, 0.16488302866488191, 0.1584367803681349, 0.13924569521349894, 0.1318141738451164, 0.06812269473223787, 0.11100971190265319, 0.15501490036167365, 0.1278098139985957, 0.1105890657157832, 0.09697274905649189, 0.40433876746300335, 0.15289773037371235, 0.14225584768249955, 0.14505152284626843, 0.15563857659544011, 0.15271739881087543, 0.4000142843243478, 0.11597333107329977, 0.1282268989055727, 0.11089250136983264, 0.13843394916343876, 0.1229580845595245, 0.10448134258906994, 0.10939213276829307, 0.12873511902531176, 0.10725453544489338, 0.10028303383491932, 0.9615185244282664, 0.9595928934612709, 0.964661390711597, 0.9627413794523068, 0.9564129630447474, 0.9410766855001036, 0.9662302925944575, 0.9357524887317736, 0.9667757516781362, 0.30139249310418537, 0.37718441404165537, 0.3322357268384226, 0.30238921622786497, 0.2662713625244907, 0.26153831958039675, 0.3441612563891032, 0.30193405811187135, 0.3269412992485743, 0.2773096034101499, 0.34073755536788164, 0.23698942667645073, 0.2802669492035883, 0.2200560466649779, 0.1970318016913315, 0.6458405751055818, 0.654637211853851, 0.3668593420645341, 0.23643485936625386, 0.16455460755194784, 0.21015559570798759, 0.2525765317791482, 0.19305258614424847, 0.12369325540373433, 0.20945267126987088, 0.12083386482317349, 0.3401601620123015, 0.23568621034853054, 0.15041540789520846, 0.1305854742939937, 0.18772391590341675, 0.347850765469476, 0.15215346465518376, 0.19914490247859662, 0.29192154503144363, 0.24994003257794373, 0.04851068568964878, 9.999999999998899e-05, 0.06188114868516237, 0.00958021028032452, 0.12191697063120321, 9.999999999998899e-05, 0.016205584877197143, 0.00787202139768628, 0.13690910491395114, 0.19388743826137944, 0.1008167080547937, 0.17720276122361933, 0.08342565201532615, 0.0717128681590401, 0.05195427875552394, 0.13003840690614465, 0.1451772037006036, 0.10363662020720898, 0.08991119035849693, 0.07467909118366678, 0.200443247307036, 0.04887234870531143, 0.16409622208527963, 0.07691884988419151, 0.15355610258801966, 0.052236947670589506, 0.06620095423469863, 0.12041520529135308, 0.15068966188958277, 0.12394816243133522, 0.07650392860440791, 0.1371174664967335, 0.13184165195003994, 0.0847396684334415, 0.15067537381592433, 0.08233703337826659, 0.4640963209898942, 0.5491296558218264, 0.5300662452498666, 0.5173344260515214, 0.4453965164905722, 0.46552730875910153, 0.4721080093069584, 0.4973371714707534, 0.4921095868741967, 0.10333610513017266, 0.12354334667001643, 0.08935067725550838, 0.1648453595325382, 0.08660454378669491, 0.16673736652295612, 0.1528256903574502, 0.09232035397715066, 0.09099682669548381, 0.2496689403878959, 0.24966215283166526, 0.23813756449806556, 0.28074101128349827, 0.2886997904948757, 0.24813263779903716, 0.2113587969196694, 0.4364319280467803, 0.40276212336214234, 0.3378528877658853, 0.29004705294456934, 0.3184994360721619, 0.3176287998912448, 0.31303674923271685, 0.279819257514626, 0.2880197862075973, 0.3338521653022716, 0.2592387935577435, 0.1915905128172215, 0.25143947892334895, 0.27849398878208453, 0.23752212336128764, 0.25322004438271817, 0.24933117841371377, 0.22697561356656892, 0.23870403807806628, 0.24583251453665766, 0.2514680037153537, 0.21818454608212856, 0.22693144506121288, 0.21165566027711946, 0.2298487341402532, 0.24808696139998587, 0.23614982045638944, 0.20720743447057266, 0.2138776866155726, 0.19254782282569238, 0.21850357126205677, 0.18234104686503017, 0.21218058553301367, 0.2267487556862514, 0.18494967884855307, 0.19372011868443095, 0.1991617384583716, 0.20729215105245913, 0.7953447722806516, 0.1873876744073497, 0.1862116674512394, 0.8693460500009247, 0.20063969129283743, 0.14833986547735545, 0.14207110775356302, 0.7625156897262492, 0.9248537678162999, 0.696685644927794, 0.21362981928425784, 0.5638092346812829, 0.6779353230477234, 0.16871668446479127, 0.1519179841864099, 0.10480414992268816, 0.10486724187579144, 0.5994283923946222, 0.19505612574255693, 0.20188804114951375, 0.22956451196644712, 0.2043677222857807, 0.1939350598258881, 0.20364983338806653, 0.20785017165407693, 0.21954317348925723, 0.2282345709311412, 0.10625118490742447, 0.10261557928629028, 0.09282986117350633, 0.10739793582053803, 0.0920922901716078, 0.09923347345956823, 0.11249916878856114, 0.09894578577403867, 0.09016993596635237]}, "mutation_prompt": null}
{"id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 58, "fitness": 0.41612407829808395, "feedback": "The algorithm EnhancedParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "eb6c8ce9-f84f-48c4-b483-ad9ef8945b16", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "1f7b81d9-15fb-45ca-9522-10a30bd2e1b7", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "ea2b17f6-8237-4b88-a4ed-850fad9bd271", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "e8ba14f6-d25d-475f-9207-4f9d1bbaf465", "solution": "import numpy as np\n\nclass DynamicSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 2.5\n        self.w_max = 0.8\n        self.w_min = 0.3\n        self.alpha = 0.5  # Crossover rate\n        self.beta = 0.9  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_velocity(self, velocity, particle, pbest, gbest):\n        inertia_weight = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n        cognitive_velocity = self.c1 * np.random.rand() * (pbest - particle)\n        social_velocity = self.c2 * np.random.rand() * (gbest - particle)\n        return inertia_weight * velocity + cognitive_velocity + social_velocity\n    \n    def pbest_gbest_boost(self, particle, pbest, gbest):\n        boost = self.beta * np.random.rand() * (gbest - pbest)\n        return np.clip(particle + boost, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            for i in range(self.population_size):\n                velocities[i] = self.adaptive_velocity(velocities[i], particles[i], \n                                                       personal_best_positions[i], global_best_position)\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.pbest_gbest_boost(particles[i], personal_best_positions[i], global_best_position)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    cross_point = np.random.randint(1, self.dim)\n                    child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n                    child = np.clip(child, self.lb, self.ub)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "DynamicSwarmOptimization", "description": "Dynamic Swarm Optimization with Adaptive Velocity and Pbest/Gbest Boosting enhances search capability by dynamically adjusting velocities and leveraging personal/global best positions integration.", "configspace": "", "generation": 61, "fitness": 0.20589511588265025, "feedback": "The algorithm DynamicSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.5507813951249793, 0.4590807945137022, 0.425471651887107, 0.6088746380460677, 0.46566336887755555, 0.41963184458195646, 0.6086108423009049, 0.46616193919492455, 0.4866447565777424, 0.1646212986595088, 9.999999999998899e-05, 0.008204337806737905, 0.10450241467675458, 0.1406295832658745, 0.04301508439393853, 0.13952609760318024, 0.05043376819172263, 0.2128138193845499, 0.1333677726932363, 0.13526736683327123, 0.17413636618780748, 0.17008726720434753, 0.11111058481798997, 0.11281357506173462, 0.1079248905159722, 0.10661962491635912, 0.11006420708440223, 0.11550732838688327, 0.10475054366943037, 0.11435107699135605, 0.13656944529913273, 0.09545817950139701, 0.10536602399956796, 0.1320467414552262, 0.09358479485549864, 0.09459866611915912, 0.9814589195390656, 0.9717314966658674, 0.9892191536026073, 0.95494609517513, 0.9814230994525595, 0.9808429781027652, 0.9822333631226742, 0.9697114596587418, 0.9718217994074974, 0.2679336745612655, 0.20742443984487713, 0.22579975688320997, 0.24592967513656272, 0.1487383143141331, 0.14011837084992695, 0.1647925059668527, 0.08628443339209135, 0.22400211675267634, 0.17011609945309136, 0.22100564677470125, 0.19203547496107598, 0.2166750397129923, 0.30733822463480154, 0.18775067289233527, 0.2490093616611626, 0.17406850500947635, 0.2129812967823137, 0.13990037089486795, 0.08483794474134665, 0.13562652933315245, 0.10777469363622005, 0.14600417936776067, 0.11748872331829296, 0.22547821124390333, 0.18902995242676146, 0.12132889297745586, 0.074775127119454, 0.13504269718885065, 0.09510903223817091, 0.12026746078315242, 0.2201170473562556, 0.12817800008874436, 0.1197658821332167, 0.09461907554417048, 0.10429366548798102, 9.999999999998899e-05, 0.00887971511042629, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004074917573685388, 9.999999999998899e-05, 0.005222944495998361, 0.08250268723362808, 0.028391563432757394, 0.06831941684222476, 0.0760482928073114, 0.03136104665418604, 0.007731748249867665, 0.06570817486323244, 0.05044393088807442, 0.037986360393655216, 9.999999999998899e-05, 0.030820870509457365, 0.020062431652958956, 0.031486446383678035, 0.04152067331552911, 0.0667102331025008, 0.035585097478397665, 0.0009720153526444619, 0.05461556818386093, 0.0838540965964748, 0.1086305376370914, 0.08680495471308292, 0.08259498857537928, 0.12916102381006767, 0.10110067361920883, 0.0446344926556127, 0.13364098810999947, 0.06002494324975871, 0.4420574224375685, 0.379525644225294, 0.3874599573385408, 0.35437063635971133, 0.4169213514152138, 0.37555157446749876, 0.38623359585444983, 0.4106995858282958, 0.4136299757355625, 0.09021920722460397, 0.05711996432449795, 0.0685632781390153, 0.09982203031133885, 0.0632509565141689, 0.11228508096762546, 0.06642230100693591, 0.12387920291106036, 0.07928486734737727, 0.17236850228246825, 0.1819225532859603, 0.15775911343125448, 0.14375801040131175, 0.14210201644704246, 0.20374742779300736, 0.22314980298811837, 0.12940130521612914, 0.18015619207724298, 0.21409629701561672, 0.2931287540407628, 0.3176326646094859, 0.2591127139139153, 0.2415385515077666, 0.2523643922438987, 0.24392143032472946, 0.2943737208495626, 0.22450923429464242, 0.1637979026101728, 0.14181249753100278, 0.2569498455290643, 0.2445971988859661, 0.21354245191996546, 0.211656366421479, 0.18995725491950455, 0.21306036032741515, 0.23998773152341923, 0.2007894625538531, 0.171152608304465, 0.17931290046008652, 0.20073857439545595, 0.18064278375918397, 0.17414655607403928, 0.21570046424671918, 0.22051568321766668, 0.20654165125975799, 0.18411477002817744, 0.18120401836803235, 0.18254243245694035, 0.2168439154853956, 0.1860699117323097, 0.19048795715834488, 0.1845079583472108, 0.18995674648676464, 0.1953009569578419, 0.11117221993064108, 0.19139480514730312, 0.1784482999704189, 0.62906874076443, 0.19729981620381065, 0.46477915771580636, 0.14192075579636587, 0.15881012950758122, 0.5216305701532401, 0.4017275533378819, 0.20952635439572254, 0.16607368419800006, 0.29917515060435895, 0.21718111946772944, 0.16291073157757507, 0.19721294034195624, 0.1810838164646792, 0.2943150729604709, 0.18281473278061877, 0.17905408212644558, 0.20548169124640436, 0.18766657127926878, 0.1497478987510884, 0.19021484769763408, 0.18519683706834833, 0.1779883925591479, 0.1933944350848923, 0.08805392797901535, 0.06992286024405603, 0.07719874289398498, 0.07187547956220441, 0.06948853170272518, 0.08194195902741375, 0.07568910310971444, 0.06779632333803398, 0.0884724610269566]}, "mutation_prompt": null}
{"id": "04b8b5a7-d70a-4a6b-afdb-606f8772df0f", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "86b9abe8-3fa7-49d4-84f5-05cb4be175f9", "solution": "import numpy as np\n\nclass EnhancedParticleSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.initial_population_size = 50\n        self.min_population_size = 20\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.alpha = 0.5  # Crossover rate\n        self.beta_initial = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self, size):\n        particles = np.random.uniform(self.lb, self.ub, (size, self.dim))\n        velocities = np.random.uniform(-1, 1, (size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2, beta):\n        mutated = target + beta * (best - target) + beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def resize_population(self, population_size, personal_best_scores):\n        if self.evaluations < self.budget * 0.5:\n            return population_size\n        else:\n            return max(self.min_population_size, population_size // 2)\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles(population_size)\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            beta = self.beta_initial * (1 - self.evaluations / self.budget)\n            \n            for i in range(population_size):\n                if self.evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.choice(population_size, 2, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2, beta)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            if self.evaluations + population_size <= self.budget:\n                for i in range(population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n            \n            population_size = self.resize_population(population_size, personal_best_scores)\n            particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles(population_size)\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarmV2", "description": "Enhanced Particle Swarm Optimization with Dynamic Population Resizing and Adaptive Parameter Control to accelerate convergence.", "configspace": "", "generation": 63, "fitness": 0.09910937381425965, "feedback": "The algorithm EnhancedParticleSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.07.", "error": "", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.20820148969816732, 0.2239998106283182, 0.19875466707712985, 0.17757195669623327, 0.17912694903875215, 0.15092011714956666, 0.18568597435682554, 0.21918096722924463, 0.17244523662004396, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05000558446193393, 0.05126152055301103, 0.0561052400183788, 0.058152303791695115, 0.049945596006361836, 0.05578575564074695, 0.04459413297848225, 0.046876910718522624, 0.04638511513166066, 0.03568612259908932, 0.03623291408040519, 0.03554045913517567, 0.04052099205358595, 0.03706027199926121, 0.040102409995267596, 0.04247985632765561, 0.04189211907006485, 0.04939275177243507, 0.08476321565529832, 0.10061536938975546, 0.07610787109082362, 0.08552744799485479, 0.09200496742778574, 0.06991471094786617, 0.09036745419915915, 0.07265745484601793, 0.07656182915017018, 0.09241378496904129, 0.13403489871316765, 0.07734497948746033, 0.10797884001359614, 0.07107532912617842, 0.06681702741564566, 0.10998748420036386, 0.09953305620936481, 0.06459682430881841, 0.1791189702443633, 0.1483752324003188, 0.14093392346735634, 0.12365170679156634, 0.10655350150145182, 0.10390175618227926, 0.11989788452854533, 0.13997739190701086, 0.1832853582242958, 0.013315243869022608, 0.0024506017170909944, 0.02024291563966485, 0.019367555946160464, 0.04531219861082214, 0.029919830066700515, 0.02249193867790711, 0.0021072274312964323, 0.009974197728410572, 0.022999678136428003, 0.03844868205810614, 0.029045061488215063, 0.06571030970152913, 0.02527567621278415, 0.024511709500897094, 0.0819213987395655, 0.10032138104642307, 0.034875246396556925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08090233071895236, 0.07971602950317758, 0.06677880577979378, 0.035028484195229304, 0.06720808066144779, 0.05304578677476934, 0.06183057568452399, 0.07361881354463351, 0.08338224587309073, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019492358737316362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.21930685475153489, 0.23014147670767482, 0.19933666743481382, 0.22186809498524274, 0.19136168951401955, 0.2121416418490748, 0.2254018736222797, 0.21103440367938175, 0.20896790943686683, 0.035221309388846045, 0.040580614228909684, 0.042294822822025346, 0.054336841410908554, 0.04157706837006392, 0.04185526439965093, 0.05132253616906923, 0.0485198888861329, 0.05396399258262796, 0.12555355133993362, 0.1547429998574389, 0.13683771951483992, 0.16781460930870995, 0.13463222631057448, 0.1509749856982251, 0.16574139695313772, 0.13622581848912685, 0.14315555705781813, 0.16788622140330423, 0.16015829754293442, 0.16408443138908368, 0.1913730569460962, 0.18508570933313095, 0.19299331713687817, 0.18077531084996767, 0.17377774300845283, 0.18141265240978655, 0.11694067409122766, 0.10530280357777899, 0.10247728365505371, 0.12445495159662401, 0.1395741567670784, 0.12578919637942854, 0.1066787656738808, 0.10238234029499438, 0.13756409597776909, 0.19706371418892132, 0.1967943899175847, 0.16844266866693347, 0.18763876886009767, 0.1762359951818231, 0.16665243100340488, 0.18401838060411257, 0.19029448735235166, 0.2048503868346857, 0.15866936273981735, 0.1591898699813119, 0.15862216547903518, 0.1484283511072002, 0.1539097981415387, 0.1458859083890276, 0.16965981874111824, 0.16744161443300676, 0.15258626406480924, 0.17338587530792993, 0.19635970365213373, 0.14758728786264186, 0.20537120612260207, 0.19322283017798536, 0.1891439505500898, 0.15234936972920154, 0.2002004446538025, 0.16016605415148222, 0.15962396489227815, 0.22114946601069574, 0.17110702716517134, 0.2029430894862333, 0.16455438920592147, 0.18535102907517198, 0.16116616041852705, 0.22437509567446057, 0.15370030159174697, 0.18847354273866124, 0.18097930883090407, 0.17639312450756484, 0.18380960009549707, 0.1850227497903607, 0.1772649433638579, 0.18683266123144593, 0.18598919439741657, 0.1969800937767595, 0.05576536301386292, 0.0624212183807602, 0.06263081918596525, 0.07247259591883082, 0.05887407334756356, 0.0672549390978393, 0.052442083025368125, 0.056449788420796176, 0.06040177602823227]}, "mutation_prompt": null}
{"id": "69e2778c-5bd1-4f96-8ffc-2614073245b0", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "3f2f6e10-210f-40a1-810a-1864c7711dd4", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "014575af-d653-4b0a-8743-5559c93889ef", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "7ece63e1-3e4f-43d2-8d20-25a36488d5cc", "solution": "import numpy as np\n\nclass EnhancedParticleSwarmWithLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.7  # Crossover rate\n        self.beta = 0.7  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Global and local learning: use the best of personal or global best for crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = (\n                        personal_best_positions[np.random.choice(self.population_size, 1)[0]],\n                        global_best_position if np.random.rand() < 0.5 else personal_best_positions[np.random.choice(self.population_size, 1)[0]]\n                    )\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarmWithLearning", "description": "Enhanced Particle Swarm with Integrated Learning Strategy accelerates convergence by incorporating global and local learning strategies and adaptive inertia weight adjustment.", "configspace": "", "generation": 67, "fitness": 0.3478523473779986, "feedback": "The algorithm EnhancedParticleSwarmWithLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8534963072412006, 0.8672696726711983, 0.8834117428869871, 0.8677506910250822, 0.858959436812289, 0.8865055483439476, 0.8411861044120852, 0.8670280127433314, 0.8330902768555493, 0.5223042621395211, 0.5448931731629227, 0.6290880306665328, 0.6150702241083876, 0.7026514921898415, 0.7358289734847907, 0.6629838563622219, 0.6983665720197056, 0.5289011141102986, 0.10438084270032266, 0.06510849217418568, 0.09564641878462532, 0.0901475868730377, 0.07997522176598937, 0.12111427603985192, 0.05132560391160479, 0.1404630745742821, 0.13301807775442753, 0.11603657032874493, 0.09696731035732431, 0.14214600569202762, 0.05655735688697627, 0.07124814882161301, 0.10375342548629507, 0.08216054285008012, 0.10553173899993107, 0.08165938607085832, 0.971708934322664, 0.974099872085275, 0.9656075198245143, 0.9793726223179549, 0.980713374801129, 0.9721419183439898, 0.9815262100952994, 0.9793193342821155, 0.9809356242684785, 0.5510119689737456, 0.49369859233646884, 0.5243013839818407, 0.4674592268853527, 0.4843838348776647, 0.5253169128667611, 0.12416619021785213, 0.47733608461913146, 0.44408921031888504, 0.3292787212803806, 0.13621077858746145, 0.3695935920343475, 0.18833928426250024, 0.8605185859032258, 0.2720496532816091, 0.2288225077720103, 0.23102411155316271, 0.22370342752069805, 0.6278067890595818, 0.48814460128816695, 0.341051992807484, 0.4735981073364707, 0.13064260436704211, 0.44483760709581066, 0.35248176193173464, 0.4404424597388855, 0.7138484590241327, 0.3750870433540665, 0.3788701074846741, 0.37928322081054455, 0.3134092763636188, 0.282597014729736, 0.29637227536886346, 0.6438871218633746, 0.4177740385744223, 0.12595080588898233, 0.5287189335357445, 0.44432651515877364, 0.44218053759240494, 0.24370739001766095, 0.33430100478010805, 0.4138874106394351, 0.3823461259753742, 0.4268117401164515, 0.34475103461486456, 0.41960079881476864, 0.6217635315672374, 0.6028402973172271, 0.5634775245020508, 0.027155257709771674, 0.5709734901893748, 0.0810283900294333, 0.15449805627068858, 0.5027435799862843, 0.058465342603926884, 0.354350614477833, 0.04810811673747106, 0.14156642891014215, 0.07903165063713136, 0.19446763450968307, 0.12772976398329505, 0.09595938727268405, 0.1445781893399053, 0.28877424827258824, 0.219419953769581, 0.15123027247848364, 0.22010885513455747, 0.18327654371557767, 0.19130203982455218, 0.236820256583946, 0.2181633160669828, 0.24146361899821056, 0.7540435036859311, 0.7018945665946358, 0.7345467416556536, 0.6477938450012459, 0.7202191519252972, 0.7046964015761998, 0.7746147972631854, 0.7263720253239836, 0.7886305638853326, 0.06929024229118641, 0.17713195537873094, 0.10995086416735433, 0.18176716260603776, 0.1278090524482195, 0.15221670952694277, 0.11877879293468774, 0.07163240463243326, 0.12305672437596038, 0.17720905888584693, 0.19754876559117074, 0.15976818700175954, 0.2666707451107988, 0.1424591903314144, 0.177763515766433, 0.21362712952100282, 0.19968490590665, 0.1528303919682379, 0.2790642392119914, 0.3663627903419654, 0.3073152698103634, 0.2994375361042182, 0.37488881290348286, 0.38541018850989817, 0.47706953457854073, 0.4362963544538282, 0.29086358018963376, 0.263436026853624, 0.25489029872008395, 0.3206524709740102, 0.2550301370941662, 0.2306797959184056, 0.2906719642979969, 0.22616713324923077, 0.2534277705261503, 0.29753724550857863, 0.2226498397834924, 0.16519584792658115, 0.1669964272934007, 0.18894694851277605, 0.20401005085253332, 0.21077096410020535, 0.2468475752067617, 0.2654431523348777, 0.19596139971671445, 0.18454160273367826, 0.17474342949495003, 0.1892705618752759, 0.17290816024843514, 0.17761685719087528, 0.2063591287507286, 0.17482180809533043, 0.19887554253713002, 0.18268595062929094, 0.1218311645215635, 0.18525453156587668, 0.15379993888041388, 0.11444683163070035, 0.195830523908626, 0.19675441381487146, 0.16560358159237198, 0.15933928745920767, 0.8384358601331822, 0.6874031586715945, 0.21193396794117458, 0.5438793474192702, 0.20399314447697048, 0.20981923878872977, 0.15253578357377606, 0.2098138827867727, 0.16606775789281547, 0.8460843782063863, 0.23095761594138542, 0.21637349260570504, 0.1985573071032085, 0.1936397049644658, 0.24733270305510913, 0.2153149380379049, 0.19164856734426017, 0.30296526385753786, 0.2135189239570141, 0.11040538722426696, 0.0830754373496535, 0.10940295214460605, 0.09175841982920374, 0.1011117715626002, 0.11933074348231099, 0.08457603572489736, 0.08267494926579144, 0.09201404690354198]}, "mutation_prompt": null}
{"id": "e461a78b-7edc-4e1c-89b7-4714e47165a2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n        self.local_search_prob = 0.2  # Probability of performing local search\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def local_search(self, position):\n        step_size = 0.1\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        new_position = position + perturbation\n        return np.clip(new_position, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            # Dynamic neighborhood strategy\n            neighborhood_size = max(2, int(self.population_size * 0.1))\n            neighbors_indices = np.random.choice(self.population_size, neighborhood_size, replace=False)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(neighbors_indices, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n                # Perform local search with some probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self.local_search(particles[i])\n                    score = func(local_candidate)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = local_candidate\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = local_candidate\n            \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm with Dynamic Neighborhood Strategy and Local Search for accelerated convergence.", "configspace": "", "generation": 68, "fitness": 0.38910079277568915, "feedback": "The algorithm EnhancedAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8459100418296546, 0.8490631209318491, 0.8731476293269124, 0.813497294036165, 0.8514626815819707, 0.8197457972650223, 0.8406078093696026, 0.8284161889055469, 0.8359637180746617, 0.6297728655890539, 0.548666695927956, 0.7334109329171754, 0.6705459655455179, 0.6626318159394162, 0.6352652719172455, 0.6695351518189994, 0.6875310774368708, 0.6896470905822143, 0.1763039910516947, 0.17671629414885703, 0.14142110716316925, 0.1757499530950527, 0.6019371646795413, 0.17845945561845633, 0.15298557376037003, 0.6277397146013146, 0.174724733768148, 0.14882656890040946, 0.15396993856513708, 0.11628620009342416, 0.13109789199162547, 0.15267497277053155, 0.13584900699596203, 0.13191662968557627, 0.13618074468400954, 0.09590325275729761, 0.9844721115550294, 0.9501715492854756, 0.9500577143375881, 0.958201664259333, 0.9803133452588283, 0.9746362637535251, 0.9606705173500926, 0.9702144441636732, 0.988111588069588, 0.38395154274835885, 0.4487706532760093, 0.40975910296361295, 0.45703431910221326, 0.4141656853086053, 0.509399837788861, 0.43481032849363477, 0.4098284149317587, 0.5116453705104133, 0.8727202927606439, 0.8901771690553852, 0.8168166357840809, 0.27549539841193205, 0.8450997565720846, 0.8383974580023856, 0.1719140014680377, 0.8829803819654752, 0.2325803045954008, 0.5843346627833581, 0.4353960916016254, 0.34875939846385506, 0.21618252664131032, 0.2900749859374321, 0.23136772663517902, 0.3836028860988834, 0.27088115288794856, 0.27826091043542234, 0.30450637386742196, 0.23501273987833182, 0.31607623552455943, 0.26329411115238766, 0.23480211011201024, 0.2667164228548965, 0.49798716965164735, 0.3185142045080699, 0.17535562422276452, 0.27119932511869493, 0.058028217780723756, 0.5221836828389979, 0.4686823435625437, 0.1550610087087716, 0.5353374094094219, 0.07650154955793809, 0.36840273647739186, 0.3604674854911353, 0.6071582580850285, 0.10432274036865441, 0.2176409658427374, 0.5658253686306107, 0.3515554955686322, 0.2929132326368201, 0.466759623121611, 0.26014811687728134, 0.2368025160418188, 0.21051448461867062, 0.14772180907091492, 0.31428131536733406, 0.24481931381937938, 0.19130965631558583, 0.20092381122168435, 0.18900669863760367, 0.10702305489314934, 0.14373334747256827, 0.41797286062255656, 0.303620263627444, 0.19292450415635398, 0.26985916519575404, 0.3443342300937846, 0.29462045103733236, 0.2451812151572378, 0.33139156735596764, 0.26672296998665046, 0.758599261726705, 0.7200588626742901, 0.6377140490191533, 0.6322834888653762, 0.720374387663415, 0.6223837799718908, 0.7807779673276418, 0.7791467938294114, 0.5962514734343549, 0.10256755054440914, 0.10600625980353562, 0.13593456491633138, 0.16158558259952993, 0.15951626183238765, 0.1636556748586936, 0.3810490711353376, 0.14518785349293117, 0.13031367304636388, 0.6396385494686234, 0.2805372860779788, 0.13931753340842112, 0.2702513317988803, 0.23906707559929763, 0.16713878423209716, 0.7235345520722822, 0.3964185905961898, 0.17641704082974008, 0.42633092408592754, 0.3991821478979789, 0.3083725501466156, 0.4575790882181062, 0.4819733919716669, 0.6022110175498201, 0.3712596110929285, 0.5900359938688402, 0.5095810541639842, 0.3219289190116478, 0.421195588996519, 0.4672896121879123, 0.286984580808736, 0.24899191623806705, 0.2865034573993347, 0.2719991652930889, 0.3096534177914728, 0.2377231785352748, 0.2297116043902131, 0.20619271624925184, 0.24328976643526135, 0.24420621925339614, 0.2053108008682093, 0.21280523213004277, 0.22659060938510944, 0.23918056559380574, 0.23641127247123317, 0.2056014488146749, 0.2067177628141027, 0.24701593410553602, 0.2159264098520315, 0.22307062766344188, 0.20370361866258413, 0.23918052131977097, 0.2052342064173598, 0.2064720937591915, 0.6819023948382436, 0.18524622007065727, 0.19440541951123036, 0.12952717517097567, 0.19971319809509314, 0.16069430794273853, 0.14185033729363927, 0.7613355763449335, 0.799110741364844, 0.8327576814021306, 0.21195120712301008, 0.6835399975823848, 0.8425239057486346, 0.16641798785295359, 0.4883842922259797, 0.6004575896215537, 0.7796258914670156, 0.1507640300806845, 0.19588151215571392, 0.1938474040188245, 0.20511008537237208, 0.19204184426597182, 0.19565959183580095, 0.20102520908613541, 0.2062669274566652, 0.2001728217601837, 0.20321354497286148, 0.10512680963737153, 0.09047888850501662, 0.10366795051811639, 0.09257573108859274, 0.09995922292523318, 0.09112428356635682, 0.09523973462648194, 0.1079813514431276, 0.09300972318459244]}, "mutation_prompt": null}
{"id": "56ff389d-c8df-47a0-87fc-4d334250d285", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.8\n        self.w_min = 0.3\n        self.alpha = 0.7  # Crossover rate\n        self.beta = 0.9  # Differential mutation rate\n        self.evaluations = 0\n        self.levy_alpha = 1.5  # Levy flight parameter\n\n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def levy_flight(self, dim):\n        u = np.random.normal(0, 1, dim) * np.power(abs(np.random.normal(0, 1, dim)), -1 / self.levy_alpha)\n        return u\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i] + self.levy_flight(self.dim)\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "HybridAdaptiveSwarm", "description": "Hybrid Adaptive Swarm Optimization integrates Levy flight for exploration and adaptive parameter control to enhance convergence speed and diversity.", "configspace": "", "generation": 69, "fitness": 0.24657256565984648, "feedback": "The algorithm HybridAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.471082225309865, 0.47756177444068604, 0.5439861119918098, 0.5217903803563266, 0.4535293831037056, 0.5435987846573971, 0.5534929516621798, 0.4857020455457105, 0.507862549181837, 0.09793088621020818, 0.34276193167545943, 0.06997923334793299, 9.999999999998899e-05, 0.07089040854804896, 0.027630486600852655, 0.013342359683828908, 0.0818891464182181, 0.04342627680209621, 0.18492167005747429, 0.17939471363089998, 0.16968447232663397, 0.1753311945342655, 0.25411203970176854, 0.16423852714002074, 0.16040262465610033, 0.14102571895561145, 0.15088508054940097, 0.11089484868367505, 0.13245256875994804, 0.1308791427890479, 0.1518069982338187, 0.11184506629162938, 0.13436428379960452, 0.1153009439638466, 0.10944188529569399, 0.12758317469975322, 0.9508835795906325, 0.9654012976284063, 0.9798637813876708, 0.9811986385787587, 0.9637313610780649, 0.9472284228590406, 0.9805193033502433, 0.9706247527711445, 0.9741524791223558, 0.2757466590536587, 0.2640581542402013, 0.24583171056197972, 0.23975241642910272, 0.2395382728012253, 0.2796371204967717, 0.2606566817685535, 0.2739379843658869, 0.2763314914647452, 0.38248847545242437, 0.3428584612593486, 0.3768383058862945, 0.27404206652375007, 0.36496246618063855, 0.271709268213964, 0.3639068863139646, 0.17536724343901167, 0.352947575620955, 0.12164211786238688, 0.12345664479648788, 0.13654592674615196, 0.1467919429645388, 0.13987575736188573, 0.1760052749282962, 0.1447792166349785, 0.2531770488833782, 0.14379726960068895, 0.12823507686407154, 0.13508908500558958, 0.1328793169073802, 0.14445082319643165, 0.14037901808484143, 0.15019566496113823, 0.18095528722184606, 0.17174125490923675, 0.1542568356684797, 0.02800483949610022, 0.07159999078839063, 0.09122372795248579, 0.0029099318868269775, 0.05489299492392152, 0.05751128665949512, 9.999999999998899e-05, 0.04854035257915912, 0.060217651335976785, 0.1518037729524303, 0.0935956195137313, 0.23513128890459856, 0.11819746192813496, 0.11972313216052022, 0.044084246260622795, 0.09315107073116391, 0.11904118480793635, 0.1129376224166112, 0.268903508541791, 0.1099843061492164, 0.022438710387847283, 0.015618009936506083, 0.09399293973243583, 9.999999999998899e-05, 0.11705756382232813, 0.0464364654858086, 0.022638929084118575, 0.20633816886822975, 0.15433786183876586, 0.13582895055807132, 0.1609548910975418, 0.12434685472744755, 0.0879771064445879, 0.17448770764521848, 0.10661899314101597, 0.13658960272266518, 0.46997846497369, 0.41290748152861123, 0.4285700559453025, 0.4603718049387695, 0.4857629862071209, 0.5270572158135978, 0.4527519539258267, 0.4609216640926329, 0.4518958889190495, 0.1068421288267355, 0.14353920979376122, 0.12855433333610966, 0.1187717228842684, 0.27623264474396025, 0.09974603922445968, 0.13825886941089172, 0.13907563442055781, 0.10051247456988588, 0.23768083270611484, 0.22830568010907193, 0.16976055971596504, 0.1595963889066152, 0.1936393210514208, 0.1757031095987519, 0.2760741158060791, 0.27070589393750044, 0.3388563705578005, 0.2935258179009216, 0.33885727660335274, 0.3142815805257593, 0.34421449906580603, 0.35789770320779546, 0.3325962792472552, 0.2742209864757137, 0.3085847610952758, 0.31318262970196686, 0.307664803093495, 0.3023979105144762, 0.3606362508749509, 0.23342677933604128, 0.27380884459207555, 0.2653988717889746, 0.2871602119928196, 0.26554507107674974, 0.24793709449515378, 0.20046107436711424, 0.22769130462284348, 0.20287839524022355, 0.22611489460175993, 0.2051600771192824, 0.18454698083243581, 0.2269067486957166, 0.2030580916296355, 0.20583038223954686, 0.20183316197537815, 0.2764770960830155, 0.24573315541959484, 0.190952957534679, 0.4116887062381881, 0.1993860058658684, 0.20289759088652592, 0.25169539854775835, 0.19914798965168468, 0.6954612183849942, 0.18475621668439712, 0.15304620470751273, 0.679241527691391, 0.1897538713229412, 0.19483802793181693, 0.1612740292379804, 0.5959352247730023, 0.16647885509528004, 0.44346906573073386, 0.21024305493336592, 0.482508000186716, 0.2065467671313077, 0.2043471263630744, 0.20109527744137512, 0.38806059992066433, 0.20758059920495842, 0.20309454214556577, 0.2138252639140924, 0.1968903308410298, 0.22018219963050178, 0.18996121519585263, 0.1808126862800865, 0.19415906162274799, 0.17704267078922786, 0.18855059265226215, 0.19205757141905755, 0.09138971562420573, 0.09305233929559631, 0.09823116289482625, 0.08820661076209146, 0.09044855231911497, 0.07397240564262886, 0.09442442580100507, 0.07815382154968942, 0.09780606419769589]}, "mutation_prompt": null}
{"id": "735afbe0-bd6a-4bb4-b870-99bf0281af8d", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "828af418-3a2e-45b3-a55b-971166711c3e", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "41d9f44f-24ac-4323-bc6f-67e6dc90c1ad", "solution": "import numpy as np\n\nclass AdaptivePSOWithLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.7\n        self.beta = 0.9\n        self.gamma = 0.1  # Learning rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def apply_learning(self, particles, personal_best_positions, global_best_position):\n        for i in range(self.population_size):\n            knowledge_gain = self.gamma * (global_best_position - particles[i])\n            particles[i] = particles[i] + knowledge_gain\n            particles[i] = np.clip(particles[i], self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n            \n            self.apply_learning(particles, personal_best_positions, global_best_position)\n        \n        return global_best_position, global_best_score", "name": "AdaptivePSOWithLearning", "description": "Dynamic Adaptive Particle Swarm Optimization with Enhanced Differential Mutation and Learning Strategy improves convergence by dynamically adjusting parameters and integrating knowledge transfer between particles.", "configspace": "", "generation": 72, "fitness": 0.4105354311350344, "feedback": "The algorithm AdaptivePSOWithLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8589668516128283, 0.8519167192760551, 0.8481284511938606, 0.8559217565592177, 0.8695944813558973, 0.859004977893911, 0.8576567055914301, 0.8657981035614347, 0.8519227521420236, 0.49243003599960855, 0.6359055036392675, 0.6049820348264092, 0.6585551974033892, 0.7274465380956429, 0.6524456671712919, 0.6837714169513577, 0.6656483899761803, 0.6819144741063672, 0.5866257426356816, 0.18127539151926098, 0.14248483024621272, 0.16053151727799908, 0.17437150217654473, 0.6945265347727047, 0.18102600192200569, 0.17999350380751278, 0.1534227090715925, 0.08061374523332032, 0.1330959112940383, 0.14008022612073034, 0.10157238785847311, 0.11172014017879772, 0.13848785825692778, 0.11046706792614402, 0.13717690839514451, 0.17639360281015437, 0.9726001809472534, 0.9359780693836038, 0.9549133264583475, 0.9362148113442218, 0.9648964152506949, 0.9478674051209279, 0.9644097973489859, 0.9731668199424216, 0.9541936149289975, 0.40740709723259383, 0.41057262796935334, 0.4801644444215486, 0.45404324188503653, 0.41234245494347843, 0.4287534557076308, 0.4422321174170698, 0.44445061862996293, 0.4605842515784502, 0.8637225307374706, 0.34848615206258393, 0.6462986549918623, 0.2662952370917613, 0.27296188810301725, 0.8727847662699331, 0.8335985686393375, 0.8534914041698298, 0.8428120709521972, 0.4656170110451959, 0.12722308125999449, 0.5503262367902861, 0.2409684439605152, 0.3434918596000953, 0.37069756586218894, 0.42453601049974077, 0.48524968057450735, 0.4099290152546028, 0.21995955364339115, 0.3282921472425947, 0.7044875538664048, 0.1776407410732399, 0.4207737404244083, 0.24365726053515202, 0.30116656108490814, 0.3560044736815272, 0.27513407149449476, 0.35484558647077535, 0.09218389155921336, 0.22560323141940752, 0.5190762338085737, 0.4503270448678761, 0.29356210607149247, 0.11542222214166176, 0.2251170079291701, 0.46338924766293377, 0.43256921764915546, 0.5036445458137953, 0.46665328634396797, 0.1733681754253017, 0.33450940659258077, 0.26761786320345315, 0.5151178537118752, 0.4284639398443063, 0.27716616848067976, 0.07679133290163209, 0.13493645602261373, 0.11611281557104758, 0.22273725776160924, 0.23411501033287418, 0.18648094281147065, 0.10191572598650145, 0.280343171277758, 0.4274447177904428, 0.3959274513634773, 0.4607272792391466, 0.2947515939893165, 0.37398794865312013, 0.46957935583485766, 0.29753668240137254, 0.1789279656665691, 0.34181707002346406, 0.30829714287727183, 0.6865047089235168, 0.6819736826430349, 0.7437248774941942, 0.7163306889020524, 0.615718014605684, 0.6673309625112921, 0.7428530187685322, 0.7798415346459607, 0.6933651189266634, 0.16868424280394645, 0.5005290957935179, 0.13854275096392432, 0.1793453451875484, 0.13826463261611477, 0.5102275841816355, 0.2306061196156899, 0.13738276808011618, 0.11462858566429401, 0.15696469110842715, 0.5407001944171894, 0.20046712421321922, 0.17629317414597334, 0.24694687092335443, 0.295361070257972, 0.17008015472186855, 0.3203928578696065, 0.20315834968995228, 0.5176074256022878, 0.48043246047105603, 0.4900930147665956, 0.4755899587080167, 0.31778907713821514, 0.6602018078625052, 0.6855911790046701, 0.5122378987024672, 0.5604943140032288, 0.2765339517330464, 0.414083077076173, 0.4157585932740522, 0.33328389723574114, 0.42162008449453137, 0.35289597865759714, 0.28674308941316073, 0.3367320751556806, 0.33064130663959324, 0.21988551986473515, 0.2816268488211574, 0.2062986099253752, 0.18797817818813523, 0.26284479613989276, 0.22882874111749552, 0.2178502290877784, 0.19236345070875926, 0.23061382124999963, 0.22324168294401991, 0.19749735301792448, 0.18346161961578233, 0.20968809869504046, 0.2192995863245384, 0.18725875966778716, 0.5918558168337702, 0.22231263318880368, 0.196109279455026, 0.8379224226963495, 0.18643203894882687, 0.1527849418445969, 0.8080932908734176, 0.9049650282458402, 0.8981162110701791, 0.7220818449757502, 0.8660805326748229, 0.8578161374222479, 0.8424222380542628, 0.7013218508943062, 0.6433280793825495, 0.20648340777660446, 0.16851911378838136, 0.16527726275239818, 0.21198482902233728, 0.7567690326694841, 0.15395268267334195, 0.19228921736754478, 0.25975260223540597, 0.21280076348579147, 0.217138570205493, 0.19563313939091675, 0.212514973687555, 0.1882746459186635, 0.181406554175512, 0.21665911672193583, 0.09588037393496052, 0.10222237783717303, 0.09961322940252537, 0.09798272201876412, 0.09839718564556732, 0.09539764632163483, 0.10360417210196571, 0.10360860482479639, 0.09722422988360646]}, "mutation_prompt": null}
{"id": "ec0f0d51-6dc3-46bb-b8d8-63e71e6deaf2", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "e72b6d9f-27be-4f12-90a5-7d6c881587d6", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6  # Crossover rate\n        self.beta = 0.8  # Differential mutation rate\n        self.evaluations = 0\n    \n    def initialize_particles(self):\n        particles = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n    \n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n    \n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.beta * (best - target) + self.beta * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n                \n            # Apply crossover\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n        \n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Differential Mutation improves convergence by integrating adaptive mutation and dynamic parameter adjustment.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8909034436103358, 0.8514267655787586, 0.8543929318463341, 0.8432221789816288, 0.8627466334001822, 0.8664293357908641, 0.8618820401895952, 0.8185323731813505, 0.850958011425336, 0.6780606778451306, 0.7236317356747807, 0.6677804010096446, 0.6535396240206023, 0.696437851423114, 0.696384820494623, 0.6946652179592466, 0.6409781348376704, 0.7096444890680478, 0.5613938695940455, 0.18574290290304296, 0.12302239939460691, 0.15345582385152734, 0.1568447294344878, 0.1546194525343213, 0.17783736269541228, 0.15598553407903726, 0.6809799981139387, 0.1467816275261581, 0.15330999309982396, 0.14581396332458585, 0.10862521015573734, 0.11065499347567953, 0.10744281933833522, 0.14080872747608686, 0.11441821800825513, 0.12588693881227375, 0.9721036149091306, 0.9804177250315548, 0.9647199123844269, 0.9557949181019144, 0.9762855057550258, 0.9676093553509931, 0.971671987399906, 0.9709866524144576, 0.9539452484027713, 0.4490513580186797, 0.5014553062170346, 0.05854055496377242, 0.46674097063265896, 0.4153425683836134, 0.42825515051526875, 0.46400379350357046, 0.4406804920856624, 0.47147469435768563, 0.8853038408701658, 0.7931466335585083, 0.8004438206482728, 0.27291808901299053, 0.27261630960309535, 0.7621685458813864, 0.22940814827713552, 0.8756393328954475, 0.6335073145815173, 0.468637504082417, 0.5979546859149589, 0.5259843919888566, 0.2559612947660005, 0.44355333451536294, 0.2755106000035581, 0.4512469665407094, 0.4921714607824479, 0.4834750299619086, 0.3826229680285339, 0.5138318088393348, 0.27915482952783166, 0.33055179567334303, 0.29407583981320906, 0.5622856216938826, 0.4026370177605102, 0.2228406379109219, 0.5131345980473135, 0.4380143037286749, 0.3986666396171794, 0.05144036538754804, 0.5272228426619109, 0.1713218045877064, 0.24950469827085076, 0.52836827567554, 0.5600989072470628, 0.5025133506604766, 0.246297554533767, 0.4511812589917409, 0.521580863569316, 0.4296442830698948, 0.35676069274072575, 0.6080971357182067, 0.417534141038744, 0.5363659173118003, 0.5885215110911026, 0.105888617262753, 0.10942011726341594, 0.11448981052108664, 0.431559879382162, 0.30296356088820486, 0.20764610143467144, 0.17051975799292218, 0.117235975210779, 0.1775264085438022, 0.43831727043516044, 0.39406130140369755, 0.513630925171596, 0.43584108925705645, 0.501506523489569, 0.46273344817172524, 0.4429067534033899, 0.4357059510463428, 0.3286583132942611, 0.7433375821968425, 0.8036698801538386, 0.755779138948233, 0.8020104931958192, 0.7879225370603179, 0.67868355911867, 0.6840462183774031, 0.7676489103867802, 0.7729551916065056, 0.14259293243190674, 0.13403434630631328, 0.12043620317676651, 0.11903145483820832, 0.0947855955863568, 0.15064116408928951, 0.1503723186105551, 0.13505024213538908, 0.08075249564493536, 0.38475955349914726, 0.20217887191328565, 0.26101479642109693, 0.47302149657325143, 0.43546064935051676, 0.16267850897939207, 0.14912880918550198, 0.293564331174884, 0.4732996232426181, 0.4359762515946106, 0.2995445649051305, 0.5247477962719611, 0.45718168606107423, 0.5045761521950392, 0.41611396867630324, 0.6017276476099733, 0.6240022316599174, 0.44200084256594163, 0.2954233862686906, 0.30047908628401554, 0.3487095849596722, 0.3823338415684945, 0.2968138347795446, 0.3454914640541781, 0.5415606778182636, 0.3070559927091795, 0.25571865361161494, 0.22236451431171878, 0.201372017006906, 0.2019679239457265, 0.23714390668828889, 0.2589097788169539, 0.26971321530521997, 0.24996984520462207, 0.2246276574733388, 0.22670487176642096, 0.24903153851223747, 0.21961355427072837, 0.19499506445872516, 0.1938111095422409, 0.2026055328087677, 0.21764928735079592, 0.1803776274526947, 0.20800950450019307, 0.19658406095428405, 0.864520638904889, 0.18576635612380143, 0.15266813641146093, 0.821458683350665, 0.8535363485856206, 0.8637394377675867, 0.6191976445029217, 0.8472090259536802, 0.19220428915103005, 0.7837755278382498, 0.210197686233616, 0.770192528112757, 0.20868076837058758, 0.16709341716195536, 0.16782862862647907, 0.2100357032611212, 0.1640350270757337, 0.8494375779844247, 0.1847142237763406, 0.1841335677692617, 0.20352926649741254, 0.2034990310088438, 0.22450292601131727, 0.2043135133386227, 0.17696336295758885, 0.23055794209732783, 0.2044306536392061, 0.12023607229179412, 0.10973843068290245, 0.09971670718962888, 0.10002724619297498, 0.09237738651494343, 0.1394997831508954, 0.10456973377629508, 0.1115853199280713, 0.09421293214163307]}, "mutation_prompt": null}
{"id": "90d26140-721c-483e-89d4-4155388bda08", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.85\n        self.w_min = 0.3\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.1  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "HybridAdaptiveParticleSwarm", "description": "Hybrid Adaptive Particle Swarm Optimizer integrates chaotic initialization, adaptive mutation, and memory-based velocity adjustment for enhanced convergence speed and solution quality.", "configspace": "", "generation": 75, "fitness": 0.42374421670580337, "feedback": "The algorithm HybridAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "cbf6ee4c-9db8-4c7d-add4-2642815347f6", "metadata": {"aucs": [0.8593610698444872, 0.8204366533607839, 0.8449854715546068, 0.8552418876292598, 0.8676037206974347, 0.836566439523704, 0.8504801318225035, 0.8402323593260838, 0.8324770072981457, 0.6713315278012205, 0.6581074762943224, 0.663992759976917, 0.6614934183291115, 0.7084840042750213, 0.7308553569644226, 0.669748911254342, 0.6589074924975941, 0.7085246560508422, 0.5921261221647673, 0.6414002068012583, 0.11923006613900744, 0.18081964465521416, 0.1449413124300558, 0.15312054800131358, 0.6316822658854502, 0.6762572876061616, 0.6693121846213452, 0.1636228197535331, 0.1228167464053187, 0.13343699508972873, 0.12693248079914576, 0.11670838176690834, 0.13680442229344003, 0.10929405198209774, 0.10642273667413882, 0.11139578744285794, 0.9643534250121528, 0.980479875947011, 0.9454678297399592, 0.9722996273237385, 0.9798552256501443, 0.9468458251243128, 0.973348501120912, 0.9720863318081332, 0.9718357664541014, 0.5506489223351388, 0.5400144233029986, 0.4707063879862874, 0.4576000713027649, 0.42748637605611184, 0.17747450914416518, 0.5750529722167992, 0.5305952128942648, 0.541344885360592, 0.8804416960530248, 0.8612279661724874, 0.8337141210908461, 0.2620687366831237, 0.27261773529675704, 0.2748537564817972, 0.8429414419882202, 0.8193137078177961, 0.7863120102739167, 0.5580706894750477, 0.12556833696227554, 0.5354083068685743, 0.5583063421067034, 0.40481405067777765, 0.4594939194296219, 0.47445113890927126, 0.4880258221658128, 0.27178659017827844, 0.1928949318725438, 0.5655323227455158, 0.27503206094015475, 0.27051004468410333, 0.44825910960022464, 0.2138552809461105, 0.26228391962683995, 0.444013359288422, 0.46546210782587016, 0.4431560721962444, 0.16182779477228582, 0.5229704017358088, 0.10625020979073596, 0.5346721648499049, 0.5099335466003612, 0.6301049895837244, 0.5034881813749308, 0.2372384458651814, 0.6597128107658665, 0.2708539545849533, 0.2329425776397862, 0.11968187484576431, 0.09443924598006759, 0.1025151094264165, 0.6002863681476427, 0.47201016123803297, 0.6459735115285357, 0.3615573987998705, 0.13254002641849183, 0.0810662774005485, 0.3096352980217183, 0.4974221619218301, 0.24121637589391975, 0.14170024581260499, 0.3271350247582705, 0.2998717002905159, 0.5341921437912334, 0.3770233762264439, 0.4804662088388373, 0.48047367450261413, 0.5163151057370526, 0.48233956537666767, 0.2264414041739995, 0.49562061352070186, 0.4318247252540094, 0.7703943375370611, 0.8068663695926471, 0.783465529692857, 0.771289277831999, 0.7412366813206523, 0.7552886000045453, 0.7902791897975711, 0.798251515171086, 0.7642142275639248, 0.1416581352314411, 0.13192818851577903, 0.11076170648199879, 0.16481926994203222, 0.1489495919467101, 0.1494385025807995, 0.17807598342694186, 0.15011240568775297, 0.13172683606716784, 0.49128712793732976, 0.1881325042254438, 0.1711839578709934, 0.1765241793580653, 0.17223713948614627, 0.20733519362053632, 0.19763198421869344, 0.5281521916543979, 0.17087901591148036, 0.27926236369431323, 0.38031450500603503, 0.42311042961113443, 0.4843197673461822, 0.29934622974586955, 0.5094254668102922, 0.5563811327615665, 0.45531907552999806, 0.6517467131683365, 0.3918982805786986, 0.46993023075558116, 0.5132023292449508, 0.2687202026385558, 0.37420231805667414, 0.38561584715042274, 0.26566825084156376, 0.6066775562729112, 0.25988602059547206, 0.20381667544563165, 0.2043446780171172, 0.22445704124191912, 0.23031363352587286, 0.2164337734187477, 0.25235555886599714, 0.23963780491872888, 0.20428399630744476, 0.24596702057882502, 0.684901642330783, 0.1937078536673723, 0.18725602748491066, 0.1810613567536905, 0.20507465774080413, 0.18696828991097747, 0.19582383960722927, 0.18929906043085853, 0.1824198024971031, 0.1851254362507857, 0.18658495619665283, 0.18401609285728315, 0.8436366541248896, 0.7837262460222462, 0.8761639256885155, 0.16055084269400455, 0.8551971477915828, 0.8638081094355854, 0.8353979134839202, 0.20944256962313512, 0.8241865144823877, 0.20883576526508718, 0.7744142436223869, 0.16806782029108014, 0.2091986285273726, 0.1643424408646893, 0.15287431679882335, 0.2240517625444215, 0.23059929775763188, 0.20820728970313562, 0.19916100608887943, 0.19889098747073541, 0.20552973284028098, 0.20239511541119548, 0.22101096680110832, 0.23088599831494117, 0.11207245663724774, 0.1079670489526976, 0.08745943618868701, 0.0996582211263749, 0.10437436230437291, 0.15125893130914247, 0.10011056187170175, 0.09666303674921983, 0.10280706951387497]}, "mutation_prompt": null}
{"id": "a16d509e-89ad-4861-87bc-9ced21d89fc6", "solution": "import numpy as np\n\nclass EnhancedHybridParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive coefficient for faster convergence\n        self.c2 = 2.0  # Increased social coefficient for faster convergence\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.6\n        self.beta = 0.8\n        self.gamma = 0.2  # Enhanced memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def differential_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.sin(np.pi * self.evaluations / self.budget)  # Sinusoidal scaling for exploration and exploitation\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridParticleSwarm", "description": "Enhanced Hybrid Particle Swarm Optimizer with adaptive velocity scaling, differential mutation, and elitist selection for improved convergence speed and solution quality.", "configspace": "", "generation": 76, "fitness": 0.331144767642589, "feedback": "The algorithm EnhancedHybridParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.8425129843137193, 0.8259212263623736, 0.8519652766965198, 0.8721249547883978, 0.8569039088514443, 0.8346805250694478, 0.8468118541135601, 0.7521789597332624, 0.826479577208473, 0.7513308262132535, 0.670651526532141, 0.40064291519051476, 0.6969380799455723, 0.5669462063749285, 0.7470776871103093, 0.6308473252279629, 0.3068078894507976, 0.04534004640939615, 0.17729761788748166, 0.18602662606143605, 0.11117669518775453, 0.18295156427952908, 0.12139312041027173, 0.14283964214303924, 0.1548523872546217, 0.14406406968892083, 0.12221136659656384, 0.10057193114672591, 0.11831634951107883, 0.15043176937745162, 0.08287377723620959, 0.12045601339124734, 0.1122650390566825, 0.12125836595441997, 0.058573707930709484, 0.11276627617813706, 0.9500767023638167, 0.9519287154894822, 0.9639498145507258, 0.9532425877081112, 0.9277678284589638, 0.9638102789855001, 0.9546017993047906, 0.9684345789059323, 0.9595859111104599, 0.5465180612557516, 0.3815394207384818, 0.05239942489661931, 0.5445784962162687, 0.13526327347644196, 0.12927497835934587, 0.12304548660727965, 0.08180769327230741, 0.41438863310481844, 0.8585342928731627, 0.3965734279263091, 0.22504676608857466, 0.279036751030301, 0.28053138371776964, 0.2747920553461355, 0.15313452888062418, 0.11457320912698743, 0.39552015277124797, 0.13297526815579896, 0.623999133492995, 0.20750765257629278, 0.1900052391765188, 0.5895703231897913, 0.11855845632928919, 0.11364907494000398, 0.498725175131723, 0.12718390369127341, 0.3055448704232736, 0.19265536974790043, 0.47792719372178016, 0.6563114996521511, 0.15564966838021066, 0.31057986751499833, 0.28465728368842036, 0.4251078484517353, 0.13331630985916276, 0.16386553587224517, 0.34896396646327477, 0.2945716010406587, 0.027068365100002878, 0.389988922483706, 9.999999999998899e-05, 0.3290079974892375, 0.3778221631384525, 0.4814683211919695, 0.15756050517749132, 0.3419610132014711, 0.38922691625722583, 0.5383568420999993, 0.07744733618441346, 0.13359319079509002, 0.22976472388657598, 0.5642552733447416, 0.5034833416480352, 0.14329499145296232, 0.12206835549221484, 0.20382485310127352, 0.288194320954666, 0.06771253955305345, 0.41619964083496774, 0.09416048774926855, 0.16939714733687727, 0.13132855170806723, 0.3211198324003599, 0.351018444329546, 0.18269806198133087, 0.20487402555882317, 0.23696115834632736, 0.3167737500737169, 0.3067319867240985, 0.06172060885991282, 0.250435821574835, 0.7948966582030443, 0.7043896065062792, 0.6419279400991283, 0.7392605561952683, 0.6657183270435326, 0.6053540822337846, 0.7741828134490976, 0.7541936041392663, 0.8211438710451152, 0.09652104514652349, 0.06029156341230113, 0.056002719813521784, 0.14777507731868023, 0.07711035327239879, 0.11243209915655283, 0.07940597866369592, 0.04263020907493431, 0.08848398106115984, 0.15377371279779506, 0.33317814770965803, 0.1879223103713834, 0.8217122401604028, 0.3552473540206099, 0.20622712540897314, 0.2147006425645427, 0.18698133339147394, 0.22891303491854997, 0.2238873547858452, 0.666501589921507, 0.3577604579267858, 0.2568939143283979, 0.3248127439612023, 0.40967612491385275, 0.2499666755531662, 0.5976894885139857, 0.27912607997096617, 0.263460851885701, 0.28492259951302534, 0.20296455499627586, 0.23802320217724182, 0.24236388765236094, 0.1904796254345179, 0.20574049450583953, 0.34300870106910375, 0.2711996960175541, 0.22790699974115036, 0.19969954596350736, 0.21189024009320234, 0.20097953432185378, 0.2079434670426653, 0.22600627323184097, 0.23841657771282465, 0.20264111840060972, 0.20878134324704167, 0.18687407843524373, 0.22369061702740878, 0.20702797214593116, 0.19195313834550065, 0.20816882000722625, 0.2250615167462079, 0.2094176088796259, 0.2003304397751322, 0.1696759934716663, 0.1861901472415638, 0.8028478281991138, 0.15288231851855583, 0.17191645252598953, 0.20054573002230014, 0.19937126235944702, 0.14255824247443016, 0.16126240852981388, 0.8367785181504903, 0.7780979613619251, 0.211265051265198, 0.07358442369343243, 0.21133101806272325, 0.16890797029726168, 0.15333059097973367, 0.10493211157906845, 0.7167087439390427, 0.8549010992152162, 0.2329626129178295, 0.22127970622332704, 0.2059984950841054, 0.19631573006293157, 0.22625005743275328, 0.2171353476226453, 0.20397760811214494, 0.21749138030531756, 0.1989689899599889, 0.08622913486468264, 0.10103050600398567, 0.08360420040534244, 0.0810393723227224, 0.08443994844904923, 0.08644365775338014, 0.0800636824890153, 0.09100027251942688, 0.09291844198086907]}, "mutation_prompt": null}
{"id": "7752fdeb-cd21-490a-bdb8-8a8ed5d68258", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.85\n        self.w_min = 0.3\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.1  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "HybridAdaptiveParticleSwarm", "description": "Hybrid Adaptive Particle Swarm Optimizer integrates chaotic initialization, adaptive mutation, and memory-based velocity adjustment for enhanced convergence speed and solution quality.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.8593610698444872, 0.8204366533607839, 0.8449854715546068, 0.8552418876292598, 0.8676037206974347, 0.836566439523704, 0.8504801318225035, 0.8402323593260838, 0.8324770072981457, 0.6713315278012205, 0.6581074762943224, 0.663992759976917, 0.6614934183291115, 0.7084840042750213, 0.7308553569644226, 0.669748911254342, 0.6589074924975941, 0.7085246560508422, 0.5921261221647673, 0.6414002068012583, 0.11923006613900744, 0.18081964465521416, 0.1449413124300558, 0.15312054800131358, 0.6316822658854502, 0.6762572876061616, 0.6693121846213452, 0.1636228197535331, 0.1228167464053187, 0.13343699508972873, 0.12693248079914576, 0.11670838176690834, 0.13680442229344003, 0.10929405198209774, 0.10642273667413882, 0.11139578744285794, 0.9643534250121528, 0.980479875947011, 0.9454678297399592, 0.9722996273237385, 0.9798552256501443, 0.9468458251243128, 0.973348501120912, 0.9720863318081332, 0.9718357664541014, 0.5506489223351388, 0.5400144233029986, 0.4707063879862874, 0.4576000713027649, 0.42748637605611184, 0.17747450914416518, 0.5750529722167992, 0.5305952128942648, 0.541344885360592, 0.8804416960530248, 0.8612279661724874, 0.8337141210908461, 0.2620687366831237, 0.27261773529675704, 0.2748537564817972, 0.8429414419882202, 0.8193137078177961, 0.7863120102739167, 0.5580706894750477, 0.12556833696227554, 0.5354083068685743, 0.5583063421067034, 0.40481405067777765, 0.4594939194296219, 0.47445113890927126, 0.4880258221658128, 0.27178659017827844, 0.1928949318725438, 0.5655323227455158, 0.27503206094015475, 0.27051004468410333, 0.44825910960022464, 0.2138552809461105, 0.26228391962683995, 0.444013359288422, 0.46546210782587016, 0.4431560721962444, 0.16182779477228582, 0.5229704017358088, 0.10625020979073596, 0.5346721648499049, 0.5099335466003612, 0.6301049895837244, 0.5034881813749308, 0.2372384458651814, 0.6597128107658665, 0.2708539545849533, 0.2329425776397862, 0.11968187484576431, 0.09443924598006759, 0.1025151094264165, 0.6002863681476427, 0.47201016123803297, 0.6459735115285357, 0.3615573987998705, 0.13254002641849183, 0.0810662774005485, 0.3096352980217183, 0.4974221619218301, 0.24121637589391975, 0.14170024581260499, 0.3271350247582705, 0.2998717002905159, 0.5341921437912334, 0.3770233762264439, 0.4804662088388373, 0.48047367450261413, 0.5163151057370526, 0.48233956537666767, 0.2264414041739995, 0.49562061352070186, 0.4318247252540094, 0.7703943375370611, 0.8068663695926471, 0.783465529692857, 0.771289277831999, 0.7412366813206523, 0.7552886000045453, 0.7902791897975711, 0.798251515171086, 0.7642142275639248, 0.1416581352314411, 0.13192818851577903, 0.11076170648199879, 0.16481926994203222, 0.1489495919467101, 0.1494385025807995, 0.17807598342694186, 0.15011240568775297, 0.13172683606716784, 0.49128712793732976, 0.1881325042254438, 0.1711839578709934, 0.1765241793580653, 0.17223713948614627, 0.20733519362053632, 0.19763198421869344, 0.5281521916543979, 0.17087901591148036, 0.27926236369431323, 0.38031450500603503, 0.42311042961113443, 0.4843197673461822, 0.29934622974586955, 0.5094254668102922, 0.5563811327615665, 0.45531907552999806, 0.6517467131683365, 0.3918982805786986, 0.46993023075558116, 0.5132023292449508, 0.2687202026385558, 0.37420231805667414, 0.38561584715042274, 0.26566825084156376, 0.6066775562729112, 0.25988602059547206, 0.20381667544563165, 0.2043446780171172, 0.22445704124191912, 0.23031363352587286, 0.2164337734187477, 0.25235555886599714, 0.23963780491872888, 0.20428399630744476, 0.24596702057882502, 0.684901642330783, 0.1937078536673723, 0.18725602748491066, 0.1810613567536905, 0.20507465774080413, 0.18696828991097747, 0.19582383960722927, 0.18929906043085853, 0.1824198024971031, 0.1851254362507857, 0.18658495619665283, 0.18401609285728315, 0.8436366541248896, 0.7837262460222462, 0.8761639256885155, 0.16055084269400455, 0.8551971477915828, 0.8638081094355854, 0.8353979134839202, 0.20944256962313512, 0.8241865144823877, 0.20883576526508718, 0.7744142436223869, 0.16806782029108014, 0.2091986285273726, 0.1643424408646893, 0.15287431679882335, 0.2240517625444215, 0.23059929775763188, 0.20820728970313562, 0.19916100608887943, 0.19889098747073541, 0.20552973284028098, 0.20239511541119548, 0.22101096680110832, 0.23088599831494117, 0.11207245663724774, 0.1079670489526976, 0.08745943618868701, 0.0996582211263749, 0.10437436230437291, 0.15125893130914247, 0.10011056187170175, 0.09666303674921983, 0.10280706951387497]}, "mutation_prompt": null}
{"id": "1fc35186-1b86-4082-9223-0b2dce542af2", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive parameter\n        self.c2 = 2.0  # Increased social parameter\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.elite_fraction = 0.2  # Fraction of elite particles\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def elite_selection(self, scores):\n        elite_count = int(self.elite_fraction * self.population_size)\n        elite_indices = np.argsort(scores)[:elite_count]\n        return elite_indices\n\n    def adaptive_tuning(self, iteration):\n        w = self.w_min + (self.w_max - self.w_min) * (1 - iteration / self.budget)\n        c1 = self.c1 * (1 - iteration / self.budget)\n        c2 = self.c2 * (iteration / self.budget)\n        return w, c1, c2\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            current_iteration = self.evaluations // self.population_size\n            w, c1, c2 = self.adaptive_tuning(current_iteration)\n\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            for i in range(self.population_size):\n                if i in self.elite_selection(personal_best_scores):\n                    # Elite particles randomly shift slightly to explore\n                    velocities[i] += np.random.normal(0, 0.1, self.dim)\n                else:\n                    # Regular update\n                    velocities[i] = (w * velocities[i] +\n                                     c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                     c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = np.clip(particles[i] + velocities[i], self.lb, self.ub)\n\n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm Optimization using Elite Strategy and Adaptive Parameter Tuning to accelerate convergence and improve solution quality.", "configspace": "", "generation": 78, "fitness": 0.10988890363001858, "feedback": "The algorithm EnhancedParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.17.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.14038317403210676, 0.16243793537065088, 0.1746169610411209, 0.18717152030127437, 0.11546557231371157, 0.17804910714008437, 0.11963789503337408, 0.11357031889989244, 0.18369804544114743, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054303672392356894, 0.03284538947476845, 0.030465951714198525, 0.04897675347581698, 0.006902783518593969, 0.03259823831098618, 0.038434228871574994, 0.029740944769809707, 0.03037109353077705, 0.024821305932420712, 0.011001607091172039, 0.0199404529023246, 0.0459038006819148, 0.025194913718698864, 0.010372732553253994, 0.03945906422816292, 0.02757888148954246, 0.027897541280722193, 0.9394901315061258, 0.8768862584838432, 0.8968896058091025, 0.8673139736194441, 0.8059359445046057, 0.6302995076212747, 0.7636314018942715, 0.8911675629121119, 0.9554641563504023, 0.06274794416174423, 0.06493070165178272, 0.0368646131370266, 0.06285100732072602, 0.09118942692144394, 0.08345679342452317, 0.059728811442180785, 0.09234516936707837, 0.08756803371030797, 0.1194091412731465, 0.10756467384194779, 0.07121957139832191, 0.16344280372915487, 0.07510610879223278, 0.12541749217580567, 0.08708313124763878, 0.09489518892738891, 0.08472740787252953, 0.04217369383683034, 0.004492405513882303, 0.00864778090931706, 9.999999999998899e-05, 9.999999999998899e-05, 0.04393139237571053, 0.007986519560669203, 0.005649209265880972, 0.03265437513719294, 0.006685083891577959, 0.009274395662189128, 0.04639814494299477, 0.00013509465458916292, 9.999999999998899e-05, 0.0015567330359581577, 0.04382092678773275, 0.00030595478629147355, 0.021643894727265467, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05952159263662016, 0.04969496323164935, 0.0698265352505385, 0.05555229734442746, 0.04999217605926498, 0.04703421551385567, 0.08588466688542373, 0.06676080775120752, 0.07434976456656583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014620052633239622, 9.999999999998899e-05, 0.003764087603398414, 0.004890273738688111, 9.999999999998899e-05, 0.011313843276801516, 0.0020617735547646676, 9.999999999998899e-05, 0.18196694511354194, 0.15756555760738078, 0.16214000795181238, 0.1663111819847123, 0.15749531411216433, 0.14959365272293068, 0.20193515745823776, 0.1607278433158723, 0.14303674102901498, 0.040800628338189204, 0.02963570469567478, 0.02198412468535549, 0.03266886175302153, 0.02785762211645082, 0.032740289295446035, 0.028453191580664505, 0.031543985272319386, 0.04563009518615435, 0.12615851870401074, 0.12115123957297713, 0.13267606996259051, 0.1902978009045585, 0.11076447202914974, 0.14842057155147992, 0.12774387113135544, 0.13790319909045667, 0.13538652408742124, 0.13054242396408366, 0.12353837687440339, 0.16550204256759227, 0.13800672315110074, 0.14214102132124118, 0.13915706129461525, 0.14463869757860226, 0.17377774300845283, 0.12757428192865394, 0.08147297834123313, 0.09935370721164438, 0.09096762801189107, 0.0917729284508898, 0.07510157710418064, 0.08694633445899325, 0.09383903371152391, 0.10435217791692575, 0.09387272673715075, 0.15094773537389938, 0.13279556715634366, 0.1398573524721065, 0.14227273358957393, 0.142534597891826, 0.14788863834575894, 0.1491342789018858, 0.14297245696355698, 0.14332962621281187, 0.141868213513617, 0.0738353814229109, 0.13895218453491265, 0.11674368071651242, 0.1352523894831127, 0.054046145956700875, 0.12526407730495726, 0.07892064610133542, 0.12496259605807458, 0.11988628906940046, 0.13813805404461965, 0.11502893332517383, 0.18014724723873565, 0.12179065319689941, 0.11385689783054154, 0.10752915094813709, 0.11801782173424036, 0.12002948068210317, 0.15136872183405325, 0.21951827430192894, 0.1538130756824856, 0.10093030629818145, 0.1287606904696913, 0.10294876004541587, 0.1450417770692526, 0.11090588675975688, 0.11277039445096526, 0.18682422298007573, 0.1938038728137781, 0.17623702308020384, 0.19065986000679136, 0.1818973448206549, 0.17213460283031223, 0.17958253180933315, 0.18245403344912625, 0.19135981379335332, 0.037705714786508526, 0.03275322759719146, 0.03605059081326267, 0.04452156955679709, 0.036541163595084414, 0.03982923642569258, 0.05307116545547452, 0.04950544979266447, 0.033533352238873326]}, "mutation_prompt": null}
{"id": "0e641edd-e129-44b2-810b-ce55a2de4893", "solution": "import numpy as np\n\nclass EnhancedMemoryParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.gamma = 0.2\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def dynamic_adaptive_mutation(self, target, r1, r2):\n        scale_factor = np.random.rand()\n        mutated = target + self.gamma * scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def social_learning(self, particles, personal_best_positions, global_best_position):\n        for i in range(self.population_size):\n            if np.random.rand() < 0.5:\n                idx = np.random.choice(self.population_size)\n                particles[i] = (particles[i] + personal_best_positions[idx] + global_best_position) / 3.0\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            self.social_learning(particles, personal_best_positions, global_best_position)\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = np.copy(particles[i])\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = np.copy(particles[i])\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.choice(self.population_size, 2, replace=False)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.dynamic_adaptive_mutation(particles[i], personal_best_positions[r1], personal_best_positions[r2])\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    idx1, idx2 = np.random.choice(self.population_size, 2, replace=False)\n                    child = (personal_best_positions[idx1] + personal_best_positions[idx2]) / 2\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedMemoryParticleSwarm", "description": "Enhanced Memory-based Particle Swarm Optimizer with Dynamic Adaptation incorporates adaptive inertia and collaborative social learning for improved exploration and convergence.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'float' and 'NoneType'\")", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {}, "mutation_prompt": null}
{"id": "fbf839b6-86a1-4010-8f9a-4a4221bac5fd", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 60  # Increased population for diversity\n        self.c1 = 2.0  # Adjusted cognitive component\n        self.c2 = 2.0  # Adjusted social component\n        self.w_max = 0.9  # Increased inertia weight for exploration\n        self.w_min = 0.4  # Adjusted inertia weight for exploitation\n        self.alpha = 0.6  # Adjusted crossover probability\n        self.beta = 0.8  # Adjusted mutation factor\n        self.gamma = 0.05  # Reduced memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        # Enhanced chaotic initialization with logistic map\n        x0 = np.random.rand(self.population_size, self.dim)\n        return self.lb + (self.ub - self.lb) * (4 * x0 * (1 - x0))\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        # Tweaked crossover technique to enhance search diversity\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (np.sin(parent1) + np.cos(parent2)) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        # Mutation adjustment for better exploration\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2) * np.random.normal(0, 1, self.dim)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            # Elitist selection: keep top-performing particles\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm Optimizer with improved chaotic initialization, dynamic parameter tuning, and elitist selection for faster convergence and solution accuracy.", "configspace": "", "generation": 80, "fitness": 0.2627929875129818, "feedback": "The algorithm EnhancedParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.687860174078607, 0.6741558238023007, 0.673458026576822, 0.6887457672680855, 0.6774332185048498, 0.6675167351283201, 0.6651740621042949, 0.6582153105075921, 0.6309654221200497, 0.41972112501435876, 0.3595378980151147, 0.4484715775410839, 0.4897912346096598, 0.4181245547746717, 0.4771356973137102, 0.37696865950859515, 0.4552624290908629, 0.41794768852784425, 0.1305949771605146, 0.1607633482714762, 0.45920193513015595, 0.16508202324403387, 0.1642595149727718, 0.4267184264080274, 0.14239597000649495, 0.1549086340205873, 0.16547311959139754, 0.13419457105436816, 0.10794005710721322, 0.11225409973866496, 0.10768491438437044, 0.15532851150679272, 0.13376283977441272, 0.14418166113240916, 0.15125750318690934, 0.10467018472208478, 0.9767959873643016, 0.9874305664307277, 0.9781751007744387, 0.975912129764005, 0.9780075923508612, 0.97279797964395, 0.9660233736033996, 0.9463645117409523, 0.9736723773656091, 0.37998027737630413, 0.20574689089903575, 0.3050650018387555, 0.28658365862116886, 0.17110950693510818, 0.14211232861491174, 0.2520147893708782, 0.26435500874691986, 0.2960173923831749, 0.312900670300974, 0.16675508242627535, 0.2136204917797624, 0.686623421104152, 0.20199229450063416, 0.5038308760472574, 0.3104574698097047, 0.16595520525156293, 0.5868473595597052, 0.3036278586228195, 0.2274751459598625, 0.17439763752545367, 0.16489428281272978, 0.16083799397435028, 0.15347211693780594, 0.17711025200573116, 0.16218723292954695, 0.1922112706635708, 0.22026874366464422, 0.1921809426361547, 0.18567805318423303, 0.21531322917559648, 0.2808586483131382, 0.18600283849192345, 0.22542334397792607, 0.2223970990970977, 0.2090504533630756, 0.021992140653975922, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024225202094803944, 0.02269081692794439, 0.020696795803692103, 0.009618360410238003, 0.0666260881550168, 0.047130749276644957, 0.06395699764661933, 0.012861973940554217, 0.06879993022798514, 0.042458169171465276, 0.028966105510444873, 0.038602441965102874, 0.04700162737474456, 0.13892466246070523, 0.05347051826333682, 0.13270266169755174, 0.05192145158563466, 0.057964408909349174, 0.053228231388809166, 0.05884747508151145, 0.04353368256496637, 0.07078081217049947, 0.06411138821073259, 0.08851620996595644, 0.011876144782128173, 0.060204444054204775, 0.04265984633090192, 0.070495425816679, 0.09770516831761467, 0.08479087884501457, 0.44316368042084386, 0.44160585349918646, 0.43917340915517367, 0.49908738043483214, 0.48811101803180124, 0.4761483943455229, 0.46160075420565294, 0.4368663594780904, 0.46248083195506995, 0.11724098459466026, 0.10830985057981779, 0.09389712386620963, 0.10152458925947372, 0.0970349246870057, 0.11701130825530126, 0.09268733341621971, 0.10475869341708877, 0.1018372145347981, 0.30528032065311417, 0.1946834174220945, 0.380589171659968, 0.18816898274256122, 0.2629656065864968, 0.11633948582431819, 0.1976405449537415, 0.1696850079822887, 0.25929308951473784, 0.38210947990573274, 0.29041110901268674, 0.34702484843204817, 0.2791596925725792, 0.3076509285308413, 0.3619055817446639, 0.3936154713129909, 0.31173096101762554, 0.3987997242896135, 0.28259149011945406, 0.2453726529155541, 0.15722823462562685, 0.239764826739145, 0.27016358221221615, 0.2790668572017435, 0.15354751601350813, 0.20497249199161116, 0.1348019588566709, 0.2361169042564637, 0.23880894758288318, 0.23215788152753503, 0.22848824903349285, 0.2785201435862903, 0.22787841357821026, 0.2632258042961272, 0.2182688503993393, 0.2663382191521131, 0.18934631357700682, 0.1938536796567718, 0.2190422162035539, 0.18551631360948762, 0.4241428523512224, 0.18760867654404878, 0.1956537788398035, 0.17837496151543497, 0.21456899005741314, 0.7027514048256609, 0.14757885983836716, 0.1836548421286247, 0.615112356642499, 0.7275047723354817, 0.18051652291858022, 0.16456242675527688, 0.18644563726834873, 0.18544090576832573, 0.3398701372533218, 0.19959594482364695, 0.5582776468515844, 0.35354848683029894, 0.14693207722457935, 0.16633837259409612, 0.12549276247332675, 0.20958304328577793, 0.2085540473923625, 0.17574077210010652, 0.1852427513473247, 0.18672381518334125, 0.19222863831111758, 0.17804708877452502, 0.1816216218243457, 0.17917597588402245, 0.17621839813998863, 0.1824059562699677, 0.1078352120793612, 0.06607233531039436, 0.07707605137424922, 0.07321751160779022, 0.07883127302631932, 0.0723271157032983, 0.09743732240975167, 0.11729591154264707, 0.09346037652326011]}, "mutation_prompt": null}
{"id": "ef62adf6-bc67-4965-8923-3646a7538457", "solution": "import numpy as np\n\nclass QuantumInspiredParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1_initial = 2.5\n        self.c2_initial = 0.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.evaluations = 0\n\n    def quantum_initialization(self):\n        center = (self.lb + self.ub) / 2\n        spread = (self.ub - self.lb) / 2\n        return center + spread * (2 * np.random.rand(self.population_size, self.dim) - 1)\n\n    def initialize_particles(self):\n        particles = self.quantum_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def dynamic_parameter_adjustment(self):\n        progress = self.evaluations / self.budget\n        c1 = self.c1_initial - (self.c1_initial - self.c2_initial) * progress\n        c2 = self.c2_initial + (self.c1_initial - self.c2_initial) * progress\n        return c1, c2\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            c1, c2 = self.dynamic_parameter_adjustment()\n\n            for i in range(self.population_size):\n                velocities[i] = (w * velocities[i] +\n                                 c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n        return global_best_position, global_best_score", "name": "QuantumInspiredParticleSwarm", "description": "Quantum-inspired Particle Swarm Optimizer enhances convergence speed using quantum superposition-based initialization and dynamic parameter adaptation.", "configspace": "", "generation": 81, "fitness": 0.2583678082165382, "feedback": "The algorithm QuantumInspiredParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.5862478522436032, 0.5553265332906169, 0.5276284892010142, 0.6795080514123921, 0.6106911231971845, 0.5815362630983728, 0.4924386592896449, 0.6096438102725472, 0.613135443919699, 0.031082499853013146, 0.0360987717873823, 0.030981541559569226, 0.10421241243321788, 0.1777825743432495, 0.14876100776887924, 0.05466651782069598, 0.07392561409601295, 0.08837967052203477, 0.10881971554158953, 0.12761431208688323, 0.10124639935845992, 0.10015578449006102, 0.10579978539878354, 0.10522558311348562, 0.07378103283360837, 0.10570180600265544, 0.09984441797542154, 0.11307534611150916, 0.16565221449630663, 0.07472082296105931, 0.09534357504367397, 0.12398135096869789, 0.06474618979503777, 0.12903918274569148, 0.11169684580530159, 0.09043693703945632, 0.9754407934307222, 0.9743757399586939, 0.9853565449163614, 0.9512817648125005, 0.9680065785115937, 0.9716453295350421, 0.9728680286662323, 0.9636034531716068, 0.9759197178618799, 0.26130313555433227, 0.31193562028550514, 0.3207581724415016, 0.33691210831730156, 0.28235147965559493, 0.24799137011611183, 0.17871408001661093, 0.3027999233653895, 0.3112928501530148, 0.627479543192142, 0.3677501836733511, 0.5615659560144171, 0.20132421140091283, 0.6335675824124178, 0.1908681523084852, 0.2035597640853989, 0.20339276243039972, 0.6358813823384336, 0.3675640971001145, 0.07336071389102328, 0.10808520459583437, 0.09096781187304037, 0.14639715212769844, 0.11443930785022127, 0.14677283971130695, 0.17824678130380867, 0.23231025438658348, 0.11994937013733997, 0.14806238326778853, 0.10799413723056572, 0.11945334402193908, 0.17381737318655688, 0.19947806854636652, 0.2155935025265403, 0.19760932985280544, 0.1054237919578076, 0.03648323586527291, 0.20511827308348451, 0.0482209178717643, 0.016351688645528717, 0.05836211726424423, 0.021975779325099976, 0.023010042593006985, 0.11387316171955075, 0.10065294845166195, 0.1311908061204453, 0.12749409318764937, 0.19335961115350608, 0.2562410665727234, 0.09530142476164893, 0.09150358556003335, 0.1392921214120899, 0.22795760535660425, 0.14653291925819356, 0.028338836283465008, 0.062037832263751036, 0.040496130215993076, 0.06777176637762228, 0.12011173670028041, 0.038845331910248415, 0.055494595462159846, 0.09248301879621901, 0.04743086659337081, 0.12292262248167662, 0.11605070116886784, 0.17242911456054588, 0.08842984438890378, 0.12035959422466569, 0.21035722710181115, 0.041657105638750025, 0.14942149913606828, 0.06524595524766486, 0.4323963100255309, 0.47372793297974247, 0.4154750311989438, 0.4860711214832538, 0.4507590635947166, 0.48388707507802486, 0.4879475992326867, 0.4221525738394627, 0.42943087450572126, 0.12051871604022713, 0.08680366826648611, 0.09170043906923708, 0.10569357336579943, 0.08943644383758076, 0.10515317481365305, 0.11287241280190541, 0.09586177346373148, 0.1001965747557444, 0.23456956625971437, 0.28849483456330316, 0.20133005815262672, 0.3068046457650381, 0.40944546042069274, 0.18715702445773152, 0.24976452484069867, 0.20664285862545373, 0.19514005934489187, 0.28264846291428924, 0.33650737122435925, 0.29186904590099316, 0.33503045805441667, 0.3482337775621879, 0.2997437519887284, 0.2858194646350489, 0.2738565445458656, 0.28642692220560406, 0.24221263700099283, 0.24072337874901006, 0.24984696527253025, 0.2251717534071226, 0.2230372123895642, 0.22390800380881282, 0.2247394378494837, 0.2192598479554334, 0.19418127580239564, 0.22829968358484776, 0.20968524702011626, 0.2433045346644951, 0.2290191347816165, 0.20451579983983825, 0.22917838720885542, 0.22269270707364308, 0.2367223313641179, 0.20076730342281446, 0.241517160694814, 0.17712635435665725, 0.18770938205107068, 0.2107835148436069, 0.21838061383049245, 0.19713900159285014, 0.20345196379098507, 0.1999295399170684, 0.1969915237382377, 0.7246422180246135, 0.18001635386894455, 0.5844231087893694, 0.7559702335403229, 0.1977105648550389, 0.19130680845096149, 0.18086149294666198, 0.1548071090169284, 0.7076832473137279, 0.642024675267916, 0.2092413002855804, 0.1108898578424049, 0.5856258362031435, 0.5598945211239077, 0.33734322602939637, 0.5836442752148143, 0.5928246035079965, 0.6320820155235183, 0.19822828637626622, 0.19881350501067774, 0.17850142895662424, 0.19332730757483263, 0.21306638449890203, 0.24688687595104397, 0.19294059145993414, 0.18677955855418582, 0.21464768136267076, 0.08420513096062787, 0.08816107266578033, 0.09839404114848371, 0.10492624926439187, 0.07913851073977507, 0.08747692641978333, 0.09830170292925033, 0.09382434696055975, 0.09376663348297187]}, "mutation_prompt": null}
{"id": "46dff46f-ade6-4626-a9f4-6bd6d67e8dd3", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 40\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.gamma = 0.05  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n        self.diversity_factor = 0.1\n\n    def chaotic_initialization(self):\n        chaotic_sequence = np.mod(np.cumsum(np.pi*np.ones(self.population_size*self.dim)), 1)\n        return self.lb + (self.ub - self.lb) * chaotic_sequence.reshape(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def update_diversity_factor(self):\n        return self.diversity_factor * (1 - self.evaluations / self.budget)\n    \n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.choice(self.population_size, 2, replace=False)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                velocities[i] += self.update_diversity_factor() * (particles[i] - personal_best_positions[r1])\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = np.clip((parent1 + parent2) / 2, self.lb, self.ub)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm Optimizer incorporating chaotic map initialization, dynamic parameters, and diversity preservation to accelerate convergence.", "configspace": "", "generation": 82, "fitness": 0.19374138608071545, "feedback": "The algorithm EnhancedParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.43713854814626507, 0.48456182077097665, 0.3915427065782757, 0.3565839062988484, 0.4051247450899449, 0.4494935041297412, 0.4413207387172182, 0.3744475527526203, 0.4838670596937453, 0.009402877212640659, 0.012047898168448423, 0.05888398801496009, 0.05468153270606613, 9.999999999998899e-05, 0.030845532361884254, 0.046288868503245206, 0.042299315631255, 0.013482481029999271, 0.08524264881175803, 0.08790692010950185, 0.11060016964932984, 0.09515830143685167, 0.08656932665202899, 0.1135270958131096, 0.11159549388854795, 0.07569720082247844, 0.0798659936472621, 0.08114883408009832, 0.0734759364847718, 0.06293924254413918, 0.07377037955595156, 0.08130737885393569, 0.07811459767142037, 0.07543342790221852, 0.05471601872215848, 0.06465798225462438, 0.9859270122301245, 0.9907143895086882, 0.9856324429000205, 0.9485030127818928, 0.9550400951102227, 0.9544776103706434, 0.9772522866743942, 0.9768421176611787, 0.97610427403522, 0.18888289479522968, 0.2309212459436425, 0.22367364816750746, 0.19761751067265243, 0.2185064806355933, 0.23037471341792304, 0.20725404364888322, 0.1497275024014847, 0.1095408004297973, 0.1649977536121371, 0.2347756545964288, 0.20260595157351102, 0.2582229180364044, 0.26894070326241815, 0.4225294539208889, 0.16112285202485488, 0.11512811291869207, 0.16209512939898518, 0.07203386869699957, 0.07386140577617772, 0.07143939839180125, 0.09408175895986004, 0.10654086391509976, 0.16963701827192745, 0.12344900770718137, 0.09921316687848625, 0.11630336036846889, 0.09453976437185174, 0.12210764378498529, 0.10867655310872781, 0.1709795296881026, 0.13496936619729294, 0.13370618790731026, 0.12844699216254007, 0.16441980633532127, 0.12270931722935585, 0.0008114924437774285, 0.01985851502254188, 9.999999999998899e-05, 0.00520280629064096, 0.0030511164321260775, 0.027772461340449306, 0.006239859159593464, 0.01273203395975342, 0.01838233762358632, 0.11142176269923953, 0.11163706655990469, 0.09949433382779971, 0.036669412588697714, 0.05484278047320201, 0.025413904533420073, 0.05243067223556408, 0.053598124059649144, 0.054628878766713185, 0.019257683773597267, 0.024003435574597498, 0.018329261665339214, 0.03449130828054825, 0.030249909726373314, 0.01884473279618981, 0.028923233062907228, 0.02709433673338757, 0.018603377749683236, 0.07251155117070396, 0.03285823582966352, 0.07888951843320025, 0.0365855203160772, 0.05574079035272994, 0.04862000925567622, 0.041202553561855315, 0.0336384512733745, 0.05264511254197746, 0.34803951245785314, 0.38153243693107164, 0.3377808704542892, 0.37692685310505836, 0.320884605461205, 0.35392621161983984, 0.34661288994511996, 0.3703100730344142, 0.32923504554535776, 0.06690421817647152, 0.1016238878739476, 0.07721796152616156, 0.11653110065309213, 0.07635961342919306, 0.10085995261447733, 0.10906244371782636, 0.1084583272757802, 0.07273423290465131, 0.2437723844118631, 0.24750461909707633, 0.23227120628539288, 0.14242024959299215, 0.21957595379620143, 0.1744737867467704, 0.14629167338860172, 0.22907092252892003, 0.25698869113115075, 0.2582412312903689, 0.23879724396130264, 0.1742144216106608, 0.2598648843637341, 0.24740105618106234, 0.27889219521764075, 0.17261679536761587, 0.2649555204622266, 0.22180872726706835, 0.18084320188702796, 0.16103728559082664, 0.18188793056325092, 0.16243139870012546, 0.2191160657509873, 0.22759445806194323, 0.15667312168686387, 0.1534198179091576, 0.1771906520528933, 0.21609492419191845, 0.2175833919296205, 0.23193442269235942, 0.23317516289315943, 0.2475743947534791, 0.23709976424196066, 0.2127196448272387, 0.24005952924978846, 0.3221856701524559, 0.1941507950113246, 0.16432033755257158, 0.18007402466701639, 0.17724387647546413, 0.1756690120930814, 0.18735026238844898, 0.20532385077097748, 0.17204550945723063, 0.2007247160722052, 0.19654709355461253, 0.18161403381156382, 0.19887038345371433, 0.16548418130711884, 0.1476588850099404, 0.49220666798603496, 0.1367670163009087, 0.13596673539091098, 0.42564227416321887, 0.4426370772898762, 0.4715247225582766, 0.40292646007959343, 0.07961787904486228, 0.13503623584850444, 0.13778422246922906, 0.1129027614019249, 0.1120319394168271, 0.11206946189336431, 0.22910644893831744, 0.2280544726464142, 0.20113294507218993, 0.21869579693781438, 0.20678008237587742, 0.2133265112728333, 0.22867954014473102, 0.22841353385618612, 0.21424491379842725, 0.08925044302326823, 0.0960249341955649, 0.09439219171898638, 0.09170810136912955, 0.07624773360652959, 0.08426109239777246, 0.09690351899156047, 0.09924740701598456, 0.06955444874085293]}, "mutation_prompt": null}
{"id": "93610052-bd0f-459f-8265-563a90464575", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.4\n        self.c2 = 1.8\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.evaluations = 0\n\n    def initialize_particles(self):\n        particles = self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def dynamic_learning_factor(self):\n        return self.c1 + (self.evaluations / self.budget) * (self.c2 - self.c1)\n\n    def stochastic_velocity_control(self, velocity, particle, personal_best, global_best):\n        random_factor = np.random.rand(self.dim)\n        inertia = (self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget))\n        cognitive = self.dynamic_learning_factor() * random_factor * (personal_best - particle)\n        social = self.dynamic_learning_factor() * random_factor * (global_best - particle)\n        new_velocity = inertia * velocity + cognitive + social\n        return new_velocity\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            for i in range(self.population_size):\n                velocities[i] = self.stochastic_velocity_control(velocities[i], particles[i],\n                                                                 personal_best_positions[i], global_best_position)\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Dynamic Learning and Stochastic Velocity Control for faster convergence.", "configspace": "", "generation": 83, "fitness": 0.20208989650902634, "feedback": "The algorithm EnhancedParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.4996650794820252, 0.37115021102645385, 0.4413896677758735, 0.4149342527068549, 0.44195008163614957, 0.49001066162474494, 0.39452095257919195, 0.4063524451291416, 0.5025758208480706, 0.02042320117113816, 9.999999999998899e-05, 0.02959209229750026, 0.07493405719197577, 0.0759442393430716, 0.0640647878689653, 0.13050450952432036, 0.12373365139561321, 0.04521369604069991, 0.09997156709701083, 0.0886410528519136, 0.10602555736524588, 0.07966400128229234, 0.061845772269515153, 0.09610965111396874, 0.07943410052705424, 0.12240716099436288, 0.09773769114969122, 0.07540896745811299, 0.08340795724702077, 0.08222186886254401, 0.0819317534108952, 0.07440848038119274, 0.07317028960394567, 0.09639297800294333, 0.09134495980851076, 0.09420059731961083, 0.9813854711151683, 0.9804250369947081, 0.9857398500826747, 0.9838351026567402, 0.9818763682632976, 0.9809254481715357, 0.9863878623472689, 0.9852929565535126, 0.9809351042542146, 0.2500274346083182, 0.15029094905990426, 0.09424005704648575, 0.20152460168226793, 0.2033863910288477, 0.23176420779225082, 0.20825272225473468, 0.07984609044522406, 0.25877003613389393, 0.19277227474525327, 0.20859951415008904, 0.20530305872215315, 0.2358037963926768, 0.24918451714388534, 0.22615077448088872, 0.11926669661695233, 0.2690104518540447, 0.23537167340599652, 0.10509956241229379, 0.05932043750204574, 0.12555728439129576, 0.08287406428892286, 0.11140751853731401, 0.08910295772523258, 0.1362386495518143, 0.10804930006155844, 0.10420887949449131, 0.09416513477922195, 0.11871116339380583, 0.131731106754442, 0.21168259727258354, 0.05421244106480594, 0.08094172680567191, 0.11733101694521608, 0.022054426725649723, 0.16962089643749545, 9.999999999998899e-05, 0.0014656760475579844, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06476909237668516, 0.057539941994130483, 0.12292110457304184, 0.08532228998115188, 0.08892902023470706, 0.012106147732495964, 0.05741447774973296, 0.04589131907803168, 0.03808170139711797, 0.010751585544978792, 0.01428338075290303, 0.01696104597710768, 0.08758438232127697, 0.03875937978248767, 0.049653775232285424, 0.046246343600999884, 0.03274726539471973, 0.013773668119949845, 0.126582949489764, 0.02191426797022089, 0.08534460630992269, 0.002945677483065956, 0.06669151485474689, 0.08007835412310504, 0.03982395483873147, 0.0507217200104344, 0.06286242325973124, 0.393352493415029, 0.33122867962201363, 0.3364668318620968, 0.3797804238482717, 0.37830618675316685, 0.38993726770003223, 0.37541594212499363, 0.37341254361806087, 0.36429321005382953, 0.08328349810075031, 0.07211922684846428, 0.10168953857992669, 0.08552198345309847, 0.08684057346414797, 0.08610882522745, 0.13083067078150357, 0.07839587508513834, 0.091025041121787, 0.16291488638600637, 0.16725146594776796, 0.1789402303026476, 0.1684559879488381, 0.17506937264243583, 0.1683590793182682, 0.2925664356284706, 0.1729019192810447, 0.19949201860853805, 0.21226278889562178, 0.2483937639079462, 0.22595149914763601, 0.1770900385381723, 0.21160564699789453, 0.2839647704032229, 0.18998071279037143, 0.3126833421540741, 0.29752134829845034, 0.17603689663083388, 0.16997750783831944, 0.23315136639490497, 0.15359889929830828, 0.15955030547271054, 0.19451842080603887, 0.1358403478737138, 0.21319429224003417, 0.23452445639179909, 0.19637720450402596, 0.13975359066513848, 0.1865155820599783, 0.18152742626823615, 0.2023364970194721, 0.17373442682240803, 0.1883460969563029, 0.20060028823217557, 0.19880625672279695, 0.18979900456271248, 0.19812999973673417, 0.18801323224856492, 0.2516665597775368, 0.19512460634022877, 0.16647865407723983, 0.2232319126952742, 0.18812716798666995, 0.17645207311801636, 0.5436750956246086, 0.16455169364781708, 0.15197246346372084, 0.5783633298320372, 0.19229779352661158, 0.6248216697234688, 0.6175944586068287, 0.16240722313191236, 0.6182112283739887, 0.4597540596789421, 0.18375865246795542, 0.37698282247518966, 0.2828952285522861, 0.318456480613467, 0.14093769693490898, 0.20198435842922047, 0.20273565607544997, 0.40651214589657225, 0.17114715490003274, 0.19319986310833115, 0.20756697384768374, 0.20677596026722933, 0.19269671057346638, 0.18562125634418725, 0.18719201997328772, 0.18522687156875794, 0.18834430263149038, 0.07624675298351757, 0.0764313309125686, 0.07538200460953304, 0.08159375320509321, 0.07328432838569243, 0.07213511763843361, 0.08498031612701851, 0.07522785131591159, 0.06859733613957764]}, "mutation_prompt": null}
{"id": "d12a1d4b-0f20-446f-8862-f5bd447766ef", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.7\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.05  # Adjusted memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * np.power(2, (beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.power(np.abs(v), 1 / beta)\n        return step\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def local_search(self, position, best_position):\n        step = self.levy_flight(self.dim)\n        new_position = position + step * (position - best_position)\n        return np.clip(new_position, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor=0.5)\n                particles[i] = self.local_search(particles[i], global_best_position)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with dynamic inertia weight adjustment, Lvy flight-based exploration, and elite-based local search for faster convergence and better solution quality.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {}, "mutation_prompt": null}
{"id": "8e12b387-7309-48e7-b60e-56202d742e50", "solution": "import numpy as np\n\nclass DynamicSwarmExploration:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Increased personal attraction\n        self.c2 = 2.0  # Increased global attraction\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.8  # Increased crossover probability\n        self.beta = 0.9  # Increased mutation factor\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def local_search(self, position):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return np.clip(position + perturbation, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * ((self.evaluations / self.budget) ** 0.5)  # Time-varying inertia\n            scale_factor = np.exp(-0.5 * self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    child = self.local_search(child)  # Apply local search\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "DynamicSwarmExploration", "description": "Dynamic Swarm Exploration introduces time-varying control parameters and enhanced local search to improve convergence speed and solution precision.", "configspace": "", "generation": 85, "fitness": 0.256630974459472, "feedback": "The algorithm DynamicSwarmExploration got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.47239678655126704, 0.49531335042952707, 0.4702907192921375, 0.4991244818893249, 0.48276310326898364, 0.5072348830043392, 0.46949921183805965, 0.49916900231001193, 0.5141908332534602, 0.10988933661056233, 0.11376670756776641, 0.1007690977172917, 0.14182510056803255, 0.12557355961164307, 0.07577690823211436, 0.09947141000819026, 0.10851506494036489, 0.10052863716025151, 0.13560735051004735, 0.1367600861632725, 0.14810147138542706, 0.12428513378609729, 0.13052868741324108, 0.15359420776780408, 0.1343600255478623, 0.1387588838259739, 0.14310937015091107, 0.12270171434720867, 0.11987628389063809, 0.12016041473193162, 0.10384610241407666, 0.12168746920355678, 0.115778981184113, 0.1141310566728726, 0.11912027602954822, 0.11391211745162577, 0.9716856812115326, 0.97390760829158, 0.9600825539038104, 0.9722781034035385, 0.9714851310737874, 0.9434215318812414, 0.9791358785819134, 0.9806491234927086, 0.9690277717973207, 0.2991086583001461, 0.2772471127477987, 0.29518363117948787, 0.2902802543302829, 0.284198657065437, 0.27904606096785145, 0.30446943348794986, 0.2800694139719009, 0.333934394068799, 0.7983829001209044, 0.7097246565320556, 0.6275420960823698, 0.7159116873567004, 0.5260988749238988, 0.7812190393535157, 0.5850079377357369, 0.6900221884242709, 0.5791253892598727, 0.2032140658517677, 0.121701140441277, 0.11020691075058386, 0.2501422253840777, 0.2144827527368376, 0.1195805376086766, 0.19089207419049847, 0.2162754302862494, 0.21231573737061282, 0.12686215315107652, 0.17996814950390194, 0.16907488430485806, 0.19170761273626713, 0.1841230540242843, 0.20039454865023487, 0.20916329182836413, 0.1829853894545851, 0.1890167462241994, 0.09448250312420059, 0.09803700328566134, 0.034158649303157484, 0.07583699202666316, 0.055417171493453266, 0.009007963402145602, 0.03104610583360956, 0.08506652722665509, 0.035328485223018236, 0.17565362959399133, 0.13386908770174122, 0.15339674755320343, 0.08262818609290623, 0.13949305322025285, 0.09769903628320553, 0.12523295760137465, 0.1460945089750878, 0.1230810088112898, 0.01632039447365896, 0.02030998066611578, 0.0053448757769547495, 9.999999999998899e-05, 0.003251473730748744, 9.999999999998899e-05, 0.003280640102115262, 0.030202955357385708, 0.01795520634097736, 0.1287657971822559, 0.1399462505184481, 0.14050264524456013, 0.14027269814288135, 0.15429673692594115, 0.14948689648065427, 0.14628752653699373, 0.13634892447185032, 0.13092642264015664, 0.41755990929383646, 0.44639827459456805, 0.4998471431448993, 0.4705464037737974, 0.456668312514364, 0.44030164009860706, 0.43474261082701404, 0.4457392309679974, 0.4867089086764258, 0.10373220366017555, 0.11008294285629416, 0.1294460669588492, 0.10434863355186952, 0.1125185087714432, 0.12979861370816237, 0.10581262568946748, 0.11755390851239622, 0.11801427481918347, 0.3064611150212837, 0.15338573993489024, 0.16850910115968998, 0.257670230920673, 0.2674214404167212, 0.25246168427421645, 0.17277224115660628, 0.19341476325741003, 0.2801957170876923, 0.2891821571727179, 0.3027117374104441, 0.3178871124414817, 0.31525201542731307, 0.29781969543987175, 0.33318749964099237, 0.32978811996451574, 0.3327360177817694, 0.3005590889988895, 0.2455813198515714, 0.2679156718314666, 0.24191676667913853, 0.24903165863925858, 0.24146246149849038, 0.24209801565559752, 0.2465463183104668, 0.24370854524598573, 0.2558945895717005, 0.20701836579900368, 0.21119198137309236, 0.23872592481758725, 0.20661007338135773, 0.2107891807094755, 0.2071597902601846, 0.2121032383939191, 0.20064868282663995, 0.20653199444797887, 0.2303218795577845, 0.20799281515689705, 0.21626111112723712, 0.23316306085066274, 0.30325305810996395, 0.2107686758432712, 0.3223578778138031, 0.22421419701869194, 0.31527143186755546, 0.18665501895582837, 0.17068058193793445, 0.1856022676008423, 0.7516991890861634, 0.1925946478126298, 0.17717179684495987, 0.14106696182798573, 0.17736138561466852, 0.20326700730283853, 0.521156044833037, 0.20897056346538234, 0.6050945443882321, 0.2110024221012482, 0.6885928749044332, 0.16756415973114236, 0.21132883097978328, 0.1591591403603625, 0.20844144393717656, 0.17844079910211963, 0.18843847775244227, 0.19473520063099115, 0.17903855923270262, 0.19508871455193244, 0.18641023986761485, 0.19026042403847843, 0.18391027568086138, 0.20211880195571863, 0.09355861442703772, 0.09289051211616028, 0.08022173911025898, 0.08173261300524026, 0.0932027020870766, 0.0838740836854337, 0.08510878504187425, 0.08127454665949518, 0.0828027939329471]}, "mutation_prompt": null}
{"id": "37afff0a-9161-4fd3-8e15-53d1c9a6dfed", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.85\n        self.w_min = 0.3\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.1  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "HybridAdaptiveParticleSwarm", "description": "Hybrid Adaptive Particle Swarm Optimizer integrates chaotic initialization, adaptive mutation, and memory-based velocity adjustment for enhanced convergence speed and solution quality.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.8593610698444872, 0.8204366533607839, 0.8449854715546068, 0.8552418876292598, 0.8676037206974347, 0.836566439523704, 0.8504801318225035, 0.8402323593260838, 0.8324770072981457, 0.6713315278012205, 0.6581074762943224, 0.663992759976917, 0.6614934183291115, 0.7084840042750213, 0.7308553569644226, 0.669748911254342, 0.6589074924975941, 0.7085246560508422, 0.5921261221647673, 0.6414002068012583, 0.11923006613900744, 0.18081964465521416, 0.1449413124300558, 0.15312054800131358, 0.6316822658854502, 0.6762572876061616, 0.6693121846213452, 0.1636228197535331, 0.1228167464053187, 0.13343699508972873, 0.12693248079914576, 0.11670838176690834, 0.13680442229344003, 0.10929405198209774, 0.10642273667413882, 0.11139578744285794, 0.9643534250121528, 0.980479875947011, 0.9454678297399592, 0.9722996273237385, 0.9798552256501443, 0.9468458251243128, 0.973348501120912, 0.9720863318081332, 0.9718357664541014, 0.5506489223351388, 0.5400144233029986, 0.4707063879862874, 0.4576000713027649, 0.42748637605611184, 0.17747450914416518, 0.5750529722167992, 0.5305952128942648, 0.541344885360592, 0.8804416960530248, 0.8612279661724874, 0.8337141210908461, 0.2620687366831237, 0.27261773529675704, 0.2748537564817972, 0.8429414419882202, 0.8193137078177961, 0.7863120102739167, 0.5580706894750477, 0.12556833696227554, 0.5354083068685743, 0.5583063421067034, 0.40481405067777765, 0.4594939194296219, 0.47445113890927126, 0.4880258221658128, 0.27178659017827844, 0.1928949318725438, 0.5655323227455158, 0.27503206094015475, 0.27051004468410333, 0.44825910960022464, 0.2138552809461105, 0.26228391962683995, 0.444013359288422, 0.46546210782587016, 0.4431560721962444, 0.16182779477228582, 0.5229704017358088, 0.10625020979073596, 0.5346721648499049, 0.5099335466003612, 0.6301049895837244, 0.5034881813749308, 0.2372384458651814, 0.6597128107658665, 0.2708539545849533, 0.2329425776397862, 0.11968187484576431, 0.09443924598006759, 0.1025151094264165, 0.6002863681476427, 0.47201016123803297, 0.6459735115285357, 0.3615573987998705, 0.13254002641849183, 0.0810662774005485, 0.3096352980217183, 0.4974221619218301, 0.24121637589391975, 0.14170024581260499, 0.3271350247582705, 0.2998717002905159, 0.5341921437912334, 0.3770233762264439, 0.4804662088388373, 0.48047367450261413, 0.5163151057370526, 0.48233956537666767, 0.2264414041739995, 0.49562061352070186, 0.4318247252540094, 0.7703943375370611, 0.8068663695926471, 0.783465529692857, 0.771289277831999, 0.7412366813206523, 0.7552886000045453, 0.7902791897975711, 0.798251515171086, 0.7642142275639248, 0.1416581352314411, 0.13192818851577903, 0.11076170648199879, 0.16481926994203222, 0.1489495919467101, 0.1494385025807995, 0.17807598342694186, 0.15011240568775297, 0.13172683606716784, 0.49128712793732976, 0.1881325042254438, 0.1711839578709934, 0.1765241793580653, 0.17223713948614627, 0.20733519362053632, 0.19763198421869344, 0.5281521916543979, 0.17087901591148036, 0.27926236369431323, 0.38031450500603503, 0.42311042961113443, 0.4843197673461822, 0.29934622974586955, 0.5094254668102922, 0.5563811327615665, 0.45531907552999806, 0.6517467131683365, 0.3918982805786986, 0.46993023075558116, 0.5132023292449508, 0.2687202026385558, 0.37420231805667414, 0.38561584715042274, 0.26566825084156376, 0.6066775562729112, 0.25988602059547206, 0.20381667544563165, 0.2043446780171172, 0.22445704124191912, 0.23031363352587286, 0.2164337734187477, 0.25235555886599714, 0.23963780491872888, 0.20428399630744476, 0.24596702057882502, 0.684901642330783, 0.1937078536673723, 0.18725602748491066, 0.1810613567536905, 0.20507465774080413, 0.18696828991097747, 0.19582383960722927, 0.18929906043085853, 0.1824198024971031, 0.1851254362507857, 0.18658495619665283, 0.18401609285728315, 0.8436366541248896, 0.7837262460222462, 0.8761639256885155, 0.16055084269400455, 0.8551971477915828, 0.8638081094355854, 0.8353979134839202, 0.20944256962313512, 0.8241865144823877, 0.20883576526508718, 0.7744142436223869, 0.16806782029108014, 0.2091986285273726, 0.1643424408646893, 0.15287431679882335, 0.2240517625444215, 0.23059929775763188, 0.20820728970313562, 0.19916100608887943, 0.19889098747073541, 0.20552973284028098, 0.20239511541119548, 0.22101096680110832, 0.23088599831494117, 0.11207245663724774, 0.1079670489526976, 0.08745943618868701, 0.0996582211263749, 0.10437436230437291, 0.15125893130914247, 0.10011056187170175, 0.09666303674921983, 0.10280706951387497]}, "mutation_prompt": null}
{"id": "a3274757-b6a3-4a91-8255-b1dd0e6b2ce5", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Increased cognitive component\n        self.c2 = 2.0  # Increased social component\n        self.w_max = 0.9  # Increased inertia weight for exploration\n        self.w_min = 0.4  # Increased minimum inertia weight\n        self.alpha = 0.6  # Increased crossover probability\n        self.beta = 0.8  # Increased mutation impact\n        self.gamma = 0.15  # Increased memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def dynamic_crossover(self, parent1, parent2):\n        mix_ratio = np.random.rand(self.dim) < self.alpha\n        child = np.where(mix_ratio, parent1, parent2)\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n        neighborhood_size = max(1, self.population_size // 5)\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                neighborhood = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                local_best_position = personal_best_positions[neighborhood[np.argmin(personal_best_scores[neighborhood])]]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (local_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, particles[i], local_best_position, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.dynamic_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm Optimizer with dynamic learning rates and neighborhood-based velocity updates for improved convergence.", "configspace": "", "generation": 87, "fitness": 0.19062572602651054, "feedback": "The algorithm EnhancedHybridAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.501459780508589, 0.47772401738029935, 0.4687893488621143, 0.5527238693522313, 0.3626242251122872, 0.49845669702228657, 0.5535862904557814, 0.5578473180387501, 0.5115386309701209, 0.1756918324694965, 9.999999999998899e-05, 0.08012714100017038, 0.14994698349637836, 0.06526735267400852, 0.04851990640150161, 0.16718288244342894, 0.09137066373308922, 0.15286473406392453, 0.10641160880267675, 0.1102854658565724, 0.13028059712894768, 0.13168944485378709, 0.13813336288299594, 0.07314589013811124, 0.09324815854772783, 0.1361375601742456, 0.10373164313608318, 0.1168685336928933, 0.06136771368261795, 0.0941984420755021, 0.08666442844989086, 0.17696181560133406, 0.1055439325605868, 0.08112379919289248, 0.07447215813122332, 0.12556873575328087, 0.9719776044050044, 0.9697643736356839, 0.9878888379797979, 0.964096814742266, 0.9740915621567231, 0.9788010957922744, 0.9886858568282847, 0.9780485606282888, 0.9742091320938367, 0.2090902894686335, 0.27845424849946687, 0.05388734612392687, 0.23316381443952816, 0.2096117476797431, 0.1630597177228046, 0.08200643706021893, 0.18436739390803458, 0.08513802959308614, 0.16308976026577238, 0.14785020129572146, 0.19957728332229174, 0.18503697212288694, 0.19628153067379206, 0.17595053540371153, 0.16040047962871284, 0.2729895028251612, 0.2156577952266734, 0.10939632318303172, 0.16941935222565885, 0.07716073267304346, 0.07065879859307334, 0.1395555711634705, 0.07284657566996433, 0.13381589799002414, 0.13072882272633546, 0.05732594209388886, 0.1029309591185893, 0.009036715931038497, 0.09547472202154017, 0.12999339012674394, 0.11118979758478398, 0.1353056809400518, 0.11586174607940725, 0.08434975003777267, 0.03281796293114381, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001264286729969477, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06848976934990025, 0.008400903529222736, 0.05902551612979001, 9.999999999998899e-05, 0.007333435479613737, 0.019242607096812914, 0.019350717211741197, 9.999999999998899e-05, 0.034040650398696526, 0.02697712466360902, 0.00933000652583249, 9.999999999998899e-05, 0.06164921874768137, 0.051665956127487145, 0.04781720463270145, 0.05556360718361719, 0.0543387660272987, 0.02678216287125401, 0.059885266549523974, 0.0637729095165247, 0.08136162055322416, 0.07348174018489839, 0.02669913926758649, 0.07120277943755804, 0.037474630250665, 0.07681579716704201, 0.05586985959810753, 0.3649302331718757, 0.4285427185474828, 0.3635653283132496, 0.20253954297985755, 0.3909285419909697, 0.17945561138043054, 0.317921032043486, 0.3770344418859901, 0.3610328989407229, 0.06275510436469611, 0.11049482617411954, 0.07146709543865304, 0.08949214951396312, 0.0584487525196713, 0.08885625748392645, 0.09841433678113154, 0.07735772901726556, 0.07138106597686766, 0.13543014102389828, 0.18003138106565952, 0.1450266276265313, 0.13758151486091375, 0.13640573984729998, 0.12037114979047514, 0.2169867115166012, 0.16214354919856377, 0.26606694702505307, 0.2457751588145597, 0.21526398156137916, 0.2915570406544079, 0.23114678365972918, 0.2287320092263877, 0.2339597259283327, 0.2932183774706336, 0.24282904106591263, 0.20881919223083423, 0.17395611435547365, 0.1729024968148689, 0.23481190788639938, 0.1773224798544688, 0.19644625380988057, 0.14431849847127287, 0.23233314474944455, 0.1560918148847542, 0.1388561946207013, 0.1928039571830914, 0.16698812853009481, 0.1920724887961036, 0.20920408126083467, 0.16992925867625197, 0.19804640170370258, 0.17409469486772555, 0.1879017616738382, 0.17595397239513788, 0.1640116474619805, 0.16664302151261, 0.20076574979834982, 0.17629457424479056, 0.1684037547263355, 0.1657351104015521, 0.16531759398899526, 0.13989173541223066, 0.1840964945200253, 0.16636913412172039, 0.43631175590449245, 0.14696419269228678, 0.5839726721456455, 0.5300056368310131, 0.18269813105358645, 0.16328716512095198, 0.17479756820018189, 0.17603513149494898, 0.443366457447791, 0.16371844580351647, 0.18269514212909077, 0.19000254597118482, 0.18255426317978807, 0.1664753089068337, 0.1924874781184528, 0.18030028781555796, 0.15035525816563877, 0.19009172220529857, 0.17055721366240573, 0.1655166681725857, 0.19998616194342067, 0.1591926321155004, 0.1898451976416814, 0.20168691385351833, 0.1702212912689558, 0.18700442809908302, 0.07716506655688349, 0.07316262372134241, 0.06746104649036677, 0.07310833661417948, 0.07819090414841534, 0.06169540920285932, 0.07663554302642184, 0.07381449414502417, 0.07577007563210159]}, "mutation_prompt": null}
{"id": "f5f78988-60fe-4602-8ea6-6ee308df6052", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.85\n        self.w_min = 0.3\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.1  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "HybridAdaptiveParticleSwarm", "description": "Hybrid Adaptive Particle Swarm Optimizer integrates chaotic initialization, adaptive mutation, and memory-based velocity adjustment for enhanced convergence speed and solution quality.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.8593610698444872, 0.8204366533607839, 0.8449854715546068, 0.8552418876292598, 0.8676037206974347, 0.836566439523704, 0.8504801318225035, 0.8402323593260838, 0.8324770072981457, 0.6713315278012205, 0.6581074762943224, 0.663992759976917, 0.6614934183291115, 0.7084840042750213, 0.7308553569644226, 0.669748911254342, 0.6589074924975941, 0.7085246560508422, 0.5921261221647673, 0.6414002068012583, 0.11923006613900744, 0.18081964465521416, 0.1449413124300558, 0.15312054800131358, 0.6316822658854502, 0.6762572876061616, 0.6693121846213452, 0.1636228197535331, 0.1228167464053187, 0.13343699508972873, 0.12693248079914576, 0.11670838176690834, 0.13680442229344003, 0.10929405198209774, 0.10642273667413882, 0.11139578744285794, 0.9643534250121528, 0.980479875947011, 0.9454678297399592, 0.9722996273237385, 0.9798552256501443, 0.9468458251243128, 0.973348501120912, 0.9720863318081332, 0.9718357664541014, 0.5506489223351388, 0.5400144233029986, 0.4707063879862874, 0.4576000713027649, 0.42748637605611184, 0.17747450914416518, 0.5750529722167992, 0.5305952128942648, 0.541344885360592, 0.8804416960530248, 0.8612279661724874, 0.8337141210908461, 0.2620687366831237, 0.27261773529675704, 0.2748537564817972, 0.8429414419882202, 0.8193137078177961, 0.7863120102739167, 0.5580706894750477, 0.12556833696227554, 0.5354083068685743, 0.5583063421067034, 0.40481405067777765, 0.4594939194296219, 0.47445113890927126, 0.4880258221658128, 0.27178659017827844, 0.1928949318725438, 0.5655323227455158, 0.27503206094015475, 0.27051004468410333, 0.44825910960022464, 0.2138552809461105, 0.26228391962683995, 0.444013359288422, 0.46546210782587016, 0.4431560721962444, 0.16182779477228582, 0.5229704017358088, 0.10625020979073596, 0.5346721648499049, 0.5099335466003612, 0.6301049895837244, 0.5034881813749308, 0.2372384458651814, 0.6597128107658665, 0.2708539545849533, 0.2329425776397862, 0.11968187484576431, 0.09443924598006759, 0.1025151094264165, 0.6002863681476427, 0.47201016123803297, 0.6459735115285357, 0.3615573987998705, 0.13254002641849183, 0.0810662774005485, 0.3096352980217183, 0.4974221619218301, 0.24121637589391975, 0.14170024581260499, 0.3271350247582705, 0.2998717002905159, 0.5341921437912334, 0.3770233762264439, 0.4804662088388373, 0.48047367450261413, 0.5163151057370526, 0.48233956537666767, 0.2264414041739995, 0.49562061352070186, 0.4318247252540094, 0.7703943375370611, 0.8068663695926471, 0.783465529692857, 0.771289277831999, 0.7412366813206523, 0.7552886000045453, 0.7902791897975711, 0.798251515171086, 0.7642142275639248, 0.1416581352314411, 0.13192818851577903, 0.11076170648199879, 0.16481926994203222, 0.1489495919467101, 0.1494385025807995, 0.17807598342694186, 0.15011240568775297, 0.13172683606716784, 0.49128712793732976, 0.1881325042254438, 0.1711839578709934, 0.1765241793580653, 0.17223713948614627, 0.20733519362053632, 0.19763198421869344, 0.5281521916543979, 0.17087901591148036, 0.27926236369431323, 0.38031450500603503, 0.42311042961113443, 0.4843197673461822, 0.29934622974586955, 0.5094254668102922, 0.5563811327615665, 0.45531907552999806, 0.6517467131683365, 0.3918982805786986, 0.46993023075558116, 0.5132023292449508, 0.2687202026385558, 0.37420231805667414, 0.38561584715042274, 0.26566825084156376, 0.6066775562729112, 0.25988602059547206, 0.20381667544563165, 0.2043446780171172, 0.22445704124191912, 0.23031363352587286, 0.2164337734187477, 0.25235555886599714, 0.23963780491872888, 0.20428399630744476, 0.24596702057882502, 0.684901642330783, 0.1937078536673723, 0.18725602748491066, 0.1810613567536905, 0.20507465774080413, 0.18696828991097747, 0.19582383960722927, 0.18929906043085853, 0.1824198024971031, 0.1851254362507857, 0.18658495619665283, 0.18401609285728315, 0.8436366541248896, 0.7837262460222462, 0.8761639256885155, 0.16055084269400455, 0.8551971477915828, 0.8638081094355854, 0.8353979134839202, 0.20944256962313512, 0.8241865144823877, 0.20883576526508718, 0.7744142436223869, 0.16806782029108014, 0.2091986285273726, 0.1643424408646893, 0.15287431679882335, 0.2240517625444215, 0.23059929775763188, 0.20820728970313562, 0.19916100608887943, 0.19889098747073541, 0.20552973284028098, 0.20239511541119548, 0.22101096680110832, 0.23088599831494117, 0.11207245663724774, 0.1079670489526976, 0.08745943618868701, 0.0996582211263749, 0.10437436230437291, 0.15125893130914247, 0.10011056187170175, 0.09666303674921983, 0.10280706951387497]}, "mutation_prompt": null}
{"id": "7f13ec41-0b76-4e10-8754-b628c27d8873", "solution": "import numpy as np\n\nclass EnhancedHybridParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1_initial = 2.5\n        self.c2_initial = 0.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.3\n        self.gamma = 0.05  # Reduced memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def multi_strategy_mutation(self, target, best, r1, r2, scale_factor):\n        if np.random.rand() < 0.5:\n            mutated = target + self.alpha * (best - target) + scale_factor * (r1 - r2)\n        else:\n            perturbed = target + np.random.normal(0, 0.1, self.dim)\n            mutated = self.alpha * perturbed + (1 - self.alpha) * target\n        return np.clip(mutated, self.lb, self.ub)\n\n    def adaptive_topology(self, global_best_position, particles):\n        avg_position = np.mean(particles, axis=0)\n        if np.random.rand() < 0.3:\n            influence_point = global_best_position\n        else:\n            influence_point = avg_position\n        return influence_point\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (self.evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.multi_strategy_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            influence_point = self.adaptive_topology(global_best_position, particles)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    else:\n                        parent1, parent2 = global_best_position, influence_point\n                    child = (parent1 + parent2) / 2\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridParticleSwarm", "description": "Enhanced Hybrid Particle Swarm Optimizer incorporates dynamic learning coefficients, multi-strategy mutation, and adaptive swarm topology for improved convergence speed and solution accuracy.", "configspace": "", "generation": 89, "fitness": 0.22289605973138496, "feedback": "The algorithm EnhancedHybridParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.5714412040182009, 0.554053196632035, 0.5111654885244584, 0.5255509991147624, 0.5781417743995625, 0.5716880323316558, 0.6000325097706543, 0.5117296952950543, 0.5700818463166677, 0.07302139276588482, 0.00023954716984353475, 0.015551821457556625, 0.08525688233228734, 0.029635749619891794, 9.999999999998899e-05, 0.0003332867924796812, 0.15975739866578365, 0.04006820758467167, 0.09260974236330499, 0.13669174779586613, 0.11601043360559637, 0.08896996791254719, 0.0510625516464297, 0.09623031428481077, 0.0926275226720088, 0.1010025746307891, 0.07991693463604788, 0.07227919800104576, 0.09756584585619388, 0.06486201781696033, 0.09664137527452799, 0.07383081237489364, 0.08925790114219745, 0.12021511145804509, 0.09483437869413047, 0.07474987932627486, 0.9687905738475213, 0.9437326521564283, 0.9696536937819404, 0.9703945079682672, 0.9457435972533816, 0.9468112683545631, 0.9523414388970087, 0.9723497138369481, 0.9778297962071195, 0.25827971310669096, 0.25563330507205506, 0.18135354486816768, 0.21316182871462575, 0.22774473044419508, 0.34715756046376856, 0.2093186127102269, 0.2276510072147605, 0.2006054281598867, 0.2179715448908559, 0.2322893889841996, 0.20593557761486736, 0.2123823672987043, 0.19109975166115478, 0.20823181541179614, 0.2079332653765118, 0.12375279603187861, 0.3517315679961893, 0.20146703823540457, 0.1665906842950453, 0.21946557765705277, 0.0988334249368732, 0.18845071243962686, 0.13457317913258593, 0.1331503394627862, 0.14204438235732686, 0.17056371124587022, 0.267216478351881, 0.23241679326624476, 0.15322800161733108, 0.16552876148728413, 0.19343434388355762, 0.11981466410690589, 0.27706982947819037, 0.18557494858541335, 0.16152053477482076, 0.007357773492186581, 9.999999999998899e-05, 0.08043899309376157, 0.008647820875833934, 9.999999999998899e-05, 9.999999999998899e-05, 0.018243991286679417, 0.035280997776277356, 0.015867441622155254, 0.12809305840884722, 0.08917160184683703, 0.11121186625631108, 0.07636020877386362, 0.07604552973331813, 0.03172794264430234, 0.1252475490078876, 0.12435937094946115, 0.06789655144739504, 0.01997480138607477, 0.06299932879808856, 0.07750507540499252, 0.06555322186446633, 0.05262241625362274, 0.052906559615786164, 0.048777537227719936, 0.0702632232526903, 0.08093271457559736, 0.10133952337156038, 0.1822236137213672, 0.16489598064607547, 0.18475597382198017, 0.14712033551789394, 0.11809958122404585, 0.14392218018785985, 0.15488198364371342, 0.0717734641405583, 0.45187194279484466, 0.5015346175655262, 0.41173350823970345, 0.4406960367690681, 0.44124107793822154, 0.4343753966506658, 0.46710284191764573, 0.4270391747442769, 0.41679959955809964, 0.08173781472152586, 0.10183274534464237, 0.07754038537274777, 0.08046358627621852, 0.09119851230629161, 0.10726172774131815, 0.08273547913051194, 0.08265701963869598, 0.09714348832855246, 0.16880006127506642, 0.17003486450027572, 0.18747644139973962, 0.16415190832039572, 0.1391529351137495, 0.14548993715712144, 0.3398931061247047, 0.1911798844938426, 0.166377006177705, 0.2113280714209662, 0.26049478727607445, 0.31594383802525017, 0.27818121975304133, 0.3053113005216457, 0.17495329135284232, 0.21986757116449707, 0.35302171719187037, 0.23951998356418502, 0.20417209022626248, 0.2606733506876676, 0.21391762733632147, 0.2385433443647641, 0.2251041949085889, 0.21718746055592408, 0.21119255684706773, 0.24525711077956636, 0.2208542062769503, 0.26204648025022537, 0.16488996636706, 0.22599136867866665, 0.2374367806363411, 0.23186654606817014, 0.1896033029750399, 0.22856545480789747, 0.2391479640918165, 0.2009759442371899, 0.1704869147912368, 0.1789077397377814, 0.16929695326399885, 0.16894950721563073, 0.18890195771697338, 0.17207978207700858, 0.16814663683118924, 0.19269277283241237, 0.17893939650143242, 0.1478678230349071, 0.1815126525650831, 0.15288706815695075, 0.6864529902829182, 0.190170232301888, 0.1949545206996227, 0.1916180632127772, 0.17716063221639544, 0.16875516797327528, 0.5648862157733747, 0.20442790830157698, 0.07325745389003846, 0.20341765598146644, 0.6461157499616843, 0.15177625700522512, 0.4178907337998531, 0.551336960069021, 0.548040291286467, 0.19578160180972337, 0.19068996084155754, 0.2062275437542309, 0.17217899719211105, 0.22012610796302834, 0.18853530739540336, 0.17227642387527664, 0.1730059088442295, 0.2116529962402255, 0.09260547733211988, 0.08114117848744773, 0.08531989445004928, 0.0785045627302472, 0.08933632856676743, 0.08946430939023597, 0.07994948285731696, 0.07042617417868058, 0.0989979708330162]}, "mutation_prompt": null}
{"id": "d77b31af-4bcc-45d9-b151-ff6ab3290419", "solution": "import numpy as np\n\nclass DynamicHybridParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 60  # Increased population size\n        self.c1 = 1.8  # Adjusted cognitive coefficient\n        self.c2 = 1.8  # Adjusted social coefficient\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.gamma = 0.15  # Modified memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * (0.5 - np.random.rand(self.population_size, self.dim))\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def differential_evolution(self, target_idx, best, particles):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while target_idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        r1, r2, r3 = particles[indices]\n        mutated = r1 + 0.8 * (r2 - r3)  # Scale factor for differential evolution\n        return np.clip((mutated + best) / 2, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                velocities[i] = np.clip(velocities[i], -3, 3)  # Limit velocity to prevent overshooting\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_evolution(i, global_best_position, particles)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            for i in range(self.population_size):\n                if self.evaluations < self.budget:\n                    score = func(particles[i])\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = particles[i]\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = particles[i]\n\n        return global_best_position, global_best_score", "name": "DynamicHybridParticleSwarm", "description": "Dynamic Hybrid Particle Swarm Optimizer employs adaptive momentum control, differential evolution, and stochastic step adjustments to accelerate convergence and improve solution precision.", "configspace": "", "generation": 90, "fitness": 0.0926116247367352, "feedback": "The algorithm DynamicHybridParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.13.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.11066261828276147, 0.15090216756565844, 0.13127087730313047, 0.15820415106679664, 0.24302167649282014, 0.10495898186919661, 0.20771145797844415, 0.22565446595775174, 0.4061700725413717, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004722648941078322, 0.03828116446476759, 9.999999999998899e-05, 0.029108711623573202, 0.03559222935407902, 0.004147114572088162, 0.06874167378261942, 0.005806067111271629, 0.08453852304336673, 0.035649402493193705, 0.0400943079621211, 9.999999999998899e-05, 9.999999999998899e-05, 0.027910828068268168, 9.999999999998899e-05, 9.999999999998899e-05, 0.015560132816675454, 9.999999999998899e-05, 0.1456428848993, 0.8158621691773037, 0.16458922812140298, 0.10417386913232896, 0.09110285003819185, 0.6937494098531823, 0.6966666705127524, 0.8805523199283082, 0.7908710449648854, 0.04018928094542629, 0.011122029121418575, 9.999999999998899e-05, 0.16677407562869206, 0.02315713892077942, 9.999999999998899e-05, 9.999999999998899e-05, 0.06105096950983646, 0.05374465026460962, 0.06838577742113594, 0.05711717194013255, 0.08689044424615822, 9.999999999998899e-05, 0.08978565065128474, 0.12314817739778516, 0.015494745281672495, 0.036580586130751325, 9.999999999998899e-05, 9.999999999998899e-05, 0.11639293823273222, 0.056989903060421954, 9.999999999998899e-05, 0.10139332515551636, 9.999999999998899e-05, 0.041215158127845486, 9.999999999998899e-05, 9.999999999998899e-05, 0.09750546951690098, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13130318251659723, 0.012797390290445576, 0.051808673689641926, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039782883849164175, 0.04314573280751011, 0.031210517695242412, 9.999999999998899e-05, 0.016800967356981666, 9.999999999998899e-05, 9.999999999998899e-05, 0.00036910531103551136, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029282351977717447, 9.999999999998899e-05, 9.999999999998899e-05, 0.021266009387409746, 0.0014347462385602139, 0.0359100444925039, 9.999999999998899e-05, 0.07876947985762495, 0.23820924590978476, 0.13761403833537678, 0.14089286874382634, 0.19973774674742373, 0.06281315178358271, 0.052045263029005584, 0.32540887944722674, 0.27398668035366214, 0.1418664840905638, 0.01855732624144768, 0.055568863534861124, 0.024343397164122926, 0.07107915201991344, 0.03941650922692119, 0.03978168420891126, 0.07219344574713105, 0.02037696032843017, 0.06242673615541716, 0.12250861924291079, 0.19013474304973044, 0.17893105839082946, 0.11367162623628047, 0.1916527448865325, 0.0902832585122062, 0.09725138614443563, 0.1509708504503926, 0.17197779405452107, 0.1355305866681623, 0.12088244990619845, 0.10706612826805573, 0.11447868518381032, 0.13410782177846237, 0.1264370610506519, 0.10713209300102977, 0.1168404459613599, 0.15169056108678725, 0.06528552997157311, 0.03762088956605425, 0.030025573259216065, 0.11734165018789922, 0.06730041732763292, 0.05081982200284296, 0.06897631645772961, 0.03211333884352685, 0.07165667082896943, 0.1896734900653816, 0.2190287991051526, 0.2013688329666259, 0.15221580230635623, 0.19961867247903065, 0.21574195633310378, 0.19890665495468363, 0.14340722897417146, 0.11321257506255167, 0.16130011694559565, 0.1588783653390139, 0.13588172149171374, 0.17499977167337455, 0.12598980870850685, 9.999999999998899e-05, 0.14459854308986453, 0.1649838123113312, 9.999999999998899e-05, 0.12699352110112327, 0.10760429595578047, 0.10118802872861765, 0.11901616833405804, 0.10583907566305006, 0.12010697189369479, 0.10957178419921343, 0.1225601694634022, 0.0865661191141982, 0.10894564934030804, 0.10896499908328972, 0.0632799600936651, 0.3139906164351072, 0.14288113943241387, 0.06934271977030093, 0.08789012042773614, 0.10005663655699815, 0.03311006176705755, 0.20539660550437344, 0.16515943661714572, 0.18327222177697577, 0.17628462060772654, 0.18045353531805342, 0.1837973741445641, 0.16833679505833987, 0.1962691588893929, 0.2118859500052338, 0.05794185123149109, 0.054012984021793664, 0.014706190824248955, 0.07127905280704583, 0.043839969591596306, 0.047019203394066955, 0.0675757209131711, 0.0225446595484331, 0.05543068816699048]}, "mutation_prompt": null}
{"id": "1352c335-3669-42c8-8291-2935a95c5776", "solution": "import numpy as np\n\nclass EnhancedMemoryAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.85\n        self.w_min = 0.3\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.2  # Enhanced memory-based velocity adjustment rate\n        self.delta = 0.05  # Reduction factor for search space\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            child = self.lb + (self.ub - self.lb) * np.random.rand(self.dim)\n        else:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        return np.clip(child, self.lb, self.ub)\n\n    def diversity_enforcing_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2) + self.delta * np.random.randn(self.dim)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.diversity_enforcing_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedMemoryAdaptiveParticleSwarm", "description": "The Enhanced Memory Adaptive Particle Swarm (EMAPS) incorporates memory-efficient search space reduction, dynamic velocity updates, and diversity-enforcing mutation to enhance convergence speed and solution quality.", "configspace": "", "generation": 91, "fitness": 0.2425858820411118, "feedback": "The algorithm EnhancedMemoryAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.4584705486159162, 0.5067743432893534, 0.47230318264037563, 0.5035270129261492, 0.4993012947781327, 0.4973246867352936, 0.4720388964759368, 0.465495787954157, 0.4492800646309747, 0.1548338440946465, 0.06973581957797792, 0.12287515490660794, 0.17847104468565356, 0.10028674139101912, 0.10858637728547127, 0.11695297963942153, 0.1466164192700362, 0.13124119497019782, 0.1393535447024773, 0.1608116103601287, 0.1096913705334156, 0.12815266382354273, 0.14602730729987456, 0.14232151720111175, 0.16249293795949526, 0.12634566632890387, 0.18716336617592533, 0.13303562205674557, 0.10149316442407874, 0.12562823103122078, 0.08560901831378576, 0.10617248134750445, 0.11290963333612214, 0.13093861215859615, 0.13661767532396718, 0.1307375932956204, 0.9715089148451775, 0.9622499892492361, 0.9456297019605912, 0.9607211221501692, 0.9879504402885414, 0.9729812138889976, 0.9721880858769298, 0.972930737827477, 0.9886391436249504, 0.28756369086486655, 0.2813137037071771, 0.2783851258297463, 0.24692630664975845, 0.23359892045899733, 0.2596372183739014, 0.28862175621098907, 0.276700083141725, 0.24923870414594895, 0.5841155862138949, 0.4821659831952193, 0.4392638985902988, 0.6376472805830177, 0.6180528184139693, 0.4393495361762161, 0.36405250585499094, 0.47381473432626153, 0.5591609821301198, 0.1858333517540678, 0.15945035227202264, 0.1674296665792866, 0.14610992815781831, 0.11180307298309067, 0.1497372798335529, 0.15506295083231814, 0.1675292881268572, 0.14344413334635753, 0.18165060649849607, 0.09944413906458816, 0.18166178380690146, 0.15744412588164813, 0.15997931662644171, 0.19987343575156613, 0.16528542277567826, 0.19836848065947765, 0.1701886362583498, 0.013481158972066476, 0.002510041646702099, 0.009726993848291898, 0.01359392640328605, 9.999999999998899e-05, 0.013545226939164268, 0.018073304604848683, 0.01464398983575188, 0.015153088756993394, 0.0643503364987178, 0.07270022617253291, 0.09310649614953503, 0.07192341296770732, 0.07592548390112219, 0.08859740648193404, 0.09081251525973077, 0.10329062855024151, 0.03750650969313574, 0.0007428993321988431, 0.00015290353925156985, 9.999999999998899e-05, 0.002910278216402329, 0.02176626159450823, 9.999999999998899e-05, 0.023545633438739944, 0.026793054753899037, 0.002800725545226257, 0.1195001221650942, 0.11327143236019854, 0.10404749318421869, 0.1092365800786731, 0.10067431680702954, 0.11479867064453397, 0.04744510577353578, 0.1569273505282487, 0.10468431466596395, 0.39247737259606763, 0.4504535845036767, 0.42916009939533906, 0.40346627806779567, 0.4057865828048489, 0.4232648976800084, 0.440470113005225, 0.41000185094687736, 0.3992221679810354, 0.08400172367062875, 0.11994696868626775, 0.0896068560095653, 0.1187883517759234, 0.11981686238521017, 0.12378258765467565, 0.10908754777282814, 0.12180380529019585, 0.11301354937163344, 0.19654634630818102, 0.14660473838956456, 0.24089006550786296, 0.23159262622262167, 0.1775069384845589, 0.24220778878817195, 0.14556907909341876, 0.18992385025841763, 0.1686854536402974, 0.2607112396089811, 0.29079508535943155, 0.3165021437795419, 0.2900411573134215, 0.28398584963394646, 0.28305617072209655, 0.2869114770583764, 0.2805764200301596, 0.30541628316303804, 0.21531406673385622, 0.20430345435074881, 0.23511128175274754, 0.2394538697523333, 0.21308221614864598, 0.21815765000118337, 0.22169631938264278, 0.2077773441067431, 0.2392929387582765, 0.22673167699429375, 0.1637676450226272, 0.19806760591781036, 0.251885552462906, 0.19065761262854763, 0.19133734360955612, 0.18251128709810704, 0.1950437572449818, 0.22212366648589754, 0.28147114236444903, 0.21856349117423102, 0.3376433229302346, 0.19759613667143006, 0.1851371419961807, 0.22859677991858862, 0.23427054378205625, 0.22554885002340874, 0.19888345434660082, 0.6485320729627291, 0.17550083810442907, 0.5840718164832779, 0.18989318038394554, 0.6150118312563995, 0.1706453010676765, 0.602348463435452, 0.17636221275576813, 0.4997486512661473, 0.5185782305876105, 0.20317555320221303, 0.4526137806341941, 0.46298694731363454, 0.17498415290583436, 0.17663328350330976, 0.20712450336210586, 0.407425728723381, 0.40647967686123543, 0.19847499711172323, 0.18528456944128713, 0.18362096332808941, 0.2064350386633993, 0.18822097489550993, 0.17594502805338763, 0.2105265873842933, 0.17831936589111685, 0.17649050287677115, 0.0713832762839729, 0.0900613944544224, 0.0755134356026268, 0.07039028477478682, 0.07455839219126714, 0.0785803310713431, 0.08352692108344106, 0.07743337180966359, 0.08310934189772012]}, "mutation_prompt": null}
{"id": "769f0b5c-46f7-445b-9098-d0978fdaddb1", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.85\n        self.w_min = 0.3\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.1  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "HybridAdaptiveParticleSwarm", "description": "Hybrid Adaptive Particle Swarm Optimizer integrates chaotic initialization, adaptive mutation, and memory-based velocity adjustment for enhanced convergence speed and solution quality.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.8593610698444872, 0.8204366533607839, 0.8449854715546068, 0.8552418876292598, 0.8676037206974347, 0.836566439523704, 0.8504801318225035, 0.8402323593260838, 0.8324770072981457, 0.6713315278012205, 0.6581074762943224, 0.663992759976917, 0.6614934183291115, 0.7084840042750213, 0.7308553569644226, 0.669748911254342, 0.6589074924975941, 0.7085246560508422, 0.5921261221647673, 0.6414002068012583, 0.11923006613900744, 0.18081964465521416, 0.1449413124300558, 0.15312054800131358, 0.6316822658854502, 0.6762572876061616, 0.6693121846213452, 0.1636228197535331, 0.1228167464053187, 0.13343699508972873, 0.12693248079914576, 0.11670838176690834, 0.13680442229344003, 0.10929405198209774, 0.10642273667413882, 0.11139578744285794, 0.9643534250121528, 0.980479875947011, 0.9454678297399592, 0.9722996273237385, 0.9798552256501443, 0.9468458251243128, 0.973348501120912, 0.9720863318081332, 0.9718357664541014, 0.5506489223351388, 0.5400144233029986, 0.4707063879862874, 0.4576000713027649, 0.42748637605611184, 0.17747450914416518, 0.5750529722167992, 0.5305952128942648, 0.541344885360592, 0.8804416960530248, 0.8612279661724874, 0.8337141210908461, 0.2620687366831237, 0.27261773529675704, 0.2748537564817972, 0.8429414419882202, 0.8193137078177961, 0.7863120102739167, 0.5580706894750477, 0.12556833696227554, 0.5354083068685743, 0.5583063421067034, 0.40481405067777765, 0.4594939194296219, 0.47445113890927126, 0.4880258221658128, 0.27178659017827844, 0.1928949318725438, 0.5655323227455158, 0.27503206094015475, 0.27051004468410333, 0.44825910960022464, 0.2138552809461105, 0.26228391962683995, 0.444013359288422, 0.46546210782587016, 0.4431560721962444, 0.16182779477228582, 0.5229704017358088, 0.10625020979073596, 0.5346721648499049, 0.5099335466003612, 0.6301049895837244, 0.5034881813749308, 0.2372384458651814, 0.6597128107658665, 0.2708539545849533, 0.2329425776397862, 0.11968187484576431, 0.09443924598006759, 0.1025151094264165, 0.6002863681476427, 0.47201016123803297, 0.6459735115285357, 0.3615573987998705, 0.13254002641849183, 0.0810662774005485, 0.3096352980217183, 0.4974221619218301, 0.24121637589391975, 0.14170024581260499, 0.3271350247582705, 0.2998717002905159, 0.5341921437912334, 0.3770233762264439, 0.4804662088388373, 0.48047367450261413, 0.5163151057370526, 0.48233956537666767, 0.2264414041739995, 0.49562061352070186, 0.4318247252540094, 0.7703943375370611, 0.8068663695926471, 0.783465529692857, 0.771289277831999, 0.7412366813206523, 0.7552886000045453, 0.7902791897975711, 0.798251515171086, 0.7642142275639248, 0.1416581352314411, 0.13192818851577903, 0.11076170648199879, 0.16481926994203222, 0.1489495919467101, 0.1494385025807995, 0.17807598342694186, 0.15011240568775297, 0.13172683606716784, 0.49128712793732976, 0.1881325042254438, 0.1711839578709934, 0.1765241793580653, 0.17223713948614627, 0.20733519362053632, 0.19763198421869344, 0.5281521916543979, 0.17087901591148036, 0.27926236369431323, 0.38031450500603503, 0.42311042961113443, 0.4843197673461822, 0.29934622974586955, 0.5094254668102922, 0.5563811327615665, 0.45531907552999806, 0.6517467131683365, 0.3918982805786986, 0.46993023075558116, 0.5132023292449508, 0.2687202026385558, 0.37420231805667414, 0.38561584715042274, 0.26566825084156376, 0.6066775562729112, 0.25988602059547206, 0.20381667544563165, 0.2043446780171172, 0.22445704124191912, 0.23031363352587286, 0.2164337734187477, 0.25235555886599714, 0.23963780491872888, 0.20428399630744476, 0.24596702057882502, 0.684901642330783, 0.1937078536673723, 0.18725602748491066, 0.1810613567536905, 0.20507465774080413, 0.18696828991097747, 0.19582383960722927, 0.18929906043085853, 0.1824198024971031, 0.1851254362507857, 0.18658495619665283, 0.18401609285728315, 0.8436366541248896, 0.7837262460222462, 0.8761639256885155, 0.16055084269400455, 0.8551971477915828, 0.8638081094355854, 0.8353979134839202, 0.20944256962313512, 0.8241865144823877, 0.20883576526508718, 0.7744142436223869, 0.16806782029108014, 0.2091986285273726, 0.1643424408646893, 0.15287431679882335, 0.2240517625444215, 0.23059929775763188, 0.20820728970313562, 0.19916100608887943, 0.19889098747073541, 0.20552973284028098, 0.20239511541119548, 0.22101096680110832, 0.23088599831494117, 0.11207245663724774, 0.1079670489526976, 0.08745943618868701, 0.0996582211263749, 0.10437436230437291, 0.15125893130914247, 0.10011056187170175, 0.09666303674921983, 0.10280706951387497]}, "mutation_prompt": null}
{"id": "3f73ca74-88c6-4ba2-b154-edef5e69141a", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9  # Slightly increased inertia weight for exploration\n        self.w_min = 0.2  # Decreased minimal inertia weight for exploitation\n        self.alpha = 0.7  # Increased crossover probability\n        self.beta = 0.8  # Increased mutation scale factor\n        self.gamma = 0.15  # Adjusted memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def dynamic_velocity_clamp(self, velocity):\n        max_velocity = (self.ub - self.lb) * 0.2\n        return np.clip(velocity, -max_velocity, max_velocity)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = 0.5 * np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.choice(self.population_size, 2, replace=False)\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                velocities[i] = self.dynamic_velocity_clamp(velocities[i])\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, \n                                                      personal_best_positions[r1], personal_best_positions[r2], scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_mutation(parent1, parent2, parent1, parent2, scale_factor)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm Optimizer incorporates dynamic velocity clamping and differential evolution-inspired mutation for faster convergence and improved solution quality.", "configspace": "", "generation": 93, "fitness": 0.24358387777860924, "feedback": "The algorithm EnhancedHybridAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.5795259192715383, 0.3892497254590156, 0.3151610237000203, 0.6969803572990878, 0.5223142030136698, 0.5032341849288042, 0.31994735655767503, 0.2818408833222704, 0.35433198599252536, 0.05804766275166895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059755496655643725, 0.12099340402296932, 0.03730110904867057, 9.999999999998899e-05, 9.999999999998899e-05, 0.14377265099499814, 0.11047404938224048, 0.11385969417960873, 0.10871077080355784, 0.14305233580708498, 0.15633755864513643, 0.1394408344323076, 0.1175209587703242, 0.13249761230167134, 0.07957954253861821, 0.10779224612038996, 0.08816518144332497, 0.09498601500727599, 0.0858242265284882, 0.043917315340288976, 0.049390358407602086, 0.10246017595617563, 0.08827955065356619, 0.9512866203149644, 0.9521139625786347, 0.9597746193941196, 0.9163194976575761, 0.9615621446317328, 0.9161101294627049, 0.9640416665951534, 0.9591598972818803, 0.9617970047425117, 0.15563840567104326, 0.11213705247756867, 0.14073995469154166, 0.14083860870898457, 0.3092110119831244, 0.19789684107595296, 0.08853807682970438, 0.15671632233292643, 0.18319760868106405, 0.22873301800531676, 0.941779467401425, 0.22841738186422367, 0.2576398448459698, 0.41032257372794134, 0.2752478747011665, 0.17289085861578257, 0.22593687054559497, 0.1782365230118076, 0.15953463405423207, 0.12834513008528137, 0.11671952750110193, 0.11936713433078727, 0.1339854201724182, 0.1252109627459016, 0.16725815499492402, 0.2932155143644699, 0.07045119632746843, 0.16591801276492024, 0.18367988469288998, 0.349782880640197, 0.13127595452212337, 0.16340275085682165, 0.13274848154509888, 0.14256399270001807, 0.15136386682630343, 0.23519826982586334, 9.999999999998899e-05, 0.09306604536349261, 0.15982787619526118, 9.999999999998899e-05, 0.1803704311626141, 0.05917718561083107, 0.05523935086953857, 9.999999999998899e-05, 0.2207089746230687, 0.11447054888726305, 0.13037141259158902, 0.1344400979912339, 0.09290266966520189, 0.17023928638635422, 0.07465983476757376, 0.0701201321189745, 0.08245702647407072, 0.196965560507546, 0.03394835485361547, 0.08662348188939539, 0.09115480397392073, 0.12022300254228924, 0.2607060526848075, 0.163466461535401, 0.13008320080309965, 0.23189004183912743, 0.3166919227816789, 0.15444536105708317, 0.1984928115997805, 0.12293654078525085, 0.12353198287473965, 0.0420619521134904, 0.16399506361276128, 0.16556612743515908, 0.10027088085001357, 0.2520633401259088, 0.4163243770021734, 0.3970481139956916, 0.5469822429528035, 0.41177415348253543, 0.322168892133772, 0.40999409214635263, 0.47630189497311126, 0.37911585305360085, 0.4531235636302927, 0.11415092754252931, 0.10966703863779326, 0.12918655569249626, 0.12699622606788175, 0.08094061272692765, 0.12893268442871653, 0.15249128384147947, 0.1542325833307785, 0.08759598166646998, 0.31406665992310157, 0.19068886403821628, 0.271111149812545, 0.3126778868019283, 0.25213597658223663, 0.19366963400153103, 0.1861351814468436, 0.31140330947004535, 0.19293238425747328, 0.2547452038532997, 0.2630386376531212, 0.3200690222059225, 0.41037741511439996, 0.4329644393337433, 0.28160726673151903, 0.46394510415374757, 0.2553985127850408, 0.31467149079218537, 0.2060761328796622, 0.22403870857927577, 0.2597306143111763, 0.2146814271220252, 0.22362150925905466, 0.28100467740831037, 0.2452881191288392, 0.30150813430657086, 0.22078569979389873, 0.2543365592488245, 0.23546769362119246, 0.2138507456158789, 0.21778639978642234, 0.2531897290493549, 0.32105759581217985, 0.27722880089485313, 0.24244850748993707, 0.2270296104490812, 0.17130638854317282, 0.1838585798533925, 0.17858503446575047, 0.1793284513677572, 0.1758006040997374, 0.1743099126847878, 0.19085979175292533, 0.19076871693998076, 0.19376196833939963, 0.8998523794033233, 0.1883190096613262, 0.15344279657646553, 0.6182268576238632, 0.1989264304694479, 0.1981215593656388, 0.6032400765720003, 0.8090888831250691, 0.5078820047951949, 0.47920714509200457, 0.21173288137136326, 0.7617151090347931, 0.20888353155127093, 0.3010532583920663, 0.155293194778241, 0.26302881693326086, 0.32270723724568595, 0.24022407455759653, 0.1975686359187201, 0.19416084307103953, 0.19272323853906614, 0.19658667173828148, 0.18983425576886592, 0.200282685896772, 0.18872198382447836, 0.19485772413078217, 0.2137522014169374, 0.10699057618345575, 0.09256823169302186, 0.09182085956353836, 0.09737708950528923, 0.10117963757877046, 0.100620279025737, 0.10030332323870006, 0.09964076430820423, 0.10279021047398296]}, "mutation_prompt": null}
{"id": "0ee9e7b5-fb67-4b5c-a3e9-6dd97b3d4dfa", "solution": "import numpy as np\n\nclass EnhancedDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.2  # Reduced cognitive component\n        self.c2 = 1.8  # Increased social component\n        self.w_max = 0.9  # Increased inertia\n        self.w_min = 0.4  # Increased minimal inertia\n        self.adaptive_factor = 0.5  # Differential evolution-inspired factor\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def differential_mutation(self, target, best, r1, r2):\n        mutated = target + self.adaptive_factor * (best - target) + self.adaptive_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.differential_mutation(particles[i], global_best_position, r1, r2)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.differential_mutation(parent1, global_best_position, parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedDifferentialParticleSwarm", "description": "Enhanced Differential Particle Swarm Optimizer combines chaotic initialization with differential evolution-inspired velocity update and adaptive mutation for improved convergence speed.", "configspace": "", "generation": 94, "fitness": 0.33209471784726313, "feedback": "The algorithm EnhancedDifferentialParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.6468428844820486, 0.6610970339829603, 0.6281610161830306, 0.7621438070019697, 0.6702633492447985, 0.7660140170655177, 0.73100395195311, 0.7004043818061798, 0.6962449184230465, 0.536277910322405, 0.4844535171233326, 0.2954929647774228, 0.276589933522577, 0.46552611169875036, 0.5482112265493742, 0.285435514262795, 0.4833121838583676, 0.5691160372269832, 0.09778918966320893, 0.3350876672080717, 0.0969250128121164, 0.0821936727020568, 0.08718022650106938, 0.09026153341994902, 0.09445879897094966, 0.10481032096343446, 0.10061565635193115, 0.08458479713329503, 0.08361034792555422, 0.09045482126876703, 0.08110754936678843, 0.08683027031409507, 0.09907653090915414, 0.0767350006324814, 0.10247788498376409, 0.08450386170893165, 0.9773899602742808, 0.9767615724519615, 0.9810356033255833, 0.9681629280717745, 0.9758838430853799, 0.9676491065153365, 0.9735189521716046, 0.9825519016467424, 0.9786060647414834, 0.41562972987458635, 0.3870912102743802, 0.05805537764617874, 0.14368969872066906, 0.3596228631541276, 0.49761520359422684, 0.505344370631085, 0.477373982627039, 0.4931310048584304, 0.7176109006932303, 0.7775372186389191, 0.7182392634758559, 0.1991016621377103, 0.7440729390043067, 0.19774002132370128, 0.6514951566122782, 0.7661011333231843, 0.66063630944308, 0.38498484048017856, 0.5311939834238548, 0.4482518451830385, 0.3989507219789351, 0.3454848513489548, 0.4631445923266839, 0.446912892394145, 0.3216380264212607, 0.33111218661333264, 0.33996288266662733, 0.4492030304211866, 0.23755266450945078, 0.12117698744512762, 0.30306303318461747, 0.38659363280851544, 0.418525690363038, 0.19649055032126128, 0.3128306554702889, 0.28618765430022053, 0.17334709820333993, 0.08806447484715085, 0.08123243723451146, 0.3338717262388329, 0.018841259256534015, 0.4607101007549792, 0.4041739715719117, 9.999999999998899e-05, 0.6603195109450267, 0.13489007054420854, 0.6338973099475056, 0.3376763935767769, 0.4336471636718898, 0.40281001163058683, 0.10250661675084105, 0.5970772248814706, 0.5915503720300834, 0.06363136208921205, 0.26110443268010386, 0.2765765209747709, 0.09745126730477938, 0.08102853066787408, 0.2842847206789827, 0.23646742251168784, 0.0890208278804222, 0.13329310547894713, 0.34137214838771146, 0.3621760551388187, 0.34268314523444443, 0.4025387460038208, 0.3551801527775985, 0.278462832254858, 0.35775680477062244, 0.2364914809650036, 0.4054981738053459, 0.701777347966422, 0.658624889575982, 0.6501267431754765, 0.6473512505635317, 0.6771923437068639, 0.6871717846311802, 0.5249024920134189, 0.6035155316334304, 0.6007007589358986, 0.06540387290311389, 0.09962596521999678, 0.10679090448975481, 0.10393659952531176, 0.09245762618720765, 0.08605966785136132, 0.09006167671152088, 0.10734573507314327, 0.08646984744552155, 0.2242058042104812, 0.1677163166974639, 0.17775279040966985, 0.15216787197067627, 0.14481041940819872, 0.1897469013395714, 0.14441597581890797, 0.15693227477319927, 0.17179369244490428, 0.38226375225443754, 0.40324658161252735, 0.32568542886265117, 0.353807023642684, 0.33771573379578246, 0.39478294834422256, 0.3207332732871516, 0.35846497400149047, 0.33126398215778063, 0.23157462949115404, 0.230201085048923, 0.2543370964474757, 0.30295905786144406, 0.2940305703149203, 0.27903189251539806, 0.3071505456042082, 0.3210479362728448, 0.31406511542898496, 0.1918176567888632, 0.18375082524596842, 0.1873296203078726, 0.20276543252162116, 0.18560569768701962, 0.19936987003884965, 0.1955784011919266, 0.18297276360839532, 0.2083401895355388, 0.2181915475717111, 0.17092278502656244, 0.19956823114230504, 0.19279373736478977, 0.19091636098002307, 0.1993714219402526, 0.18630688237078497, 0.2135724179406926, 0.22087200508496863, 0.20576275057876037, 0.20210469892846417, 0.12364012739490049, 0.5336098226441219, 0.1807353633553921, 0.5526039065358712, 0.13974600226620626, 0.18130558778531058, 0.19773975245277264, 0.6855761349385616, 0.20819990952036638, 0.20676726013637037, 0.5144113375185433, 0.8044820741083809, 0.1522434075236555, 0.1241299935113871, 0.20504388338559598, 0.15231185286297189, 0.2154121594222751, 0.19854522229308647, 0.1825909138806906, 0.19600617468994797, 0.19080752448208482, 0.18989410998134437, 0.24822127205617894, 0.1961594349788709, 0.1909952949287047, 0.08409289968965217, 0.07011748319196465, 0.08149166490106385, 0.08390914245385361, 0.08700339221952236, 0.07484086428612968, 0.080798755708816, 0.09200646595352535, 0.08775178248024951]}, "mutation_prompt": null}
{"id": "6e8fb430-c249-4cb1-a359-fe19e9b2207c", "solution": "import numpy as np\n\nclass EnhancedParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_decay = 0.99\n        self.min_inertia = 0.1\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def exponential_inertia(self, w_max, evals):\n        return max(self.min_inertia, w_max * self.inertia_decay ** evals)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.exponential_inertia(self.inertia_decay, self.evaluations)\n            for i in range(self.population_size):\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n        return global_best_position, global_best_score", "name": "EnhancedParticleSwarmOptimization", "description": "Enhanced Particle Swarm Optimization with an exponential decay inertia factor and improved global exploration for faster convergence.", "configspace": "", "generation": 95, "fitness": 0.20771970387777827, "feedback": "The algorithm EnhancedParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.6324737180187194, 0.490693806233221, 0.730159037212815, 0.6914823240395281, 0.4463921701344141, 0.4330764704972109, 0.5065287733552983, 0.34739855688420906, 0.4443987651784478, 0.12287959799482906, 9.999999999998899e-05, 0.046926898211098855, 9.999999999998899e-05, 0.08953416003438286, 9.999999999998899e-05, 9.999999999998899e-05, 0.08852771399433679, 9.999999999998899e-05, 0.09762409509598946, 0.14728365630402862, 0.061386122003684096, 0.07869009117411441, 0.10696424199022736, 0.10598356186487778, 0.0646541154890421, 0.113691219531045, 0.08679716170225271, 0.050814957509178194, 0.050599051482742685, 0.08417915727155245, 0.11210459709032039, 0.03867731920262507, 0.04993342948508017, 0.09780012607998545, 0.07552681915734372, 0.05630853245111356, 0.9897197898265996, 0.9439781409859866, 0.9907946186130997, 0.09961960609496578, 0.9747678527837806, 0.9811532481896306, 0.9862185907589024, 0.9735469906759848, 0.9774288859762701, 0.3316684259773941, 0.1682377019649215, 0.10475567474532999, 0.1649372415985375, 0.1369072858957352, 0.13001480199409854, 0.12263773497420971, 0.19986573121145412, 0.1258454812499442, 0.32563371952988696, 0.21439152897780245, 0.22420186608904602, 0.19494340147594003, 0.21366277025322578, 0.1925803951815137, 0.12479947036299255, 0.12444446756849226, 0.1103933691589416, 0.29762233540535765, 0.13056767367861344, 0.06383611621079477, 9.999999999998899e-05, 0.22405447763835096, 0.1571061245449651, 0.12795046298006074, 0.13311758032468968, 0.1549086946738658, 0.13940018397446696, 0.13215758713195647, 0.14070753300048822, 0.1329051556428298, 0.19082661111403532, 0.17344347560483042, 0.14527284413483543, 0.1185703375298024, 0.1211951697652881, 0.04067916968354168, 9.999999999998899e-05, 9.999999999998899e-05, 0.05641474225622056, 0.1204071661388445, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.047855481442079295, 0.14874907833006978, 0.07765180908796543, 0.22164799182224793, 0.22446530127782027, 0.029424734276643494, 0.10630366827023341, 0.094222319460608, 0.0892775019140889, 0.09007534762178271, 9.999999999998899e-05, 0.07633352585904107, 0.1548496239148508, 0.08255261836201921, 0.07282996325526858, 0.09569639222526749, 9.999999999998899e-05, 0.08134742578893694, 0.0663468513569444, 0.13076966813236068, 0.20829217200427863, 0.12086098461112704, 0.04952672708428474, 0.04595849111891803, 0.09671859584425857, 9.999999999998899e-05, 0.06353130701247389, 0.08542372889210659, 0.4915648768033144, 0.3732427937102806, 0.6330085739562512, 0.39393347785639854, 0.2964595033582751, 0.38747956460676847, 0.7603113401258358, 0.3596481132974021, 0.5009378297388924, 0.0834496037225042, 0.07583741598842464, 0.09105360235530047, 0.10013876760684148, 0.1035739745538713, 0.11222602316166519, 0.09181176425016857, 0.0864199204557835, 0.0798924349777419, 0.19768279072230166, 0.3559761274512151, 0.15656920665510243, 0.2487475795416214, 0.27400948736691044, 0.18735137579075134, 0.3017626328056343, 0.12991170376252104, 0.1817615292404725, 0.18412690034778934, 0.2693689127474439, 0.22753011723630168, 0.18422786614706566, 0.205705449778384, 0.27094522801843113, 0.25692479836927073, 0.22818249652772649, 0.21735871028363085, 0.24483452318279741, 0.12001174305106321, 0.1921525482428218, 0.29532521746452767, 0.21015639433941824, 0.1894137423519966, 0.1770507359211848, 0.23283120914463906, 0.2536514435569971, 0.2566278753644756, 0.23463785731198938, 0.21089530750967733, 0.27691775426849763, 0.21152069203643042, 0.23459674947511944, 0.22745461457149618, 0.2423626986259404, 0.26312583872439477, 0.1918607130734309, 0.17239001622898154, 0.17236502078941662, 0.1827738699260717, 0.17516668058493, 0.17232817315672277, 0.191691388423337, 0.1718526934465726, 0.18627665789369507, 0.3327152509878476, 0.12702551247969518, 0.18895515871847235, 0.5814958757754953, 0.20213802253398794, 0.11709553857685384, 0.14323027153195056, 0.16305791337265585, 0.4558790913294192, 0.664188464274373, 0.2140224597749829, 0.07361420170982746, 0.20790000538258568, 0.1686451769659354, 0.14916459879888622, 0.10464467638605435, 0.10443520772458903, 0.3491902496378362, 0.2048344288347973, 0.2042233137913988, 0.214083942111433, 0.19269594627170294, 0.2057848494239417, 0.21261210366561822, 0.2420604667409859, 0.2033991993768579, 0.23705985093882032, 0.08010566252904461, 0.083856510704436, 0.07804987751890713, 0.05724900749881745, 0.09709269201301907, 0.07641908231003036, 0.12297141333976247, 0.08196673312894931, 0.0962948402673004]}, "mutation_prompt": null}
{"id": "82dadc94-8119-4fe2-bcfb-06c535e9de60", "solution": "import numpy as np\n\nclass EnhancedHybridParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1_base = 2.0\n        self.c2_base = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.gamma = 0.15  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_mutation(self, target, best, scale_factor):\n        direction = np.random.uniform(-1, 1, self.dim)\n        mutated = target + scale_factor * (best - target + direction)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            c1 = self.c1_base * (1 - self.evaluations / self.budget)\n            c2 = self.c2_base * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.choice(self.population_size, 2, replace=False)\n                velocities[i] = (w * velocities[i] +\n                                 c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[r1] - particles[r2]))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridParticleSwarm", "description": "Enhanced Hybrid Particle Swarm with adaptive learning coefficients and dynamic particle interactions for faster convergence.", "configspace": "", "generation": 96, "fitness": 0.17545027452020848, "feedback": "The algorithm EnhancedHybridParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.30656206401423114, 0.2973299990854227, 0.29940672426058523, 0.3116870340406024, 0.28834652651964354, 0.297726489962161, 0.2938249890312653, 0.3269095108162339, 0.30504047622291686, 0.00631183631357779, 0.0024060569999310166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09880205795444164, 0.10563200098043468, 0.09328987237776165, 0.08639316822226628, 0.08423144957417628, 0.07874504263127668, 0.07169861931363097, 0.08697058044076478, 0.09549559687171572, 0.06951790067673924, 0.08332497831209762, 0.09616413430174453, 0.07940810197911086, 0.06985856057853757, 0.071333164171687, 0.08656383805659462, 0.050320983495554694, 0.07527397504795952, 0.9494692296963109, 0.946523449310855, 0.9420676370698926, 0.9055337069716352, 0.9074290683080297, 0.9531306523121995, 0.9402488172940852, 0.9222148724320929, 0.941059880391609, 0.19128467812253558, 0.20476501130707458, 0.1801753588196352, 0.17561878274351383, 0.20226767824368252, 0.19521300766060634, 0.18891090894100915, 0.1856332757208794, 0.18281270247458092, 0.2360046957060422, 0.2482841194387816, 0.23623757845463778, 0.22560284627501292, 0.22346021161209462, 0.2201068078154833, 0.20145229723328795, 0.19288500239804118, 0.24826217480701884, 0.06982799687744679, 0.04442476558976416, 0.08899885423129439, 0.053023288331285445, 0.1024944969147411, 0.10651574374414818, 0.11123117623349221, 0.10660134726004566, 0.10698065223729969, 0.10346396198976238, 0.11482810514098729, 0.10919603942618394, 0.10502731654974018, 0.08428827592336641, 0.08827946129816189, 0.08192055430106593, 0.08122738664765439, 0.07038333433019783, 9.999999999998899e-05, 0.0055058978556442595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001726147161394298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058812209602924104, 0.05880720645041071, 0.10822598870621203, 0.10242393774984992, 0.06634095731949474, 0.015073663169873908, 0.06918467740947032, 0.07950403707634723, 0.1412244382339346, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04837093855622476, 0.07450687136208467, 0.04171376005398908, 0.07378375056108266, 0.06070920088044418, 0.0583868720417724, 0.041033903945402406, 0.05300354659108164, 0.05613517073191687, 0.31681990124355874, 0.30966672007217344, 0.3004471736098263, 0.326501493767272, 0.3282536507620487, 0.3068907638422097, 0.3147057318305958, 0.2917595116692452, 0.29023369898769147, 0.10562253357028073, 0.08253980857675436, 0.09616534655650388, 0.0894143668753864, 0.1132974975609915, 0.09179622670727072, 0.08154032174955028, 0.08764937895596558, 0.09894123685660683, 0.14906298648782756, 0.1668927009044573, 0.2724249563610003, 0.16678403420093257, 0.16644428329842198, 0.13399806069612807, 0.17654872021677515, 0.14374790911299407, 0.18297824176709354, 0.22256380008045007, 0.23159322773167468, 0.22304751929855993, 0.19832730030475199, 0.24095633155304563, 0.20965647295708478, 0.21680985447885248, 0.23824646852918208, 0.2231975899584494, 0.1692456969607239, 0.1561614405574201, 0.17174120229746126, 0.1568751133375097, 0.16284949709944507, 0.14544071454308682, 0.1807377911576652, 0.1600476504089502, 0.1565704335478526, 0.19076908451570762, 0.17831368442485196, 0.1975998903963645, 0.19630335505696417, 0.20584401344471748, 0.20349647183481712, 0.20315153588667834, 0.19042992387343405, 0.21653735605211966, 0.1791608501114773, 0.1703643750779209, 0.1715663040544092, 0.17648765859359972, 0.18955635149272787, 0.17003636233248087, 0.17335461082305192, 0.17399179711000756, 0.16988353766036757, 0.4034404986605862, 0.16600465794899322, 0.1532387740830673, 0.3839603875792106, 0.18749377547872548, 0.1889781713316483, 0.13743345100590576, 0.15130536549325224, 0.40713305887557993, 0.42130922520034897, 0.19663196457467302, 0.1041795134587088, 0.2723073615711823, 0.3498296405893021, 0.14084787182896907, 0.10457433742906941, 0.1961497160699427, 0.28302121361222377, 0.20253467561556204, 0.1788507286536899, 0.1880386907295356, 0.16805778580387631, 0.19922037211653365, 0.19790677698399728, 0.19726910115090035, 0.18126002104972339, 0.20421133006810188, 0.08435379680070565, 0.07094111647655899, 0.0825379460006217, 0.08190140986146599, 0.0770299441424468, 0.08063647476011915, 0.07794264621578662, 0.07732891015335175, 0.0766399449073506]}, "mutation_prompt": null}
{"id": "ef4a5e57-29d9-4dba-b54d-8781c604b25c", "solution": "import numpy as np\n\nclass EnhancedHybridParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.2  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n        self.elite_fraction = 0.1\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def differential_crossover(self, parent1, parent2, parent3):\n        mutant = parent1 + self.beta * (parent2 - parent3)\n        return np.clip(mutant, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def elite_selection(self, scores, particles):\n        elite_size = int(self.elite_fraction * self.population_size)\n        elite_indices = np.argsort(scores)[:elite_size]\n        return particles[elite_indices]\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                elite = self.elite_selection(personal_best_scores, personal_best_positions)\n                r1, r2, r3 = np.random.choice(elite.shape[0], 3, replace=False)\n                r1, r2, r3 = elite[r1], elite[r2], elite[r3]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2, parent3 = elite[np.random.choice(elite.shape[0], 3, replace=False)]\n                    child = self.differential_crossover(parent1, parent2, parent3)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridParticleSwarm", "description": "Enhanced Hybrid Particle Swarm Optimizer leveraging differential evolution crossover, elite selection, and dynamic parameter adaptation for improved convergence efficiency. ", "configspace": "", "generation": 97, "fitness": 0.21805126229126484, "feedback": "The algorithm EnhancedHybridParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.22.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.7847196730141294, 0.5337229580127085, 0.4224908315800068, 0.4837186457144247, 0.7260866199366633, 0.4676388267952195, 0.621271846689635, 0.6743173909289596, 0.35986757333375985, 0.011468407683470683, 0.13052199577375245, 9.999999999998899e-05, 0.12139968587782346, 0.26844050897728544, 9.999999999998899e-05, 0.016599943309256182, 0.0048373056757101685, 0.09400248890664176, 0.08902995692908955, 0.05189463279169415, 0.10756556578809373, 0.09282502118154057, 0.1070224665286389, 0.08848057525861075, 0.09836260876879022, 0.09105678633858227, 0.06781979354394585, 0.059847765649544304, 0.08088751932027338, 0.10702441503640381, 0.05080903103253187, 0.040575263088903246, 0.04604875315804913, 0.05929999042750855, 0.055217093071027734, 0.06688127942119249, 0.9616968181588594, 0.9617170324066734, 0.9808529097021446, 0.9423851952501695, 0.9438692182548714, 0.9626083533123492, 0.9739776181741054, 0.9340580515066188, 0.9621147775059706, 0.22827473351531702, 0.2416817493910246, 0.11198381933722734, 0.15033223359123582, 0.38216422577211273, 0.14207454754928917, 0.14260698699973984, 0.0879688411237517, 0.4254140228388925, 0.2400851359763141, 0.2759535189421154, 0.2076393153348186, 0.40565056372087405, 0.21300831693695976, 0.11485723606946063, 0.1655630907958321, 0.1576442985917842, 0.2258278849022165, 0.21731444124294985, 0.1293713317547981, 0.38563235241723115, 0.10046543081796622, 0.12805813663918375, 9.999999999998899e-05, 0.1658957377799437, 0.13544833715773152, 0.16187685748891423, 0.16089096630822697, 0.009784610492723389, 0.1607084437226688, 0.18515211542149934, 0.13747829983448334, 0.12814736667740034, 0.15063837117756196, 0.12157700172594343, 0.10592396139701743, 0.06685493497078987, 0.12374441275174741, 9.999999999998899e-05, 0.01745726972083117, 9.999999999998899e-05, 0.027989680198197364, 0.18318259335609344, 0.06902859881116097, 9.999999999998899e-05, 0.09030675365583318, 0.0946540262329083, 0.04376436499866143, 0.08478474525488344, 0.019712660302732776, 0.14643206070983417, 0.11681876136446667, 0.056228025803072845, 0.07926620039732368, 0.05391104943728664, 0.04009365328616221, 0.15097974007169923, 0.09578501632936554, 0.029840215612809473, 0.1423483961021058, 9.999999999998899e-05, 0.11700193998199027, 0.32364009791031856, 0.4350616186491717, 0.021764366277107206, 0.1516844410030973, 0.2188940426620537, 0.17164068515459163, 0.48921045535697605, 0.1483741684608847, 0.07510554211591303, 0.07065222566610996, 0.3870293820301457, 0.5561582362940571, 0.4446494680313473, 0.6110189628032825, 0.6532404104309034, 0.3183333437905691, 0.6488726455719349, 0.5137587751833952, 0.649098624201824, 0.10576408023662931, 0.06640057371123853, 0.038840419784588076, 0.10784458156660925, 0.11524780860670158, 0.13389937571491506, 0.0587901496244001, 0.07232860246376771, 0.06462433799904865, 0.1413459235756509, 0.189895927946646, 0.16100955632781133, 0.18093103469776683, 0.15302281008993635, 0.16517503218984797, 0.15776505969326482, 0.14884766538239413, 0.23905977215081442, 0.16643829319259218, 0.23501080301453392, 0.21836106941884292, 0.20317481022827055, 0.1741055130785979, 0.23566368063911158, 0.22915002059213063, 0.2858739762335445, 0.22352983637710055, 0.1115659905449864, 0.2889832708351193, 0.19797061404743876, 0.14129541396665213, 0.1544250231153772, 0.11660547110564967, 0.22268684287273888, 0.20158042912066387, 0.18656860447117896, 0.18963100876298222, 0.16490144493160408, 0.18677044491755013, 0.18119914887803235, 0.1950461523769813, 0.1700152421301171, 0.17512955605346492, 0.19077127913379466, 0.16448316875813085, 0.16146760042110786, 0.18890796712384672, 0.2044564589648109, 0.18006475275684153, 0.22475184002163062, 0.19332219444378895, 0.18747840498910318, 0.1790672097980034, 0.16448951808417878, 0.5447168321416115, 0.10220782571227705, 0.166471401083927, 0.4469798046154374, 0.19692182898805843, 0.20033565620890292, 0.1299426393750427, 0.15711934075162204, 0.5031467064169433, 0.6917977198665772, 0.20557441083031813, 0.07315938570917191, 0.1678928766060468, 0.1670302095654721, 0.13450594833593477, 0.19733101083637183, 0.36015577211104566, 0.11038074475116832, 0.18198059919005483, 0.17421915197919569, 0.24563913244011892, 0.21147403223048344, 0.18589374865234776, 0.17580855544536966, 0.1948025287246532, 0.24978845608611355, 0.17243534630805157, 0.07284111079953415, 0.08076750895505935, 0.06431495708179968, 0.059024009081698026, 0.0855739067653456, 0.05590739815666801, 0.060548293473026926, 0.06802995752749907, 0.061418012743250205]}, "mutation_prompt": null}
{"id": "2e4cd35f-867f-4a77-8fe1-2f2319be0ca3", "solution": "import numpy as np\n\nclass EnhancedHybridParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.6\n        self.c2 = 1.6\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.15  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n        self.fast_local_search_rate = 0.2  # Rate for fast local search\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def fast_local_search(self, particle, global_best):\n        \"\"\"Apply fast local search to refine particle position.\"\"\"\n        perturbation = np.random.normal(0, self.fast_local_search_rate, self.dim)\n        new_position = particle + perturbation * (global_best - particle)\n        return np.clip(new_position, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = self.fast_local_search(particles[i], global_best_position)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridParticleSwarm", "description": "Enhanced Hybrid Particle Swarm Optimizer with dynamic parameters and fast local search for improved convergence speed and solution quality.", "configspace": "", "generation": 98, "fitness": 0.3473227593168613, "feedback": "The algorithm EnhancedHybridParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.8178655547310227, 0.8164088221493636, 0.8450759752626457, 0.8487161217728917, 0.8150759950916067, 0.8440122656012521, 0.8426164265916802, 0.7898099309936204, 0.8515030744117272, 0.6792744398235877, 0.626518139386717, 0.6448264116621825, 0.6753723433060496, 0.584320269837092, 0.6954112132673456, 0.5061900588810619, 0.679460832804254, 0.6601328546253149, 0.1814059814599832, 0.18144315516546738, 0.13831878141921694, 0.18163220804646374, 0.13545295884196873, 0.15460643494551551, 0.18425911512306736, 0.1552043558244106, 0.12205124626301933, 0.14391062070108152, 0.17478435578034002, 0.10469639398456532, 0.14116464213490854, 0.08265709653490505, 0.1100489192831332, 0.1321307904611294, 0.09828848681421787, 0.09385867246789514, 0.9644432047403245, 0.9650838266464259, 0.9731480841944377, 0.9470898738658625, 0.9724707372936435, 0.9708882849841018, 0.9738650412785272, 0.9665547117205378, 0.982102705600247, 0.364726314965531, 0.3851065544394411, 0.5023418207513535, 0.526229809877101, 0.45542424230507905, 0.5480189101299502, 0.3651859440872187, 0.3697106785327059, 0.5626149380183749, 0.22696273569188186, 0.8911310160355714, 0.864099626470765, 0.27878325217212907, 0.7237658340592115, 0.20978684857472485, 0.832089066168944, 0.8169389943213891, 0.22622148339219916, 0.6641963944741516, 0.4766885889512742, 0.3590243383061573, 0.3167922458660444, 0.590051166692274, 0.2773378815422799, 0.3224519554825971, 0.6807953269402891, 0.31354654280448957, 0.24877281617319713, 0.3702781649773307, 0.2511954567437614, 0.3257039224690934, 0.40110475134864787, 0.4747071124280484, 0.3152147118224983, 0.3411161519854361, 0.20747051868382715, 0.0633881027083949, 0.10094219398271231, 0.097091353906961, 0.07088581023072693, 0.06425413931758428, 0.12913378791318886, 0.04172696225368511, 0.2100453922841946, 0.07074484516711077, 0.169290738894341, 0.07040042196253071, 0.22155693985514457, 0.11384439077636166, 0.06344011247133097, 0.0687443851203754, 0.19300511859234204, 0.06484650069909625, 0.06591000740772701, 0.07094834892967194, 0.1020784368248081, 0.0778795089758465, 0.13542037630191595, 0.2849926682543791, 0.3566769149514405, 0.16535905128606831, 0.21295857446181332, 0.15370727490147396, 0.22434967850294674, 0.16576834400033258, 0.22879440931776607, 0.1281168274366441, 0.2280520261939395, 0.28613320472683246, 0.18082217303210457, 0.16180420771359716, 0.17294741280551318, 0.5801140712300582, 0.5925536444897426, 0.6115766375806639, 0.5384740557442209, 0.5544138044284148, 0.5770823697481966, 0.5899394468902799, 0.5773783841789843, 0.5952447333610023, 0.13879591857365992, 0.12057097421899265, 0.13887033888557976, 0.14675534976296223, 0.12065558353865091, 0.12396194384935066, 0.16686948777051314, 0.12063209509224748, 0.12445823323916083, 0.2782106101199634, 0.2281814630509269, 0.3369087221529027, 0.14125217031941906, 0.41300807162537245, 0.5280300244222277, 0.1678123546908752, 0.2771986732729673, 0.16327073389295488, 0.4223590806786728, 0.5118201781116392, 0.4260504606042973, 0.540353951245363, 0.618971172617165, 0.33088492264614944, 0.6546642560638457, 0.551775990833264, 0.6141873495663694, 0.26500398815730475, 0.2331649368824299, 0.34119480519848766, 0.5243252659037665, 0.37995986724615316, 0.2822206079685394, 0.4045838031494491, 0.23464569195043938, 0.3099837138091155, 0.21503845108882125, 0.23151810512048154, 0.1930645127204189, 0.227444123599857, 0.2515821639518645, 0.24538472044303772, 0.24284538061723937, 0.19886877150902016, 0.22083750418269155, 0.19107082254930208, 0.18285247473660227, 0.22037945014014193, 0.18846428621756273, 0.20308595761935289, 0.17136926878034353, 0.19602383520878242, 0.2241644489192599, 0.18426258719391164, 0.1841485241804358, 0.18769344925670517, 0.18437864305398133, 0.7926761677368273, 0.19723322512809494, 0.8648948986942405, 0.16514741701868274, 0.6465241683281912, 0.1631107237741075, 0.15085607386662137, 0.20992110182033874, 0.7348101449402537, 0.16390010474995964, 0.16468929555053657, 0.16705588358500423, 0.21024524427763058, 0.7027562573219321, 0.1656604764252292, 0.21908694752409175, 0.20396443371042583, 0.19359299952733633, 0.2022550476473146, 0.2252705930299499, 0.20353117139062005, 0.21496654470032972, 0.20659719869037885, 0.21854091497847794, 0.12012541174383984, 0.10679932588461016, 0.09992209927388596, 0.10365213498625214, 0.08829579257560549, 0.09591040162486986, 0.10661137903666784, 0.12295041727104161, 0.0915164201554498]}, "mutation_prompt": null}
{"id": "45331b97-21b5-4b28-b18e-dfb5b05e8237", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.85\n        self.w_min = 0.3\n        self.alpha = 0.5\n        self.beta = 0.7\n        self.gamma = 0.1  # Memory-based velocity adjustment rate\n        self.evaluations = 0\n\n    def chaotic_initialization(self):\n        return self.lb + (self.ub - self.lb) * np.random.rand(self.population_size, self.dim)\n\n    def initialize_particles(self):\n        particles = self.chaotic_initialization()\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, np.inf)\n        return particles, velocities, personal_best_positions, personal_best_scores\n\n    def adaptive_crossover(self, parent1, parent2):\n        if np.random.rand() < self.alpha:\n            cross_point = np.random.randint(1, self.dim)\n            child = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n        else:\n            child = (parent1 + parent2) / 2\n        return np.clip(child, self.lb, self.ub)\n\n    def adaptive_mutation(self, target, best, r1, r2, scale_factor):\n        mutated = target + self.beta * (best - target) + scale_factor * (r1 - r2)\n        return np.clip(mutated, self.lb, self.ub)\n\n    def __call__(self, func):\n        particles, velocities, personal_best_positions, personal_best_scores = self.initialize_particles()\n        global_best_position = None\n        global_best_score = np.inf\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(particles[i])\n                self.evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = particles[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = particles[i]\n\n            w = self.w_max - (self.w_max - self.w_min) * (self.evaluations / self.budget)\n            scale_factor = np.exp(-self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2 = personal_best_positions[r1], personal_best_positions[r2]\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * np.random.rand() * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * np.random.rand() * (global_best_position - particles[i]) +\n                                 self.gamma * (particles[i] - global_best_position))\n                particles[i] = particles[i] + velocities[i]\n                particles[i] = self.adaptive_mutation(particles[i], global_best_position, r1, r2, scale_factor)\n                particles[i] = np.clip(particles[i], self.lb, self.ub)\n\n            if self.evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    parent1, parent2 = personal_best_positions[np.random.choice(self.population_size, 2, replace=False)]\n                    child = self.adaptive_crossover(parent1, parent2)\n                    score = func(child)\n                    self.evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = child\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = child\n\n        return global_best_position, global_best_score", "name": "HybridAdaptiveParticleSwarm", "description": "Hybrid Adaptive Particle Swarm Optimizer integrates chaotic initialization, adaptive mutation, and memory-based velocity adjustment for enhanced convergence speed and solution quality.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "90d26140-721c-483e-89d4-4155388bda08", "metadata": {"aucs": [0.8593610698444872, 0.8204366533607839, 0.8449854715546068, 0.8552418876292598, 0.8676037206974347, 0.836566439523704, 0.8504801318225035, 0.8402323593260838, 0.8324770072981457, 0.6713315278012205, 0.6581074762943224, 0.663992759976917, 0.6614934183291115, 0.7084840042750213, 0.7308553569644226, 0.669748911254342, 0.6589074924975941, 0.7085246560508422, 0.5921261221647673, 0.6414002068012583, 0.11923006613900744, 0.18081964465521416, 0.1449413124300558, 0.15312054800131358, 0.6316822658854502, 0.6762572876061616, 0.6693121846213452, 0.1636228197535331, 0.1228167464053187, 0.13343699508972873, 0.12693248079914576, 0.11670838176690834, 0.13680442229344003, 0.10929405198209774, 0.10642273667413882, 0.11139578744285794, 0.9643534250121528, 0.980479875947011, 0.9454678297399592, 0.9722996273237385, 0.9798552256501443, 0.9468458251243128, 0.973348501120912, 0.9720863318081332, 0.9718357664541014, 0.5506489223351388, 0.5400144233029986, 0.4707063879862874, 0.4576000713027649, 0.42748637605611184, 0.17747450914416518, 0.5750529722167992, 0.5305952128942648, 0.541344885360592, 0.8804416960530248, 0.8612279661724874, 0.8337141210908461, 0.2620687366831237, 0.27261773529675704, 0.2748537564817972, 0.8429414419882202, 0.8193137078177961, 0.7863120102739167, 0.5580706894750477, 0.12556833696227554, 0.5354083068685743, 0.5583063421067034, 0.40481405067777765, 0.4594939194296219, 0.47445113890927126, 0.4880258221658128, 0.27178659017827844, 0.1928949318725438, 0.5655323227455158, 0.27503206094015475, 0.27051004468410333, 0.44825910960022464, 0.2138552809461105, 0.26228391962683995, 0.444013359288422, 0.46546210782587016, 0.4431560721962444, 0.16182779477228582, 0.5229704017358088, 0.10625020979073596, 0.5346721648499049, 0.5099335466003612, 0.6301049895837244, 0.5034881813749308, 0.2372384458651814, 0.6597128107658665, 0.2708539545849533, 0.2329425776397862, 0.11968187484576431, 0.09443924598006759, 0.1025151094264165, 0.6002863681476427, 0.47201016123803297, 0.6459735115285357, 0.3615573987998705, 0.13254002641849183, 0.0810662774005485, 0.3096352980217183, 0.4974221619218301, 0.24121637589391975, 0.14170024581260499, 0.3271350247582705, 0.2998717002905159, 0.5341921437912334, 0.3770233762264439, 0.4804662088388373, 0.48047367450261413, 0.5163151057370526, 0.48233956537666767, 0.2264414041739995, 0.49562061352070186, 0.4318247252540094, 0.7703943375370611, 0.8068663695926471, 0.783465529692857, 0.771289277831999, 0.7412366813206523, 0.7552886000045453, 0.7902791897975711, 0.798251515171086, 0.7642142275639248, 0.1416581352314411, 0.13192818851577903, 0.11076170648199879, 0.16481926994203222, 0.1489495919467101, 0.1494385025807995, 0.17807598342694186, 0.15011240568775297, 0.13172683606716784, 0.49128712793732976, 0.1881325042254438, 0.1711839578709934, 0.1765241793580653, 0.17223713948614627, 0.20733519362053632, 0.19763198421869344, 0.5281521916543979, 0.17087901591148036, 0.27926236369431323, 0.38031450500603503, 0.42311042961113443, 0.4843197673461822, 0.29934622974586955, 0.5094254668102922, 0.5563811327615665, 0.45531907552999806, 0.6517467131683365, 0.3918982805786986, 0.46993023075558116, 0.5132023292449508, 0.2687202026385558, 0.37420231805667414, 0.38561584715042274, 0.26566825084156376, 0.6066775562729112, 0.25988602059547206, 0.20381667544563165, 0.2043446780171172, 0.22445704124191912, 0.23031363352587286, 0.2164337734187477, 0.25235555886599714, 0.23963780491872888, 0.20428399630744476, 0.24596702057882502, 0.684901642330783, 0.1937078536673723, 0.18725602748491066, 0.1810613567536905, 0.20507465774080413, 0.18696828991097747, 0.19582383960722927, 0.18929906043085853, 0.1824198024971031, 0.1851254362507857, 0.18658495619665283, 0.18401609285728315, 0.8436366541248896, 0.7837262460222462, 0.8761639256885155, 0.16055084269400455, 0.8551971477915828, 0.8638081094355854, 0.8353979134839202, 0.20944256962313512, 0.8241865144823877, 0.20883576526508718, 0.7744142436223869, 0.16806782029108014, 0.2091986285273726, 0.1643424408646893, 0.15287431679882335, 0.2240517625444215, 0.23059929775763188, 0.20820728970313562, 0.19916100608887943, 0.19889098747073541, 0.20552973284028098, 0.20239511541119548, 0.22101096680110832, 0.23088599831494117, 0.11207245663724774, 0.1079670489526976, 0.08745943618868701, 0.0996582211263749, 0.10437436230437291, 0.15125893130914247, 0.10011056187170175, 0.09666303674921983, 0.10280706951387497]}, "mutation_prompt": null}
